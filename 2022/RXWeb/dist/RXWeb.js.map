{"version":3,"file":"RXWeb.js","mappings":"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AE,KAAD,aAA5B,Y,qCAG5E,gBAQ+F,WAAAwY,GAAiB3W,EAAYC,EAAU9B,I,wEAT1I,0CAoBkC,mBAA0C4Y,GAAA,WAC5E,oBAA2B9Y,EAC3B,eAAmCE,EAAA,WAAO,EJhDyB2X,GIgDtB5X,EJhDwC2X,KIgD/B5X,EJhD2C4X,OIgDpD,EJhDsBC,GIgDH5X,EJhDqB2X,KIgDZ5X,EJhDwB4X,OIgDjC,EAChE,YJ0SsC,IAAAW,GI1SnBrY,GACnB,YAAuB,eAASD,EAAW,oBCjH/C,mBAEI,MvGuIoD+X,GuGvI3CrtB,EAAI4X,GACb,EvGsIoDyV,GuGtI3C5oB,EAAImT,GACb,OvGmDkEoV,GuGnDvDoB,EvGmDwEnB,KuGnDlEoB,EvGmD8EpB,OuGnDpF,EvGkF2C,IAAAF,GuGlFjCqB,EvGkF2CnB,KuGlFtCoB,EvGkFuDpB,KAAZ,GAbhB,IAAAF,GAAU,IAaTA,GuGlFpBqB,EvGkF8BnB,KuGlFzBoB,EvGkF0CpB,KAAZ,GAbNA,KuGrEnBrV,EvGqEmCqV,KAAX,GuGlExE,mBACI,MLwIsDK,GKxI7CttB,EAAI4X,GACb,ELuIsD0V,GKvI7C7oB,EAAImT,GACb,OLqDmEsV,GKrDxDkB,ELqD0EnB,KKrDpEoB,ELqDgFpB,OKrDtF,EL+E6C,IAAAW,GK/EnCQ,EL+E8CnB,KAAK,SK/E9CoB,EL+E0DpB,OAb7B,IAAAW,GAAW,IAaVA,GK/EtBQ,EL+EiCnB,KAAK,SK/EjCoB,EL+E6CpB,OAblBA,KAAK,IKlE3BrV,ELkEsCqV,OK/DtF,mBAmBI,GAAA1X,EAAO,EADuE,OvGwBZyX,GuGvBlD3W,EvGuBmE4W,KuGvB1Dzc,EvGuBsEyc,OuGvB/E,EAAczc,EvGsDwB,IAAAuc,GuGtDfvc,EvGsDyByc,KuGtDnB,GAAiBzc,EAAK6F,EvG2WhC,IAAA0W,GuG3WuCxX,IvGsDO0X,KAAZ,GuGrDrE,GAAA1X,EAAO,EAFuE,OvGwBZyX,GuGtBlD3W,EvGsBmE4W,KuGtB1Dzc,EvGsBsEyc,OuGtB/E,EAAczc,EvGwCuB,IAAAuc,GuGxCdvc,EvGwCwByc,KuGxClB,GAAiB5W,EAAO7F,EvG0WlC,IAAAuc,GuG1WwC,GAACxX,IvGwCG0X,KAAX,GuGvC5D,MAAa,GAAyB,iBAGlD,mBAmBI,GAAA1X,EAAA,WAAO,EAD2E,OLQf2X,GKPnD7W,ELOqE4W,KKP5Dzc,ELOwEyc,OKPjF,EAAczc,ELiC0B,IAAAod,GKjCjBpd,ELiC4Byc,KAAK,SKjC3B,GAAiBzc,EAAK6F,ELkW7B,IAAAuX,GKlWoCrY,ILiCU0X,OKhCpF,GAAA1X,EAAA,WAAO,EAF2E,OLQf2X,GKNnD7W,ELMqE4W,KKN5Dzc,ELMwEyc,OKNjF,EAAczc,ELmByB,IAAAod,GKnBhBpd,ELmB2Byc,KAAK,IKnB1B,GAAiB5W,EAAO7F,ELiW/B,IAAAod,GKjWsCrY,EAAD,eLmBO0X,OKlB1E,MAAa,GAAyB,iBtGlDxB,eAEtB,KAFyD,YAEzD,sBACI,eAGqC,IAAAqB,GAAO,GAE5C,eAGqC,IAAAA,IAAO,GAE5C,gBAGmC,EAEnC,eAGkC,G,0FqGsFtC,WAAkC,uB,uBAElC,WACI,MAAY,YACZ,GAAI,MAAA3oB,GAAAA,EAAA,OAAS,qBAAb,CACI,IAAK,eAAS,MAAa,KAC3B,gBAAU,OAEV,YJ/C+C,IAAAioB,GI+C/C,YJ/C0DX,KAAK,II+CvD,YJ/CkEA,OIiD9E,OAAOtnB,G,qJrGnHX,0COVJ,iBACkD,OAAuB,sBAAf,WAAP4oB,GAAuC,WAAPC,GACnF,iBACqD,OAACD,EAAA,OAAuB,gBAAUC,EAAA,QAIvF,iBACuD,OR+Yf,IAAAzB,GAvGI,eQxSYwB,ERwSjBtB,MAAA,OQxSiB,ORwSZ,eQxS0BuB,ERwS/BvB,MAAA,QAuGW3qB,SQtXlD,iBAKe,IAHX,EAAeisB,E0F8QoBtB,K1F7QnC,EAAcuB,E0F6QqBvB,K1F5QnC,GAAIwB,EAAA,WAAU,EACV,O0FyB+DvB,G1FzBpDqB,E0FyBsEtB,K1FzBjEuB,E0FyB6EvB,M1FzBlF,EACPsB,E0FkDgD,IAAAX,G1FhDhDW,E0FgD2DtB,KAAK,S1FhD3DuB,E0FgDuEvB,O1F3CpF,GAAIyB,EAAA,YAAY,EACZ,OAAO,IAAAd,GAAMc,EAAA,OAAWD,IAI5B,MAAiBC,EAAA,mBAAc,GAAf,IAAoBD,GAArB,UAAkC,GACjD,EAAUC,EAAA,SAAWC,EAAA,SAAWF,IAChC,OAAO,IAAAb,GAAMtlB,EAAA,S0FUsD4kB,GAAkB,I1FV9DU,GAAMtlB,G0FUwD2kB,KAAY,I1FV5DW,GAAMa,G0FUsDxB,O1FV1E,EAA8BwB,EAAlC,IA+BvB,eAA8C,UAAcpW,EAAG,IAE/D,iBACI,GAAIA,EAAA,YAAK,EAAG,OAAS,GAAFA,EAAWuW,GAE9B,IAAID,EAAatW,EAAA,mBAAO,GAAR,mBAAauW,IAAd,UAAwB,GACnCtmB,EAAM+P,EAAA,SAAIsW,EAAA,wBAAWC,KAKzB,OAJItmB,EAAA,YAAOsmB,IACPtmB,EAAAA,EAAA,wBAAOsmB,IACPD,EAAAA,EAAA,mBAAY,KAEA,GAATA,EAAkBC,GAAY,GAAJtmB,EAAasmB,G,2EP/D9C,YAM0D,OAAa,qBA6OrB,MAAZ,UFDY,IE5O+B5lB,EF4O3C,S,uEE1OtC,YAOoE,OAAa,qBAoO/B,MAAZ,UAAY,MApOyCA,EAoOrD,S,0EAlOtC,cA2PA,oBD5PA,+BCCA,mBAMyD,ODASgkB,EAAiB,IC8PhD,EAAsB,MAAZ,WD9PsCC,KCAFjkB,EDAcikB,W,0ECE/F,cA6PA,MAS6D,sBAT7D,iBiG9PA,gCjGCA,mBAM0D,OiGASC,EAAkB,IjGgQhD,EAAW,eAAL,KAAAD,MAAA,QiGhQ0CA,KjGAFjkB,EiGAcikB,W,gEjGEjG,cA2OA,oBA3OA,mBAEsD,ODMD,MAAU,IC4O5B,EAAsB,MAAZ,WD5OkBA,KAAgB,ID2O5C,EAAsB,IEjPgBjkB,EFiP5B,MC3OkCikB,KAAX,Q,gECLpE,cAwOA,oBAxOA,mBAEuD,ODGF,MAAU,IC4O5B,EAAsB,MAAZ,WD5OkBA,KAAgB,IC4O5C,EAAsB,MA/OiBjkB,EA+O7B,MD5OkCikB,KAAX,Q,gECFpE,cAqOA,oBArOA,mBAEqD,ODAA,MAAU,IC4O5B,EAAsB,MAAZ,WD5OkBA,KCASjkB,EDAOikB,KAAX,Q,gECCpE,cA4OA,MAS6D,sBAT7D,iBA5OA,mBAEuD,OiGAA,MAAW,IjGmP7B,EAAW,eAAL,KAAAA,MAAA,QiGnPuBA,KAAK,IjGAIjkB,EiGAOikB,Y,kEjGElF,cA8NA,oBA9NA,mBAEuD,ODMD,MAAU,IC+N7B,EAAsB,MAAZ,WD/NmBA,KAAiB,ID8N9C,EAAsB,IEpOkBjkB,EFoO9B,MC9NoCikB,KAAZ,Q,kECLrE,cA2NA,oBA3NA,mBAEwD,ODGF,MAAU,IC+N7B,EAAsB,MAAZ,WD/NmBA,KAAiB,IC+N9C,EAAsB,MAlOmBjkB,EAkO/B,MD/NoCikB,KAAZ,Q,kECFrE,cAwNA,oBAxNA,mBAEsD,ODAA,MAAU,IC+N7B,EAAsB,MAAZ,WD/NmBA,KCAUjkB,EDAOikB,KAAZ,Q,kECCrE,cA+NA,MAS6D,sBAT7D,iBA/NA,mBAEwD,OiGAA,MAAW,IjGsO9B,EAAW,eAAL,KAAAA,MAAA,QiGtOwBA,KAAK,SjGAKjkB,EiGAOikB,Y,kEjGEpF,cAiNA,oBAjNA,mBAEuD,ODMD,MAAe,OAAL,ICkN7B,EAAsB,MAAZ,WDlNmBA,KAAiB,IDiN9C,EAAsB,IEvNkBjkB,EFuN9B,MCjNoCikB,Y,kECLjF,cA8MA,oBA9MA,mBAEwD,ODGF,MAAe,OAAL,ICkN7B,EAAsB,MAAZ,WDlNmBA,KAAiB,ICkN9C,EAAsB,MArNmBjkB,EAqN/B,MDlNoCikB,Y,kECFjF,cA2MA,oBA3MA,mBAEsD,ODAA,MAAe,OAAL,ICkN7B,EAAsB,MAAZ,WDlNmBA,KCAUjkB,EDAOikB,Y,kECCjF,cAkNA,MAS6D,sBAT7D,iBAlNA,mBAEwD,OiGAA,MAAW,IjGyN9B,EAAW,eAAL,KAAAA,MAAA,QiGzNwBA,KAAK,SjGAKjkB,EiGAOikB,Y,8DjGEpF,cAoMA,oBD9LA,8BCNA,mBAEqD,ODMDE,ECqMjB,MAAsB,MAAZ,WFDV,MAAsB,IE1McnkB,EF0M1B,Y,8DEzM7C,cAiMA,oBD9LA,8BCHA,mBAEsD,ODGFmkB,ECqMjB,MAAsB,MAAZ,WAAV,MAAsB,MAxMenkB,EAwM3B,Y,8DAvM7C,cA8LA,oBD9LA,8BCAA,mBAEoD,ODAAmkB,ECqMjB,MAAsB,MAAZ,WArMyBnkB,Q,8DACtE,cAqMA,MAS6D,sBAT7D,iBiGrMA,+BjGAA,mBAEsD,OiGAAokB,EjG4MjB,MAAW,eAAL,KAAAH,MAAA,QA5M8BjkB,Q,8DAEzE,cAuLA,oBDzKA,iCCdA,mBAMqD,ODcDqkB,EC4KjB,MAAsB,MAAZ,WFDV,MAAsB,IEzLcrkB,EFyL1B,Y,8DExL7C,cAgLA,oBDzKA,iCCPA,mBAMsD,ODOFqkB,EC4KjB,MAAsB,MAAZ,WAAV,MAAsB,MAnLerkB,EAmL3B,Y,8DAlL7C,cAyKA,oBDzKA,iCCAA,mBAMoD,ODAAqkB,EC4KjB,MAAsB,MAAZ,WA5KyBrkB,Q,8DACtE,cA4KA,MAS6D,sBAT7D,iBiG5KA,kCjGAA,mBAMsD,OiGAAskB,EjG+KjB,MAAW,eAAL,KAAAL,MAAA,QA/K8BjkB,Q,wEAEzE,cA0JA,oBD9LA,8BCoCA,mBAMiD,ODxCGmkB,ECqMjB,MAAsB,MAAZ,WFDV,MAAsB,IE5JenkB,EF4J3B,Y,wEE3J7C,cAmJA,oBD9LA,8BC2CA,mBAMkD,OD/CEmkB,ECqMjB,MAAsB,MAAZ,WAAV,MAAsB,MAtJgBnkB,EAsJ5B,Y,wEArJ7C,cA4IA,oBD9LA,8BCkDA,mBAMgD,ODtDImkB,ECqMjB,MAAsB,MAAZ,WA/I0BnkB,Q,wEACvE,cA+IA,MAS6D,sBAT7D,iBiGrMA,+BjGsDA,mBAMkD,OiG1DIokB,EjG4MjB,MAAW,eAAL,KAAAH,MAAA,QAlJ+BjkB,Q,8DAE1E,cA6HA,oBDzKA,iCDuOJ,4BE3LI,mBAQ6C,OF8LR,MAAW9G,EC5OImrB,EC4KjB,MAAsB,MAAZ,WFDV,MAAsB,IE7HMrkB,EF6HlB,OCORikB,Y,8DCnIrC,cAoHA,oBDzKA,iCCwOJ,8BAnLI,mBAQ+C,OAsLR,MAAYhrB,ED7OCorB,EC4KjB,MAAsB,MAAZ,WAAV,MAAsB,MArHQrkB,EAqHpB,ODgBNikB,Y,8DCpIvC,cA2GA,oBDzKA,iCC8DA,mBAQ2C,ODhESI,EC4KjB,MAAsB,MAAZ,WA5GgBrkB,Q,8DAC7D,cA4GA,MAS6D,sBAT7D,iBiG5KA,kCjGgEA,mBAQ6C,OiGlESskB,EjG+KjB,MAAW,eAAL,KAAAL,MAAA,QA7GqBjkB,Q,8CAEhE,kEAM2C,aAAY,EAAL,KAAAikB,KAAK,S,8CAEvD,kEAM2C,aAAY,EAAL,KAAAA,KAAK,S,sEAEvD,8CAwEA,gBAxEA,mBAE+D,aA+E5B,MAAsB,MAAZ,WAAV,MAAsB,MA/E+BjkB,EA+E3C,Y,8DA7E7C,oCkGnNJ,YlGmNI,mBAEqD,akGlNiC/G,ElGkN1B3C,KAAK2tB,KAASjkB,EAAMikB,Y,4DAChF,oCkGjNJ,YlGiNI,mBAEoD,akGhNgChrB,ElGgNzB3C,KAAK2tB,KAAQjkB,EAAMikB,Y,8DAC9E,oCkG/MJ,YlG+MI,mBAEqD,akG9MiChrB,ElG8M1B3C,KAAK2tB,KAASjkB,EAAMikB,Y,8CAChF,oCkG7MJ,YlG6MI,kBAEkC,akG5MsBhrB,GlG4Mf,KAAAgrB,Y,oDAEzC,+CAUmC,OAAK/qB,EAAL,KAAA+qB,W,uDACnC,WASqC,YAAAA,Q,mDACrC,WASiC,OAAiB,MAAZ,a,oDACtC,oBASqD,sBATrD,kBASmC,OAAK,eAAL,KAAAA,MAAA,Y,sDAEnC,cF+DJ,gCE/DI,kBASqC,OFiEE,MAAW/qB,EEjEb,KAAA+qB,Y,yDACrC,WAEuC,OAAA3tB,Q,oDACvC,oDASmC,aAAsB,MAAZ,gB,sDAC7C,oBAS6D,sBAT7D,mCASqC,aAAW,eAAL,KAAA2tB,MAAA,a,uDAE3C,WAMqC,OApDa,MAAZ,a,yDAqDtC,WAMuC,OA3DW,MAAZ,a,sBA6DtC,WAAyC,OA7DS,MAAZ,WA6DW5rB,Y,gIA3UrD,0BAG6D,8B,oBAH7D,mHAG6D,4B,odJ8rT7D,YAIiB,IAAN,SAAM,U,KACT,EAAK,EAAAiT,KAAL,M,KACA,EAAK,EAAAC,GAAO,EAAK,IAAjB,M,QACa,EAAAsa,EAAL,GAHZ,OAAO,G,0GmDjhTP,qBAA2C,GAAK7Q,EAAiB,EAAjE,qC,2YtCyGJ,cAMI,OAAWzK,GAAS,GAAKA,GAAS,MAAW,cAAIA,GAAY,M,uBA7BjE,YAII,OAAW,EAAA2D,UAAW,KAAU,cAAK,I,sEAgIzC,YAQI,GAAI,EAAAA,UACA,MAAM,IAAA1D,GAAuB,kBACjC,OAAO,cAAK,Q,iFA0iBhB,YAII,GAAI,gBAAsB,EAAAvM,MAAQ,EAAG,OAAO,MAC5C,MAAW,MAEX,OADK,GAALyT,GACOA,G,kEAsFX,cASe,MAHX,GAAI,eAAJ,CACG,GAAI,EAAAzT,MAAQ,EAAG,OAAY,GAAL,GAEoB,MAAlC,YwBvhCuD0T,GAAY,IxBuhCnE,OAAR,OAAkDmU,GAAS,EAAT,GAAuB1C,Gc79BrE,Gd+9BgB,MAAhB,MAAP,OAA+B,Qc/9BxB,G,sBd6+BX,YAMoB,MACL,EAHX,EAAa,cAAU,EAAAnlB,MACnBsM,EAAQ,EACZ,IAAgB,4BAAhB,CAAgB,eACZvM,GAAO,EAAAuM,EAAAA,EAAA,MAAP,IAAkBD,EACtB,OAAOtM,G,uBA+CX,YAMoB,MACL,EAHX,EAAa,YAAU,EAAAC,MACnBsM,EAAQ,EACZ,IAAgB,4BAAhB,CAAgB,eACZvM,GAAO,EAAAuM,EAAAA,EAAA,MAAP,IAAkBD,EACtB,OAAOtM,G,wIA83DX,cAII,MAAa,GAAa,EAAAC,MAG1B,OAFAD,EAAO,eAAO,GACdA,EAAO,UAAIsM,GACJtM,G,gBAwBX,cAII,GAAI,eAAoB,OAAY,GAAL,EAAU0N,GACzC,MAAa,KAGb,OAFOC,GAAP3N,EAAc,GACP2N,GAAP3N,EAAc0N,GACP1N,G,yJ8Fn/FX,YAII,GAAY,IAAR,EAAAC,KACA,OAAOqN,KACX,MAAe,EAAA0I,QAAQ/I,WACvB,IAAKA,EAASC,UACV,OAAOI,KACX,MAAYL,EAASE,OACrB,IAAKF,EAASC,UACV,OAAOK,GpG8PiD,IAAAqY,GoG9P1CtX,EpG8P+C4H,IoG9P/C5H,EpG8PoD3P,QoG7PtE,MAAa,GAAsB,EAAAsB,MACnCD,EAAO,UpG4PqD,IAAA4lB,GoG5PjDtX,EpG4PsD4H,IoG5PtD5H,EpG4P2D3P,Q,GoG1PvC,MAAhBsO,EAASE,OAApBnN,EAAO,UpG0PiD,IAAA4lB,GAAK,EAAA1P,IAAK,EAAAvX,coGzP7DsO,EAASC,WAClB,OAAOlN,G,iD1G8PX,cAKI,OAAO,mBAAe,I,yDA2e1B,cAMI,OAAIoO,EAAA,sBAA6B,KAAUI,MAC/B,eAAL,WAAkBJ,EAAQ,wBAAH,M,wBA8LlC,cAQI,OAAW,kBAAOM,GAAP,EAAqBA,EAAkB,G,2CAuFtD,gBAQI,GAAID,EAAA,gBAAeC,GAAf,EAA6B,MAAM,GAAyB,kDAAiDA,EAAjD,oCAAoFD,EAApF,gBAChE,OAAI,kBAAOA,GAAP,EAA4BA,EAC5B,kBAAOC,GAAP,EAA4BA,EACzB,G,iPcdX,cASI,OAA6C,GAAtC,IAAAO,GAAqB,EAAMhB,K,yC6Fv+BtC,cAMuD,MAAT,EAA1C,EAAa,GAA6B,gBAAS,EAAA8Z,GAATra,IAA4C,EAAAzN,KAAL,IAAvC,QAAuE,EAAZ,EAAKA,KAAL,GAGrG,OAFAD,EAAO,eAAO,GACP2N,GAAP3N,EAAc0N,GACP1N,G,6CnC5DX,YAKI,GCkO0D,IAAV,EAAAzD,ODjO5C,MAAM,IAAAiQ,GAAuB,2BACjC,OAAO,aAAK,I,oBCoQhB,YAG4D,kB,0CDrK5D,YAQI,GCsH0D,IAAV,EAAAjQ,ODrH5C,MAAM,IAAAiQ,GAAuB,2BACjC,OAAO,aAAK,Q,yCAyXhB,czDzgBI,KyDihBQsC,GAAK,GzD/gBT,MAAM,IyD+gBQ,sDzD/gByBzU,YyDghB3C,OVjV4F,EAAAuF,UUiV3E,EAAK,GAAFkP,EAAe,EAAAvS,U,6sChDhjBvC,cAEI,SAD8DqP,EAAN,cAE1BvB,GAF0B,OAAMuB,G,IAS9D,eATwD,OAStCoc,GAAqB3d,G,IACvC,YAVwD,OAUzC4d,GAAkB5d,G,IACjC,aAXwD,OAWxC6d,GAAmB7d,G,IACnC,YAZwD,OAYzC8d,GAAkB9d,G,IACjC,WAbwD,OAa1C+d,GAAiB/d,G,IAC/B,YAdwD,OAczCge,GAAkBhe,G,IACjC,aAfwD,OAexCie,GAAmBje,G,IACnC,cAhBwD,OAgBvCke,GAAoBle,G,QAC7B,MAAM,GAAsB,kDAA+CuB,M,0OA8DvF,WAC8C,MAAM,M,cAEpD,gBAEI,MAAI,iBAAAgF,EACOA,EsCyIiFhR,UtCzIrEiU,EAAYC,GAEtB,EAAY,oBAAsBD,EAAYC,I,eAI/D,cAEQ,MAAY0U,kBAGZ,MAAYA,kBAAkBC,GAErB,EAAT,OAA+C,IAAnD,OAAmDC,O,6BAmGvD,WAC6B,MAAS,YAAT,EAAsB,IAA/C,YAAY,GAAE,MAAM,KAAM,YAAD,OAQzBre,EAAM,OAAWuB,EACVvB,G,2dMtKP,oDAAuB,UAAK,KAAM,MAAlC,G,uGAMA,oDAAuB,UAAK,MAA5B,G,kbOZJ,YAG4D,WAAAse,GAAelD,I,gBAE3E,cAIwF,WAAAkD,GAAelD,I,sGL23CvG,uBAWgD,IAAAhT,IAAAA,EAAiB,QAAG,IAAAC,IAAAA,EAAe,UAC/E,KAAa,0BAAkBD,EAAWC,EAAS,UAC9C,EAAYxJ,KAAKoD,EAASmG,EAAWC,I,wBAgrB9C,YAII,MAAO,GAASxI,MAAMxP,KAAK,I,iTIt+D/B,YAMuD,IAAQ,O,iHIpHvD,sDAAsC,UAAK2b,EAAMH,IAAKG,EAAM1X,OAA5D,G,swBaTJ,sDACyD,UAAKiqB,EAAU,MADxE,G,0GuDPA,qBAAuC,GAAMxW,EAA7C,kCAHJ,WAGI,G,sCACA,wDAAmD,UAAMA,EAASD,GAJtE,WAII,G,2KtDJJ,YAEI,MAAM,IAAA0W,GAAqBzW,I,wCAa/B,YAEI,MAAM,GAAqC,qBAAqBtH,EAArB,8B,gECwd/C,YAYI,SAAW,MAAM,GAAyB,2BAC1C,SAAO,WAAiB,WACxB,GAAO,YAAiB,WACO,EAAvB,KAAWge,MAAM,K,8hBsDlf7B,gBAMI,WAAAC,GAAUjP,EAAsBsL,GAAV,GAAoBrL,I,0J5CO9C,YAEU,IAAN,gBAAepf,G,IACX,SAA6B,EAAjB,KAAiB8f,YAA7B,M,IACA,SAAY,GAAmB,EAAH9f,KAAsBA,EAAG,KAAiBquB,SAAc,KAAiBC,YAArG,M,IACA,UAA8B,EAAjB,KAAiBC,aAA9B,M,IACA,WAA+B,EAAjB,KAAiBC,cAAgB,EAAY5sB,QAA3D,M,QAGQ,oBAAA5B,GAAsC,EAAjB,KAAiByuB,uBACtC,iBAAAzuB,GAAmC,EAAjB,KAAiB0uB,oBACnC,iBAAA1uB,GAAmC,EAAjB,KAAiB2uB,oBACnC,kBAAA3uB,GAAoC,EAAjB,KAAiB4uB,qBACpC,gBAAA5uB,GAAkC,EAAjB,KAAiB6uB,mBAClC,iBAAA7uB,GAAmC,EAAjB,KAAiB8uB,oBACnC,kBAAA9uB,GAAoC,EAAjB,KAAiB+uB,qBACpC,mBAAA/uB,GAAqC,EAAjB,KAAiBgvB,sBACrC,YAAAhvB,EAAA,I,cACA,aAAAA,GAAkC,EAAjB,KAAiBivB,e,CAE9B,MAAkB,OAAa3rB,eAAetD,GAAGwD,YAEI,EAAjDA,IAAgB,OAAgB,KAAiB0rB,SACjD1rB,IAAgB,MAAe,KAAiB2rB,eAG5CxP,GAD0Bnc,IAvBlD,U,iSKoCJ,YAI0C,sBAAA4rB,GAAA,MAAkB7O,GAAkB,I,0BAyB9E,YAIgG,OAAnC,EAAR,OAC5C,G5C2BgB,K4CSzB,YAAsC,OAAM,ER4EsBkD,e,IQ3E9D,M,IAAA,O,IAAA,OADkC,OACT,E,QADS,OAE1B,GAtCc,KAAiB,I5C2BlB,G4C3B8B4F,GAAQ,G5C2BrB,KAAV,G,oB4CChC,cAMqD,SAAY3pB,SAASkY,GAAW9S,K,wOR9BrF,YAQI,OAAOuqB,GAAW,EAAM,EAAG,UAAM,I,kHc/CrC,gBAgB+B,MAN3B,QAD6C,IAAAnM,IAAAA,GAAsB,GAC/D,QAAc,OAAgB,MAAT7b,EACzB,GAAa,MAATA,EAAe,OAAO,EAC1B,IAAK6b,EAAY,OAAO,IAAQ7b,GAEhC,GAAI,EAAKzF,SAAUyF,EAAMzF,OAAQ,OAAO,EAEb,EAAL,EAAKA,OAA3B,IAAK,IAAL,EAAc,EAAd,QAGI,IAAc,GAFC,aAAKgQ,GACJvK,EAAA,WAAMuK,GACUsR,GAC5B,OAAO,EAIf,OAAO,G,+CA6EX,kBAOI,YAD2D,IAAAA,IAAAA,GAAsB,Gd0EgB,EAAAjB,QczEnF,IAAApB,OAAO,KAAM,eAAe,oBAARyO,IAAyBpM,EAAY,MAAW,MAAe,oBAARqM,K,kDkChJ7F,cAMI,GAAI,IAAStY,EAAb,CACI,MAAsB,EAAYuY,YAChB,MAAdC,EACK,EAAL,YAA+B,IAAcxY,IAE7CwY,EAAW,UAAIxY,K,4WzGkC3B,YAIqD,OAAIlE,EAAS,OAAO,EAAY0X,GAAT1X,GAAuBJ,M,4I0GVnG,cAWY,MALR,OAAItU,IAAMyE,EAAU,EACX,MAALzE,GAAmB,EACd,MAALyE,EAAkB,EAGQ,EAAAqI,UAAtB,iBAAA9M,GAAA,OAAgCyE,I,oGzGogB5C,YAMqD,OACjD,IADuD,EAAAwC,KAClDoqB,KAEGC,GAAa,I,kB6EldzB,cAII,OAAO,iBAAgBlF,GAAT1X,K,sECzGlB,YAK+C,WAAA6c,GAAqB,I,yV7EHpE,YAMmD,OAAI7c,EAAS,OAAO,EAAY8c,EAAT9c,GAAsBb,M,oHqB6DhG,cAU6CmF,GAAzCyY,GAA6B,EAAA5Y,IAtE7B,mBDgDQ,IAAAC,GCsBsD,Q,0BAGlE,gBAWuDE,GAAnD,KAA6BE,EAAUL,IApFvC,mBDgDQ,IAAAC,GCoCgE,Q,q8BiEvC5E,cAOqF,WAAA4Y,GAAkB,EAAM7E,I,0FEkJ7G,YAGyC,WAAQ,KAAK8E,cAAe,EAAKC,eAAjC,qB,qBC3OzC,cAeI,YADyB,IAAA7G,IAAAA,EAAuB,KAChD8G,GAAA,EAAsB,GAAI9G,I,4OvBmJ9B,YA1FI,IAJA,IAAIlQ,EAAa,EACbC,EAAW,EAAAvX,OAAS,EAAT,EACXuuB,GAAa,EAEVjX,GAAcC,GAArB,CACI,MAAiBgX,EAA4BhX,EAAhBD,EAC7B,OAAsB,eAAKtH,MAE3B,GAAKue,E,CAMD,IAAKpP,EACD,MAEA5H,EAAAA,EAAY,EAAZ,OARC4H,EAGD7H,EAAAA,EAAc,EAAd,EAFAiX,GAAa,EAuFkB,OA5EpC,EAAA5N,YAAA,EAAYrJ,EAAYC,EAAW,EAAX,I,gDAmfnC,cAKI,OAAI,KAAWjG,GX1X8D,EAAAjO,UW2XxDiO,EAAOtR,QAErB,G,kOAqfX,kBASI,YAD4C,IAAAsX,IAAAA,EAAkB,YAAW,IAAAgK,IAAAA,GAAsB,GACpFA,GAAc,mBACrBkN,GAAe,IAAAlG,YAAY1J,GAAOtH,EAAYgK,GXr4B8C,EAAA/W,Yc3MM,oBHklChFqU,GAAMtH,I,oIA0KhC,kBAYI,QADqD,IAAAgK,IAAAA,GAAsB,QAAO,IAAA9P,IAAAA,EAAa,GACxE,IAAnBsX,EAAW,OAAf,CACI,MAAgBA,EAAW,GAC3B,GAh/BsD,IAg/BjD2F,EAh/BuCzuB,OAi/BxC,OAgCZ,kBASI4gB,GAAwBpP,GAExB,IAAIkd,EAAgB,EAChBrL,EAAY,KAAQoL,EAAWC,EAAepN,GAClD,IAAkB,IAAd+B,GAA4B,IAAT7R,EACnB,OAAOR,GAAO,EAAKlT,YAGvB,MAAgB0T,EAAQ,EACxB,EAAa,GAAsBmd,GAAiB,GAANnd,EAAmB,K,GAK7D,GAHA/N,EAAO,UA36B6E,EAAAkd,YAAA,EA26B/D+N,EAAerL,GA36BkFvlB,YA46BtH4wB,EAAgBrL,EAAYoL,EAAUzuB,OAAtB,EAEZ2uB,GAAalrB,EAAOC,QAAQ8N,EAAQ,EAAR,GAAW,MAC3C6R,EAAY,KAAQoL,EAAWC,EAAepN,UAC3B,IAAd+B,GAGT,OADA5f,EAAO,UAl7BiF,EAAAkd,YAAA,EAk7BnE+N,EAAe,EAAA1uB,QAl7BsFlC,YAm7BnH2F,EA5DQ,GAAMgrB,EAAWnN,EAAY9P,GAI8C,I7DqT7E,E6DrT6E,EAAb,GAAtE,KAAkBsX,OAAlB,EAA2CxH,EAAoB9P,I7D8O/D,EAAM,GAAaod,GAAwB,OAuElD,IAAa,4BAAb,CAAa,eACTze,EAAY,U6DtTgF,K7DsTlEC,I6DtT9B,O7DuTOD,G,osBFvkDX,cACoD,ORiZZ,IAAAqZ,GAvGI,eQ1SSwB,ER0SdtB,MAAA,OQ1Sc,IR0ST,eQ1SuBuB,ER0S5BvB,MAAA,QAuGW3qB,U,oDQ1UlD,YAC4C,OAAO,WAAN+V,GAAkE,GAA/BA,IAAO,IAAO,K,4QAjE9F,cAEI,MAAekW,E0FkSoBtB,K1FjSnC,EAAcuB,E0FiSqBvB,K1FhSnC,GAAIwB,EAAA,WAAU,EACV,O0F6C+DvB,G1F7CpDqB,E0F6CsEtB,K1F7CjEuB,E0F6C6EvB,M1F7ClF,EAAS,IAAAW,GAAA,GAAc,IAAAA,GAAA,GAItC,GAAIc,EAAA,YAAY,EACZ,OAAO,IAAAd,GAAMc,EAAArmB,IAAWomB,IAI5B,MAAiBC,EAAA,mBAAc,GAAf,IAAoBD,GAArB,UAAkC,GACjD,EAAUC,EAAA,SAAWC,EAAA,SAAWF,IAChC,OAAO,IAAAb,GAAMe,EAAA,mB0FkCsDzB,GAAkB,I1FlCzDU,GAAMtlB,G0FkCmD2kB,KAAY,I1FlCvDW,GAAMa,G0FkCiDxB,O1FlCrE,EAA8B,EAAO,M,sDAmDrE,YAC8C,OAAyB,KAAxB5U,EAAA,mBAAO,IAAI,WAAqBA,EAAA,OAAjC,Y,koDiCjDI,KS8C/B,oBAAZ,SAA2B,QAAO,UAAe,QAAO,SAAS,KACxD,IAAA+Z,GAAhB,QAA6B,QAA2B,IAAAC,G,U4D1EJ,MAAuB,YrFkKhE,MqFhKX,OrF+JIpK,GqFhKAjhB,GrFiKO,SqFjKPA,ErFiKOrB,QAAA,mBqFhKX,M,GzDwYsD,EAAWoB,IGzYlC,GAAS,I,GHyYc,EAAWA,IGxYlC,GAAS,I,GMoEV,WAA8B,EAA9B,MFkOc,IAAAurB,IAAmB,cAAU,OAAExlB,GAAF9M,EAAYyE,GAAgB,Me9JlD,eAAiBvC,EAAL,KAAoBA,EAAL,KAAoBA,EAAL,O,GAwDxD,MlDlHzB,IAAA4W,GsFoCkC,M,S/H9HhC,iBAAW,CAAC,OAAZ,c,wX0CoCd,oD,uNbkGA,uB,8oBmGSwE,W,ECO3C,Y,MACF,Y,GAMM,oB,2PzCiPjC,oC,+UtC7UA,gC,iBJ6zBA,2C,oNoFjQmC,oB,sGCthBR,sCA2KG,6BAEA,yB,GAGE,2B,GAEA,kC,+FChRF,oE,yXCuCH,gBAGvB,G,4GCLA,qBAaJ,iBAqBI,qCAA4B,EAC5B,a,iBAiBA,sD,iBAgEgC,qB,+JCuKS,I,OACzC,WAAkB,I,oGAPtB,YAMO,EAEH,Y,iBAIJ,0C,iBAGe,mCAA4B,GAA5B,I,eAiBG,cADd,YAAO,E,eA4BkC,GAAK,W,iCAMZ,gB,mKCgMlC,Q,w6MHliByC,yCAIzC,4B,4DAaA,iB,sGASuD,MAAQ,W,4GAExB,EAAM,4C,6CAMH,gDAa0B,qD,8FAShD,eAHhB,KAAI,sC,0DAIR,4C,sCAEA,OAII,IAAY,IAC+B,6BAE/C,6C,kHAMA,mC,aAGgC,sB,MAAR,mCACpB,IADA,EACA,KAAO,GAA4B,iC,2BAGvC,gBAUI,4B,8ECzEJ,aAA0B,aACtB,W,IAEJ,E,OACO,OAAP,EAAO,2DA8BP,cAAiB,MACjB,aADiB,WAIP,KAJO,WAKV,KACX,wCAGuC,4BAGnC,sBAAqB,W,qCACY,QACjC,G,eAAA,yF,gPAAkC,yF,oWAAlC,8B,iCACuC,mCAAQ,MAgD3C,EAAiB,4DAAjB,c,IACA,YAAiB,+B,OAEN,gB,OAEX,cAAI,EAAe,4BACf,kBAAgB,4BAcd,oD,OACI,oB,GAnDlB,oBA4BI,EA5BJ,4CAuDA,sCAQO,uBAAkB,O,iCAIa,qCAGlC,M,4DAOiC,yB,KAGjC,EACA,G,IAAA,K,cAAA,K,cAGiB,G,iFAmBjB,aAEwB,uB,uBAGV,yB,KG2HP,EH1HC,G,IAAA,K,cAAA,KAC0B,c,GACX,OAAO,E,uHASI,6B,iEzGjGiB,iByGmGzB,KzGnGuD,c,kCyGsGjF,M,uBAKI,SACJ,6B,kBAGI,MAAI,Q,OAAa,kCAGrB,kEAGQ,M,mECwEiC,sDAEnC,0C,YACN,IAFA,IAGJ,Q,wEAlQmC,0CA+Cb,iG,IAAA,qD,EAJlB,iD,0JAuFJ,yC,WAkHc,yG,MACN,EAAY,iDAChB,kE,OAQG,c,0BA5HP,Y,IA0GI,IAAsC,EAAtC,I,OAAA,K,4FA+CJ,gCAKI,sBAEJ,iC,MAYI,8BAA+B,KAIP,oBAA6C,EAA7C,WAAC,iBAAD,iBAEE,oBAAiB,Y,0HAGlB,aAAyC,6BAAxC,M,gGC3WuB,4DAGjD,EAHiD,IACjD,W,OAOA,0BA8BA,sBASqB,4CAErB,EAFqB,e,wBA9CrB,8E,0GAOA,iB,0GA2CyB,MAAQ,W,8IAEa,E,mEAEL,Y,mEAEQ,O,EAAR,8B,4BAGJ,YAAa,4B,kDAAL,wE,oJAY5B,uBACN,oBADP,IAOI,gEACA,iB,aAI0D,uC,0DAY1D,kC,OAEA,oBAGJ,yD,IACA,gBACA,C,0EAIA,kBAAQ,0B,6HAIqB,e,mBAMzB,YCaJ,yBAAO,a,GDZ0B,Y,OAC7B,iBACW,WAAM,kC,GAFY,C,MAIzB,S,+GAqBS,iC,oDAAjB,KAAiB,W,0BCbjB,MAAO,E,mBDwBF,SALD,IAAI,gCAAwB,QAE5B,WAAa,IAFe,KAGvB,W,GAIL,Q,OACA,WAAe,SAAf,EAAe,IAAf,SACA,KAAO,+B,uFAMX,iDAEA,wB,kHAQI,I,aAJJ,c,8IAII,Q,aAJJ,c,oJAII,Y,aAJJ,c,qJA0BI,K,aAJJ,c,qKAkBU,8BCoHH,qC,8BDlHsE,kB,KAArE,E,GACW,IAIvB,KAJuB,cAIvB,K3GpG6C,YAAM,E,Y2GuGrC,M,KCyGP,EDxGC,OCyGG,E,cDxGuB,EAAU,kC,wC3GzGC,KAAM,c,mC2GkH9B,I,KAAjB,c,KAGA,YAAI,EAUA,GASI,SAEJ,M,KAGA,EAEA,S,QAGA,wCAOwB,kC,MACpB,KAAgB,e,GAChB,oBAQK,OAPC,MAAN,qBAGR,6B,GAIa,8CAAb,GAEA,4C,IAKA,EAAO,KAAP,cACJ,kB,qBAQ6B,GAAD,wBAAC,+BAAD,yBAAiF,mCACzG,MADA,wCACA,O,0GAQA,2BAAkB,O,gBChLtB,EDoLW,ECpLX,mD,OACI,oBAAO,EDoLG,GAEa,6D,MAAqC,I,GAEhC,O,EAApB,kBAJE,EAIF,cAJE,IAIF,4D,OAO8B,EAMtB,2BACA,yBAIR,4CAIc,uBAAN,MAAM,kBAEN,0C,wCAGA,sD,sCAGJ,KAAa,WACb,C,2BAQA,EAAI,c,QACJ,WAAa,I,KACT,W,iC3G9OyB,KAAM,0B2GqPzC,O,mBAOW,O,iBAHjB,KAAI,kC,2CAER,O,EAAA,wCAGI,KAAS,OAAT,OAmB0C,G,yDAAA,eAT1C,OADM,KAIF,UAJE,YAMN,yBAAY,EAAX,eANK,MAUF,sBAAsB,G,sBAVpB,EAWE,e,wBAQD,W,CC7QP,YAAO,M,WD+QC,c,GACI,Y,OACI,aAAQ,IAA8B,c,GAD1C,C,0EAmBR,6G,8GAIR,YASW,oBChTP,Y,6DDmTY,WAAa,MAC6B,gBAEnC,MAAP,KAAO,yCAFP,E,IAIJ,GAPE,EAOF,8B,2DACI,Q,6D3GtUmC,0B2GmVzC,QAA4C,M,4BAMlD,SAAK,EAAc,G,eAON,gEAAb,GAAa,EAAb,cACO,gBAMP,YALe,MAAf,G,gFAQA,KAGA,aAAc,gCAKd,I,gBAAA,C,yBAKA,cAAsB,IAAtB,C,2DAIS,e,KAAT,SAAS,EACT,GAOY,QAFZ,OACI,kCAAkC,E,uBAC1B,gC,EAUT,W,mTAUX,Y,oTAAA,wF,sDAIA,MAIwC,sC,oaAWZ,sD,IAExB,E,OADA,2FAEA,iC,OACI,kBAAQ,0EAEZ,mC,MAA0B,2B,sFAM1B,iCACA,eADA,WACA,IAEA,iC,MAJA,UAEA,oBACA,EADA,WAEA,SAFA,iB,4CAI+B,O,iBAG3B,c,2CARJ,c,qDAHJ,EAEI,W,qBAFJ,QAEI,aACA,QACA,QACA,cACA,qBANJ,sB,+KE3emD,a,qDCtD/C,Q,0BAFJ,Y,sFAAA,S,iBAAA,M,qCAAA,uCAW0C,c,oEAKT,Y,oHCTzB,QAAE,mB,qCAsGF,aAA6B,MAAN,EAAM,iDAA7B,G,+EC9GA,YAAQ,U,4BAIV,wBL4iBE,oBAA2B,EAA3B,+C,iCAVJ,6CAEA,gC,mBACA,iC,6DACA,6DANJ,M,wME/gBA,iCjGgLiC,OAAhB,OiGtKb,iBjGuKI,mCiGvK4B,iCjGsKhC,wBiGtKgC,eAEpC,mC,OAKmC,aAA+C,mC,2BAMX,mC,OlGSnE,KkGT4G,gB,mCAMxE,8BAG7B,aAAc,sB,8EACS,oK,qVACG,I,OACjC,sB,kCAAA,0I,+jBAAA,oE,4CAGI,qB,2BAEJ,aACI,4B,4CAEA,qB,ySClFR,oB,MACI,qClGsNa,kBAAgB,iBACzB,qBkGpNU,mBlGqNQ,c,4BkGvNhB,E,ElGsNgB,kBAAlB,4DAAkB,EAAlB,e,OACQ,Q,yJkG3MR,gC,8DAGA,wC,iCAEqC,qCACzC,Y,sMA+BA,wBAAuB,W,OACvB,qBACA,wC,OAA6B,YAAuB,IAAd,EAAqB,mBAA9B,8B,4MC/B7B,IAxBJ,kCAwBI,mE,OAAA,gL,uGAAA,oC,OAAA,I,KAAA,a,KAAA,e,4CAkEgB,GAAZ,0BAEJ,iCA6BkF,wC,2CAiBnE,I,KAAA,a,KACf,e,IAiBoC,cAAF,4D,iCCzIlC,sB,IAUA,QACJ,cAII,OAFJ,WACI,IAAI,GACG,G,4DA6DP,Y,2CAAA,c,2DCtFA,aAJA,E,8EALJ,K,cAAA,Q,yDDuCA,uD,OAAA,sBAMI,iDAAS,4BANb,uD,OAQY,OAAwB,SARpC,0GAMI,sC,kDAkDA,gG,iCC/FJ,iBAKI,K,IALJ,Q,qBAAA,kB,kBC+EA,KAOI,EAAa,gB,+GAyCL,kDAEZ,K,IAAA,Q,uCAkFgB,GA+ChB,eAsBA,cAKkD,Q,wIA5JlD,mC,OAAA,iD,uCA2HiD,iC,IACzC,I,OACU,GADV,EACU,WAAV,WAAoC,GAxC5C,gC,OAsCI,OAA6C,aAAtC,wG,oBAiBX,aAMiC,4BAAgC,IAUmB,sBAAO,qDAE3F,W,OAgBkE,EAAjB,yBAGjD,oBAawE,EAbxE,0C,gBAawE,Q,iBClSpE,M,gBAAA,Q,+CAWA,qF,qCA4CQ,a,aAJJ,gB,qDAoBqB,OAAN,GAA0C,U,uEAE/B,KAAtB,G,uDAU2B,G,6BhB7BwC,e,qCAmBtD,Y,IACrB,EOyMsC,OPzMH,KOyMG,G,OPnM1C,uBAEA,KAeqD,EAAe,a,kCCpE5D,IACA,cAAK,EAAL,mD,4BAgBY,+D,wCeQR,oF,OAAsB,sBAAN,W,0CAnF5B,kB,IAAA,U,kBAAA,sB,IAAA,uB,UAAA,O,cAAA,0B,8MTuTQ,sBAAY,qCACZ,EADY,IANZ,W,uDP7RmC,iC,2BAAqC,uB,+BADxE,OAAI,G,IAAW,UACf,OO4RkC,K,kBPxQtC,K,IAMI,S,gHOkQkC,iCPzMC,oBOyMD,WPzMC,IAKvC,uDAvBJ,MCvEI,yC,KAKA,cAKqB,G,sBD2GzB,Y,OAKQ,mCAAO,EAAP,G,iBC5FA,aAAK,wC,OAA0B,qCAEnC,oDAEoC,I,gDA4BI,8BADxB,EAC+B,GAD3C,4DAEM,iB,mGAIE,iB,yDAGR,E,0DAIA,E,OAAQ,kC,OAGR,E,EAAI,uBAEc,EAClB,OACK,IACT,qD,UAEsB,aAAsB,uC,IACxC,EACA,E,GAAkB,iCAElB,EAAI,M,uCAOQ,IAEhB,E,yIAKJ,iFAEI,W,0IAGI,MAAY,W,IAAJ,I,OAAI,OAAJ,EAAI,OAAJ,OAAI,yC,wCAA2B,IAAlB,GAAb,azFhCL,2C,QyFgCK,M,4IAMR,GAAI,GACR,0D,8BAIA,e,wFAhBJ,iG,sEAoCA,MACI,W,IADgD,E,KAAA,2B,oBAMpD,wBACI,I,YAeuC,8C,OACvC,kBAMA,aAA2B,kC,0EAEvB,yB,iCACa,sC,gDAEa,GACrB,G,4BAgBG,mBAAgC,qB,0ZgBuQhD,K,IASI,Q,qBAEJ,WAeI,O,GAgDJ,eAKI,YAD+B,UAAgC,MAC/D,U,eAsBe,eAAM,E,8BAmCzB,e,mBA4CsC,W,wDAQlC,qC,sBAzJ0B,+CAAgC,IAAhC,IrH2wBV,UqH1wBhB,ErH0wBgB,GqH1wBhB,gCrH0wBgB,+BAAa,oBqH1wBP,OAC1B,0C,YAEA,QAIwC,Q,uCAMV,0D,YAAA,QrH6vBV,WqH5vBhB,IrH4vBgB,IAAhB,GAAgB,cAAAxZ,KAAA,2CqH5vBI,sC,UAsBpB,oBAAQ,EAAR,WAAQ,MAAR,gBAgCJ,gC,OAeI,kBACJ,oBAEA,aAIuC,8BAAoB,IAE3D,oBAImC,EAJnC,WAIuD,WAJvD,WAKc,MAA4B,oBAAtC,aACI,uBACG,MAQgC,iCACvC,+BC5bI,2DACU,iBAEd,e,kCAGgB,aAAK,mC,OACjB,G,kFAGmD,uD,+CAKvD,O,WAFI,OAEJ,G,eAoBI,sBAKI,QAKA,kC,wBA+bI,W,OAA4C,qB,qBAgapD,YAAyB,GAKzB,mB,qDAdA,gD,gEAkHA,oBAAiB,ErHrkCrB,KAAI,gBqHskCM,ErHrkCN,kBqHqkC8B,ErHpkC9B,yBAAM,K,qBqH8rCwB,c,yGAKI,a,eAsD9B,WAAI,E,e1GxwCZ,S0G2wCI,a1G3wCJ,Y,yB0G+wCI,cAAI,EAAO,kBAAU,EAArB,EAA0C,YAA/B,cAAX,I,sGAaqC,yD,6BA6BA,GAAO,W,sHCt1Cd,c,8CAkBf,sB,eAGf,GAAO,W,qECRP,aAAM,E,+BAuBN,gB,6BA8BA,c,6BAWA,eAAO,E,+CChGf,gB,eA+B6D,c,2BAOA,c,0KC6EzD,gB,iBC/EI,UAAqB,yBACrB,yC,sBAiBgD,cLsI5C,yBAAmB,gBAAnB,eAAwC,EAAxC,e,OAEQ,QAGR,yEACA,EADA,IAEA,W,OAAc,8BAFd,IAMgB,YACpB,kCAKA,kCAA0B,Y,GACnB,MAAP,E,CAOI,U,MAucJ,4B,4BA5bsC,mB,YxH2B1BA,KAAA,gC,gCAAA,kEwH3BwC,ExH2BxC,e,IAA8B,wB,KAC9C,wB,4BwH5BI,4BAEA,aAAY,kC,OAEkC,uBxHuBlC,sBwHvBuB,GxHuBvB,UwHvBuB,0BxHuBvB,EwHvBuB,e,MxHuBH,mB,OAAU,gBAAO,c,gEACrD,iB,0CwHvBQ,sBAAI,0CAAyC,EAAzC,IAER,WACJ,yB,uBAEA,kCACQ,aAAW,+C,IAAW,MAC1B,SAAqB,IAAuB,OAAW,QAAlC,QAArB,aAMA,MACkB,SAAlB,a,IAAkB,0BACd,OAAgB,4BAAhB,KACkB,MAAd,G,4CAKZ,QAWI,E,SAJ0D,MAArD,EAGL,U,OAEJ,UAEA,sEAQI,sCAEI,KAEJ,0BAAa,GAKb,kCAAI,G,KAEU,uB,8EAKJ,yCAAN,c,4CAIR,+CAgDI,K,IM3MA,E,SAEkB,E,qCNkMV,EAtCgC,S,mBAuClC,I,oCAMN,O,MAAiB,mB,GA3CjB,gB,WAYuB,MAOvB,IADA,IAAqB,WACrB,EAAa,WAAb,CAEI,QAAmB,OACnB,GAAO,OAAP,gBAIG,EAAO,E,SAOd,aAHwB,G,GM5LhB,MADR,E,OAAA,E,kFNqMQ,W,yCMnMJ,EAAM,WAAI,C,INwMd,E,SAAiB,gDM/MrB,4D,ONoMA,KAWI,uBAXJ,KACI,iBAA4B,GAA5B,IMjMA,K,wHNsMQ,+D,QACI,I,sCAJR,Y,wFAQJ,e,mDAvMA,2GA8MgB,SAAO,EAAP,6CAGpB,sD,IAQQ,E,qCACI,EAAU,SACV,EAAK,SAA2C,EAAO,O,GACvD,gBACA,I,EAAA,I,IAG8C,Y,aAE9C,c,uCAEI,kEAWN,UACc,2D,mFADpB,uB,OAGI,E,IrHnRqC,EAAM,WqHmRpB,G,EACvB,0B,OAAyC,OAJ7C,GAI6C,S,kCAID,sD,QAAA,EAC5C,W,2CAU0B,EAD1B,I,IACI,Y,aAAgB,c,MADZ,EACY,+B,oEAGhB,Q,eAJI,6C,0EAYR,kB,Q1G7UG,E0G6UK,EAAY,S,oBAIpB,S,cAjRA,Y,mCA4RU,+BACF,kE,EAOA,QAEQ,OAAJ,EAAI,MACA,gDAIA,aAAI,iB,cAMQ,kD,kCAMA,iD,OAIZ,SAAI,M,8CAKI,oB,OAOZ,e,GACA,EAAO,a,kFAOR,KAAI,UACX,IAAC,EAGD,GAJJ,kCASO,iDACX,QAGyB,qB,GAAA,gBAAwB,0GAAxC,0D,SM7ca,cAAO,I,MAAP,oDN6clB,OM5cA,eACA,8C,qHNgdA,I,oBADA,QAEA,WAAO,WAAc,GAArB,wE,qDAGJ,eAEU,EAFV,IAII,W,IAEA,EACJ,qB,sBAIQ,OAAiB,IAAjB,W,0DAhXJ,OAiXI,EAhXA,KAAM,a,MAuXF,oDAAsB,SAAO,OAAP,MACtB,Q,QAI0D,iFAE7D,W,IACT,qB,oCAHA,oD,OAAoC,KXnPE,+BWmPgC,M,yGAM1D,C,8BAnYR,IAAO,EAAP,IACI,KAAM,aAwYK,eAAY,QACnB,uBADmB,KAGR,mB,GAOJ,c,gFAmDnB,O,EAAA,uC,kBAtcW,WACH,KAAM,8D,CAgaM,eAEA,WAER,MANE,EAMF,cAEQ,IAAJ,EAAI,UAAyB,gB,0GAcD,S,2BAIxC,G,sEAoBA,KAaI,8C,IAAgC,U,EACpC,E,8CAOqD,oBAAW,OAAX,oC,OAe9C,WAVP,GAWI,qD,IAAqC,E,SAErC,GAAe,OAAf,IAAqC,K,QAGjC,qB,WANR,GASJ,UA1fW,0D,IACH,SAkgBA,EAAI,oBAAwB,G,KAI5B,mBAAqB,I,KACrB,iBAAiB,I,2DAKzB,gC,IAAA,U,KACiD,uB,KAAyB,qB,iCAMhD,KAAN,yB,OAEZ,8BAHJ,GAAY,EAAK,UAIb,+C,OrHxjBqC,C,6BqHyjB7B,eAJZ,SAMA,QAAQ,8B,WAiBR,+C,SA3iBA,K,EA8hBuD,Y,qDAAA,GA9f9B,Y,IAAzB,SAAyB,Q,OAEzB,uBAEI,KACA,gBArCJ,G,SA6iBU,2DACF,iB,OAEQ,QAEA,yD,OAEA,C,MACyB,mB,GAAA,a,sCAAmD,eAAO,G1GnoBjG,I0GmoBiG,a,GACtD,IAAnB,gC,YAGM,0BAAV,gDAKd,4C,OAEyB,C,IAAA,qB,IAAA,e,2BAMjB,cAEI,iB,0BARa,uB,yBAArB,G,SAcI,sBAAO,gE,YAOkD,gDAAN,8FAEnD,qD,2BAKR,gD,arH7nBuC,qCqH+nB7B,MrH/nB6B,EqH+nB7B,8CrH/nB6B,0D,GqHsnBoB,gD,6EAiBxD,4BAAqC,gD,QAAhD,SAAW,MAGN,wBAAO,2BAEZ,qCAAuB,Y,OACvB,KAAO,uB,gDA5mBP,EAsnBI,K,SAEI,wBAA4C,4CAC5C,MAGI,SACO,oCAIvB,QAjoBW,IAAP,G,KA8oBQ,IAAe,GACX,MAKI,gC,UAYZ,aAAO,2C,OAON,C,IACD,EAAI,mB,IAEA,EAAO,6C,OAEX,G,0FAMR,GAOe,OAIK,GAJL,WAAX,+J,IAIA,EAAgB,8C,OAEhB,c,YAgBK,QAbD,EAAc,WAAqB,IAAP,IAE5B,QAII,iEAMJ,qD,IACA,EAAC,IAA4D,qB,GAEvB,WAAV,IAA5B,mBAGJ,kBAAuB,cAEvB,MAAY,aACZ,MAAI,GAAiB,6CAAkC,MAAlC,YAGrB,EAAO,KACX,Q,yGAGa,wD,oCAGT,iE,kHAKA,EAAmB,GAInB,QAAoC,CACd,IAAN,E,EAAM,qB,GAAe,EAAO,cAA5C,MACA,KAAO,S,+BAOP,aAA0B,EAA1B,CAEI,MAAwE,iBAE5E,Q,oDAKA,EAAU,EACY,IAAM,I,gCAExB,kBACI,WAEJ,OAFmB,SACnB,KAAI,6BAAJ,KAAI,GACA,GAAiB,IAAO,EAAP,a,2BAIsC,Q,CAAA,uH,sNACzD,E,GACoB,O,EAAtB,QAAsB,C,oCAAA,e,MACC,GAAN,2BAAM,e,+DAAN,uD,6MACmB,gD,cAAA,uD,GAAA,O,YM5wBpC,O,+DACA,oD,qFN0wBiB,iI,GAAA,O,yEADjB,gB,8GADJ,2C,4JAD+D,I,0EAAA,e,aAAA,0B,KAAA,uB,mCAAjB,G,qFASlD,S,IAWI,EAAO,YACX,a,eASI,qC,mCAkBgD,sD,+CAQE,uD,mHASV,I,OAAQ,uF,gEAYmB,sE,wBAUjB,+B,aAalD,EAAG,E,8CAGiC,0CAAgB,gB,yKAShD,aAAM,gC,UAFiC,EAGvC,YAHuC,U,cAM3C,SAN2C,S,IAAA,EAOd,a,YAPc,EAQnC,a,kCAaJ,wBAAQ,qB,wCAC2B,4B,4EAInC,2CAAQ,cAAW,IAAX,CACK,G,eAAb,gEAAa,kB,qCAIb,mCAAQ,+BAAkB,M,eAC1B,S,+CAG0B,e,sBACJ,iB,KAAQ,E,iEACH,6B,GAAQ,e,wGAQZ,SAFnB,eAAQ,S,KACuB,E1G9+BrCA,KAAA,Q0G8+B+C,EAAV,S,KAC/B,EAAmB,oC,erHl8Bc,S,OqH+7BrC,oBAMA,aAAgB,EAChB,S,KAAsB,EACtB,OAAI,kB,KAAkE,EACtE,eACA,S,iCAqBwB,EAhBxB,S,QAGI,MADA,aAAiB,EACjB,kD,YAGW,IAAT,a,MACF,mCAAQ,EAEJ,aAAI,sBAAkB,qB,mEAe9B,W,iBARI,gB,IAAgD,EAA5B,OAA4B,EAA5B,U,SrH99Ba,E,kKqH0+BzC,6D,MAAQ,GAGiB,gDACzB,sEACA,EADA,IAEA,W,OACA,K,qEAGI,iB,0EAI0B,wDAE9B,mD,wCAQkC,mCAA1B,sC,OAAoB,KAAM,iBAAN,oDACpB,mC,OAAiC,UAEzC,+C,sBAGI,e,0GAWqC,Y,aAM7C,0D,OAMI,uBrH7kCA,sBqH8kC8B,2CrH7kCxB,EqH6kCwB,IAC9B,W,OAAqC,KAAM,iBADb,gB,0BAW1B,sBAAiB,wCACb,EADa,e,OO/qCuD,mBP+qCvD,IASjB,Y,uBAEJ,sBAAO,uDAGsE,W,OAAA,0BAHtE,IAWP,YACK,yBAAL,K,qFATuC,KAAsC,2B,kDAajF,qBApiCQ,W,OAojC8C,wBARvB,6DACnB,iB,OAGQ,MAAJ,kB,kDAIU,E,6BAGd,QAEA,6B,GAEO,e,IACP,wB,0CAYR,MAAI,eAAJ,EAAI,gBAGgC,EAAM,sB,QAAhC,iB,wLAQlB,U,8BACA,WAAwC,+BAAD,YAAC,KAAD,C,gOAyBnB,uC,oDAAA,iL,wDACa,MAAQ,oD,uEAId,6FAChB,oBAEP,gD,0GAAA,sC,EAW0B,e,oGAML,oBAAD,EAAC,WAAiD,oBAAjD,WAAjB,MACA,6EACQ,iB,OACQ,SAAC,mBAAU,OAA0C,qD,MAAjE,mB,0SAYZ,cACI,+C,wDAAA,e,cAAA,a,GAAA,yC,uCAKqC,gD,cADN,Y,IAAQ,iB,8KAEd,C,2BACC,KAAE,W,kHAGhC,0D,GACmC,oC,YAAQ,0EACX,yD,IAAQ,E,oCAEpC,6C1GlwCA,G0GmwCW,sDAGP,oBM7qCA,EN6qCA,WM5qCO,aN4qCP,WM3qCQ,e,iChH3FZ,gCgH4Fc,I,qENyrCiB,2B,iFACG,Q,qHAGN,mBAE5B,M,kGAI4B,qEAE5B,EAF4B,IAC5B,W,0CAEyC,sBxGx0CzC,W,uLwG20CoC,gB,GACpC,OACA,wE,iBAU4B,EAApB,IARJ,CAEA,GAAI,mBAEa,S,GxG10CrB,OwG00CqB,WAAoB,EAAM,OAA1B,iD,SAIA,MAErB,+DAG8B,oBAE9B,EAF8B,WAC9B,aAD8B,e,yGAMK,SAGnC,oB,IADA,Y,wBAGQ,sBAAO,uCACD,EADC,e,sFAKwB,eACvC,gCACA,mC,wCAGQ,GAAO,6CAEf,kEASwC,8E,2EAEZ,W,OAE5B,QACA,2C,oCAGQ,iBAAS,GAAqB,iBAAQ,M,IAC9C,a,qDAG0B,IAE1B,O,6CACyB,Q,2CACgB,aAAS,oB,6EACO,cAAI,kDAIjC,+CAE5B,W,OADA,uB,sBAEA,uCACU,iB,2HCz7Cd,oBAMgD,EANhD,+CAgDoB,aAAZ,mBAEA,mB,oBAaI,aAHJ,gCACI,MAGA,gC,mFAFJ,gCAGI,M,oFC/DZ,oCAiB+B,6BAAgC,S,0VAuDY,MAenE,gC,gFAEJ,e,oBAYkD,wD,gEAeO,M,4EApH7D,mB,oBCKA,aAiByB,iCAAe,KAMd,2DAA6B,iBAoBN,mBACzC,aAAgB,mBAAhB,cACU,wBAAV,W,gDApBR,2CAsBA,oBAE+B,aAAiB,sC,uJAIT,aAGnC,qC,wKC7B6C,Y,mDA1BjD,Y,GAyBI,OAAI,E,MAAkB,mB,+BA6BtB,EAAO,SAAoB,GA6BsB,Q,cACzC,OACA,EAEJ,6B,MA9BR,4E,uDAgFQ,G,oBAIA,kD,mCCnFJ,M,oEAQwC,G,oBAAQ,aAAuC,0CAAvC,QAMG,oD,2EAAA,kD,0DAOzC,EAAN,EAAM,kB,GAAA,Q,MCAa,2M,8BACf,iC,MAAY,0BDDgC,cCElC,MAAO,EAAP,WAAO,aAAP,WACR,M,OAAqB,K,cDH3B,OCIA,W,ODJA,G,cAQM,OAAc,gB,0ECnCG,aACvB,sB,IEZJ,GAKA,GAKA,G,wCH8CiE,OAN7D,W,OAM6D,G,sCAoB7D,EAAI,GAA2B,M,YAE/B,EAAO,a,6CAOH,aAAa,O,4CC1EM,0B,eDkTnB,kB,OAD2D,gB,+DAuK/D,gC,mCCxdA,0BAAe,EAAQ,6BACvB,a,eDkiCJ,QAAI,MAAJ,e,eAndI,gB,wCAyEA,iB,eAwHI,QAAc,Q,eA2Bd,KAAI,uB,wFAkFa,iB,eAOrB,eACA,e,iBAgG0B,cAG9B,YAFA,mB,mBAwBI,kBACA,4B,iBAWmB,cAEvB,gBADA,Y,kDAYkC,c,8CGtiCtB,c,0EAUR,Y,gFAqCyB,cACrB,gBAAgB,E,+CCgFM,GAL1B,GAAkB,aAClB,gBAAc,EACd,4BAG0B,qBADtB,MAAgB,iDAAhB,iCACA,MAAI,EAAJ,cAEA,YAAS,OACT,sBACK,EAAL,cAAkB,SAAlB,MAEA,QACA,KAAI,SAAQ,EACF,cACK,c,wOCqLyC,sD,kDAAhD,K,+EAsFsB,e,kGA7E1C,e,mDAAA,gB,oBA0MY,YAAC,E,uEA0LT,QACA,qBLlnBQ,6C,uBAKA,OAAM,gC,OARV,G,QAoB4B,GANrB,MAFX,mCAGQ,OAFJ,8BAA2B,GAEvB,EAAW,cAKa,uD,MAAwB,2B,EAA5C,oC,GACA,MAAc,E,OAElB,E,IACkB,EAAd,S,wC1HvBiC,EAAM,a0Ha/C,qF,IAiBA,IACA,E,OACJ,oD,oBAOI,YAEO,KAGP,sBAAc,uDAG0E,W,IAAA,I,SAEhF,iCAAJ,MAAI,aACA,iBAAe,GAGf,K,EAGa,K,KAIA,oD,QACL,a,WAQZ,Q,GAEI,O,mBAIgC,gB,kCAKlB,I,mDAjC1B,Y,oBAyCI,GADA,aAA2B,2B,IAC3B,eACO,Y7GlLX,U,sB6GyMW,wB,OAPK,gD,WAA4B,oB,gFAIzB,G,MACH,cAAJ,mBACA,mBADA,WC9Ke,0EDgLhB,EChLgB,e,OACL,8BAElB,yBAAO,UAAP,+C,OD0KQ,sD,yCAMR,iC,gCAIa,aAAU,wB,IAOA,I,6DCxMA,e,GAAA,6DAEvB,MADA,OACA,E,QDuMA,UAEgB,uC,IAChB,EAAO,EACX,8B,UAQS,+BALL,OAAc,GAAd,C,GAKK,OAJL,EAAI,sB,6BAUJ,IAAI,EAAC,EACD,OAA2B,eAA3B,4CACA,KAAI,SAAU,EAAd,I,uDACI,OAA4B,uD,OAMhC,G,+DAKR,oB,iBAsBqB,0D,IACjB,EAAO,E,GAGY,iF,2BADf,E,OAKI,iB1H3OR,a2HE2B,4B,O3HD3B,I,EAAoC,K,EAAA,E,YgI7D9B,2BACF,sFACA,2BN+S4B,GM/SD,QAEvB,Y,QACA,KAAgB,OAAO,EAAvB,I,YACW,EN2Sa,6C,YAEhC,e,yDASJ,yBAKU,OAAN,G,YAAM,+BCvQN,GAAW,IAAX,IACmB,kBACnB,YADmB,+CACH,iE3HChB,CAAoC,G,oF0HoQpC,oB,yBAIJ,O,EAAA,oDAQ+B,OAL+B,Y,kCAM1D,mC,gDAG+D,yB,mBAQ3D,EAAe,QACM,KAAT,OAAS,MAAT,SAGZ,EAAO,uB,2BAKH,c,2BAEA,gB,aAFR,qBAAQ,W,0BAQJ,MACI,+C,UAEA,U,EAEI,a,QAI8B,EAAM,eAAkB,IAAlB,CAClB,K,QAM1B,qBAEI,GAAgB,QAAoB,G,MACpC,E,EACA,EAAgB,0C,OAChB,oB,gJAQZ,uB,sBAKI,K,mCAIe,aC9ZgB,kC,GD+ZP,MAApB,KAAoB,mBAApB,KAEI,iBADe,EACM,GAFzB,C,MAII,sB,GAAW,O,iFAHf,mD,IAOA,EAAa,KAAb,gBACc,MAAV,GAAU,Y,OACV,EAAI,uBAA6B,uBAErC,GAHc,Q,iBClRX,qC,QACH,EAAI,E,EDyRgC,OACjC,O,kCCzRH,C,QD4RqC,WAIf,kBAJuB,e,IAMjD,MADA,I,GAGA,OADA,c,yBAFA,iC,mJAMI,gCAAO,I,sDAIX,qD,IAGI,E,4CAMI,OACA,Q,oBAII,e,mBAGsB,EAAyB,E,+DAG7B,UAE9B,G,OADA,G,2EAG+E,yC,OAApB,e,0BAUV,+BAAY,Y,uHAO3B,oBAEtC,EAFsC,2C,0IA6B9B,aAES,MACL,sBAAY,qCAGX,EAHW,eAKxB,uBASiB,kD,OACb,CACA,GAAI,aAAiB,OACrB,sBACA,IAAK,qBACL,EAAqB,yBAArB,G,oDAQsC,kBAAQ,+C,sFAIM,mCAA4B,K,uCAC/C,O,YAAQ,wB,8DACV,gEAEnC,iC,OAS+D,mFAAvD,sBAAW,GAAe,oCAAf,eAA4C,EAA5C,IAEf,WACJ,IAGsG,qB,GAAA,iB,MAE/E,a,IAEnB,EAHc,EAAI,aACd,a,eACqC,gBAAoD,eAAzF,aAFJ,gB,EAIQ,mB,OACA,QACA,yCAGJ,SAAa,QACT,yB,KAKK,aAAO,iBAAQ,W,UACpB,MAGZ,e,oCApB8D,IhBzQrB,SgBiSc,U,OAAE,K,4EAFiB,W,MAAI,M,uEAAJ,6B,mDAEhE,E,8EC9hBiB,+FACL,+CAElB,2B,iDDyhBsE,yB,iHAIxB,OAAgC,eAAhC,yBAAuB,sD,uCAAvB,mF,cAIlD,MAGI,EAHJ,WAIQ,aAJR,WAI8C,SAif9C,yBAA6D,UAAc,aAAQ,qBAjfnD,W,OAE5B,KAAO,WAGX,+C,OAKiC,2BAH7B,GACmC,gCAAc,aACjB,qCAAqB,cAEzD,iC,MAEA,+C,iCAWQ,gCACJ,cAAe,oDAKF,M,6CAaA,K,GAAA,6C,kBACb,GAAW,MADX,8BAGI,OADJ,uBACI,aAEI,yB,0DAQI,yBAAR,mCAAQ,G,eAEZ,GACJ,S,qBM7oBU,sBACF,yEACA,iB,0CAGI,sBAAW,aAAX,qBAAW,eACA,EADA,e,kFNipBvB,sCAA2D,iB,+FAY7B,MAAkC,W,8DAExD,aADiE,QACjE,Y,IAD2D,E,EAE3D,oB,OAF2D,IAE/C,mBAF+C,KAGnD,sB,oGAKiB,Y,IAAzB,IAAe,IAAU,EAAV,EAAU,EACJ,+BAAT,oCAAZ,IAAY,OAAZ,cACA,EAAI,yBAAwB,EAAO,e,IAGvC,U,CAIK,yB,YAAA,+B,qFAKG,U,6JAGA,I,qEAKA,M,GAAA,0B,0BAGA,yB,+DAHA,e,KAQR,GAAO,qBAAP,CACQ,KAAmB,QAEnB,IAAI,GAAoC,KAApC,GAAJ,CAAsD,K,QAIlD,kBAAe,G,WACf,G,EACA,E,UAKhB,0C,oDAIQ,GACI,yB,oDAKa,oB,OAAoB,O,iDAOK,uD,kGAElC,O,uEAMhB,wDAMiB,gD,OACT,gC,gDAER,yBAKyC,4BAA/B,yCACkC,gD,IADxC,E/GhsBGA,K+GgsBH,iB,6CAUJ,oDAIwC,M,GAKA,OAApC,EAAK,sBAET,oC,QAA0C,E,cAElC,I,EAAI,IAAQ,M,GACR,e,MAE0B,W,sDAGlB,0CAChB,aAAmB,6C,aAIX,O,iBAAwB,EAAO,YAKnC,I,IAF4B,EAAO,WAAc,WAAd,GAAP,MAErB,kBAAP,I,iDAHiB,OAAjB,IAAS,WAAQ,iDAQwB,sBAAkB,W,OACvD,IAAO,GAAP,OAGR,0CAEwF,6BAGpE,yC,OACR,WAAQ,IACR,EAGJ,SAAa,MAGT,KAFJ,I,iDAKa,E,OACT,O,G7G9yBhB,WDgDQ,EAAO,aChDW,O,0B6GgzBd,GAEwE,IAAkB,GAAtF,G,sGhB5hByB,gE,6DgBuiB7B,IACA,IAAO,oBAGX,0BAAM,4BAAsB,Q,2GAIG,W,OAGnC,gB,6DACkC,I,wBAAA,8DAKlC,oBACqB,EADrB,WACgB,4EAA4F,MAAxG,W,OAGA,gBAEJ,yD,QAE+C,KAAK,W,8BAI5C,sCAAiC,W,C7Gn2B7C,yC,U6Go2ByB,WAA2B,I7G31BpD,Q,mL6Gi2BwD,kBAIpD,OADA,0DAOA,K,uDADgC,uD,EAChC,eAIgB,oD,IACL,EAAO,mBADd,OAAY,iBAAZ,GAMJ,OAFI,GACA,6BACJ,GAOI,aAAkB,wC,IAClB,EAAK,GAAe,uCAApB,W,OACJ,yB,yBAGgB,GACR,aAAK,+BAEL,aAAK,+BAHT,mDAKA,gD,yDAS8B,iC,qHAGL,mCAK7B,M,yDAEW,KAAP,0CAAO,KAAP,uB,mDAIM,2B,4CAQN,EAAK,OAAO,MAAP,C,GAAoB,mBACzB,yB,OACI,E,OAAA,G,4DACA,Y,gBAER,gB,CAGI,GAAI,UAAJ,oB,YACI,UAAQ,6BAIJ,+B,GAAR,EAAQ,OAAR,E,sCAE8B,qBAAgB,e,6OAqC3B,6B,oBASI,kB,2RAoB/B,wB,8DAIgB,MAAK,KAAL,uBAAK,KAAU,kBAAM,WAAhB,mDAAkC,MAI5C,MAAP,GAAO,kBACX,IAEyC,aAAe,wC,4FAC2B,IAA3B,iBAA2B,C7GlgCnF,gB,+D6GmgCA,Q,2GAG+C,uEAG/C,6DAGe,M,8DAOU,GAArB,0BAA4C,YAAY,U,oJAUvB,MAAR,0FAAQ,M,oFACG,uB,+FAEf,mBAAQ,gC,6DACT,UAAQ,uB,sCAC8C,uD,IAApB,E,8FACvB,iC,qdAQV,wB,8EAEzB,oBAAqE,M,iHAGzE,eAEuF,kCAA5D,2CAAqB,Y,aAA+B,OAA3E,EAA6D,qCAAc,GAAQ,0C,iCAEvF,sF,oBGhlCuC,aAKnC,2BAJA,SAMY,c7HGZ,MACI,EADJ,WAEU,kBAFV,W6HAA,SAoBI,6C,0FAKa,iC,uEAKA,6B,sDAKwB,M,mDAAQ,M,+BACN,2C,0FAGtB,OAAjB,KACI,IlHsBF,cACC,mC,wCkHnBQ,GAAM,MAAN,sCACX,oBACA,EADA,0CAUJ,+B,yCAIoB,+B,2CAAiB,iE,sFASP,sBAAO,4CACb,EADa,IAE7B,W,IACA,E,OACY,OAAZ,OAAY,4BAIhB,sBAAO,gE,IAOH,E,OAAA,0CACA,sBAAgB,0CACJ,EADI,IACM,W,OAEV,QAGZ,sBAAgB,yCAChB,EADgB,IAEhB,W,OACA,QAIJ,aAAO,kC,qCAIP,aAAc,gCAGF,oD,OAAA,MAAZ,GAAY,qBAER,aAAQ,0C,mDAGR,iCACR,qDAG+B,iCAA+B,SAA/B,WAA+B,SAItD,yBAAI,uCACA,EADA,e,OAGA,M,8DAGJ,MAEI,cAAI,mBAER,UAFQ,WAGR,S,wEC4BQ,iB,OAEA,KAGI,sBAAc,aAAO,gBAArB,eACA,EADA,e,0BAQH,sBAAL,iDACA,EADA,IAGJ,W,OAGA,KAEJ,kF,OAKA,cAAkB,mDAElB,sBAAmB,4CAEf,W,OACI,sBAEJ,sBAAS,GAAO,UAAP,oCACT,EADS,IAEJ,W,OAEL,aAAwB,2CAEd,6C,MACF,S,SAKQ,IAAU,EACV,c,GACA,+B,OAEJ,E,GACA,qC,OACA,E,GAEI,M,KAKU,OADV,EAAO,sCADX,C9HzGyB,G,MAAA,EAAM,e,4B8HqHvC,GAAQ,MADR,IAAkB,GAAb,iCACL,C,cAGY,SAMhB,O,2BAAA,SAGA,G,OACA,sCACJ,oB,yCdjOR,c,IcoOwE,EAC1D,S,KAMN,QACA,cAEI,GAAY,OAAZ,EAAO,sBnHrIf,SmHsIY,YAAY,4BACZ,OAAI,E,GAIJ,M,UAGJ,iCAGE,sCACN,YAAmC,c,+BAMnC,QAAQ,U,mIdjQhB,sB,2BAAA,mBAMI,UAEQ,GARZ,O,sCAAA,uHiBA2F,kDAGb,qB,OAAA,kBAAE,K,mDAAsB,W,IAAA,yB,IAAA,qB,yPACpF,wDAAV,qD,gFAAU,yB,oBAAA,Y,EAAA,+B,+DAAV,Q,0FAAU,O,aACN,Y,gBADJ,oC,+DAGJ,kB,4KAJkG,4B,OAAA,yB,cAAA,yD,mDAtCtG,KAgCI,iCACA,oD,IAqEA,EAnEA,KAGA,MAKJ,MAEA,GAwDI,WACA,OAAgB,O,GAChB,M,OAAA,oCACA,+DAGA,cAAiB,I,IACjB,EAAc,G,GACd,oB,EAG0B,QAC1B,MAAU,yBACH,sC,YAG6B,aAIpC,OAFA,oBAMI,Q,4BAG2B,W,OAAQ,KAAM,S,0DAGzC,OAAQ,I,+GAQZ,KAKI,kB,OACA,YAAS,EACT,2BAAgB,I,QANhB,c,+DAWJ,mD,KAGI,IAAgB,wBACX,KACT,wD,OAEA,0DAGI,oD,QACA,EACJ,8B,aAzCkB,yB,qGAAA,8B,oEAAA,qD,6FAAA,iB,MAAA,gE,iCAAA,gCFyOd,oBACI,8C,4EA6BZ,U,IA+DI,UA/D+B,Y,uDAOD,K,yLAsBO,qC,6CAMe,S,UAAvB,IAAI,mB,eAOzB,GACA,oBAA0C,EAA1C,W/H3S2C,c+H2S3C,eAQoC,+C,QAE5C,Q,uCACsC,+B,wIAGkB,6B,IAAlC,E,mCAC0B,sB,iCACP,Y,MGxbJ,G,4DH4brC,6CAGyB,4B,4CAIjB,qB,yBAIA,yBAAc,gBAAd,M,2BAIA,S,iKAfR,iB,MAAA,mC,EAoBQ,kBADE,iBAAN,iBACiB,I,2FAKzB,iE,oEAWyD,aAAwB,oB,uCAGjF,2DAUyC,GAAO,eAA5C,KAAI,kEAAiC,KAAO,aAC5C,OAAO,E,4CAGX,uB,QAaI,MADoC,aAAO,EACpC,kD,6BAGX,2CAewC,aAAO,sBAC3C,iBAAO,I,+IA4BP,gB,IAAA,gB,OAAA,I,4JASS,6EACE,+E,sQAVX,kC,aAAA,0E,yCAWA,6B,4QA8HA,I,iEAYuC,iC,MAEnC,UAcA,cACsC,MAEtC,EAFsC,WAQtC,SARsC,e,8EA7B1C,iC,IAAA,e,iIA2CJ,aAcI,0B,yG/H7tBA,IAAI,G+HyuBY,gB/HvuBN,4BAAiC,Y,8C+H+tB3C,wC,OAmB6B,K,gCAOjC,OACuB,G,gCIhxB4C,e,8EAAA,0B,oCAAA,iB,4OJ2xB5B,gCAA2C,uB,6FASxC,8B,OAAqB,a,gHIzyBxB,uI,oBAK4B,6C,uHAAA,c,kFAAA,kB,uDAAA,0C,kHAAA,mC,EAAA,mC,wCAAA,c,IAAA,iB,6BAAA,kE,8DC2FnE,GCWA,GAaA,GCrBI,G,MF/EA,GAAc,K,qBAEV,W,wKAuEA,oB,gCnH6yBJ,gEsH9vBsB,kDtH8vBtB,gBsH1vBI,iBAAO,E,4GCvFiG,QAAG,KAAH,G,eCgChH,eAOQ,gB,mLCyM6D,gB,aAAA,O,WAAA,kB,mBADjD,uF,oDAAA,iB,mBAAA,e,wBAAA,uB,eCnMpB,uB,IAI8C,gB,SAJ9C,oB,gCA/D2E,mEN8EvE,cAHa,kD,2CANjB,c,4GCRI,iB,kMM6HoF,gBAA7D,iBAAI,aAAU,yBAAd,W5I5FsB,EAAM,iB,e4I4F5B,EAA6D,6C,4FAJxF,oC,qCAAA,M,sDAAA,+C,4ECpBI,QhIpKJ,WDgDQ,GiIkIa,IADkC,wCAClB,8B,aAkB7B,SAAU,K,QACV,uC,QAII,wCApBA,wBAlER,e,0CjCNW,IAAP,E,eiCiBuB,cAEf,kB,qBhIhIhB,aDgDQ,Q,IiIiI+C,6C,IAAA,eAClC,kE,gBAPb,EAAmB,KAAnB,kB,GACA,EAAI,uBACA,oC,CAEA,6BAAoB,G,4BAgF5B,8B,aAEiD,c,QAC1C,+BAAc,Q,QAQM,6BClHjB,KD4CI,S,KAGN,K,+EArBQ,qD,GAGR,2D,4DAQJ,KAAI,W,uBA6EmB,EALvB,cACU,oB,uFApFG,wB,wGAAD,mB,OAwFW,mBC7GJ,uB,2GA1JiB,eAExC,wB,yBA0GI,gBAAe,EACX,sBAAW,E,gCAEX,kB,sDAKJ,aAAO,Y,oCAWU,oCAHrB,QADY,gBACI,YxChJ0B,eAG1C,a,sGAIsB,kB,uDAGb,kBAAL,GMmHJ,oBACI,kBAAO,GNnHH,oBAAiB,gCACjB,mBAAK,wB,uD8BHjB,oBAmBY,EAnBZ,WAmBY,UAnBZ,oB,gKA0FQ,0F,8BAAA,qD,kDAAgB,aAAhB,gD,sFADJ,E,gIGLY,WADE,K,OACW,gB,MACb,qB,QAEI,E,MACI,avIgByB,cAAM,YuIdzB,sB,8D1J9Gb,mB,OAAb,O,qGkKgBI,kEACA,EADA,e,OAGY,qB,oGAAA,kF,oMAGR,+B,mFAHR,G,MAAA,iB,uBAKM,OAA0B,iC,WX4C5B,sC,MACA,E,gEAEA,oB,uRW1DR,U,IAAA,gC,iFAcA,6F,6TAKY,oC,gCADJ,gB,kHXoCF,qDACE,O,EAAA,K,0FWlCgB,M,mEAAA,sB,MAAA,E,yBAAA,wD,OAAhB,0D,sEAAA,iB,wEACI,oCPcQ,mCAA8B,sD,YAK1C,mF,oG9BiPkC,YAClC,sBAAkB,4BAA4B,eAM9C,EAN8C,IAO9C,W,OAPA,K,uIsC1QkB,4BAEd,mE,wCANuD,UAAC,kB,WAG1B,uD,QAC9B,IAGJ,yK,UA3BR,gD,wKAoB+C,O,iBAAA,c,2PAAA,C,MhJoDvC,IgJnDsD,E,EAApD,OhJkDN,EgJlDwB,aAAiB,WAAS,ShJoD9C,SAAM,O,yE0GwNV,MAAsC,esC1QA,ItC0QtC,GAAsC,MAAtC,6B,GsCpQI,c,wKPuDA,YATR,mFQlFA,Y,uEAyCyB,MAA2D,W,OAA1D,KACtB,kF,OAAA,KAEA,sECqKQ,uDCrCkB,sC,wBAAA,oECtEO,uF,MAAA,mD,6GAAA,wC,0EAFxB,yB,kBAAA,uE,OAKT,gE,qPAHoB,E,sBAiBhB,iB,WAAA,c,iJACF,mC,EAFF,mC,0PAbA,kB,QALS,aAaI,iF,MAAA,+B,EAAA,W,EAAA,yC,4iBAHT,+B,eAAA,wC,yBAHR,qHXlBQ,yF,mBAPR,yE,cAAA,sBC+L2B,e,OAAE,YAAa,WAAU,c,IAAM,I,0BAClC,wC,GAAA,I,MAAA,qC,OAAA,U,2KAbxB,kF,IAQI,IrHrQkE,WqHsQlE,uBAAY,mB,2CAQhB,qC,OAAA,0DrHtRA,KqHkSmC,gB,OAAA,iEAAE,kBAAa,4B,yGAAqB,6D,kBAAA,c,sFAAA,iB,+MADnD,iE,2SACZ,iB,cAAA,uB,mOAZR,wBAUI,gBACO,K,oEAKX,iC,qCCnQA,EAOY,gF,KACJ,E,+BACsC,MAA0B,eAA1B,kD,YU7BhC,IAAN,a,MV6BsC,sBAAoC,KAApC,Q,EAT9C,wDAJ2E,iE,mQACvE,kB,+BAAA,iB,2CAAA,e,4TWnBQ,kC,EAAJ,SACI,K,qKAER,mB,sVAJQ,kB,aAAA,iB,0JALZ,4D,+GAKI,yB,EAAA,E,EAAA,E,oEAAA,wB,0HjBwFJ,+KAWA,0C,gYeQQ,K,EAAA,mB,EAAA,gB,KAAA,0B,GAAA,sE,wGACF,IAFF,iC,mFfRA,E,yMAVJ,oEAmBiB,W,OAAA,4GAOb,yC,uOANQ,0B,qBAAA,4B,4DAAJ,yC,yUADS,mD,uGANjB,4B,qFO9BI,E,OAAA,2CA5Ea,6C,OACb,MjIsFO,uG,wHiIrFH,+C,0FAMA,KAAI,wC,4CAKR,E,oKhCqHA,0CACI,C,IgC9GiB,EAArB,EAAI,wC,GACI,OAAR,EACA,OAD0B,2CACtB,KACA,GAAQ,gB,QACR,yC,KAEJ,sCAAyB,G,mCAiDzB,0BA9CJ,mDAiBgB,+D,IA9CL,KAAI,qC,OjIsFJ,wC,GiIFC,O,IAlFJ,EAAI,OAAJ,M,kEAIc,qCAAiB,M,kBAGrB,sB,2BAqCV,2C,QA7CgC,qCAAO,K,KAAP,qC,UAAhC,OA8CkB,sD,qDhCkFtB,KAAO,mC,GACH,S,sGgC5GJ,M,IACQ,SAAI,K,uMA4BhB,O,uBAAA,GAMI,6DACe,MjI4BR,W,OiIFC,Q,8EAHJ,M,+CAvBA,sBACA,gBAAa,EACT,gBAAQ,6B,8BAUhB,KACoB,uB,gFAEa,6BAAM,G,IAEvC,I,qDAAA,8B,ajIWO,SiINwD,K,MACvD,EjIKD,0C,QiILH,6BAGI,O,4KAIK,qCjIFN,IiINwD,YjIMxD,iBiIFC,QAHJ,EAAI,UAAO,WAAX,I,EAOyC,gB,wCAJrC,c,+BAIa,kB,gFAKe,I,SAKR,mC,wIAEP,Q,qBAKH,G,qCAKG,OAoBb,c,IACA,IAAW,K,GAEX,KAAK,WAAL,yBAAmB,cACnB,sBAAmB,kBAEnB,gBAAS,wC,CAGT,6B,GAI0B,yBAC9B,sBACA,KAAO,aACH,EAAU,2BAAM,U,gDAMV,sCACC,GAAX,MAAW,gBACD,QAAI,2B,wGAU0B,I,GAAD,wCAAC,8B,iCAiBf,E,kDAE7B,wCAiByB,yEACjB,iBAAK,I,2MAjBmB,iC,4DAGH,sB,0CAE7B,wCAII,KAAI,yBAAmB,QAA0C,E,iRAMjE,oBAAU,EACV,gBAAK,EAAuB,+C,iHAMgB,4DAAC,EAAD,e,wDAClB,4D,2DCtDV,qD,+CAMpB,sD,IACI,I,OAEA,kBAAS,QAAT,sBAEJ,4B,qFAMI,OAAc,YACd,EAAmB,KAAP,6BAAZ,GACI,EAAW,MAAX,GAAW,GAAf,KAAe,YAAX,yB,GACA,oB,GAuGR,QAEA,EAAI,mBAAqB,iB,KAAwB,sCACtC,qBAAU,cA1Gb,CACA,mCACA,mCAAoB,EAAS,G,0ECF3B,I,kBAOR,W,yCANF,Q,2HDSA,uB,IAEA,yMA8BA,oBhIlMJ,EgIkMI,WjIlJI,iBiIkJJ,WA9BA,M,mDhIpKJ,OgIkMI,iBjIlJI,iBiIkJJ,kBAEI,SAAU,gBAAQ,GAAR,oBACN,SAAgB,KAAI,c,KAEpB,OhIhMR,YDgDe,OChDf,ODgDQ,WAAO,EiIiJa,OjIjJb,KChDf,OgIkMQ,YAAO,GAEX,MAAO,GAAP,G,UAMI,aAAa,iIAErB,a,aAII,iC,OACA,Y,IACA,IAAW,E,UACf,iB,2BAnP4D,wD,+GAyPhE,wBASI,kC,OAEA,eA/DQ,sBAAW,W,MACX,uBAAS,SAAT,oBAEA,sBAAW,W,iDAkFqC,gC,OAAP,oIA5D7C,aAAI,uC,OACA,MACA,sB,KAEA,sD,qDAiEmB,aCpGb,oB,WD2FmC,sBAC5B,iB,8EAlBrB,yEAkBO,Y,iDAIO,4C,QAIa,4BClHjB,G,YDyFN,2B,gEC7EA,mCAAwB,c,mDDsGD,2B,QACvB,yD,8GCvHR,KDiHQ,4C,MACA,cAAU,S,OAXc,W,QAOrB,sCADQ,mBAAU,uBAAwB,SCzGvC,gD,uCDkHoC,2C,6FCtG1C,qCAAwB,gB,uNDuGxB,4CATJ,Y,2GC5OI,0E,OAUC,oB,gDAOkB,CAHnB,kBACA,a,YAGI,SAAmB,I,KAEf,SAA2B,UAWvB,yC,IAuHhB,c,KApHgB,EAAI,Y,OjIjDpB,sB,ciIoDiC,E,KjI7DjC,E,qBiIiEM,a,KAEE,oB,8ClI8CN,c,gDkI5CM,IlI0CR,KkI1CQ,cACA,oBAAqB,SAArB,EAAqC,GAAO,M,KAEpD,a,wBA8BA,qC,mGAGJ,oBAEI,EAFJ,WAGI,oBAHJ,WAIS,IAuBgB,kEACT,WAEhB,oB,OAEA,yEACI,EAAgB,+CAAqB,WAArC,e,yDAgBU,iB,MATF,c,EAYJ,EAbuB,IAeJ,iE,+FAOnB,8B,2BAtBuB,MAwBb,c,oFAlBlB,qCAII,WAAU,IAJd,K,WAMQ,G,eAUA,G,iGAMR,wDlI1HQ,IkI4HJ,ElI5HI,yEkI0HR,0E,gCdvMkC,SAAC,uDAA2B,KAA3B,8D,QAGd,qBACT,QAAQ,eAAR,KACA,sCACK,GAFL,CAMI,aAAW,EAAa,GAAb,EAEN,IADA,MAAI,MACJ,EAAI,qC,OACT,WAAW,kBAAX,O,IAKZ,qB,mDAEgB,4B,OACR,6BAAoB,aAAO,iB,MAGvB,M,8SA9BhB,8BAMmC,Y,8CANnC,yBAMmC,YANnC,Q,cAAA,gB,qBuBIgC,QAG5B,eAH4B,KAC5B,sCACA,GAMA,OAHA,iCAGoB,E,0BAIJ,QACyB,IAAjC,aAAiC,C,UACxB,2BAwBgC,SACrC,W,0FArBR,yE,GACA,yEACI,IAAW,sBAAX,GACA,OAAI,Y,4BAGE,sC,2CAIE,OAUK,6B,OAA4B,mDAOjD,qC,yBAwBI,QAA0B,oBApBtB,QAAW,sBAAX,G,6EAaJ,G,CAO0B,IAbtB,gB,kEAmBqC,E,IANpC,eAAqB,CAC1B,mB,WAKyC,SACjC,OADiC,E,MACjC,oBAAsC,qCAAtC,K,4CASZ,I,IAFI,EARyC,oDAK7C,yE,EAEA,wEAEI,EAAO,GACX,kC,MAlFiC,0E,eAAA,+C,GAAA,qCAqFrC,I,mMAAA,kCvJpEI,IAAI,EuJqEsC,avJrEtC,eACA,SuJoEmD,gBvJnEnD,YAAM,WAAyB,EAAQ,EAAjC,W,kBwJjBG,iC,kFlDeQ,yBAAQ,I,6CMwHzB,EAAO,c,qDN3GqB,sE,qDAEpB,uE,4NAGZ,qB,OMqGA,E,+BNjGS,EAAL,OAAK,6BACgB,+C,OACb,IAAW,8BACV,cAAmB,8C,amDMhC,G,MC1DJ,GC8P8B,G,GC9O9B,GtDyCgD,GAAW,K,qBAEvD,WAC0B,O,2BAkBH,ItGSvB,IACI,EAdW,M,0CsGQc,E,wBAAa,cAAN,gDAAM,K,kCACb,OAAM,KAAN,YA+MrB,GAAa,K,4BA3MC,E,EAAA,E,EAAA,E,wBAFtB,KACW,G,2BAEqC,iBM8X5C,wC,mENhVA,gCAAU,E,eAiDY,c,sKAUV,E,QM0QhB,QACI,UN7QI,IAmGA,IACA,EApGA,GAMQ,MqBxDwE,K,OrByDxE,E,GAOhB,O,KqBhEwF,O,SrBkExF,sB,mCAAA,YACW,MAH4B,E,gDM6RvC,iI,ONzRQ,E,8EuDtMqD,E,mCACG,Q,oDAEV,c,2FAK9B,KAApB,I,uBAUJ,kC,2DCxBiB,kBAAC,Q,kDAGlB,iDAC2D,sC,2CCGlD,Y,2BAEb,QAUI,kC,cACA,EAGJ,G,IAAA,GAUI,e,IAAA,0DACA,G,sBAEA,MAAY,EACC,I,IAAA,U,qCAAb,QAEA,EAAI,gC,kJCvBQ,U,wBACa,eAAoB,Q,gDAEjB,E,gBAE5B,S,IAAA,oBACI,sCACA,G,mBAc6D,M,KASR,M,6BAKrD,EAAI,OAAK,K,QACL,Y,QAF+D,U,YAUnD,MAAL,EAAK,8BACZ,W,IAEA,QAGA,kBANJ,0BAiBA,E,YACI,G,OACA,EAiER,e,kECxGJ,e,6BRqByB,gB,eANnB,cACmB,eAAjB,iBACA,kB,uDStDR,c,eCkO8D,c,gCA2C1C,cACA,Y,YAEI,0BAAM,GAAsB,O,qDA6EhC,YAAO,E,eAkIoB,kBAAO,GAAP,G,uIR3OgB,Y,cAG3D,G,WAQI,+BAAyB,MAAzB,qCAeA,I,qCAGsB,Q,kGA1B1B,G,wDAC2B,IAAQ,yC,0DAO/B,WAAU,QAAV,c,EAI+D,K,8NC3QvE,oB,kIAkBsB,E,oBQRlB,MRS+B,iBAAP,I,kCQTxB,wC,mBAEA,E,OAAA,8D,cAGA,0BAAkC,qB,8CAA2C,mC,oE9DoDpC,I,+EMwYlC,gEACH,EADG,e,aN1WmD,SAAa,2BAkM/D,aAAa,gC,OAtKgB,MAvBzB,sBAAmB,GA8LV,UA9LL,mCAAsC,EAAtC,e,YAaA,mEAEJ,EAFI,e,aAOA,qDAGqB,aAAP,wBAAO,YAAX,oCAAN,6C,uHAqBZ,yBAAM,UAAU,mBAAhB,eAEO,EAFP,IAKJ,WACJ,0CAIW,aAAP,oB,wFACI,aAAiC,0BAqIjC,MAnImD,iC,MAC/C,gBAAc,KAGN,2BAAJ,EAAI,yF,MAAgB,O,EAEpB,W,OAGJ,Y,IAA4B,E,OAE5B,SAA6B,YA0HpB,SA1HoB,KA0HpB,GA1HoB,KA0HpB,0CArHE,iCAGU,SAHV,WAKX,I,kD2DjLhB,iCAM2D,M,yEAe3D,iCAMsB,gBANtB,e,oBASA,4CAUQ,cAAkB,mBAHtB,gBAGsB,eAaX,oBACX,EADW,sCRrDf,IAsDI,cAhDY,mBAkDR,iBAlDQ,eAqDR,oF,yFAFF,e,EAAA,EAFF,Y,IAMA,EAAI,S,IAEA,K,8EATJ,gBAGE,wBACmB,yC,+CApCzB,QAFA,0BAEA,OAiCgB,oBADZ,oCAzBoC,I,gEA0BpC,MAMA,W,aAEI,W5I9BJ,aDgDQ,I6IlBJ,U,6CA9BR,a,mEAsBgB,MADZ,W,uEAIqB,4DAAjB,EAAiB,e,8FAHrB,MAMA,W,OAEqB,Q,sCAjBzB,I,iBAAA,C,MAEA,e5IbA,WDgDQ,U6InCR,QAOgB,iBAPhB,KAMI,Y,GAGE,WACmB,QAAoB,E,8BAArC,Y,OACA,kB,mBADA,C,MAKiB,YAFrB,O,qD3I3BMA,KAAK,Y,C2IgET,qB,GACE,Q,YAHS,Q,iBAAA,KAAb,YAiBA,GACA,YACI,QAAU,EAvCd,2BAuC2C,e,OAAA,kBACpC,YAAI,IAEH,GAHmC,QAIC,GAAM,YAAN,C,mBAC5B,gEAGN,mCAPV,iBAnCJ,I,oE3I/CUA,KAAK,Y,C2IgET,qB,GACE,Q,iCAHS,Q,iBAAA,KAAb,YAiBA,GACA,YACI,QAAU,E,2BAA6B,e,OAAA,kBACpC,YAAI,IAEH,GAHmC,QAInC,gDAAoC,iB,uDAhC5C,4BAGJ,qBAEA,WAIiB,Q,iBAAA,KACT,Y,YADS,iB,GAAb,OAiBA,MAAI,EAAW,mBAAqB,KAAO,aAC3C,QAAY,M,OAC+B,GAGnC,aAAkB,gC,SACwB,O,EAA1C,gC,KAIE,E,EAAN,4BAAM,uB,sBAPV,iB,cSvGI,gCARR,iICyLiD,6CACzC,M,2DAEI,iB,0CACF,mB,MACQ,iB,iNA7IV,S,8fAgGR,K,OAAA,GAwCiD,gD,IAAA,gB,KAGrC,gB,QAEA,IAAM,I,YAHV,Q,gBAAA,KAKA,c,GAPG,Y,qBAqBX,Y,0CAAA,OAII,Q,iCACA,O,EAAa,S,mDAuBb,OAC4B,MAD5B,E,kBAVY,K,8DANsB,4EAElC,8BADA,UAYA,kBACmC,YARvB,K,+CAaA,aAAc,MAAd,M,mCACR,2CAAa,4BAAsB,G,sIAoBU,yB,iCAIrC,0BvD5HL,CAAP,KACW,wD,WuD6HC,kCAEQ,aAAQ,oB,wGAW5B,+CAfY,W,OvD5HZ,KAAO,wBuD8HgB,uC,SAEH,SAA0C,mC,oBrBhE9D,gC,eqBiFY,e,SAbI,qB,OAgBhB,4C,2GvDnJI,KAAO,gBuD6HC,C,MACI,UAyBD,S,GAxBK,S,OAA0C,K,GAElD,WAAW,IAAuB,kBAAY,e,IAuB5C,OAMV,OAAK,G,kCAzBW,c,kEA4B+C,KAAO,W,YAClE,cAAS,K,8CAKD,UAEhB,Y,KAGiB,gB,YAAA,oBACb,GAEA,6BAGJ,iCAEA,iE,6DAGY,MACA,0CACR,yC,0NAqB6B,wBAAe,4C,OAExC,Q,EAAA,K,EAAA,EAhBG,W,OAOH,EAAa,aACT,OAA4C,YAC5C,K,kKAcG,oBAEP,EAFO,WAGP,oBAHO,WAKF,iB,yJAiBa,Q,4BAoGN,e,EAAmB,EnK9VM,Y,qCmKqVlC,SAAP,K,mDAIgB,uBAKmB,wBACnB,kBAAY,uB,WAKT,wDAEX,iDAGQ,aAA4B,4B,IAGxB,yB,+BAuBR,OAAM,mBAGV,aAAmB,QACnB,G,aACQ,SAAO,K,+DAQvB,2BAO0B,aAAkB,eAAtB,c,UAClB,aAAK,W,EAAO,K,EAAA,E,EAAA,E,gEANZ,M,0CAQJ,U,wBAAA,E,KAAA,E,EAAA,E,kEAGI,M,wDAM0B,wB,EAA+B,K,EAAA,E,EAAA,E,EAA/B,E,qHAEN,U,wBAAA,E,KAAA,E,EAAA,E,EAGxB,W,yCADA,M,oBAEA,0D,6FA6EA,uBAAsB,0BAMtB,QACJ,cAEyB,mB,IAErB,W,2HE3nBkC,gDAClC,kBAAY,+BFoL6B,6FACzC,Q,QAEI,uD,WACF,I,mUGmLsB,gB,oEXvIe,MAK/B,gEAGc,I,6CCnPwD,iDAEtF,0EQSY,0E,MAGZ,0E,4CAGI,8BAAS,GAHW,0CAIpB,8BAAS,M,oBAIT,sCAAQ,I,eAEZ,c,OACmB,OAAf,IACA,O,kCAM6H,gB,2BACjI,gFGpCI,cAOY,c,0CCNZ,c,cAiBA,mD,+BAGA,mB,qCCxBJ,eAAmD,0BAEnD,cAAuC,c,wFAGuC,2B,EAAA,K,8BAIpC,I,kGL+BkB,MAAQ,W,mCAKhE,kD,iCAC8C,8BAAyB,c,iKM9C3E,MAEA,yEAIkB,qE,4CHOkD,M,iCCbpE,uCAOI,iC,8CAJI,MAAQ,0E,wCAuBwD,EAAC,yD,uCACD,IAAS,2G,qCACJ,I,wIACvC,wD,qSChBtC,4C,mGAAA,c,0JAAA,W,SAIA,gCACI,I,OEP2C,2C,mMAU5B,cAAV,qD,sDpEhBT,cACI,GAAuB,K,cAEsB,gDAa7C,qCAA4B,yBAZ5B,iCAAoC,uBAApC,WACI,M,0BAOI,OAJA,W,OAIA,GAPiC,6BAAE,gBAsB3C,eAG4B,8BAAE,aAAM,sB,yFAWxC,c,gBAMA,iF,EAAA,iB,uDAM0B,oBAA4B,a,KANtD,G,cAgBsC,c,oMqErBwC,S,eC5CV,oD,qGCS5D,KAAK,MAAK,KACV,gBACA,iB,uEnDmBA,GAAO,W,yCAGX,iB,cAyBI,c,mBA2BuB,cACvB,cAAc,EAAO,UAAO,E3HFhC,0B,qE2H+BJ,SAW+C,e,yDAY6C,Y,+OpBlH7E,2DAIP,IAAa,K,sLAKN,W,OACX,EAG4B,oC,wCAMC,uEAC7B,oBACI,EADJ,iB,sGAPI,WAGJ,OADI,QACJ,I,gDAGJ,uC,mFASI,OADe,YACf,M,mCAHJ,mDAUI,iCAGI,sC,oFAMuB,oBAA+B,kB,wCAGU,MAAM,gB,aAGpD,MAAE,UAAF,4B5FhBf,O,8B4FoB4B,oBAAE,oBAC1B,iE,iCqE3Df,sBAII,I,4DAoB4E,MlEkQtC,iCAClC,qBADkC,WAOlC,K,+FqEpTR,uC,mCDaI,gCACI,EAA6B,8F,OACxB,gBAET,mEAGkB,gG,OAAA,gBAIE,8DAHR,MACiB,iG,OACjB,KAAK,cAEE,yC,iBAIf,QAAO,KACX,U,UAKiB,WAML,GAPS,oBAAY,W,OACZ,mB,sCAGb,c,aAHJ,aAMA,a,OACA,QAAO,EACX,U,kBAE8C,GAE9C,+C,OAAsD,KAAM,e,yBAEI,IAEhE,uI,QAAkC,M,yBAEY,MAE9C,+I,QAAkC,gBAEL,yBAAC,M,wLAWT,yBAJR,MAIE,aAAM,wB,8CAGO,EAAM,W,yFAKpB,uDAA0B,+H,6EAKpC,EAAI,W,GACA,IAAM,K,OAFuB,K,yDnD5EzC,Q,gBAAA,Y,OAGI,O,6DAGmC,IACA,kF,sJAI/B,aAAgB,wCAEhB,oBACA,aACA,+BAec,2DACH,MACX,W,IACA,E,OACA,SAAa,KAAb,sCAEA,kF,OAII,+BACJ,aAAQ,oCAEZ,mC,gCAG6B,qD,8DAMpB,MAGT,2C,qCAOS,MACL,6CACA,yC,IACA,oBACJ,0B,iDAIA,UAEiB,4CAAM,mBACQ,yC,O3HQ3B,M2HNJ,yC,UAEA,oBACI,EADJ,WAEQ,qBAFR,WAEuB,CAAO,K3HE1B,sBAAM,aAAsB,WAAQ,K2HEpC,W,gIAKuC,oBAG3C,EAH2C,WAC3C,YAD2C,WAE3C,M,4DAEwC,iB,4BACiB,kI,sBAC7B,gB,2DAKY,+B,MAExC,MAGA,mE,+FAeA,W,oBASI,kDAcL,4B,IAHC,E,OACA,6C,mDACA,oE,IAE6C,6B,qCAC7C,wB,yC3I8uWA,QAAa,IAAb,4BACI,Q,Y6Bn2WJ,KDgDQ,E5BozWD,G,qE2I3uWY,iB,iIlBtHnB,OA1BJ,uBA0BI,GkBsH2B,uB,2DlB9DvB,oB,oGAG8B,kBAGlC,UAAqB,EAAwB,EAAxB,G,8BAGrB,KACiB,gB,sCkBsDjB,8BAIoB,iDAEZ,mC,sEAM4C,mB,qId9FlB,Q,mBmE/ED,qBAAmB,sB,sBACpD,4BACiB,gCACjB,6BAEA,4BAAwB,yC,0BAEY,uC,iJCJ6D,oB,qBrDArG,4C,WTAA,+BSCA,0BTUI,6E,4DAuCA,Q,aAkBA,S,wCSjEJ,KAA8D,0C,0JAW9D,Y,+BxB2CoB,OACK,YADL,c,EAAA,EALI,Y,OAAA,wBAAmB,oDAC/B,IAIQ,I,oG8E1DpB,K,uFCC0B,yC,UACkB,iB,yF/D0nB5C,c,WAEA,QAA6D,QAE7D,oD,oGAyBsC,Q,wYKxlBtC,Q,OAAA,I,myBWbA,gBAYA,YAHY,QAAR,EAAQ,Q,qBAGZ,mB,KAUI,E,6CAEI,E,YAEA,QADF,sEACE,Y,sBAHJ,W,wBAMI,oE,iMG8CA,E,IAmBO,E,QAAA,oFAbM,KAEb,EAAI,mB,0UGoKyD,2B,6CAAA,Q,sECnQM,6B,qsU3IqC3E,8D,6kCoLzEA,oC,mGAAA,sE,4gDvLyuBA,0F,8lFAgSA,+D,YmGp6BA,kE,UrC+RA,8D,SnB2jBA,sE,OhDv5BA,yC,SDaA,0E,ihB8LqKuC,oE,8qBCzJa,uC,szFzLs7CpD,0E,wI0L35CI,oC,KAGI,gC,4YlK1FR,2E,6jBRqBA,0E,w0D2KPA,8BAOI,Y,gCAE8D,O7K0C9D,Y,O6K1CA,UACA,M,sCAYJ,qBAQ8E,MAA3C,IAAAizB,iBAAiDzK,E7KqBhF,G6KrBY,Q,2CASO,0B,OAEnB,4G,gCAuBA,QAKA,wBAKA,cAKA,kBAGoC,EAapC,4BAGkD,IAAO,sBAAP,GAElD,iBAGI,0EAEA,KAAI,uFACA,qBAAU,wBAAmB,mCAOjC,sBAAO,4DAEP,KAAA0K,aAAa,qBAAU,mC7K7EX,qB6KmFP,2DACD,4BAAO,GACP,kBAAO,mBAEP,KAAI,oCACO,yBACP,qBAGJ,4CAAe,8BAGX,4BAAO,MAGX,kHAEO,wBAEP,oBAAO,4DAGX,wE,iQApGJ,mB,wEAAA,0C,4hKApCwC,8D,OAAC,cAQS,gF,yRAwG9C,mC,kNAHU,uBxLnDV,kB,kIwLpBJ,kB,6EC4KmB,kCC3OvB,OD4OY,2C,4CC5OZ,E,mCAQI,e,iGAEA,sC,mKAOmB,iIACX,kGFyDR,8F,4FAAA,gBAoCY,4BAAO,6D,+EAqDnB,iB,OAAA,6H,wHAaI,iBAAgB,0EAAhB,wEAAgB,uD,kBAAA,c,+BAAhB,yBAAgB,gCAAhB,iD,wUAbJ,mC,+EAmBI,EAAO,6BAA6B,OAAS,GACjD,S,EAQ+C,WAA3C,O7K3HJ,uD,O6KyHuE,iDAMnE,IAGJ,kD,IAII,cACA,uB,OAAc,wCAEd,K3L6lDY,oBAAAlzB,KAAA,yD,I2L1lDwB,I3L0lDxBA,K2L1lDwB,W3L0lDxBA,K2L3lDR,YAGA,G,OAOA,sD,MAIR,qBAAkC,c,IAlGG,E,WAAA,8DACzB,OAAI,qBACO,U,4BAO8B,sF,MAAA,+B,kDAEV,gJ,kMACnC,iD,MAAY,6DAAZ,WAAY,yD,MAAZ,yC,GAAA,e,wHAFA,gBAEA,oB,+RAH6C,uE,YAAA,iB,8EAYH,qB,8BC0F/B,0ECpNnB,kDD0NQ,c,OCrNR,cAUA,kDD2MQ,gB,8ECvOR,qB,IAUI,4E,oDAGJ,Y,OAAA,K,KAAA,M,+GAPI,oCAAgB,+D,kWAYpB,mG,OAAA,iH,kSAKA,iB,OAAA,+G,qSAKA,iB,wGAAA,Y,iGAUqC,sF,2HAYT,M,OAAA,cACpB,SAAiB,OAAM,EAAW,SAAgB,YAClD,M,yDAKJ,e,qEAnBA,sGAAAmzB,EAAA,cAAiC,2DAEjC,IAA0B,mB,OAC1B,qCAA8B,EAAAvV,IAAA,GnMyLlC,M,4FzBjN6B,8BA0B7B,OAmDA,sCA1EA,wCAEA,gBAAkC,KAAY,kBAS9C,uFAYA,E,oIArBA,8C,qF4NgBsC,wFAGG,W,OAAA,iG,IACjC,YAGmB,+BAAlB,iBAAA5d,KAAA,gDAKL,oDAAAozB,EAAA,QAAS,IAAT,InMgLJ,mCmMxKA,oD,+BAOI,Q,GACJ,yD,kCAEA,O,K7L6tDgB,E6LxtDZ,gB7LwtDJ,EAAgB,8D,wDAAApzB,KAAA,8F,IAAA,E6L/sDZ,E,I7L+sDyB,oC,yB6L7sD7B,IADI,EAAO,0BAAP,kBACJ,a,QAMI,KAIA,4C,IAAA,EAAY,IAAM,iB,OnM0kBtB,2BmMzkBI,GnMykBJ,0DmMxkBI,mEAA4B,yBnMwkBhC,mCmMvkBA,sBAjGkD,eAAC,uD,oN5NHvD,I,4GA2DI,gE,oPAhCwD,iB,yKAKtB,EAAA2S,IAAQ,W,yKAE1C,2F,OAAA,6B,6CAAA,gB,uGAMA,iB,OAAA,oD,sEAMA,sG,oIAW4D,2CAAQ,SAAA0gB,EAAA,G,MAEpE,yE,oLAAA,0E,gIASQ,aAAa,KAAT,MAAAC,SAAA,KAAoB,iBAAX,C,+CAAuB,e,kBAAO,WAAAA,S,SAA3C,e,wHAmBF,iDACW,G,qFAnBJ,I,KAAL,MAAK,qB,KACK,4B,UAIiD,uC,GAAA,sI,GAAA,e,kDAAxC,oC,iGADnB,e,oBAIoB,kB,EAAA,8C,GkC6CuB,OAAN,EAAM,mB,MlC7C3C,8G,WAE4C,uH,iDAExC,uB,IACS,oBAAK,WAAL,O,IACT,EAAM,kC,yFAGV,wB,8eA3BR,wC,4EAsCA,wE,4FAAA,2C6NpFgF,e,6CCM3C,yB,mDCtBzC,wB,uD/NoGI,uE,wGA4DmE,mCAAL,uBAAK,gC,8cAmC5B,0D,+HASe,qC,qDgOzMlD,yBAAuB,E,kFAS3B,sD,sOAAA,4C,6BAaA,2B,0GAeoB,wB,W9LqF+B,iB,sE8LnFC,6BAE7C,4B,yHCjCX,6G,kCCqCmD,M,GAAA,qF,ygBAAC,kB,6DLxChD,2BAG6C,KAAN,cACnC,sBADyC,EAClB,4BAAgB,EACvC,qBAFyC,E,yHAsB7C,Y,OAA+D,E,EACa,EAAS,gB,2IAjBpE,wBAAT,mCAAS,0D,0FMqB0C,yB,IAAA,gE,OAAA,sB,+SAavD,mFAbuD,6B,6DAavD,2B,qCAbA,uBAAoB,E,2JAoBpB,sB,4FAJJ,c,IAAA,iE,uCAkB+B,8C,iCjMtD/B,0BiMuDgB,EjMtDZ,uBiMsDkE,EjMrDlE,gCAAM,yD,iEiMiE8B,O,sBAAA,M,gEAgBpC,W,8KAbR,QAOI,yDAEA,uB,wEAuBA,cAAI,S3M4FqD,sB2M5FrD,SAAJ,qB,uCLxHsC,YACtC,S,yEAcI,uC,kDCfR,mB,8BAAA,qC,kCAOI,qB,+CAFA,uC,OAAA,yB,mCACA,Y,2LACA,uE,oRAPJ,oC,wBAAA,wG,kFAAA,mB,4CAgCA,+C,oF/N+FgC,kB,gKAmBhC,gB,8FAAA,gG,OAAA,kB,iBAM4E,wB,iMAE5E,oH,4CAAA,gB,6EAAA,iB,6HAAA,E,EAAA,S,SAMkE,wB,SAAa,wB,gPAM5C,iB,mIAC/B,yBAgBA,8FAAgF,W,OAAhF,0B,kHAiBA,iCAIwD,cAAM,yC,OAAU,kBAAQ,KAAR,iB,+IgO7MhD,+BAA4D,WAA5D,W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,2HFmD5B,0B,MACA,I,EAFiD,MACzB,K,GACD,OAF0B,U,wEAI9B,aAAf,mBAAe,EAAA6gB,QAAA,6B,yHDyGuC,mBCvGlD,gBDuGkD,6B,MAAa,mD,+DAAR,wB,eCrG9C,G,6MErBzB,2K,IAAA,6EA3CA,sCFkDI,0I,EqNlDJ,4C,EAAA,yEnN2CA,gG,OAKI,eAAAC,EAAA,GA1CgC,WAA7B,c,0BFmDC,OADiD,UAEjD,wEAAuB,aAF0B,6BAE1B,6B,yHAEnB,mBAAe,EAAAC,cAAA,6B,iEDyGuC,E,EAAa,S,iFAAR,GAAL,qCAAK,+B,iMGjHvE,sHAOA,iF,sCAPA,8DApDA,kBFkDI,mR,OqNlDJ,gD,InNyDI,MALJ,a,GA9CoC,IAA7B,G,kFFmDC,aADiD,6BACzB,6BACxB,wH,CAFiD,mCAE1B,6B,iEAEnB,EDyGsD,E,6RAAA,M,4LGxGlE,2E,wCAAA,yCAOA,mB,kBAPA,0DA7DA,8CFkDI,2K,OAAA,iD,MqNlDJ,IrNkDI,a,GqNlDJ,OnN6DA,UAKI,0BAAiB,IAAW,GAAX,uCA5De,KAA7B,Q,mLFkDkD,mCACzB,6B,MACxB,mD,QAFiD,EAI9B,E,kBDyGuC,ICvGlD,oB,gQDuGkD,wDGxFlE,qHAPA,iF,EAAA,oC,6CAAA,iB,oBAAA,cAOA,0C,8CAPA,2K,OAtEA,oBFkDI,2B,IAAA,mB,GAAA,iBqNlDJ,qFnNsEA,0DAKI,0BAAiB,IAAW,uBAAX,mE,kIFnBoC,EAE1B,E,EAAvB,O,SAEI,EAAe,sB,miBE0B3B,2CAPA,mB,EAAA,gB,EAAA,c,0FAAA,yEAOA,gG,2BAPA,0B,IA/EA,MA+EA,a,GF7BI,gKqNlDJ,wH,CnN+EA,gE,IAKI,SAAiB,uBAAW,qB,UF3BxB,E,kBADiD,IAE1B,oB,SAEJ,wB,eDyGuC,sBCvGlD,EDuGkD,gBCvGlD,+BDuG+D,oH,6ECnH3E,mH,IAAA,yB,EqNlDJ,mB,EAAA,qCnNwFA,6EAKI,EAAiB,OAAW,6BAvFI,EAA7B,iBAwFY,QAxFZ,mB,8DFmDC,kB,EADiD,c,EAEjD,2BAAAC,a,EAAuB,4C,EAF0B,uBAE1B,kD,qHAEnB,E,0CDyGsD,QAAa,e,yGAAR,K,MAAL,M,aCrGzC,SAAT,gB,wBE8BZ,EAAO,WAGX,G,OAAA,iR,CAAA,yH,yGAKI,qCAAiB,+BAhGe,0BAA7B,IAiGY,uBAjGZ,+D,qBFmDC,wDEiDR,oH,IAAA,sV,yYAOI,I,gBACA,I,MACA,yB,MACA,G,MAAA,M,IACA,oBAAY,eACZ,S,WAEA,E0ClDA,E,E1CzD6B,MAArB,K,K0CyDR,W1CoDA,I0CpDA,wE,G1ChEgC,IAA7B,M,mLFkDkD,qBACzB,2C,MAAxB,mD,cACA,O,0CAEmB,wB,0YEkE3B,6f,0PAOI,I,MAAA,qBACA,Q,WACA,M,IAAA,IAAAC,EAAA,GACA,kC,WAEA,I,EADA,MAAY,K,KACZ,KA7H6B,MAArB,IA+HR,wE,G0CtEA,I1CuEA,EAAS,I0CvET,mB1CwEA,uC0CxEA,wH,wI5CbI,O,WACuB,sB,WAAA,sB,eAEJ,G,mBAAA,qK,uME+EpB,yB,4DAOP,ogB,cAAA,S,4KAOI,G,MAAA,M,IACA,EAAAC,EAAA,gBAAe,UAAf,OACA,S,WACA,I,EAAA,W,KACA,K,IAAA,MACA,wE,GAAA,MAAuC,IAjJV,qBAArB,qCAmJR,wH,C0C1FA,mB1C4FA,6C,M0C5FA,mD,+D5CZ2B,wB,kZAMN,UAAT,a,4DE+FT,6E,oFAOP,mW,cAAA,S,OAAA,2C,sJAOI,oC,WAEA,I,EADA,MAAe,EAAf,G,KACA,KACA,sCAAe,KAAf,uC,GACA,uCAAY,6BACZ,wH,CArK6B,qBAArB,2C,M0CyDR,uB1C8GA,4B,c0C9GA,O,S5Cb4B,wB,gDACD,G,mBAAA,qK,4CAEJ,iC,0HDyG4C,uB,EAAL,mB,yCCrGlD,2E,oFEmHT,2C,qCAOP,mR,cAAA,S,OAAA,sF,yJAOI,I,EAAA,W,KACA,K,IAAA,MACA,wE,GAAA,UACA,sFAAe,sDAAf,sC,CACA,mCAAY,6B,MACZ,mD,c0ChIA,O,0C5CbI,wB,sFACA,oH,+RD2G+D,2E,EAAL,OAAK,6B,gDCrG9C,yC,qCEuIlB,gB,wFAOP,2K,cAAA,S,OAAA,gH,6JAOI,sCAAiB,EAAjB,0C,GACA,uCAAe,6BACf,wH,CACA,gE,MAAA,mD,cAEA,O,S0CpJA,E1CwJA,sB,SAxNgC,IAA7B,S0CiEI,E1CjEJ,S,eFmDC,GADiD,qBACzB,+C,gKACD,iCD2GmC,qBCvGlD,oEDuGkD,yB,MAAa,mB,sYAAR,c,EAAL,2BAAK,a,gDCrG9C,yE,qHE2JlB,E,iCAOP,qC,IAAA,wF,UAAA,a,+SAAA,6C,uFASI,wB,SACA,wB,eACA,GACA,gGAAuC,sDAAvC,kC,QAEA,M,O0C1KA,wD1C2KA,mH,I0C3KA,S1C4KA,Y0C5KA,mF1ChEgC,EAA7B,O0CiEI,6B,gE5CdH,6E,EADiD,KACzB,uC,EACxB,yC,EAAuB,iB,EAF0B,gB,kBAI9B,wC,EAAf,UAAe,kC,gMDyGoD,E,sFAAR,O,YAAA,OAAL,qBAAK,K,SCrG9C,IAAT,IAAS,G,SE+KlB,M,iCAOP,wEAGoG,KAArB,QAA2B,O0CnLtG,mD1CmL2E,wH,CAE/E,yH,IAAA,iB,yVAQ2C,kH,IACpC,wGAlJH,sCAGA,IAAY,qBAxGiB,mBAArB,oBA2GR,E0ClDA,uB1C8Ce,4BAIf,wB0ClDA,E1CmDS,iBAAW,Q0CnDpB,qB1CoDA,K0CpDA,oC1C+LI,E0C/LJ,iB1CgMA,E0ChMA,O1CgMA,SAhQgC,SAA7B,O,wFFmDC,2E,EADiD,uBACzB,qCADyB,kC,qBAE1B,E,wCAEJ,QAAf,K,EDyGmE,e,uBAAb,Y,0FAAK,UAAL,8BAAK,0C,aCrG9C,mBAAT,uC,yHEoMT,gE,6DAKP,iB,SAAA,wB,SAAA,wB,gZAAA,qBAQI,mF,sCACG,gEA5IH,EAAe,uBAAf,oDAGA,EAAY,EAAZ,0CA5H6B,EAArB,2BAAqB,cA+H7B,E0CtEA,O1C+DiB,U0C/DjB,E1CuEA,gB0CvEA,S1CwEA,OAqII,E0C7MJ,U1C6MI,8BACJ,E0C9MA,U1C8MA,kCA9QgC,yBAA7B,gCAA6B,kB,qHFmD5B,E,wCACuB,QAF0B,K,iCD6GS,OCzGtD,YDyGsD,OAAa,4B,yJAAR,0DAAL,8BAAK,sDAAL,oC,CCrGzC,mBAAT,6C,6DEkNT,M,oBAKP,wB,SAAA,wB,eAAA,G,qQmNvRA,sH,InN+R2C,qBAAC,mF,sCAR5C,yBAQI,uC,EAAuC,2EACpC,yFAtIH,EAAe,iBAGf,EAAY,gBAhJiB,gBAmJ7B,OAPiB,KAOjB,8B0C1FA,E1C2FA,iBAAS,2B0C3FT,I1C4FA,qB0C5FA,kD1C2NI,E0C3NJ,uB1C2NI,uE,qBA3R4B,E,wCFmD5B,QADiD,K,uBAI9B,M,IAAf,OAJ6C,YAI9B,O,6BDyGuC,iBCvGlD,G,wTDuGuD,gE,MAAL,uBAAK,4B,QCrG9C,E,oBEqOzB,wB,SAAA,wB,eAAA,2L,6EFnPI,oH,IAAA,qB,EqNlDJ,iF,EAAA,oCnN6S2C,yBAAC,uC,6EAR5C,8CAQI,2C,EAAuC,iBACpC,kCAhIH,EAAe,UAAf,8BAGA,EAAY,iBAAZ,2BApK6B,yBAArB,6BAAqB,qBAuK7B,yBAJe,6BAIf,0C,qB0C9GA,E,O1C0OA,iBAAArL,EAAA,G,IFvPI,OEnD4B,Q,OFoD5B,e,MAAuB,M,IAF0B,mBAE1B,O,2BAEJ,SAAf,QAAe,G,WDyGuC,I,EAAA,W,KAAa,K,mZAAR,E,EAAL,IAAApmB,K,SGyI3D,wB,iCAKP,0M,QAAA,M,+DFjQI,mH,IAAA,uK,EqNlDJ,qC,EAAA,2EnN2T2C,8CAAC,2C,mBAR5C,kBAQI,gB,EAAuC,wCACpC,yHAlFH,EAAe,uBAAf,uE,qBA7N6B,E,O0CyD7B,iBAAAomB,EAAA,G,I1ChEgC,O0CgEhC,IAAAA,I1CuPI,K,qBFpQA,Q,IADiD,O,YACzB,OACxB,0BAAuB,SAF0B,W,WAI7C,I,EAAe,W,UDyGuC,oCCvGlD,EDuGkD,KCvGlD,uC,GDuG+D,U,0UCrGtD,wB,mDEiQzB,wL,QAAA,M,OAAA,wDAzHI,qBAPiB,qEAOjB,yB,I0ClIA,S1CmIA,Y0CnIA,E1CoIA,uB0CpIA,0D1CqQI,sCACJ,E0CtQA,U1CsQA,aAtUgC,YAA7B,2B,2HFmDC,6BAAAsL,c,EADiD,iB,EAEjD,gB,EAAuB,c,EAF0B,iBAE1B,uB,gDAEJ,yE,EAAf,uBAAe,uE,qBDyGuC,E,yIAAK,SAAL,W,iBCrGzC,IAAT,EAAS,K,UE0QlB,U,qFAKP,kL,CAAA,yH,IAAA,iB,iSASO,wDAlIY,oH,IAGf,SAAY,YA5MiB,yBAArB,4BAAqB,8BA+M7B,SAJe,6B0ClJf,O1CuJA,YAAS,M0CvJT,Y1CwJA,e0CxJA,Y1CmRI,E0CnRJ,uB1CmRI,oDACJ,8CApVgC,EAA7B,iB0CiEI,wB,qC5CdH,gB,EADiD,iBACzB,uB,EACxB,4C,EAAuB,yE,EAF0B,uBAE1B,uE,qBAEJ,E,wCDyGuC,a,oHAAA,I,EAAK,W,UCrG9C,IAAT,EAAS,I,qFEwRlB,0D,yHqPnVoC,gEAAC,yD,IAcD,M,EAAC,S,SA4BD,wB,SAAC,wBAcD,e,GAcA,oEAAC,oH,QAcD,MA5F3C,+D,0FAAA,yB,IAAA,8IrP6GA,6IAlGA,8CARA,2CFkDI,6I,EqNlDJ,yE,EAAA,8F,qBkCK4C,E,OAR5C,sB,IASO,OADH,IAAAtL,IAAAA,EAAA,GrPgHA,IAAYuL,a,IAxGiB,MAArB,E,EA2GR,E0ClDA,O1C4CA,YAMA,O0ClDA,S1CmDA,EAAS,c0CnDT,O1CoDA,EqPnHSC,EAAS,E3M+DlB,I2M/DK,GACLxL,EAAM,G,UrPF0B,MAA7B,I0CiEI,G,U5CdH,UADiD,4BACzB,kBADyB,0B,GAEjD,MAAAmL,IAAuB,qBAAAH,QAAA,6BAF0B,4BAE1B,mEAF0B,yB,CAI9B,qBAAAE,cAAA,6B,IAAf,SAAe,4C,QDyGuC,EAAa,EAAb,ICvGlD,K,oFDuGuD,oEAAL,8BAAK,oDAAL,kC,QCrGzCO,EAAS,I,OuP1D3B,wD,2HAKP,mB,yHAAA,6IrPmHA,4GAtHA,kBARA,gBFkDI,mQ,qBqNlDJ,E,OkCmB2C,sB,IAAvC,OAAwC,aACrC,iB,IAAA,Q,ErPkHH,EAAe,OqPnHf,YrPmHe,OAGf,SAAY,kBA5HiB,S0CyD7B,I1CsEAC,IAPiB,G0C/DjB1L,EAAM,G,I2MjDG,I3MiDT,Q1CwEA,E0CxEA,K,G2MhDA,I3MgDA,G1ChEgC,IAA7B,M,qFFmDC,0DADiD,4BACzB,sDADyB,sC,CAE1B,gE,IAF0B,yBAE1B,4B,QAEJ,E,EAAf,IAAe,K,oRDyG4C,M,OCrG9C,wDuPvCzB,uH,MAAA,mB,EAAA,iF,wCAAA,uB,oHAAA,4GrPyHA,4EA1IA,8CARA,2EFkDI,gG,cAAA,S,OAAA,sB,IuPjBwC,OlCjC5C,akCyBA,iB,IAQI,Q,IAAuC,O,YAAA,OACpC,sCrPwHH,IAAe,IAAf,GAGA,K,IAGA,E0C1FA,E1C0FA,EAnJ6B,QAArB,K,G0CyDR,I1C2FA,G0C3FA,I1C4FA,MqP/HS,iCAAJ,uCACL,G3MkCA,U1ChEgC,mBAA7B,iB0CiEI,sB,yH5CdH,gE,IADiD,yBACzB,4B,QACD,E,EAF0B,S,SD6GS,wB,SAAa,wB,+NAAR,wD,6IwP9HvE,mF,EAAA,oC,EAAA,uB,EAAA,qC,+EAAA,4C,8DAAA,4ErPmJA,yN,cA1LA,S,OFkDI,sB,WAAA,auPHuC,iB,IAAC,Q,WlC/C5C,Y,OkCuCA,0BAQI,aAAuC,IAAvC,GACG,K,IrPkJH,IAAe,EqPlJZ,a,GrPqJH,IAAY,GAxLiB,MAArB,I0CyDR,0B1CkIA,IAJe,GAIf,uC0ClIA,K1CmIA,EAAS,M0CnIT,mB1CoIA,uCqPzJS,kFAAJ,sC,CrP3C2B,mBAA7B,gB0CiEI,6B,6D5CdH,M,EADiD,S,SAI9B,wB,gDDyGoD,G,siBwPhH/E,uC,EAAA,2E,8GAAA,gB,0DAAA,yN,crP6KA,S,OA1NA,sB,IF0CI,OElDJ,QFkDI,sB,MqNlDJ,M,IAAA,OrNkDI,YqNlDJ,OkC6D2C,4BAAC,S,WAR5C,K,MAQI,EAAuC,EAAvC,a,GACG,iBrP4KH,wEAGA,KAAY,QAhOiB,qBAArB,qC0CyDR,0B1C0KA,IAJe,OAIf,mF,C0C1KA,mB1C4KA,6C,IqPnLS,E3MOT,uB2MPS,4B,IrPzDuB,M,oBFoDL,wB,mDD2GmC,wL,6EwPlGlE,gG,OAAA,8H,OAAA,8B,0LvPTQ,yG,OADA,gC,sFuPmBD,iB,gFATP,8D,qJAAA,wD,qCAAA,4ErP2IA,wB,KAAA,EAtMA,+BARA,gBFkDI,SqNlDJ,GrNkDI,oIqNlDJ,+DkC2E2C,S,KAAC,EAAxC,G,eARJ,0EAQI,2CAAuC,oBACpC,S,KAAA,ErP/D0B,GAyM7B,aAAe,EAGf,cAAY,6CA5MiB,gBAArB,oB0CyDR,oC,KAAA,E5CdqD,GuPqB5C,qCAAJ,WrPvE2B,mBAA7B,E,uCFmDC,qEADiD,oC,OAEjD,oBAAuB,S,KAF0B,EAI9B,yBAAf,mBAAe,I,6BDyGuC,EAAa,wB,kLAAb,E,2BCrGzC,Q,auPYlB,E,4CAKP,8E,KAAA,8I,uRAQI,gB,iBACG,wBrPoFH,sBAAe,G,IAGf,OAAY,Y,IApKiB,gBAArB,W,M0CyDR,E1C8GA,mB0C9GA,c1C8GA,GqPzFS,mB3MrBT,K2MsBA,gB,0CvPnCI,4BADiD,gCACzB,Q,sCACD,iB,cAAA,gB,8DAEJ,kB,4BAAA,a,EAAA,mC,qBAAA,mE,2IAFnB,6EAFiD,wBAE1B,0D,gTuPuB/B,uD,GAAA,mI,mDAAA,S,KAAA,E,oBrPqFA,E,oCAtKA,EFkDI,mEuPuCuC,GlCzF3C,2EkCyF2C,oCAAC,2B,cAR5C,EAQI,6FACG,uDrPoFH,uDAGA,wBAAY,yGApKiB,kBAArB,+CAuKR,K0C9GA,S1CuGiB,wB0CvGjB,sB1C+GS,E0C/GT,mB1CgHA,IqP3FS,a3MrBT,E2MsBA,S,KrPtFgC,E,sCFmD5B,S,KADiD,E,GAEjD,wBAAuB,eAF0B,8BAE1B,mE,oCAEJ,2BAAf,S,ODyGsD,wC,cAAa,E,yICrG/D,mC,EuP0BT,mC,qBCMiB,gI,MAAR,mDAAmB,wB,EAAX,mB,oNACA,iBAAR,wB,EAAQ,iB,EAAA,gB,EAAA,c,4CACA,4C,EAAA,uBAAR,6BAAQ,qB,EAAA,8F,qGAGE,W,uBAAA,E,4BEvEa,wC,mWI7BX,gE,uFAwBkB,wB,mDN+EtB,kGAAR,uBAAQ,+D,qBATZ,wD,iehCAR,yC,iGgCyCoB,4C,gThCjChB,M,GAAA,iE,6DgC+BJ,I,ieANJ,wB,kBAAA,oE,4HCtH4C,M,OA0BA,wDzPqBpC,8I,gpByP1DR,Q,iBAAA,0B,+CAAA,gKvPSA,wH,CF0CI,yH,IAAA,MqNlDJ,ErNkDI,S,0CyP1CA,wB,eACA,GACA,8FAAuC,0F,QAEvC,M,+D1PyJ8D,8I,giBCrGlD,8F,qEARyC,G,MAEjD,M,8CADA,G,WyPpBD,I,gcAdP,wB,mDAAA,wL,QAAA,M,OvPfA,wD,+QFwDgB,oC,4OARyC,gB,EAEjD,c,0FADA,yE,kTyPfR,Q,6CAAA,wC,0BAAA,mC,IvP1CA,MAQA,a,GF0CI,gKqNlDJ,wH,CoCiD2C,gE,IAAC,qD,IAP5C,MAOI,W,S7MqBA,wB,gD5CdqD,GAEjD,oEAAuB,oH,4QyPF/B,qB,EAAA,qC,wCAAA,2E,4DAAA,4C,8DAAA,4EAdA,yHvPlCA,gG,cF0CI,S,OAAA,0DqNlDJ,4BoCkE2C,QAAC,W,QAV5C,YAUI,oBvPrD6B,Q0CyD7BA,EAAA,G,IAAA,E6MlBA,M7MkBA,S6MFA,iB7MEA,gB,E1ChEgC,IAA7B,O,SFmDC,M,gBADiD,O,EAEjD,QAAuB,wEAF0B,SAE1B,I,0DAEJ,wH,uEDyGuC,mD,QAAa,E,4FAAb,G,oECrGzC,oH,6IyP6BzB,W,OAAA,6GAnDA,EAmDA,IAnDA,W,OvPlCA,mCF0CI,6F,OAAA,yBqNlDJ,mFoCwG2C,W,OAAC,0BAX5C,iFAMI,EANJ,e,OAOI,8BACA,kFAAY,EAAZ,IACA,W,OAAA,+BACA,sBAA2B,uDAC3B,EAD2B,e,OvP1FE,0B0CyD7B,sB6MlBA,oBAAO,oBAqDqB,e7MnC5B,E6MmC4B,I7MnC5B,W,O1ChEgC,0B,qCFmD5B,sBADiD,iCAEjD,kB,mDAEmB,4D,sDDyGuC,0BAAa,8B4P/ClE,4EACb,W,OC4B6C,kC,oEDdzC,wB,iGC9H+D,O,6EAAA,qC,gQAPnE,iC,sCAOmE,yC,8EAPnE,6BAOoC,S,sCAAiB,sBAAc,8C,6FAAd,kCAPrD,2F,IAAA,yC,yGAOqD,4CAAc,+B,oCAehB,oCACU,oBAAC,gB,2CAGE,O,oDAAD,kFAAC,E,4BALvC,iBALkB,gBhNsDvC,2B,0CgNjDqB,mBACb,QAAsB,wBACtB,aAAsB,2BACtB,mBA8ER,qD,2BAKsD,sCAAmB,E,mDDsB7E,gD,uECKA,2BAMI,qCACA,4CAMA,iB,8CGxIA,mD,uW/PmCI,wBAAwB,GACxB,sBAAU,E,wIAaS,O,8EAeU,2B,4CAAA,mC,2DAEZ,4BDwFsD,2B,+MCjF3E,uB,IAAA,kDASA,S,oLAJI,uBAEkB,2B,qCAAA,2B,yBAAA,yB,6FADlB,uBAEY,yC,0B4P5FpB,2DAsBkD,sBAtBlD,WAsBmD,YAIf,6DAAE,wBAAF,WFkG5B,IE9F4B,sD,OAAA,mB,6IAAoB,sF,yOAON,Q,OrO0CM,IqOtExD,6CrOs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nB,6CASS,W,OAAhB,KAAgB,gCAAM,sBAAI,4DAAc,EAAd,e,O9BtqBtB,yH8BwrDY,W,OAAArC,KAAA,gEGxvDhB,sBACI,6B,mPjC2ER,iBAgBI,4C,oFAEJ,iB,OAAA,sI,wXAWgC,qEDQkC,iB,OAAa,uC,kQAAR,sI,4GAAL,sCAAK,MCL5D,0G,yPAdX,W,OAAA,qC,qGAeA,uCoQpKA,sG,OAAA,0B,uTAIY,iJ,iIADuD,iB,8QCNnE,2B,uHA4BwC,K,uBAIK,2DAIL,2B,+CAQD,OAJA,oB,OAIA,Y,oBAII,wB,+CAIG,mB,2FAIT,K,0CAYG,G,0CAJO,wB,8FAE3C,+EAEoC,wB,yHC1DpC,mD,yEAEkC,kB,sVA6BeA,KAAA,oB,iGAiBE,Y,oCAE/C,wC,6CAEA,mBAKS,qBAAiB,8B,aApDlC,8CAKI,mB,OADmF,gCAQnF,iCARmF,SAmBnF,UASA,M,0DA5BmF,c,CChBvF,yCAMA,OALQ,6BACO,8B/O8D6C,qE+O1D5D,O,wChP4EwD,2B,wBiP/EG,uB,oFC2B/C,iB,yeANR,c,OAEA,OAQA,M,yCAeqC,mG,sTAAA,M,2DAAA,wBAMrC,uB,4BAlBJ,uBAMI,KAAI,kBAAc,ECRlB,wBzOkG6C,MAAM,oByOlGrC,O,SCpClB,E,yCAKsD,MAA9C,E/NsEG,O+NtEH,yC,6KALR,oB,oCAQA,mB,IACyE,U,gOCKrE,mB,OAEA,sCAA2C,oCAAa,I3OuEpD,M,qF2O3EsB,uB,gCAWJ,6B,SAAA,E,oDAElB,UAAS,EAAL,8B,yCACO,gD,2MAIW,mB,sBAAA,8B,qBAAA,E,8PAwCN,uC,+GAIZ,kB,OAAO,uB,slBAVf,qE,gKAkDJ,4C,EArBA,iB,yQjIoN0C,kB,ociIpN1C,kB,OAAA,mB,gDAAA,2B,mBAwBuC,sDAC/B,yBACJ,8C,6DCpGwC,8C,WAEhC,kB,kCAMJ,cAAS,OAAW,EAAO,oBAA3B,Y,0EAlBR,MAuBI,qD,0CAvBJ,qP,ufAOQ,2B,2CADJ,2BAWmB,qC,oDCJnB,uB,wEAAQ,WAER,kBAP6F,8D,OAQjG,6DAPI,EAOJ,I,mDARA,mB,IAAA,uC,sYCXiB,gB,iF9OgIgC,E,E8O/HtC,kB,6CAK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,gB2UfmC,S3UgB7B,OAAsB,GA6CmB,kBA7CzC,IAFV,SAEI,IAAM,mBAAsB,G,OAD5B,uB2UZM,G3UaN,EAAM,EsTzFd,e,ImBurBA,KnBvrBA,sE,eAAA,a,IAOyB,I,IAPzB,0BAQY,UARZ,2EAUY,uBADU,GATtB,I,mBmBaA,KAGuC,M,6BAEvC,mC,wBAAA,aAEiD,4B,8BAAgB,G,mBlB+XpD,ID7YL,EC6YiC,SDvY/B,WmBurBF,EAAc,ErBrsB4C,cGqZ9D,yBACA,UADS,6BACT,IkB7WmC,S,4BAIvC,qC,qBnB/BU,WmBurBF,ErV1VqC,gBmU0CzC,cACA,OkBjWqC,MAopB9B,GnBhsBH,gBmB4CiC,K,wBAIzC,2B,iBlB4Va,ID7YL,EC6YiC,SD5YjC,kBAKE,c,GmBurBF,EtVzT+B,EoUSnC,SAAS,kBAAT,KkBxUiC,OA4nB1B,WAAAtvB,GAAA,G,4CAxmBX,IAIuC,EAAa,SA0lB5C,EAAJ,gBlB1SS,EAAM,EAAN,eAAc,ED7YvB,MC6YqC,GkBpTzC,enBzFQ,EmB0rBQ,G,InBprBN,ImBurBM,WAAc,wCAAtB,OpP1SkC,W+NlZP,UqB6F/B,GrB7FM,SqB6Fa,GlBgTnB,wBkBjT6C,G,iBlBgTpC,MAAc,SD7YnB,EC6YiC,EAAAsvB,cD5YjC,UmByrBsC,I,GnBprBpC,ImBurBF,SlBhTK,wBHnY+E,KGoYxF,0B,wBkBmTO,G,iBlBnSE,MAAc,SkB6SnB,IlB7SkC,ckB8S9BC,EA3kBkD,EA2kBlD,U,GACA,EAAM,EAEJ,MrB/qBV,GG8XS,6BH9XJ,KG+XL,0B,qDADuB,IAAd,IkB6SL,UACI,QACA,EAAM,c,IlB/Sd,GAAA7c,EACA,M,6BkB7QJ,mCrBlHI,aqBkHJ,aAE+D,cAAgB,M,kCAE/E,I,+CAwBA,QAIiD,EAAc,SAAd,KlB4OpC,GAAM,GAAN,IAAc,I,EAAd,a,MkB6SL,iCAAoC,KAApC,SAEI,GAAM,GAEV,IAAM,I,EAAN,ElBjTJ,W,MACA,sCkBgTI,UA5hBJ,ErBpIK,EqBoIc,IrBpIL,EAAa,QG+W3B,O,gBkBpPJ,kB,MAAA,uFlBoPI,SACA,W,gCkBzOJ,S,QAAA,gD,OAA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,cCmHJ,qDAQA,ID9HA,cCoMqB,CAAC,KD/LpB,EC+LmB,WAErB,6BAFqB,WAGjB,K,aA4ER,4BACiB,4BAMjB,+B,MAGqD,EAAR,KAAP,oB,uCmB7RlC,anBsE0C,gBAAQ,W,4EmB5E1D,iDpBKI,iBoBDQ,uBpBEJ,qCoBFgB,apBOd,oBALF,sCoBD6B,Y,GpBM3B,mDoBFC,IAAP,KAAY,MACZ,QAAc,kDAGlB,kB,QAII,sC,eAQK,Id7BD,Wc6BJ,Qd7B2B,sCc6B3B,YAGJ,kB,QAI2C,sC,eAGJ,qBAEvC,Q,8CAAA,Y,wBAGA,oD,eAKW,MAAP,EAAO,OAGX,Q,2DAAA,aAKQ,atVmTqC,sBsVnTjB,Y,InB8WxB,EnU3DyC,asVlTrC,sBtV2NkC,KAAL,KAAiB,GsVvNtD,OnB0WI,mBmB3WO,UACX,GnByWmB,oBAAN,EAAM,WAAN,oBAAM,WAAN,M,yCmBpWa,4BL/Bb,aE+TyC,OAA9B,W,MGhSL,EHiSN,KAAqC,oBAG9C,cAAY,MGpSG,EHoSH,WFnUR,MK8DE,oBAA6B,qBACvC,4B,qCAYI,2BAGJ,oBAEA,aAQkC,MpBzHlC,kDmBgsB8C,iCAC5B,sBAD4B,iB,iCnBhsB9C,qB,yBAOgB,IAAS,U,oBAPzB,qBASsB,K,4CmBorBlB,OANJ,UlBpSa,ED5YL,GC4YiC,ED5YjC,K,uBC4YJ,EACA,gB,OkBmTA,OAAO,E,OACX,U,ElBpSa,GkBsSb,ElBtSmB,K,mBkB8SX,E,OAGM,OAFF,IAAM,MlB/Sd,E,GkBoTJ,G,sB/G1pB4B,G6FUqB,K,uB7FAjD,0D,cAEI,UAGJ,EAOoB,GAAX,EAAW,G,yBAuBhB,MAAO,OAAP,uCACI,IAAW,aAAQ,kCACnB,EAAQ,sBAAR,IAAAqU,EACA,IAAU,gBAAV,U,6FAQJ,EAAc,EAAAtY,M,yCA0BlB,eACoB,gBAEpB,eAEA,W,eAYoB,uBAAL,QAAAA,M,iB4FjKf,W5FwKoB,QAAL,K,gBAAX,wBACA,KAAY,kBAAZ,G,Q4FzKJ,E,KASsB,WACV,uE,4B7FoBR,KAFA,oB6FtBA,KAAI,4B,sB7F+CA,+C,oBCoEU,uDAAV,K,oBAwBoB,aAAxB,2CACY,M,oBAShB,aAEyD,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,IQb7C,IRagE,iB,qFAE7B,QAAK,I,uGQlBvE,aRoBA,kCQjBI,ERiB2E,EQjBvE,Q,OAAuB,YRiBgD,QAAmB,EQjBnE,2C,uCRmBqC,KAAK,IAAL,IAAgB,GAAQ,MAAnB,KAAW,IAAhB,G,kDQtBpE,0B,mBAG+B,ORqBsC,EAFD,SAAK,Q,2DAQrE,IAAK,KAAS,QAAQ,EAAjB,MAAuC,GAAvC,0BAAL,c,gDQ9BJ,kCRiCA,YAII,mE,OAAc,EQlCV,eAAQ,G,0BAAe,QR2FtB,UACT,Q,wB2CvFA,sB,iCASI,UlCiDa,QkC/CD,IAAZ,IAEA,EAAI,kBpVkIJ,oBoVhIW,EpVgIX,M,qBoV9GA,Y,0BARJ,gBAQI,qC,clCqCyB,GAAZ,KQrE8C,kE,mETNhC,2BmCyCO,Y,OAAlC,oBAAe,InCxCR,YmCwCsC,MAGjD,uC,OAQI,0B,aACA,kDAEY,0BAAW,cpV6FvB,oBoVzFQ,EpVyFR,+C,IAAA,Q,coVhFJ,O,kBAAA,G,eASI,elCkDa,E,sBkCmEb,oDnClM2B,yBmC+Ed,UAAmB,OnC/EL,emC+E3B,EnC/E2B,iFmCkF/B,iDAQI,2DACA,EADA,IACA,ElC4EyB,6E,OkCvEC,UAMA,gBAPtB,gH,OACsB,wBAClB,4BAAY,uEACP,c,8FAIa,Y,OAAtB,0BACgB,EAAA2C,EAAA,S,0BAMxB,oHAQI,0BACA,mH,IAAA,ElC6Da,KAAmB,mBAAnB,SkC7Db,gC,OAEc,c,InCxHa,YmCwH3B,0B,aAGJ,4BASI,yC,KAAA,GlCuFa,GkCnFb,MAAI,GAFQ,iCAAkB,GAE9B,Y,KAEQ,M,6DAIA,IpVOG,GoVPS,oBAAZ,KC4+BqD,YD5+BzC,W,yGAGxB,0EAUI,mEACA,e,IAAA,IlC2Ea,Q,ODvOb,EmC8Je,YnC9JX,YAAuBoiB,GAAwB,EAAxB,UmC8J3B,qBAAe,EnC7JRrzB,UmCgKX,8C,IAQI,2ElCyEyB,EkCzEzB,YAAAoR,EAAA,gBAAAsH,EAAA,KACA,QAEA,aAAY,eAAa,kBAEzB,EAAI,wBpV1BJ,KoV2BW,U,MACH,U,6CpV5BR,Y,+BoVgCQ,qBAGZ,sCnCvLQ,cAAQ,MAAe,EAAf,WmCoMZ,YnCpMY,emCuMhB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EAAgB,MAAO,EAAMnM,GAI7B,OAFA,GACW,EAAgB,EAAP,KACf,E,0BnXWD,QACA,EAAM,QmXQV,QACA,iBAAyB,G,IACrB,EAAI,EAAJ,O,qCC7C6B,2D,+E1TmLM,Y2TjJT,QAE9B,K3T+IuC,oB,gsCqT9FvC,cAAU,MAEV,EAFU,WAIN,WAJM,uBb1Dd,wDAImE,0C,uDAD7D,Y,4CAFF,Y,yDoBJyD,gDAErD,GAAAnF,KAAA,Q,gDJVqC,gB,4TAAA,wC,cAMb,iCAAqC,SAArC,WAExB,Q,2uEjDoBR,yB,gFfy0BI,gC,g9BQtxB+B,IAfJ,GAeI,kB,uGAf/B,mB,8HpE0EsB,oB,gH/D9HlB,IAA0B,EAA1B,G,qKAiGR,6B,uEAkBI,S,OAD2E,E,mBAD/E,MAEI,E,uYqI5II,IAAJ,IAA2B,U2D6EoD,InE3C1E,I,4BmEiET,cAG2D,ElSsTjB,E+NlZP,Q,0CQbnC,G2D2GA,E,O3DxG+B,G,m3FP4JL,M,SAClB,S,GACO,OA9CH,OAAoB,IA+CxB,Q,I5HgFI,E4H7EJ,E,Y5HiFe,cAAgCmF,EAAA,iDAA3C,GAAW,EAAX,mCACA,EAAU,EAAV,OACA,iC,SACK,0C,0BAEL,oCACA,YAAiB,qB,wB4HrIrB,GALJ,GAsDO,EAjDH,OAFJ,EAAa,GAAS,M,MACtB,EAEY,E,c5H2GhB,kB4H/FI,G,IACA,IAAgB,E,uB5HyGF,qBADd,EACc,G,4iByJ9DsB,wB,yBa1KH,0B,wEsBEjC,6B,wGpBsLJ,YATc,IAAN,IACA,EAAO,QAGJ,IAAP,I,YAKJ,a,wExK8EI,QACA,mB,yBAIqB,qB,6oEgLxKa,Y,yiO9SqStC,sE,MFxBA,mC,kBAAA,+E,U+T7WsC,M,svCjYsDtC,qC,yGA2LA,kD,mBV3MA,qD,uhBgBk9CA,mF,0P4Xx/CqD,mB,0xBzXcrD,yC,yD2DiYA,yC,iBFzQA,gD,ulBgT5CoB,8C,+B5WstDpB,6C,okD4D/xBA,gB,+oB7C97BQ,sC,sCK+mDR,4C,ySuWnrD8B,kBEZ1B,O,4DCyDJ,qB9XivDoB,MAAhB,IAAgB,E8X7uDhBuE,EAAM6sB,Q9X6uDU,wBAAhB,CAAgB,I8X3uDR,E9X2uDQ,W8X3u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","sources":["webpack://RXWeb/webpack/universalModuleDefinition","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/call/HttpClientCall.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/statement/HttpStatement.kt","webpack://RXWeb/../../../../src/main/kotlin/Main.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/request/builders.kt","webpack://RXWeb/./kotlin/src/kotlin/util/Standard.kt","webpack://RXWeb/./kotlin-dce/wrapper.js","webpack://RXWeb/./kotlin-dce/js/arrayUtils.js","webpack://RXWeb/./kotlin-dce/js/callableReferenceUtils.js","webpack://RXWeb/./kotlin-dce/js/conversions.js","webpack://RXWeb/./kotlin-dce/js/core.js","webpack://RXWeb/./kotlin-dce/js/misc.js","webpack://RXWeb/./kotlin-dce/js/polyfills.js","webpack://RXWeb/./kotlin-dce/js/markerFunctions.js","webpack://RXWeb/./kotlin-dce/js/rtti.js","webpack://RXWeb/./kotlin-dce/js/long.js","webpack://RXWeb/./kotlin-dce/runtime/arrayUtils.kt","webpack://RXWeb/./kotlin-dce/runtime/Enum.kt","webpack://RXWeb/./kotlin-dce/primitiveCompanionObjects.kt","webpack://RXWeb/./kotlin-dce/common/src/generated/_Arrays.kt","webpack://RXWeb/./kotlin-dce/common/src/generated/_Ranges.kt","webpack://RXWeb/./kotlin-dce/unsigned/src/kotlin/UByte.kt","webpack://RXWeb/./kotlin-dce/unsigned/src/kotlin/UInt.kt","webpack://RXWeb/./kotlin-dce/unsigned/src/kotlin/UShort.kt","webpack://RXWeb/./kotlin-dce/builtin-sources/Ranges.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/collections/Collections.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/collections/Maps.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/collections/Sets.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/text/StringNumberConversions.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/time/Duration.kt","webpack://RXWeb/./kotlin-dce/unsigned/src/kotlin/UnsignedUtils.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/collections/Sequences.kt","webpack://RXWeb/./kotlin-dce/common/src/generated/_Collections.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/collections/Iterables.kt","webpack://RXWeb/./kotlin-dce/common/src/generated/_Sequences.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/util/Preconditions.kt","webpack://RXWeb/./kotlin-dce/builtin-sources/Iterators.kt","webpack://RXWeb/./kotlin-dce/builtin-sources/ProgressionIterators.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/CharCode.kt","webpack://RXWeb/./kotlin-dce/builtin-sources/Progressions.kt","webpack://RXWeb/./kotlin-dce/builtin-sources/Collections.kt","webpack://RXWeb/./kotlin-dce/builtin-sources/Range.kt","webpack://RXWeb/./kotlin-dce/builtin-sources/Unit.kt","webpack://RXWeb/./kotlin-dce/builtin-sources/internal/progressionUtil.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/builtins.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/coroutines/CoroutineImpl.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/util/Standard.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/util/Result.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/coroutines/Continuation.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/coroutines/intrinsics/IntrinsicsJs.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/exceptions.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/text/numberConversions_js-v1.kt","webpack://RXWeb/./kotlin-dce/js/src/generated/_ArraysJs.kt","webpack://RXWeb/./kotlin-dce/js/src/generated/_CollectionsJs.kt","webpack://RXWeb/./kotlin-dce/js/src/generated/_DigitChars.kt","webpack://RXWeb/./kotlin-dce/js/src/generated/_WhitespaceChars.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/collections.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/kotlin.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/collections/AbstractMutableCollection.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/collections/AbstractMutableList.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/collections/AbstractMutableMap.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/collections/AbstractMutableSet.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/collections/ArrayList.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/collections/ArraySorting.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/collections/EqualityComparator.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/Comparator.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/collections/HashMap.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/collections/HashSet.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/collections/InternalHashCodeMap.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/collections/InternalStringMap.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/collections/LinkedHashMap.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/collections/LinkedHashSet.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/console.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/coroutines/SafeContinuationJs.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/exceptionUtils.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/math.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/numbers_js-v1.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/numbers.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/random/PlatformRandom.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/reflect/KClassImpl.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/collections/InternalMap.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/jsOperators.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/text/string.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/reflect/KTypeImpl.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/reflect/primitives.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/reflect/reflection.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/regexp.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/text/CharacterCodingExceptionJs.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/text/StringBuilderJs.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/text/char.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/text/numberConversions.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/text/regex.kt","webpack://RXWeb/./kotlin-dce/common/src/generated/_Strings.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/text/Strings.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/text/StringBuilder.kt","webpack://RXWeb/./kotlin-dce/js/src/generated/_ComparisonsJs.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/text/stringsCode.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/text/utf8Encoding.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/collections/AbstractCollection.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/collections/AbstractList.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/collections/AbstractMap.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/collections/AbstractSet.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/collections/MapWithDefault.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/collections/MutableCollections.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/collections/ReversedViews.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/collections/SequenceBuilder.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/coroutines/ContinuationInterceptor.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/coroutines/CoroutineContext.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/coroutines/CoroutineContextImpl.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/coroutines/intrinsics/Intrinsics.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/random/Random.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/properties/Interfaces.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/random/XorWowRandom.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/ranges/Ranges.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/text/Appendable.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/text/Char.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/text/Indent.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/text/regex/MatchResult.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/util/Lazy.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/util/Tuples.kt","webpack://RXWeb/./kotlin-dce/unsigned/src/kotlin/ULong.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/experimental/bitwiseOperations.kt","webpack://RXWeb/./kotlin-dce/unsigned/src/kotlin/UIntRange.kt","webpack://RXWeb/./kotlin-dce/unsigned/src/kotlin/UIterators.kt","webpack://RXWeb/./kotlin-dce/unsigned/src/kotlin/ULongRange.kt","webpack://RXWeb/./kotlin-dce/unsigned/src/kotlin/UProgressionUtil.kt","webpack://RXWeb/./kotlin-dce/common/src/generated/_Maps.kt","webpack://RXWeb/./kotlin-dce/common/src/generated/_Sets.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/coroutines/cancellation/CancellationException.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/reflect/KTypeHelpers.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/throwableExtensions.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/comparisons/Comparisons.kt","webpack://RXWeb/./kotlin-dce/js/src/kotlin/coroutines/js/internal/EmptyContinuation.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/util/DeepRecursive.kt","webpack://RXWeb/../../../../../common/src/Delay.kt","webpack://RXWeb/../../../../../common/src/EventLoop.common.kt","webpack://RXWeb/../../../../../common/src/flow/SharedFlow.kt","webpack://RXWeb/../../../../../common/src/internal/LockFreeTaskQueue.kt","webpack://RXWeb/../../../../../js/src/JSDispatcher.kt","webpack://RXWeb/../../../../../common/src/AbstractCoroutine.kt","webpack://RXWeb/../../../../../common/src/Builders.common.kt","webpack://RXWeb/../../../../../common/src/CancellableContinuation.kt","webpack://RXWeb/../../../../../common/src/CancellableContinuationImpl.kt","webpack://RXWeb/../../../../../atomicfu/src/commonMain/kotlin/kotlinx/atomicfu/AtomicFU.common.kt","webpack://RXWeb/../../../../../common/src/CompletableDeferred.kt","webpack://RXWeb/../../../../../common/src/CompletionState.kt","webpack://RXWeb/../../../../../common/src/CoroutineDispatcher.kt","webpack://RXWeb/../../../../../common/src/CoroutineExceptionHandler.kt","webpack://RXWeb/../../../../../common/src/CoroutineName.kt","webpack://RXWeb/../../../../../common/src/CoroutineScope.kt","webpack://RXWeb/../../../../../common/src/CoroutineStart.kt","webpack://RXWeb/../../../../../common/src/Job.kt","webpack://RXWeb/../../../../../common/src/JobSupport.kt","webpack://RXWeb/../../../../../common/src/MainCoroutineDispatcher.kt","webpack://RXWeb/../../../../../common/src/NonCancellable.kt","webpack://RXWeb/../../../../../common/src/Supervisor.kt","webpack://RXWeb/../../../../../common/src/Timeout.kt","webpack://RXWeb/../../../../../common/src/channels/AbstractChannel.kt","webpack://RXWeb/../../../../../js/src/internal/LinkedList.kt","webpack://RXWeb/../../../../../js/src/internal/StackTraceRecovery.kt","webpack://RXWeb/../../../../../common/src/channels/ArrayBroadcastChannel.kt","webpack://RXWeb/../../../../../common/src/channels/ArrayChannel.kt","webpack://RXWeb/../../../../../common/src/channels/Channel.kt","webpack://RXWeb/../../../../../common/src/internal/InlineList.kt","webpack://RXWeb/../../../../../common/src/channels/Broadcast.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/util/HashCode.kt","webpack://RXWeb/../../../../../common/src/channels/ChannelCoroutine.kt","webpack://RXWeb/../../../../../common/src/channels/Channels.common.kt","webpack://RXWeb/../../../../../common/src/flow/terminal/Reduce.kt","webpack://RXWeb/../../../../../common/src/internal/Atomic.kt","webpack://RXWeb/../../../../../common/src/channels/ConflatedBroadcastChannel.kt","webpack://RXWeb/../../../../../common/src/channels/LinkedListChannel.kt","webpack://RXWeb/../../../../../common/src/flow/internal/SafeCollector.common.kt","webpack://RXWeb/../../../../../common/src/flow/operators/Zip.kt","webpack://RXWeb/../../../../../common/src/flow/terminal/Collect.kt","webpack://RXWeb/../../../../../common/src/internal/ConcurrentLinkedList.kt","webpack://RXWeb/../../../../../common/src/internal/DispatchedContinuation.kt","webpack://RXWeb/../../../../../common/src/internal/DispatchedTask.kt","webpack://RXWeb/../../../../../common/src/channels/Deprecated.kt","webpack://RXWeb/../../../../../common/src/channels/Produce.kt","webpack://RXWeb/../../../../../common/src/flow/Builders.kt","webpack://RXWeb/../../../../../common/src/flow/Flow.kt","webpack://RXWeb/../../../../../common/src/flow/operators/Merge.kt","webpack://RXWeb/../../../../../common/src/flow/operators/Limit.kt","webpack://RXWeb/../../../../../common/src/flow/internal/FlowExceptions.common.kt","webpack://RXWeb/../../../../../common/src/flow/terminal/Count.kt","webpack://RXWeb/../../../../../common/src/internal/LimitedDispatcher.kt","webpack://RXWeb/../../../../../common/src/internal/LocalAtomics.common.kt","webpack://RXWeb/../../../../../common/src/intrinsics/Undispatched.kt","webpack://RXWeb/../../../../../common/src/selects/WhileSelect.kt","webpack://RXWeb/../../../../../common/src/sync/Semaphore.kt","webpack://RXWeb/../../../../../js/src/CompletionHandler.kt","webpack://RXWeb/../../../../../common/src/internal/Scopes.kt","webpack://RXWeb/../../../../../common/src/internal/Symbol.kt","webpack://RXWeb/../../../../../common/src/internal/SystemProps.common.kt","webpack://RXWeb/../../../../../common/src/internal/ThreadSafeHeap.kt","webpack://RXWeb/../../../../../common/src/intrinsics/Cancellable.kt","webpack://RXWeb/../../../../../js/src/Runnable.kt","webpack://RXWeb/../../../../../common/src/selects/Select.kt","webpack://RXWeb/../../../../../js/src/CoroutineContext.kt","webpack://RXWeb/../../../../../common/src/selects/SelectUnbiased.kt","webpack://RXWeb/../../../../../common/src/sync/Mutex.kt","webpack://RXWeb/../../../../../js/src/Debug.kt","webpack://RXWeb/../../../../../js/src/Dispatchers.kt","webpack://RXWeb/../../../../../js/src/EventLoop.kt","webpack://RXWeb/../../../../../js/src/CoroutineExceptionHandlerImpl.kt","webpack://RXWeb/../../../../../js/src/Exceptions.kt","webpack://RXWeb/../../../../../js/src/Promise.kt","webpack://RXWeb/../../../../../js/src/SchedulerTask.kt","webpack://RXWeb/../../../../../js/src/internal/CopyOnWriteList.kt","webpack://RXWeb/../../../../../js/src/flow/internal/FlowExceptions.kt","webpack://RXWeb/../../../../../js/src/internal/LocalAtomics.kt","webpack://RXWeb/../../../../../js/src/internal/ProbesSupport.kt","webpack://RXWeb/../../../../../js/src/internal/ThreadContext.kt","webpack://RXWeb/../../../../../js/src/internal/ThreadLocal.kt","webpack://RXWeb/../../../../ktor-utils/js/src/io/ktor/util/reflect/TypeInfoJs.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/features/HttpTimeout.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/features/cache/HttpCacheEntry.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/ReadSession.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/HttpClient.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/core/Input.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/HttpClientConfig.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/content/ObservableContent.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/engine/HttpClientEngineBase.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/engine/ProxyConfig.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/call/SavedCall.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/call/TypeInfo.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/call/utils.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/engine/HttpClientEngine.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/engine/Utils.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/features/BodyProgress.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/features/DataConversion.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/features/DefaultRequest.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/features/DefaultResponseValidation.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/features/DefaultTransform.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/features/ExpectSuccess.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/features/HttpCallValidator.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/features/HttpClientFeature.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/features/HttpPlainText.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/features/HttpRedirect.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/features/HttpRequestLifecycle.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/features/HttpSend.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/features/cache/HttpCache.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/features/cookies/HttpCookies.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/features/observer/ResponseObserver.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/features/websocket/WebSockets.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/features/websocket/builders.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/request/ClientUpgradeContent.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/request/DefaultHttpRequest.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/request/buildersWithUrl.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/request/forms/FormDataContent.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/request/forms/formBuilders.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/core/BytePacketBuilder.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/core/Buffers.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/request/forms/formDsl.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/request/HttpRequest.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/core/ByteReadPacket.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/statement/DefaultHttpResponse.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/request/utils.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/response/Migration.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/statement/HttpResponse.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/statement/HttpResponsePipeline.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/statement/Readers.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/utils/CacheControl.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/utils/Content.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/utils/SharedCollections.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/client/utils/headers.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/common/src/io/ktor/network/sockets/TimeoutExceptionsCommon.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/js/src/io/ktor/client/engine/ProxyConfigJs.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/js/src/io/ktor/client/engine/js/Js.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/js/src/io/ktor/client/engine/js/JsClientEngine.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/js/src/io/ktor/client/engine/js/JsUtils.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/js/src/io/ktor/client/engine/js/ReadableStream.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/js/src/io/ktor/client/engine/js/browser/BrowserFetch.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/js/src/io/ktor/client/engine/js/compatibility/Utils.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/js/src/io/ktor/client/HttpClientJs.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/js/src/io/ktor/client/engine/HttpClientEngineJs.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/js/src/io/ktor/client/engine/js/node/NodeFetch.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/js/src/io/ktor/client/features/DefaultTransformJs.kt","webpack://RXWeb/../../../../ktor-client/ktor-client-core/js/src/io/ktor/client/features/websocket/JsWebSocketSession.kt","webpack://RXWeb/../../../../ktor-http/ktor-http-cio/common/src/io/ktor/http/cio/ChunkedTransferEncoding.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/Coroutines.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/core/Strings.kt","webpack://RXWeb/../../../../ktor-http/ktor-http-cio/common/src/io/ktor/http/cio/internals/Chars.kt","webpack://RXWeb/../../../../ktor-http/ktor-http-cio/common/src/io/ktor/http/cio/HttpHeadersMap.kt","webpack://RXWeb/../../../../ktor-http/ktor-http-cio/common/src/io/ktor/http/cio/RequestResponse.kt","webpack://RXWeb/../../../../ktor-http/ktor-http-cio/common/src/io/ktor/http/cio/internals/AsciiCharTree.kt","webpack://RXWeb/../../../../ktor-http/ktor-http-cio/common/src/io/ktor/http/cio/CIOHeaders.kt","webpack://RXWeb/../../../../ktor-http/ktor-http-cio/common/src/io/ktor/http/cio/websocket/CloseReason.kt","webpack://RXWeb/../../../../ktor-http/ktor-http-cio/common/src/io/ktor/http/cio/internals/CharArrayPool.kt","webpack://RXWeb/../../../../ktor-http/ktor-http-cio/common/src/io/ktor/http/cio/internals/Tokenizer.kt","webpack://RXWeb/../../../../ktor-http/ktor-http-cio/common/src/io/ktor/http/cio/websocket/FrameCommon.kt","webpack://RXWeb/../../../../ktor-http/ktor-http-cio/common/src/io/ktor/http/cio/websocket/FrameType.kt","webpack://RXWeb/../../../../ktor-http/ktor-http-cio/js/src/io/ktor/http/cio/RequestResponseBuilderJs.kt","webpack://RXWeb/../../../../ktor-http/ktor-http-cio/js/src/io/ktor/http/cio/websocket/DefaultWebSocketSessionJs.kt","webpack://RXWeb/../../../../ktor-http/ktor-http-cio/js/src/io/ktor/http/cio/websocket/FrameJs.kt","webpack://RXWeb/../../../../ktor-http/ktor-http-cio/common/src/io/ktor/http/cio/websocket/Utils.kt","webpack://RXWeb/../../../../ktor-http/ktor-http-cio/js/src/io/ktor/http/cio/websocket/WebSocketSessionJs.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/Codecs.kt","webpack://RXWeb/./kotlin-dce/src/kotlin/text/regex/RegexExtensions.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/Text.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/core/Closeable.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/ContentDisposition.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/ApplicationResponseProperties.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/CacheControl.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/HeaderValueWithParameters.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/ContentRange.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/ContentTypes.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/Cookie.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/Headers.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/HttpHeaderValueParser.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/HttpHeaders.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/HttpMessageProperties.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/HttpProtocolVersion.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/HttpStatusCode.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/HttpUrlEncoded.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/Parameters.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/LinkHeader.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/IpParser.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/Query.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/Ranges.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/URLBuilder.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/URLParser.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/URLProtocol.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/URLUtils.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/auth/HeaderValueEncoding.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/auth/HttpAuthHeader.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/content/Multipart.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/content/OutgoingContent.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/parsing/Debug.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/parsing/GrammarBuilder.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/parsing/ParserDsl.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/parsing/regex/RegexParserGenerator.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/websocket/Utils.kt","webpack://RXWeb/../../../../ktor-http/js/src/io/ktor/http/URLBuilderJs.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/auth/AuthScheme.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/content/TextContent.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/DateUtils.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/FileContentType.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/Mimes.kt","webpack://RXWeb/../../../../ktor-http/common/src/io/ktor/http/content/CachingOptions.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/ByteChannelSequential.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/charsets/Encoding.kt","webpack://RXWeb/../../../../ktor-io/js/src/io/ktor/utils/io/bits/MemoryPrimitivesJs.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/core/InputArrays.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/core/internal/Require.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/core/Buffer.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/ByteReadChannel.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/ByteWriteChannel.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/ChannelLittleEndian.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/WriterSession.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/core/internal/Numbers.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/bits/PrimiteArrays.kt","webpack://RXWeb/./kotlin-dce/common/src/generated/_UArrays.kt","webpack://RXWeb/../../../../ktor-io/js/src/io/ktor/utils/io/bits/MemoryFactoryJs.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/core/AbstractInput.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/ByteChannelCtor.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/core/Builder.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/ExceptionUtils.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/core/Output.kt","webpack://RXWeb/../../../../ktor-io/js/src/io/ktor/utils/io/bits/MemoryJs.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/core/PacketDirect.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/core/internal/UTF8.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/core/AbstractOutput.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/core/BufferPrimitives.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/core/BufferCompatibility.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/core/BufferFactory.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/core/InputPrimitives.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/core/OutputPrimitives.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/core/Packet.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/core/Preview.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/core/Scanner.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/core/internal/ChunkBuffer.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/core/internal/Unsafe.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/errors/Errors.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/internal/AwaitingSlot.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/internal/SequentialCopyTo.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/pool/Pool.kt","webpack://RXWeb/../../../../ktor-io/js/src/io/ktor/utils/io/ByteChannelJS.kt","webpack://RXWeb/../../../../ktor-io/js/src/io/ktor/utils/io/ByteChannelSequentialBaseSharedStateJs.kt","webpack://RXWeb/../../../../ktor-io/js/src/io/ktor/utils/io/ConditionJS.kt","webpack://RXWeb/../../../../ktor-io/js/src/io/ktor/utils/io/bits/ByteOrderJs.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/bits/ByteOrder.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/pool/ByteArrayPool.kt","webpack://RXWeb/../../../../ktor-io/js/src/io/ktor/utils/io/ExceptionUtilsJs.kt","webpack://RXWeb/../../../../ktor-io/js/src/io/ktor/utils/io/NativeUtilsJs.kt","webpack://RXWeb/../../../../ktor-io/js/src/io/ktor/utils/io/bits/PrimitiveArraysJs.kt","webpack://RXWeb/./kotlin-dce/js/src/org.w3c/org.khronos.webgl.kt","webpack://RXWeb/../../../../ktor-io/js/src/io/ktor/utils/io/charsets/CharsetJS.kt","webpack://RXWeb/../../../../ktor-io/js/src/io/ktor/utils/io/js/TextDecoders.kt","webpack://RXWeb/../../../../ktor-io/js/src/io/ktor/utils/io/charsets/DecodeBuffer.kt","webpack://RXWeb/../../../../ktor-io/js/src/io/ktor/utils/io/charsets/ISO88591.kt","webpack://RXWeb/../../../../ktor-io/js/src/io/ktor/utils/io/core/IoBufferJS.kt","webpack://RXWeb/../../../../ktor-io/js/src/io/ktor/utils/io/core/ByteOrderJS.kt","webpack://RXWeb/../../../../ktor-io/js/src/io/ktor/utils/io/core/ByteReadPacket.kt","webpack://RXWeb/../../../../ktor-io/js/src/io/ktor/utils/io/core/CloseableJS.kt","webpack://RXWeb/../../../../ktor-io/js/src/io/ktor/utils/io/core/InputArraysJS.kt","webpack://RXWeb/../../../../ktor-io/js/src/io/ktor/utils/io/concurrent/SharedJs.kt","webpack://RXWeb/../../../../ktor-io/js/src/io/ktor/utils/io/core/InputJs.kt","webpack://RXWeb/../../../../ktor-io/js/src/io/ktor/utils/io/core/AbstractOutputSharedStateJs.kt","webpack://RXWeb/../../../../ktor-io/js/src/io/ktor/utils/io/core/AbstractInputSharedStateJs.kt","webpack://RXWeb/../../../../ktor-io/js/src/io/ktor/utils/io/core/BufferSharedStateJs.kt","webpack://RXWeb/../../../../ktor-io/js/src/io/ktor/utils/io/core/ScannerJS.kt","webpack://RXWeb/../../../../ktor-io/js/src/io/ktor/utils/io/core/OutputJs.kt","webpack://RXWeb/../../../../ktor-io/js/src/io/ktor/utils/io/core/PacketJS.kt","webpack://RXWeb/../../../../ktor-io/js/src/io/ktor/utils/io/js/TextDecoder.kt","webpack://RXWeb/../../../../ktor-io/js/src/io/ktor/utils/io/core/StringsJS.kt","webpack://RXWeb/../../../../ktor-io/js/src/io/ktor/utils/io/errors/IOException.kt","webpack://RXWeb/../../../../ktor-io/js/src/io/ktor/utils/io/js/TextDecoderFallback.kt","webpack://RXWeb/../../../../ktor-io/js/src/io/ktor/utils/io/js/Decoder.kt","webpack://RXWeb/../../../../ktor-io/common/src/io/ktor/utils/io/bits/MemoryPrimitives.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/ByteChannels.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/Ranges.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/CoroutinesUtils.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/Attributes.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/CaseInsensitiveMap.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/CaseInsensitiveSet.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/Charset.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/DelegatingMutableSet.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/Annotations.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/Bytes.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/Crypto.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/Encoders.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/Lock.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/NonceManager.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/collections/ConcurrentCollection.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/StringValues.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/cio/Readers.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/collections/ConcurrentList.kt","webpack://RXWeb/../../../../../atomicfu/src/jsMain/kotlin/kotlinx/atomicfu/locks/Synchronized.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/collections/ConcurrentMap.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/collections/internal/ConcurrentListSlice.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/collections/internal/ConcurrentMapKeys.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/collections/internal/ConcurrentMapValues.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/collections/internal/ForwardListIterator.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/collections/internal/ForwardListNode.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/collections/internal/MapNode.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/collections/internal/MutableMapEntries.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/collections/internal/SharedForwardList.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/collections/internal/SharedList.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/converters/ConversionService.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/converters/DataConversion.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/date/Date.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/date/GMTDateParser.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/pipeline/DebugPipelineContext.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/pipeline/PhaseContent.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/pipeline/Pipeline.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/pipeline/PipelinePhaseRelation.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/pipeline/StackTraceRecover.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/pipeline/PipelinePhase.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/pipeline/StackWalkingFailed.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/pipeline/StackWalkingFailedFrame.kt","webpack://RXWeb/../../../../ktor-utils/js/src/io/ktor/util/CoroutinesUtilsJs.kt","webpack://RXWeb/../../../../ktor-utils/js/src/io/ktor/util/CryptoJs.kt","webpack://RXWeb/../../../../ktor-utils/js/src/io/ktor/util/LockJs.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/pipeline/SuspendFunctionGun.kt","webpack://RXWeb/../../../../ktor-utils/js/src/io/ktor/util/AttributesJs.kt","webpack://RXWeb/../../../../ktor-utils/js/src/io/ktor/util/PlatformUtilsJs.kt","webpack://RXWeb/../../../../ktor-utils/common/src/io/ktor/util/reflect/Type.kt","webpack://RXWeb/../../../../ktor-utils/js/src/io/ktor/util/CollectionsJs.kt","webpack://RXWeb/../../../../ktor-utils/js/src/io/ktor/util/converters/ConversionServiceJs.kt","webpack://RXWeb/../../../../ktor-utils/js/src/io/ktor/util/date/DateJs.kt","webpack://RXWeb/../../../../ktor-utils/js/src/io/ktor/util/network/NetworkAddressJs.kt","webpack://RXWeb/webpack/bootstrap","webpack://RXWeb/webpack/startup"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"RXWeb\"] = factory();\n\telse\n\t\troot[\"RXWeb\"] = factory();\n})(this, function() {\nreturn ","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.call\n\nimport io.ktor.client.*\nimport io.ktor.client.request.*\nimport io.ktor.client.statement.*\nimport io.ktor.util.*\nimport io.ktor.util.reflect.TypeInfo\nimport io.ktor.util.reflect.typeInfo\nimport io.ktor.utils.io.*\nimport io.ktor.utils.io.concurrent.*\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\nimport kotlin.reflect.*\nimport io.ktor.client.call.TypeInfo as DeprecatedTypeInfo\n\n@InternalAPI\ninternal fun HttpClientCall(\n    client: HttpClient,\n    requestData: HttpRequestData,\n    responseData: HttpResponseData\n): HttpClientCall = HttpClientCall(client).apply {\n    request = DefaultHttpRequest(this, requestData)\n    response = DefaultHttpResponse(this, responseData)\n\n    if (responseData.body !is ByteReadChannel) {\n        @Suppress(\"DEPRECATION\")\n        attributes.put(HttpClientCall.CustomResponse, responseData.body)\n    }\n}\n\n/**\n * A class that represents a single pair of [request] and [response] for a specific [HttpClient].\n *\n * @property client: client that executed the call.\n */\npublic open class HttpClientCall internal constructor(\n    client: HttpClient\n) : CoroutineScope {\n    private val received: AtomicBoolean = atomic(false)\n\n    public val client: HttpClient? by threadLocal(client)\n\n    override val coroutineContext: CoroutineContext get() = response.coroutineContext\n\n    /**\n     * Typed [Attributes] associated to this call serving as a lightweight container.\n     */\n    public val attributes: Attributes get() = request.attributes\n\n    /**\n     * Represents the [request] sent by the client\n     */\n    public lateinit var request: HttpRequest\n        internal set\n\n    /**\n     * Represents the [response] sent by the server.\n     */\n    public lateinit var response: HttpResponse\n        internal set\n\n    protected open val allowDoubleReceive: Boolean = false\n\n    protected open suspend fun getResponseContent(): ByteReadChannel = response.content\n\n    /**\n     * Tries to receive the payload of the [response] as a specific expected type provided in [info].\n     * Returns [response] if [info] corresponds to [HttpResponse].\n     *\n     * @throws NoTransformationFoundException If no transformation is found for the type [info].\n     * @throws DoubleReceiveException If already called [receive].\n     */\n    public suspend fun receive(info: DeprecatedTypeInfo): Any = receive(info as TypeInfo)\n\n    /**\n     * Tries to receive the payload of the [response] as a specific expected type provided in [info].\n     * Returns [response] if [info] corresponds to [HttpResponse].\n     *\n     * @throws NoTransformationFoundException If no transformation is found for the type [info].\n     * @throws DoubleReceiveException If already called [receive].\n     */\n    public suspend fun receive(info: TypeInfo): Any {\n        try {\n            if (response.instanceOf(info.type)) return response\n            if (!allowDoubleReceive && !received.compareAndSet(false, true)) {\n                throw DoubleReceiveException(this)\n            }\n\n            @Suppress(\"DEPRECATION\")\n            val responseData = attributes.getOrNull(CustomResponse) ?: getResponseContent()\n\n            val subject = HttpResponseContainer(info, responseData)\n            val currentClient = client ?: error(\"Failed to receive call($this) in different native thread.\")\n\n            val result = currentClient.responsePipeline.execute(this, subject).response\n            if (!result.instanceOf(info.type)) {\n                val from = result::class\n                val to = info.type\n                throw NoTransformationFoundException(response, from, to)\n            }\n\n            return result\n        } catch (cause: Throwable) {\n            response.cancel(\"Receive failed\", cause)\n            throw cause\n        } finally {\n            response.complete()\n        }\n    }\n\n    override fun toString(): String = \"HttpClientCall[${request.url}, ${response.status}]\"\n\n    public companion object {\n        /**\n         * [CustomResponse] key used to process the response of custom type in case of [HttpClientEngine] can't return body bytes directly.\n         * If present, attribute value will be an initial value for [HttpResponseContainer] in [HttpClient.responsePipeline].\n         *\n         * Example: [WebSocketSession]\n         */\n        @Deprecated(\n            \"This is going to be removed. \" +\n                \"Please file a ticket with clarification why and what for do you need it.\"\n        )\n        public val CustomResponse: AttributeKey<Any> = AttributeKey(\"CustomResponse\")\n    }\n}\n\n/**\n * Raw http call produced by engine.\n *\n * @property request - executed http request.\n * @property response - raw http response\n */\n@Deprecated(\n    \"HttpEngineCall deprecated.\",\n    level = DeprecationLevel.ERROR,\n    replaceWith = ReplaceWith(\"HttpResponseData\")\n)\n@InternalAPI\npublic data class HttpEngineCall(val request: HttpRequest, val response: HttpResponse)\n\n/**\n * Constructs a [HttpClientCall] from this [HttpClient] and with the specified [HttpRequestBuilder]\n * configured inside the [block].\n */\n@Deprecated(\n    \"Unbound [HttpClientCall] is deprecated. Consider using [request<HttpResponse>(block)] in instead.\",\n    level = DeprecationLevel.ERROR,\n    replaceWith = ReplaceWith(\n        \"this.request<HttpResponse>(block)\",\n        \"io.ktor.client.request.request\",\n        \"io.ktor.client.statement.*\"\n    )\n)\n@Suppress(\"RedundantSuspendModifier\", \"unused\", \"UNUSED_PARAMETER\")\npublic suspend fun HttpClient.call(block: suspend HttpRequestBuilder.() -> Unit = {}): HttpClientCall =\n    error(\"Unbound [HttpClientCall] is deprecated. Consider using [request<HttpResponse>(block)] in instead.\")\n\n/**\n * Tries to receive the payload of the [response] as a specific type [T].\n *\n * @throws NoTransformationFoundException If no transformation is found for the type [T].\n * @throws DoubleReceiveException If already called [receive].\n */\npublic suspend inline fun <reified T> HttpClientCall.receive(): T = receive(typeInfo<T>()) as T\n\n/**\n * Tries to receive the payload of the [response] as a specific type [T] described in [typeInfo].\n *\n * @throws NoTransformationFoundException If no transformation is found for the type [T].\n * @throws DoubleReceiveException If already called [receive].\n */\npublic suspend inline fun <reified T> HttpResponse.receive(): T = call.receive(typeInfo<T>()) as T\n\n/**\n * Exception representing that the response payload has already been received.\n */\n@Suppress(\"KDocMissingDocumentation\")\npublic class DoubleReceiveException(call: HttpClientCall) : IllegalStateException() {\n    override val message: String = \"Response already received: $call\"\n}\n\n/**\n * Exception representing fail of the response pipeline\n * [cause] contains origin pipeline exception\n */\n@Suppress(\"KDocMissingDocumentation\", \"unused\")\npublic class ReceivePipelineException\n@Deprecated(\"Please use overload with io.ktor.util.reflect.TypeInfo parameter\")\nconstructor(\n    public val request: HttpClientCall,\n    public val info: DeprecatedTypeInfo,\n    override val cause: Throwable\n) : IllegalStateException(\"Fail to run receive pipeline: $cause\") {\n\n    public constructor(request: HttpClientCall, info: TypeInfo, cause: Throwable) : this(\n        request,\n        DeprecatedTypeInfo(info.type, info.reifiedType, info.kotlinType),\n        cause\n    )\n}\n\n/**\n * Exception representing the no transformation was found.\n * It includes the received type and the expected type as part of the message.\n */\n@Suppress(\"KDocMissingDocumentation\")\npublic class NoTransformationFoundException(\n    response: HttpResponse,\n    from: KClass<*>,\n    to: KClass<*>\n) : UnsupportedOperationException() {\n    override val message: String? = \"\"\"No transformation found: $from -> $to\n        |with response from ${response.request.url}:\n        |status: ${response.status}\n        |response headers: \n        |${response.headers.flattenEntries().joinToString { (key, value) -> \"$key: $value\\n\" }}\n    \"\"\".trimMargin()\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.statement\n\nimport io.ktor.client.*\nimport io.ktor.client.call.*\nimport io.ktor.client.engine.*\nimport io.ktor.client.features.*\nimport io.ktor.client.request.*\nimport io.ktor.http.*\nimport io.ktor.utils.io.*\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.*\nimport kotlinx.coroutines.*\n\n/**\n * Prepared statement for http client request.\n * This statement doesn't perform any network requests until [execute] method call.\n *\n * [HttpStatement] is safe to execute multiple times.\n */\npublic class HttpStatement(\n    private val builder: HttpRequestBuilder,\n    private val client: HttpClient\n) {\n    init {\n        checkCapabilities()\n    }\n\n    /**\n     * Executes this statement and call the [block] with the streaming [response].\n     *\n     * The [response] argument holds a network connection until the [block] isn't completed. You can read the body\n     * on-demand or at once with [receive<T>()] method.\n     *\n     * After [block] finishes, [response] will be completed body will be discarded or released depends on the engine configuration.\n     *\n     * Please note: the [response] instance will be canceled and shouldn't be passed outside of [block].\n     */\n    public suspend fun <T> execute(block: suspend (response: HttpResponse) -> T): T {\n        val response: HttpResponse = executeUnsafe()\n\n        try {\n            return block(response)\n        } finally {\n            response.cleanup()\n        }\n    }\n\n    /**\n     * Executes this statement and download the response.\n     * After the method finishes, the client downloads the response body in memory and release the connection.\n     *\n     * To receive exact type you consider using [receive<T>()] method.\n     */\n    public suspend fun execute(): HttpResponse = execute {\n        val savedCall = it.call.save()\n        savedCall.response\n    }\n\n    /**\n     * Executes this statement and run [HttpClient.responsePipeline] with the response and expected type [T].\n     *\n     * Note if T is a streaming type, you should manage how to close it manually.\n     */\n    @OptIn(ExperimentalStdlibApi::class)\n    public suspend inline fun <reified T> receive(): T = when (T::class) {\n        HttpStatement::class -> this as T\n        HttpResponse::class -> execute() as T\n        else -> {\n            val response = executeUnsafe()\n            try {\n                response.receive<T>()\n            } finally {\n                response.complete()\n            }\n        }\n    }\n\n    /**\n     * Executes this statement and run the [block] with a [HttpClient.responsePipeline] execution result.\n     *\n     * Note that T can be a streamed type such as [ByteReadChannel].\n     */\n    public suspend inline fun <reified T, R> receive(crossinline block: suspend (response: T) -> R): R {\n        val response: HttpResponse = executeUnsafe()\n        try {\n            val result = response.receive<T>()\n            return block(result)\n        } finally {\n            response.cleanup()\n        }\n    }\n\n    /**\n     * Return [HttpResponse] with open streaming body.\n     */\n    @PublishedApi\n    internal suspend fun executeUnsafe(): HttpResponse {\n        val builder = HttpRequestBuilder().takeFromWithExecutionContext(builder)\n        @Suppress(\"DEPRECATION_ERROR\")\n        val call = client.execute(builder)\n        return call.response\n    }\n\n    /**\n     * Complete [HttpResponse] and release resources.\n     */\n    @PublishedApi\n    internal suspend fun HttpResponse.cleanup() {\n        val job = coroutineContext[Job]!! as CompletableJob\n\n        job.apply {\n            complete()\n            try {\n                content.cancel()\n            } catch (_: Throwable) {\n            }\n            join()\n        }\n    }\n\n    /**\n     * Check that all request configuration related to client capabilities have correspondent features installed.\n     */\n    private fun checkCapabilities() {\n        builder.attributes.getOrNull(ENGINE_CAPABILITIES_KEY)?.keys\n            ?.filterIsInstance<HttpClientFeature<*, *>>()\n            ?.forEach {\n                requireNotNull(client.feature(it)) {\n                    \"Consider installing $it feature because the request requires it to be installed\"\n                }\n            }\n    }\n\n    override fun toString(): String = \"HttpStatement[${builder.url.buildString()}]\"\n}\n\n@Deprecated(\n    \"[HttpStatement] isn't closeable.\",\n    level = DeprecationLevel.ERROR,\n    replaceWith = ReplaceWith(\"this.execute<T>(block)\")\n)\n@Suppress(\"unused\", \"KDocMissingDocumentation\", \"UNUSED_PARAMETER\")\npublic fun <T> HttpStatement.use(block: suspend (response: HttpResponse) -> T) {\n}\n\n@Deprecated(\n    \"Unbound [HttpResponse] is deprecated. Consider using [execute()] instead.\",\n    level = DeprecationLevel.ERROR,\n    replaceWith = ReplaceWith(\"this.execute()\")\n)\n@Suppress(\"KDocMissingDocumentation\", \"unused\")\npublic val HttpStatement.response: HttpResponse\n    get() = error(\"Unbound [HttpClientCall] is deprecated. Consider using [HttpResponse] instead.\")\n\n/**\n * Read the [HttpResponse.content] as a String. You can pass an optional [charset]\n * to specify a charset in the case no one is specified as part of the Content-Type response.\n * If no charset specified either as parameter or as part of the response,\n * [io.ktor.client.features.HttpPlainText] settings will be used.\n *\n * Note that [fallbackCharset] parameter will be ignored if the response already has a charset.\n *      So it just acts as a fallback, honoring the server preference.\n */\npublic suspend fun HttpResponse.readText(fallbackCharset: Charset? = null): String {\n    val originCharset = charset() ?: fallbackCharset ?: Charsets.UTF_8\n    val decoder = originCharset.newDecoder()\n    val input = receive<Input>()\n\n    return decoder.decode(input)\n}\n","import io.ktor.client.*\nimport io.ktor.client.request.*\nimport kotlinx.browser.document\nimport kotlinx.browser.window\nimport kotlinx.coroutines.await\nimport org.w3c.fetch.CORS\nimport org.w3c.fetch.Headers\nimport org.w3c.fetch.RequestInit\nimport org.w3c.fetch.RequestMode\n\n//@JsName(\"CryptoJS\")\n//external fun CryptoJS()\n\nval cryptJs = \"https://cdnjs.cloudflare.com/ajax/libs/crypto-js/3.1.9-1/crypto-js.min.js\"\n\nsuspend fun main() {\n    window.alert(\"start 3\")\n\n    val client = HttpClient()\n    val r = client.get<String>(cryptJs)\n\n    window.alert(r)\n\n\n//    document.onload = {\n//        window.alert(\"onload ${document.body?.outerHTML }\")\n//    }\n//    window.alert(document.body?.outerHTML ?: \"nobody\")\n}\n\nsuspend fun load(url: String) = window.fetch(\n    url,\n    RequestInit(\n        //headers = Headers().apply { set(\"Access-Control-Allow-Origin\", url) },\n        mode = RequestMode.CORS,\n    ),\n).await().text().await()\n\n//fun function(jscode: String) = js(\"window.Function(jscode)\")\n//fun requireJsModule(module: String) = js(\"require(module)\")\n\nfun loadingLib(path: String) = document.createElement(\"script\").apply {\n    setAttribute(\"src\", path)\n    setAttribute(\"type\", \"javascript\")\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.request\n\nimport io.ktor.client.*\nimport io.ktor.client.call.*\nimport io.ktor.client.statement.*\nimport io.ktor.client.utils.*\nimport io.ktor.http.*\n\n/**\n * Executes a [HttpClient] request, with the information from the [builder]\n * and tries to receive a specific type [T], if fails, an exception is thrown.\n */\npublic suspend inline fun <reified T> HttpClient.request(\n    builder: HttpRequestBuilder = HttpRequestBuilder()\n): T = HttpStatement(builder, this).receive()\n\n/**\n * Executes a [HttpClient] request, with the information configured in [builder] block\n * and tries to receive a specific type [T], if fails, an exception is thrown.\n */\npublic suspend inline fun <reified T> HttpClient.request(block: HttpRequestBuilder.() -> Unit): T =\n    request(HttpRequestBuilder().apply(block))\n\n/**\n * Executes a [HttpClient] request, with the [urlString] and the information configured in builder [block]\n * and tries to receive a specific type [T], if fails, an exception is thrown.\n */\npublic suspend inline fun <reified T> HttpClient.request(\n    urlString: String,\n    block: HttpRequestBuilder.() -> Unit = {}\n): T = request(\n    HttpRequestBuilder().apply {\n        url(urlString)\n        block()\n    }\n)\n\n/**\n * Executes a [HttpClient] request, with the [url] and the information configured in builder [block]\n * and tries to receive a specific type [T], if fails, an exception is thrown.\n */\npublic suspend inline fun <reified T> HttpClient.request(\n    url: Url,\n    block: HttpRequestBuilder.() -> Unit = {}\n): T = request(\n    HttpRequestBuilder().apply {\n        url(url)\n        block()\n    }\n)\n\n/**\n * Executes a [HttpClient] GET request, with the information from the [builder]\n * and tries to receive a specific type [T], if fails, an exception is thrown.\n */\npublic suspend inline fun <reified T> HttpClient.get(builder: HttpRequestBuilder): T {\n    builder.method = HttpMethod.Get\n    return request(builder)\n}\n\n/**\n * Executes a [HttpClient] POST request, with the information from the [builder]\n * and tries to receive a specific type [T], if fails, an exception is thrown.\n */\npublic suspend inline fun <reified T> HttpClient.post(builder: HttpRequestBuilder): T {\n    builder.method = HttpMethod.Post\n    return request(builder)\n}\n\n/**\n * Executes a [HttpClient] PUT request, with the information from the [builder]\n * and tries to receive a specific type [T], if fails, an exception is thrown.\n */\npublic suspend inline fun <reified T> HttpClient.put(builder: HttpRequestBuilder): T {\n    builder.method = HttpMethod.Put\n    return request(builder)\n}\n\n/**\n * Executes a [HttpClient] DELETE request, with the information from the [builder]\n * and tries to receive a specific type [T], if fails, an exception is thrown.\n */\npublic suspend inline fun <reified T> HttpClient.delete(builder: HttpRequestBuilder): T {\n    builder.method = HttpMethod.Delete\n    return request(builder)\n}\n\n/**\n * Executes a [HttpClient] OPTIONS request, with the information from the [builder]\n * and tries to receive a specific type [T], if fails, an exception is thrown.\n */\npublic suspend inline fun <reified T> HttpClient.options(builder: HttpRequestBuilder): T {\n    builder.method = HttpMethod.Options\n    return request(builder)\n}\n\n/**\n * Executes a [HttpClient] PATCH request, with the information from the [builder]\n * and tries to receive a specific type [T], if fails, an exception is thrown.\n */\npublic suspend inline fun <reified T> HttpClient.patch(builder: HttpRequestBuilder): T {\n    builder.method = HttpMethod.Patch\n    return request(builder)\n}\n\n/**\n * Executes a [HttpClient] HEAD request, with the information from the [builder]\n * and tries to receive a specific type [T], if fails, an exception is thrown.\n */\npublic suspend inline fun <reified T> HttpClient.head(builder: HttpRequestBuilder): T {\n    builder.method = HttpMethod.Head\n    return request(builder)\n}\n\n/**\n * Executes a [HttpClient] GET request, with the specified [scheme], [host], [port], [path] and [body].\n * And allows to further configure the request, using a [block] receiving an [HttpRequestBuilder].\n *\n * Tries to receive a specific type [T], if fails, an exception is thrown.\n */\npublic suspend inline fun <reified T> HttpClient.get(\n    scheme: String = \"http\",\n    host: String = \"localhost\",\n    port: Int = DEFAULT_PORT,\n    path: String = \"/\",\n    body: Any = EmptyContent,\n    block: HttpRequestBuilder.() -> Unit = {}\n): T = request {\n    url(scheme, host, port, path)\n    method = HttpMethod.Get\n    this.body = body\n    apply(block)\n}\n\n/**\n * Executes a [HttpClient] POST request, with the specified [scheme], [host], [port], [path] and [body].\n * And allows to further configure the request, using a [block] receiving an [HttpRequestBuilder].\n *\n * Tries to receive a specific type [T], if fails, an exception is thrown.\n */\npublic suspend inline fun <reified T> HttpClient.post(\n    scheme: String = \"http\",\n    host: String = \"localhost\",\n    port: Int = DEFAULT_PORT,\n    path: String = \"/\",\n    body: Any = EmptyContent,\n    block: HttpRequestBuilder.() -> Unit = {}\n): T = request {\n    url(scheme, host, port, path)\n    method = HttpMethod.Post\n    this.body = body\n    apply(block)\n}\n\n/**\n * Executes a [HttpClient] PUT request, with the specified [scheme], [host], [port], [path] and [body].\n * And allows to further configure the request, using a [block] receiving an [HttpRequestBuilder].\n *\n * Tries to receive a specific type [T], if fails, an exception is thrown.\n */\npublic suspend inline fun <reified T> HttpClient.put(\n    scheme: String = \"http\",\n    host: String = \"localhost\",\n    port: Int = DEFAULT_PORT,\n    path: String = \"/\",\n    body: Any = EmptyContent,\n    block: HttpRequestBuilder.() -> Unit = {}\n): T = request {\n    url(scheme, host, port, path)\n    method = HttpMethod.Put\n    this.body = body\n    apply(block)\n}\n\n/**\n * Executes a [HttpClient] DELETE request, with the specified [scheme], [host], [port], [path] and [body].\n * And allows to further configure the request, using a [block] receiving an [HttpRequestBuilder].\n *\n * Tries to receive a specific type [T], if fails, an exception is thrown.\n */\npublic suspend inline fun <reified T> HttpClient.delete(\n    scheme: String = \"http\",\n    host: String = \"localhost\",\n    port: Int = DEFAULT_PORT,\n    path: String = \"/\",\n    body: Any = EmptyContent,\n    block: HttpRequestBuilder.() -> Unit = {}\n): T = request {\n    url(scheme, host, port, path)\n    method = HttpMethod.Delete\n    this.body = body\n    apply(block)\n}\n\n/**\n * Executes a [HttpClient] PATCH request, with the specified [scheme], [host], [port], [path] and [body].\n * And allows to further configure the request, using a [block] receiving an [HttpRequestBuilder].\n *\n * Tries to receive a specific type [T], if fails, an exception is thrown.\n */\npublic suspend inline fun <reified T> HttpClient.patch(\n    scheme: String = \"http\",\n    host: String = \"localhost\",\n    port: Int = DEFAULT_PORT,\n    path: String = \"/\",\n    body: Any = EmptyContent,\n    block: HttpRequestBuilder.() -> Unit = {}\n): T = request {\n    url(scheme, host, port, path)\n    method = HttpMethod.Patch\n    this.body = body\n    apply(block)\n}\n\n/**\n * Executes a [HttpClient] HEAD request, with the specified [scheme], [host], [port], [path] and [body].\n * And allows to further configure the request, using a [block] receiving an [HttpRequestBuilder].\n *\n * Tries to receive a specific type [T], if fails, an exception is thrown.\n */\npublic suspend inline fun <reified T> HttpClient.head(\n    scheme: String = \"http\",\n    host: String = \"localhost\",\n    port: Int = DEFAULT_PORT,\n    path: String = \"/\",\n    body: Any = EmptyContent,\n    block: HttpRequestBuilder.() -> Unit = {}\n): T = request {\n    url(scheme, host, port, path)\n    method = HttpMethod.Head\n    this.body = body\n    apply(block)\n}\n\n/**\n * Executes a [HttpClient] OPTIONS request, with the specified [scheme], [host], [port], [path] and [body].\n * And allows to further configure the request, using a [block] receiving an [HttpRequestBuilder].\n *\n * Tries to receive a specific type [T], if fails, an exception is thrown.\n */\npublic suspend inline fun <reified T> HttpClient.options(\n    scheme: String = \"http\",\n    host: String = \"localhost\",\n    port: Int = DEFAULT_PORT,\n    path: String = \"/\",\n    body: Any = EmptyContent,\n    block: HttpRequestBuilder.() -> Unit = {}\n): T = request {\n    url(scheme, host, port, path)\n    method = HttpMethod.Options\n    this.body = body\n    apply(block)\n}\n\n/**\n * Creates a [HttpRequestBuilder] and configures it with a [block] of code.\n */\npublic fun request(block: HttpRequestBuilder.() -> Unit): HttpRequestBuilder = HttpRequestBuilder().apply(block)\n\n/**\n * Executes a [HttpClient] GET request, with the specified [url] as URL and\n * an optional [block] receiving an [HttpRequestBuilder] for further configuring the request.\n *\n * Tries to receive a specific type [T], if fails, an exception is thrown.\n */\npublic suspend inline fun <reified T> HttpClient.get(\n    urlString: String,\n    block: HttpRequestBuilder.() -> Unit = {}\n): T = get {\n    url.takeFrom(urlString)\n    block()\n}\n\n/**\n * Executes a [HttpClient] POST request, with the specified [url] as URL and\n * an optional [block] receiving an [HttpRequestBuilder] for further configuring the request.\n *\n * Tries to receive a specific type [T], if fails, an exception is thrown.\n */\npublic suspend inline fun <reified T> HttpClient.post(\n    urlString: String,\n    block: HttpRequestBuilder.() -> Unit = {}\n): T = post {\n    url.takeFrom(urlString)\n    block()\n}\n\n/**\n * Executes a [HttpClient] PUT request, with the specified [url] as URL and\n * an optional [block] receiving an [HttpRequestBuilder] for further configuring the request.\n *\n * Tries to receive a specific type [T], if fails, an exception is thrown.\n */\npublic suspend inline fun <reified T> HttpClient.put(\n    urlString: String,\n    block: HttpRequestBuilder.() -> Unit = {}\n): T = put {\n    url.takeFrom(urlString)\n    block()\n}\n\n/**\n * Executes a [HttpClient] DELETE request, with the specified [url] as URL and\n * an optional [block] receiving an [HttpRequestBuilder] for further configuring the request.\n *\n * Tries to receive a specific type [T], if fails, an exception is thrown.\n */\npublic suspend inline fun <reified T> HttpClient.delete(\n    urlString: String,\n    block: HttpRequestBuilder.() -> Unit = {}\n): T = delete {\n    url.takeFrom(urlString)\n    block()\n}\n\n/**\n * Executes a [HttpClient] OPTIONS request, with the specified [url] as URL and\n * an optional [block] receiving an [HttpRequestBuilder] for further configuring the request.\n *\n * Tries to receive a specific type [T], if fails, an exception is thrown.\n */\npublic suspend inline fun <reified T> HttpClient.options(\n    urlString: String,\n    block: HttpRequestBuilder.() -> Unit = {}\n): T = options {\n    url.takeFrom(urlString)\n    block()\n}\n\n/**\n * Executes a [HttpClient] PATCH request, with the specified [url] as URL and\n * an optional [block] receiving an [HttpRequestBuilder] for further configuring the request.\n *\n * Tries to receive a specific type [T], if fails, an exception is thrown.\n */\npublic suspend inline fun <reified T> HttpClient.patch(\n    urlString: String,\n    block: HttpRequestBuilder.() -> Unit = {}\n): T = patch {\n    url.takeFrom(urlString)\n    block()\n}\n\n/**\n * Executes a [HttpClient] HEAD request, with the specified [url] as URL and\n * an optional [block] receiving an [HttpRequestBuilder] for further configuring the request.\n *\n * Tries to receive a specific type [T], if fails, an exception is thrown.\n */\npublic suspend inline fun <reified T> HttpClient.head(\n    urlString: String,\n    block: HttpRequestBuilder.() -> Unit = {}\n): T = head {\n    url.takeFrom(urlString)\n    block()\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        define('kotlin', ['exports'], factory);\n    }\n    else if (typeof exports === 'object') {\n        factory(module.exports);\n    }\n    else {\n        root.kotlin = {};\n        factory(root.kotlin);\n    }\n}(this, function (Kotlin) {\n    var _ = Kotlin;\n\n    insertContent();\n}));\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.isBooleanArray = function (a) {\n    return (Array.isArray(a) || a instanceof Int8Array) && a.$type$ === \"BooleanArray\"\n};\n\nKotlin.isByteArray = function (a) {\n    return a instanceof Int8Array && a.$type$ !== \"BooleanArray\"\n};\n\nKotlin.isShortArray = function (a) {\n    return a instanceof Int16Array\n};\n\nKotlin.isCharArray = function (a) {\n    return a instanceof Uint16Array && a.$type$ === \"CharArray\"\n};\n\nKotlin.isIntArray = function (a) {\n    return a instanceof Int32Array\n};\n\nKotlin.isFloatArray = function (a) {\n    return a instanceof Float32Array\n};\n\nKotlin.isDoubleArray = function (a) {\n    return a instanceof Float64Array\n};\n\nKotlin.isLongArray = function (a) {\n    return Array.isArray(a) && a.$type$ === \"LongArray\"\n};\n\nKotlin.isArray = function (a) {\n    return Array.isArray(a) && !a.$type$;\n};\n\nKotlin.isArrayish = function (a) {\n    return Array.isArray(a) || ArrayBuffer.isView(a)\n};\n\nKotlin.arrayToString = function (a) {\n    if (a === null) return \"null\"\n    var toString = Kotlin.isCharArray(a) ? String.fromCharCode : Kotlin.toString;\n    return \"[\" + Array.prototype.map.call(a, function(e) { return toString(e); }).join(\", \") + \"]\";\n};\n\nKotlin.arrayDeepToString = function (arr) {\n    return Kotlin.kotlin.collections.contentDeepToStringImpl(arr);\n};\n\nKotlin.arrayEquals = function (a, b) {\n    if (a === b) {\n        return true;\n    }\n    if (a === null || b === null || !Kotlin.isArrayish(b) || a.length !== b.length) {\n        return false;\n    }\n\n    for (var i = 0, n = a.length; i < n; i++) {\n        if (!Kotlin.equals(a[i], b[i])) {\n            return false;\n        }\n    }\n    return true;\n};\n\nKotlin.arrayDeepEquals = function (a, b) {\n    return Kotlin.kotlin.collections.contentDeepEqualsImpl(a, b);\n};\n\nKotlin.arrayHashCode = function (arr) {\n    if (arr === null) return 0\n    var result = 1;\n    for (var i = 0, n = arr.length; i < n; i++) {\n        result = ((31 * result | 0) + Kotlin.hashCode(arr[i])) | 0;\n    }\n    return result;\n};\n\nKotlin.arrayDeepHashCode = function (arr) {\n    return Kotlin.kotlin.collections.contentDeepHashCodeImpl(arr);\n};\n\nKotlin.primitiveArraySort = function (array) {\n    array.sort(Kotlin.doubleCompareTo)\n};\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.getCallableRef = function(name, f) {\n    f.callableName = name;\n    return f;\n};\n\nKotlin.getPropertyCallableRef = function(name, paramCount, getter, setter) {\n    getter.get = getter;\n    getter.set = setter;\n    getter.callableName = name;\n    return getPropertyRefClass(getter, setter, propertyRefClassMetadataCache[paramCount]);\n};\n\nfunction getPropertyRefClass(obj, setter, cache) {\n    obj.$metadata$ = getPropertyRefMetadata(typeof setter === \"function\" ? cache.mutable : cache.immutable);\n    obj.constructor = obj;\n    return obj;\n}\n\nvar propertyRefClassMetadataCache = [\n    {\n        mutable: { value: null, implementedInterface: function () {\n            return Kotlin.kotlin.reflect.KMutableProperty0 }\n        },\n        immutable: { value: null, implementedInterface: function () {\n            return Kotlin.kotlin.reflect.KProperty0 }\n        }\n    },\n    {\n        mutable: { value: null, implementedInterface: function () {\n            return Kotlin.kotlin.reflect.KMutableProperty1 }\n        },\n        immutable: { value: null, implementedInterface: function () {\n            return Kotlin.kotlin.reflect.KProperty1 }\n        }\n    }\n];\n\nfunction getPropertyRefMetadata(cache) {\n    if (cache.value === null) {\n        cache.value = {\n            interfaces: [cache.implementedInterface()],\n            baseClass: null,\n            functions: {},\n            properties: {},\n            types: {},\n            staticMembers: {}\n        };\n    }\n    return cache.value;\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.toShort = function (a) {\n    return (a & 0xFFFF) << 16 >> 16;\n};\n\nKotlin.toByte = function (a) {\n    return (a & 0xFF) << 24 >> 24;\n};\n\nKotlin.toChar = function (a) {\n    return a & 0xFFFF;\n};\n\nKotlin.numberToLong = function (a) {\n    return a instanceof Kotlin.Long ? a : Kotlin.Long.fromNumber(a);\n};\n\nKotlin.numberToInt = function (a) {\n    return a instanceof Kotlin.Long ? a.toInt() : Kotlin.doubleToInt(a);\n};\n\nKotlin.numberToShort = function (a) {\n    return Kotlin.toShort(Kotlin.numberToInt(a));\n};\n\nKotlin.numberToByte = function (a) {\n    return Kotlin.toByte(Kotlin.numberToInt(a));\n};\n\nKotlin.numberToDouble = function (a) {\n    return +a;\n};\n\nKotlin.numberToChar = function (a) {\n    return Kotlin.toChar(Kotlin.numberToInt(a));\n};\n\nKotlin.doubleToInt = function(a) {\n    if (a > 2147483647) return 2147483647;\n    if (a < -2147483648) return -2147483648;\n    return a | 0;\n};\n\nKotlin.toBoxedChar = function (a) {\n    if (a == null) return a;\n    if (a instanceof Kotlin.BoxedChar) return a;\n    return new Kotlin.BoxedChar(a);\n};\n\nKotlin.unboxChar = function(a) {\n    if (a == null) return a;\n    return Kotlin.toChar(a);\n};\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.equals = function (obj1, obj2) {\n    if (obj1 == null) {\n        return obj2 == null;\n    }\n\n    if (obj2 == null) {\n        return false;\n    }\n\n    if (obj1 !== obj1) {\n        return obj2 !== obj2;\n    }\n\n    if (typeof obj1 === \"object\" && typeof obj1.equals === \"function\") {\n        return obj1.equals(obj2);\n    }\n\n    if (typeof obj1 === \"number\" && typeof obj2 === \"number\") {\n        return obj1 === obj2 && (obj1 !== 0 || 1 / obj1 === 1 / obj2)\n    }\n\n    return obj1 === obj2;\n};\n\nKotlin.hashCode = function (obj) {\n    if (obj == null) {\n        return 0;\n    }\n    var objType = typeof obj;\n    if (\"object\" === objType) {\n        return \"function\" === typeof obj.hashCode ? obj.hashCode() : getObjectHashCode(obj);\n    }\n    if (\"function\" === objType) {\n        return getObjectHashCode(obj);\n    }\n    if (\"number\" === objType) {\n        return Kotlin.numberHashCode(obj);\n    }\n    if (\"boolean\" === objType) {\n        return Number(obj)\n    }\n\n    var str = String(obj);\n    return getStringHashCode(str);\n};\n\n\nKotlin.toString = function (o) {\n    if (o == null) {\n        return \"null\";\n    }\n    else if (Kotlin.isArrayish(o)) {\n        return \"[...]\";\n    }\n    else {\n        return o.toString();\n    }\n};\n\n/** @const */\nvar POW_2_32 = 4294967296;\n// TODO: consider switching to Symbol type once we are on ES6.\n/** @const */\nvar OBJECT_HASH_CODE_PROPERTY_NAME = \"kotlinHashCodeValue$\";\n\nfunction getObjectHashCode(obj) {\n    if (!(OBJECT_HASH_CODE_PROPERTY_NAME in obj)) {\n        var hash = (Math.random() * POW_2_32) | 0; // Make 32-bit singed integer.\n        Object.defineProperty(obj, OBJECT_HASH_CODE_PROPERTY_NAME, { value:  hash, enumerable: false });\n    }\n    return obj[OBJECT_HASH_CODE_PROPERTY_NAME];\n}\n\nfunction getStringHashCode(str) {\n    var hash = 0;\n    for (var i = 0; i < str.length; i++) {\n        var code  = str.charCodeAt(i);\n        hash  = (hash * 31 + code) | 0; // Keep it 32-bit.\n    }\n    return hash;\n}\n\nKotlin.identityHashCode = getObjectHashCode;\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.compareTo = function (a, b) {\n    var typeA = typeof a;\n    if (typeA === \"number\") {\n        if (typeof b === \"number\") {\n            return Kotlin.doubleCompareTo(a, b);\n        }\n        return Kotlin.primitiveCompareTo(a, b);\n    }\n    if (typeA === \"string\" || typeA === \"boolean\") {\n        return Kotlin.primitiveCompareTo(a, b);\n    }\n    return a.compareTo_11rb$(b);\n};\n\nKotlin.primitiveCompareTo = function (a, b) {\n    return a < b ? -1 : a > b ? 1 : 0;\n};\n\nKotlin.doubleCompareTo = function (a, b) {\n    if (a < b) return -1;\n    if (a > b) return 1;\n\n    if (a === b) {\n        if (a !== 0) return 0;\n\n        var ia = 1 / a;\n        return ia === 1 / b ? 0 : (ia < 0 ? -1 : 1);\n    }\n\n    return a !== a ? (b !== b ? 0 : 1) : -1\n};\n\nKotlin.charInc = function (value) {\n    return Kotlin.toChar(value+1);\n};\n\nKotlin.charDec = function (value) {\n    return Kotlin.toChar(value-1);\n};\n\nKotlin.imul = Math.imul || imul;\n\nKotlin.imulEmulated = imul;\n\nfunction imul(a, b) {\n    return ((a & 0xffff0000) * (b & 0xffff) + (a & 0xffff) * (b | 0)) | 0;\n}\n\n(function() {\n    var buf = new ArrayBuffer(8);\n    var bufFloat64 = new Float64Array(buf);\n    var bufFloat32 = new Float32Array(buf);\n    var bufInt32 = new Int32Array(buf);\n    var lowIndex = 0;\n    var highIndex = 1;\n\n    bufFloat64[0] = -1; // bff00000_00000000\n    if (bufInt32[lowIndex] !== 0) {\n        lowIndex = 1;\n        highIndex = 0;\n    }\n\n    Kotlin.doubleToBits = function(value) {\n        return Kotlin.doubleToRawBits(isNaN(value) ? NaN : value);\n    };\n\n    Kotlin.doubleToRawBits = function(value) {\n        bufFloat64[0] = value;\n        return Kotlin.Long.fromBits(bufInt32[lowIndex], bufInt32[highIndex]);\n    };\n\n    Kotlin.doubleFromBits = function(value) {\n        bufInt32[lowIndex] = value.low_;\n        bufInt32[highIndex] = value.high_;\n        return bufFloat64[0];\n    };\n\n    Kotlin.floatToBits = function(value) {\n        return Kotlin.floatToRawBits(isNaN(value) ? NaN : value);\n    };\n\n    Kotlin.floatToRawBits = function(value) {\n        bufFloat32[0] = value;\n        return bufInt32[0];\n    };\n\n    Kotlin.floatFromBits = function(value) {\n        bufInt32[0] = value;\n        return bufFloat32[0];\n    };\n\n    // returns zero value for number with positive sign bit and non-zero value for number with negative sign bit.\n    Kotlin.doubleSignBit = function(value) {\n        bufFloat64[0] = value;\n        return bufInt32[highIndex] & 0x80000000;\n    };\n\n    Kotlin.numberHashCode = function(obj) {\n        if ((obj | 0) === obj) {\n            return obj | 0;\n        }\n        else {\n            bufFloat64[0] = obj;\n            return (bufInt32[highIndex] * 31 | 0) + bufInt32[lowIndex] | 0;\n        }\n    }\n})();\n\nKotlin.ensureNotNull = function(x) {\n    return x != null ? x : Kotlin.throwNPE();\n};\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nif (typeof String.prototype.startsWith === \"undefined\") {\n    Object.defineProperty(String.prototype, \"startsWith\", {\n        value: function (searchString, position) {\n            position = position || 0;\n            return this.lastIndexOf(searchString, position) === position;\n        }\n    });\n}\nif (typeof String.prototype.endsWith === \"undefined\") {\n    Object.defineProperty(String.prototype, \"endsWith\", {\n        value: function (searchString, position) {\n            var subjectString = this.toString();\n            if (position === undefined || position > subjectString.length) {\n                position = subjectString.length;\n            }\n            position -= searchString.length;\n            var lastIndex = subjectString.indexOf(searchString, position);\n            return lastIndex !== -1 && lastIndex === position;\n        }\n    });\n}\n// ES6 Math polyfills\nif (typeof Math.sign === \"undefined\") {\n    Math.sign = function(x) {\n        x = +x; // convert to a number\n        if (x === 0 || isNaN(x)) {\n            return Number(x);\n        }\n        return x > 0 ? 1 : -1;\n    };\n}\nif (typeof Math.trunc === \"undefined\") {\n    Math.trunc = function(x) {\n        if (isNaN(x)) {\n            return NaN;\n        }\n        if (x > 0) {\n            return Math.floor(x);\n        }\n        return Math.ceil(x);\n    };\n}\n\n(function() {\n    var epsilon = 2.220446049250313E-16;\n    var taylor_2_bound = Math.sqrt(epsilon);\n    var taylor_n_bound = Math.sqrt(taylor_2_bound);\n    var upper_taylor_2_bound = 1/taylor_2_bound;\n    var upper_taylor_n_bound = 1/taylor_n_bound;\n\n    if (typeof Math.sinh === \"undefined\") {\n        Math.sinh = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var result = x;\n                if (Math.abs(x) > taylor_2_bound) {\n                    result += (x * x * x) / 6;\n                }\n                return result;\n            } else {\n                var y = Math.exp(x);\n                var y1 = 1 / y;\n                if (!isFinite(y)) return Math.exp(x - Math.LN2);\n                if (!isFinite(y1)) return -Math.exp(-x - Math.LN2);\n                return (y - y1) / 2;\n            }\n        };\n    }\n    if (typeof Math.cosh === \"undefined\") {\n        Math.cosh = function(x) {\n            var y = Math.exp(x);\n            var y1 = 1 / y;\n            if (!isFinite(y) || !isFinite(y1)) return Math.exp(Math.abs(x) - Math.LN2);\n            return (y + y1) / 2;\n        };\n    }\n\n    if (typeof Math.tanh === \"undefined\") {\n        Math.tanh = function(x){\n            if (Math.abs(x) < taylor_n_bound) {\n                var result = x;\n                if (Math.abs(x) > taylor_2_bound) {\n                    result -= (x * x * x) / 3;\n                }\n                return result;\n            }\n            else {\n                var a = Math.exp(+x), b = Math.exp(-x);\n                return a === Infinity ? 1 : b === Infinity ? -1 : (a - b) / (a + b);\n            }\n        };\n    }\n\n    // Inverse hyperbolic function implementations derived from boost special math functions,\n    // Copyright Eric Ford & Hubert Holin 2001.\n\n    if (typeof Math.asinh === \"undefined\") {\n        var asinh = function(x) {\n            if (x >= +taylor_n_bound)\n            {\n                if (x > upper_taylor_n_bound)\n                {\n                    if (x > upper_taylor_2_bound)\n                    {\n                        // approximation by laurent series in 1/x at 0+ order from -1 to 0\n                        return Math.log(x) + Math.LN2;\n                    }\n                    else\n                    {\n                        // approximation by laurent series in 1/x at 0+ order from -1 to 1\n                        return Math.log(x * 2 + (1 / (x * 2)));\n                    }\n                }\n                else\n                {\n                    return Math.log(x + Math.sqrt(x * x + 1));\n                }\n            }\n            else if (x <= -taylor_n_bound)\n            {\n                return -asinh(-x);\n            }\n            else\n            {\n                // approximation by taylor series in x at 0 up to order 2\n                var result = x;\n                if (Math.abs(x) >= taylor_2_bound)\n                {\n                    var x3 = x * x * x;\n                    // approximation by taylor series in x at 0 up to order 4\n                    result -= x3 / 6;\n                }\n                return result;\n            }\n        };\n        Math.asinh = asinh;\n    }\n    if (typeof Math.acosh === \"undefined\") {\n        Math.acosh = function(x) {\n            if (x < 1)\n            {\n                return NaN;\n            }\n            else if (x - 1 >= taylor_n_bound)\n            {\n                if (x > upper_taylor_2_bound)\n                {\n                    // approximation by laurent series in 1/x at 0+ order from -1 to 0\n                    return Math.log(x) + Math.LN2;\n                }\n                else\n                {\n                    return Math.log(x + Math.sqrt(x * x - 1));\n                }\n            }\n            else\n            {\n                var y = Math.sqrt(x - 1);\n                // approximation by taylor series in y at 0 up to order 2\n                var result = y;\n                if (y >= taylor_2_bound)\n                {\n                    var y3 = y * y * y;\n                    // approximation by taylor series in y at 0 up to order 4\n                    result -= y3 / 12;\n                }\n\n                return Math.sqrt(2) * result;\n            }\n        };\n    }\n    if (typeof Math.atanh === \"undefined\") {\n        Math.atanh = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var result = x;\n                if (Math.abs(x) > taylor_2_bound) {\n                    result += (x * x * x) / 3;\n                }\n                return result;\n            }\n            return Math.log((1 + x) / (1 - x)) / 2;\n        };\n    }\n    if (typeof Math.log1p === \"undefined\") {\n        Math.log1p = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var x2 = x * x;\n                var x3 = x2 * x;\n                var x4 = x3 * x;\n                // approximation by taylor series in x at 0 up to order 4\n                return (-x4 / 4 + x3 / 3 - x2 / 2 + x);\n            }\n            return Math.log(x + 1);\n        };\n    }\n    if (typeof Math.expm1 === \"undefined\") {\n        Math.expm1 = function(x) {\n            if (Math.abs(x) < taylor_n_bound) {\n                var x2 = x * x;\n                var x3 = x2 * x;\n                var x4 = x3 * x;\n                // approximation by taylor series in x at 0 up to order 4\n                return (x4 / 24 + x3 / 6 + x2 / 2 + x);\n            }\n            return Math.exp(x) - 1;\n        };\n    }\n})();\nif (typeof Math.hypot === \"undefined\") {\n    Math.hypot = function() {\n        var y = 0;\n        var length = arguments.length;\n\n        for (var i = 0; i < length; i++) {\n            if (arguments[i] === Infinity || arguments[i] === -Infinity) {\n                return Infinity;\n            }\n            y += arguments[i] * arguments[i];\n        }\n        return Math.sqrt(y);\n    };\n}\nif (typeof Math.log10 === \"undefined\") {\n    Math.log10 = function(x) {\n        return Math.log(x) * Math.LOG10E;\n    };\n}\nif (typeof Math.log2 === \"undefined\") {\n    Math.log2 = function(x) {\n        return Math.log(x) * Math.LOG2E;\n    };\n}\nif (typeof Math.clz32 === \"undefined\") {\n    Math.clz32 = (function(log, LN2) {\n        return function(x) {\n            var asUint = x >>> 0;\n            if (asUint === 0) {\n                return 32;\n            }\n            return 31 - (log(asUint) / LN2 | 0) | 0; // the \"| 0\" acts like math.floor\n        };\n    })(Math.log, Math.LN2);\n}\n\n// For HtmlUnit and PhantomJs\nif (typeof ArrayBuffer.isView === \"undefined\") {\n    ArrayBuffer.isView = function(a) {\n        return a != null && a.__proto__ != null && a.__proto__.__proto__ === Int8Array.prototype.__proto__;\n    };\n}\n\nif (typeof Array.prototype.fill === \"undefined\") {\n    // Polyfill from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/fill#Polyfill\n    Object.defineProperty(Array.prototype, 'fill', {\n        value: function (value) {\n\n            // Steps 1-2.\n            if (this == null) {\n                throw new TypeError('this is null or not defined');\n            }\n\n            var O = Object(this);\n\n            // Steps 3-5.\n            var len = O.length >>> 0;\n\n            // Steps 6-7.\n            var start = arguments[1];\n            var relativeStart = start >> 0;\n\n            // Step 8.\n            var k = relativeStart < 0 ?\n                    Math.max(len + relativeStart, 0) :\n                    Math.min(relativeStart, len);\n\n            // Steps 9-10.\n            var end = arguments[2];\n            var relativeEnd = end === undefined ?\n                              len : end >> 0;\n\n            // Step 11.\n            var finalValue = relativeEnd < 0 ?\n                             Math.max(len + relativeEnd, 0) :\n                             Math.min(relativeEnd, len);\n\n            // Step 12.\n            while (k < finalValue) {\n                O[k] = value;\n                k++;\n            }\n\n            // Step 13.\n            return O;\n        }\n    });\n}\n\n(function() {\n    function normalizeOffset(offset, length) {\n        if (offset < 0) return Math.max(0, offset + length);\n        return Math.min(offset, length);\n    }\n    function typedArraySlice(begin, end) {\n        if (typeof end === \"undefined\") {\n            end = this.length;\n        }\n        begin = normalizeOffset(begin || 0, this.length);\n        end = Math.max(begin, normalizeOffset(end, this.length));\n        return new this.constructor(this.subarray(begin, end));\n    }\n\n    var arrays = [Int8Array, Int16Array, Uint16Array, Int32Array, Float32Array, Float64Array];\n    for (var i = 0; i < arrays.length; ++i) {\n        var TypedArray = arrays[i];\n        if (typeof TypedArray.prototype.fill === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'fill', {\n                value: Array.prototype.fill\n            });\n        }\n        if (typeof TypedArray.prototype.slice === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'slice', {\n                value: typedArraySlice\n            });\n        }\n    }\n\n    // Patch apply to work with TypedArrays if needed.\n    try {\n        (function() {}).apply(null, new Int32Array(0))\n    } catch (e) {\n        var apply = Function.prototype.apply;\n        Object.defineProperty(Function.prototype, 'apply', {\n            value: function(self, array) {\n                return apply.call(this, self, [].slice.call(array));\n            }\n        });\n    }\n\n\n    // Patch map to work with TypedArrays if needed.\n    for (var i = 0; i < arrays.length; ++i) {\n        var TypedArray = arrays[i];\n        if (typeof TypedArray.prototype.map === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'map', {\n                value: function(callback, self) {\n                    return [].slice.call(this).map(callback, self);\n                }\n            });\n        }\n    }\n\n    // Patch sort to work with TypedArrays if needed.\n    // TODO: consider to remove following function and replace it with `Kotlin.doubleCompareTo` (see misc.js)\n    var totalOrderComparator = function (a, b) {\n        if (a < b) return -1;\n        if (a > b) return 1;\n\n        if (a === b) {\n            if (a !== 0) return 0;\n\n            var ia = 1 / a;\n            return ia === 1 / b ? 0 : (ia < 0 ? -1 : 1);\n        }\n\n        return a !== a ? (b !== b ? 0 : 1) : -1\n    };\n\n    for (var i = 0; i < arrays.length; ++i) {\n        var TypedArray = arrays[i];\n        if (typeof TypedArray.prototype.sort === \"undefined\") {\n            Object.defineProperty(TypedArray.prototype, 'sort', {\n                value: function(compareFunction) {\n                    return Array.prototype.sort.call(this, compareFunction || totalOrderComparator);\n                }\n            });\n        }\n    }\n})();\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/**\n * @param {string} id\n * @param {Object} declaration\n */\nKotlin.defineModule = function (id, declaration) {\n};\n\nKotlin.defineInlineFunction = function(tag, fun) {\n    return fun;\n};\n\nKotlin.wrapFunction = function(fun) {\n    var f = function() {\n        f = fun();\n        return f.apply(this, arguments);\n    };\n    return function() {\n        return f.apply(this, arguments);\n    };\n};\n\nKotlin.isTypeOf = function(type) {\n    return function (object) {\n        return typeof object === type;\n    }\n};\n\nKotlin.isInstanceOf = function (klass) {\n    return function (object) {\n        return Kotlin.isType(object, klass);\n    }\n};\n\nKotlin.orNull = function (fn) {\n    return function (object) {\n        return object == null || fn(object);\n    }\n};\n\nKotlin.andPredicate = function (a, b) {\n    return function (object) {\n        return a(object) && b(object);\n    }\n};\n\nKotlin.kotlinModuleMetadata = function (abiVersion, moduleName, data) {\n};\n\nKotlin.suspendCall = function(value) {\n    return value;\n};\n\nKotlin.coroutineResult = function(qualifier) {\n    throwMarkerError();\n};\n\nKotlin.coroutineController = function(qualifier) {\n    throwMarkerError();\n};\n\nKotlin.coroutineReceiver = function(qualifier) {\n    throwMarkerError();\n};\n\nKotlin.setCoroutineResult = function(value, qualifier) {\n    throwMarkerError();\n};\n\nKotlin.getReifiedTypeParameterKType = function(typeParameter) {\n    throwMarkerError();\n};\n\nfunction throwMarkerError() {\n    throw new Error(\n        \"This marker function should never been called. \" +\n        \"Looks like compiler did not eliminate it properly. \" +\n        \"Please, report an issue if you caught this exception.\");\n}\n\nKotlin.getFunctionById = function(id, defaultValue) {\n    return function() {\n        return defaultValue;\n    }\n};","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\nKotlin.Kind = {\n    CLASS: \"class\",\n    INTERFACE: \"interface\",\n    OBJECT: \"object\"\n};\n\nKotlin.callGetter = function (thisObject, klass, propertyName) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(klass, propertyName);\n    if (propertyDescriptor != null && propertyDescriptor.get != null) {\n        return propertyDescriptor.get.call(thisObject);\n    }\n\n    propertyDescriptor = Object.getOwnPropertyDescriptor(thisObject, propertyName);\n    if (propertyDescriptor != null && \"value\" in propertyDescriptor) {\n        return thisObject[propertyName];\n    }\n\n    return Kotlin.callGetter(thisObject, Object.getPrototypeOf(klass), propertyName);\n};\n\nKotlin.callSetter = function (thisObject, klass, propertyName, value) {\n    var propertyDescriptor = Object.getOwnPropertyDescriptor(klass, propertyName);\n    if (propertyDescriptor != null && propertyDescriptor.set != null) {\n        propertyDescriptor.set.call(thisObject, value);\n        return;\n    }\n\n    propertyDescriptor = Object.getOwnPropertyDescriptor(thisObject, propertyName);\n    if (propertyDescriptor != null && \"value\" in propertyDescriptor) {\n        thisObject[propertyName] = value;\n        return\n    }\n\n    Kotlin.callSetter(thisObject, Object.getPrototypeOf(klass), propertyName, value);\n};\n\nfunction isInheritanceFromInterface(ctor, iface) {\n    if (ctor === iface) return true;\n\n    var metadata = ctor.$metadata$;\n    if (metadata != null) {\n        var interfaces = metadata.interfaces;\n        for (var i = 0; i < interfaces.length; i++) {\n            if (isInheritanceFromInterface(interfaces[i], iface)) {\n                return true;\n            }\n        }\n    }\n\n    var superPrototype = ctor.prototype != null ? Object.getPrototypeOf(ctor.prototype) : null;\n    var superConstructor = superPrototype != null ? superPrototype.constructor : null;\n    return superConstructor != null && isInheritanceFromInterface(superConstructor, iface);\n}\n\n/**\n *\n * @param {*} object\n * @param {Function|Object} klass\n * @returns {Boolean}\n */\nKotlin.isType = function (object, klass) {\n    if (klass === Object) {\n        switch (typeof object) {\n            case \"string\":\n            case \"number\":\n            case \"boolean\":\n            case \"function\":\n                return true;\n            default:\n                return object instanceof Object;\n        }\n    }\n\n    if (object == null || klass == null || (typeof object !== 'object' && typeof object !== 'function')) {\n        return false;\n    }\n\n    if (typeof klass === \"function\" && object instanceof klass) {\n        return true;\n    }\n\n    var proto = Object.getPrototypeOf(klass);\n    var constructor = proto != null ? proto.constructor : null;\n    if (constructor != null && \"$metadata$\" in constructor) {\n        var metadata = constructor.$metadata$;\n        if (metadata.kind === Kotlin.Kind.OBJECT) {\n            return object === klass;\n        }\n    }\n\n    var klassMetadata = klass.$metadata$;\n\n    // In WebKit (JavaScriptCore) for some interfaces from DOM typeof returns \"object\", nevertheless they can be used in RHS of instanceof\n    if (klassMetadata == null) {\n        return object instanceof klass;\n    }\n\n    if (klassMetadata.kind === Kotlin.Kind.INTERFACE && object.constructor != null) {\n        return isInheritanceFromInterface(object.constructor, klass);\n    }\n\n    return false;\n};\n\nKotlin.isNumber = function (a) {\n    return typeof a == \"number\" || a instanceof Kotlin.Long;\n};\n\nKotlin.isChar = function (value) {\n    return value instanceof Kotlin.BoxedChar\n};\n\nKotlin.isComparable = function (value) {\n    var type = typeof value;\n\n    return type === \"string\" ||\n           type === \"boolean\" ||\n           Kotlin.isNumber(value) ||\n           Kotlin.isType(value, Kotlin.kotlin.Comparable);\n};\n\nKotlin.isCharSequence = function (value) {\n    return typeof value === \"string\" || Kotlin.isType(value, Kotlin.kotlin.CharSequence);\n};","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors. \n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Copyright 2009 The Closure Library Authors. All Rights Reserved.\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS-IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n/**\n * Constructs a 64-bit two's-complement integer, given its low and high 32-bit\n * values as *signed* integers.  See the from* functions below for more\n * convenient ways of constructing Longs.\n *\n * The internal representation of a long is the two given signed, 32-bit values.\n * We use 32-bit pieces because these are the size of integers on which\n * Javascript performs bit-operations.  For operations like addition and\n * multiplication, we split each number into 16-bit pieces, which can easily be\n * multiplied within Javascript's floating-point representation without overflow\n * or change in sign.\n *\n * In the algorithms below, we frequently reduce the negative case to the\n * positive case by negating the input(s) and then post-processing the result.\n * Note that we must ALWAYS check specially whether those values are MIN_VALUE\n * (-2^63) because -MIN_VALUE == MIN_VALUE (since 2^63 cannot be represented as\n * a positive number, it overflows back into a negative).  Not handling this\n * case would often result in infinite recursion.\n *\n * @param {number} low  The low (signed) 32 bits of the long.\n * @param {number} high  The high (signed) 32 bits of the long.\n * @constructor\n * @final\n */\nKotlin.Long = function(low, high) {\n  /**\n   * @type {number}\n   * @private\n   */\n  this.low_ = low | 0;  // force into 32 signed bits.\n\n  /**\n   * @type {number}\n   * @private\n   */\n  this.high_ = high | 0;  // force into 32 signed bits.\n};\n\nKotlin.Long.$metadata$ = {\n    kind: \"class\",\n    simpleName: \"Long\",\n    interfaces:[]\n};\n\n\n// NOTE: Common constant values ZERO, ONE, NEG_ONE, etc. are defined below the\n// from* methods on which they depend.\n\n\n/**\n * A cache of the Long representations of small integer values.\n * @type {!Object}\n * @private\n */\nKotlin.Long.IntCache_ = {};\n\n\n/**\n * Returns a Long representing the given (32-bit) integer value.\n * @param {number} value The 32-bit integer in question.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromInt = function(value) {\n  if (-128 <= value && value < 128) {\n    var cachedObj = Kotlin.Long.IntCache_[value];\n    if (cachedObj) {\n      return cachedObj;\n    }\n  }\n\n  var obj = new Kotlin.Long(value | 0, value < 0 ? -1 : 0);\n  if (-128 <= value && value < 128) {\n    Kotlin.Long.IntCache_[value] = obj;\n  }\n  return obj;\n};\n\n\n/**\n * Converts this number value to `Long`.\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is `NaN`, `Long.MIN_VALUE` if it's less than `Long.MIN_VALUE`,\n * `Long.MAX_VALUE` if it's bigger than `Long.MAX_VALUE`.\n * @param {number} value The number in question.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromNumber = function(value) {\n  if (isNaN(value)) {\n    return Kotlin.Long.ZERO;\n  } else if (value <= -Kotlin.Long.TWO_PWR_63_DBL_) {\n    return Kotlin.Long.MIN_VALUE;\n  } else if (value + 1 >= Kotlin.Long.TWO_PWR_63_DBL_) {\n    return Kotlin.Long.MAX_VALUE;\n  } else if (value < 0) {\n    return Kotlin.Long.fromNumber(-value).negate();\n  } else {\n    return new Kotlin.Long(\n        (value % Kotlin.Long.TWO_PWR_32_DBL_) | 0,\n        (value / Kotlin.Long.TWO_PWR_32_DBL_) | 0);\n  }\n};\n\n\n/**\n * Returns a Long representing the 64-bit integer that comes by concatenating\n * the given high and low bits.  Each is assumed to use 32 bits.\n * @param {number} lowBits The low 32-bits.\n * @param {number} highBits The high 32-bits.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromBits = function(lowBits, highBits) {\n  return new Kotlin.Long(lowBits, highBits);\n};\n\n\n/**\n * Returns a Long representation of the given string, written using the given\n * radix.\n * @param {string} str The textual representation of the Long.\n * @param {number=} opt_radix The radix in which the text is written.\n * @return {!Kotlin.Long} The corresponding Long value.\n */\nKotlin.Long.fromString = function(str, opt_radix) {\n  if (str.length == 0) {\n    throw Error('number format error: empty string');\n  }\n\n  var radix = opt_radix || 10;\n  if (radix < 2 || 36 < radix) {\n    throw Error('radix out of range: ' + radix);\n  }\n\n  if (str.charAt(0) == '-') {\n    return Kotlin.Long.fromString(str.substring(1), radix).negate();\n  } else if (str.indexOf('-') >= 0) {\n    throw Error('number format error: interior \"-\" character: ' + str);\n  }\n\n  // Do several (8) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = Kotlin.Long.fromNumber(Math.pow(radix, 8));\n\n  var result = Kotlin.Long.ZERO;\n  for (var i = 0; i < str.length; i += 8) {\n    var size = Math.min(8, str.length - i);\n    var value = parseInt(str.substring(i, i + size), radix);\n    if (size < 8) {\n      var power = Kotlin.Long.fromNumber(Math.pow(radix, size));\n      result = result.multiply(power).add(Kotlin.Long.fromNumber(value));\n    } else {\n      result = result.multiply(radixToPower);\n      result = result.add(Kotlin.Long.fromNumber(value));\n    }\n  }\n  return result;\n};\n\n\n// NOTE: the compiler should inline these constant values below and then remove\n// these variables, so there should be no runtime penalty for these.\n\n\n/**\n * Number used repeated below in calculations.  This must appear before the\n * first call to any from* function below.\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_16_DBL_ = 1 << 16;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_24_DBL_ = 1 << 24;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_32_DBL_ =\n    Kotlin.Long.TWO_PWR_16_DBL_ * Kotlin.Long.TWO_PWR_16_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_31_DBL_ =\n    Kotlin.Long.TWO_PWR_32_DBL_ / 2;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_48_DBL_ =\n    Kotlin.Long.TWO_PWR_32_DBL_ * Kotlin.Long.TWO_PWR_16_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_64_DBL_ =\n    Kotlin.Long.TWO_PWR_32_DBL_ * Kotlin.Long.TWO_PWR_32_DBL_;\n\n\n/**\n * @type {number}\n * @private\n */\nKotlin.Long.TWO_PWR_63_DBL_ =\n    Kotlin.Long.TWO_PWR_64_DBL_ / 2;\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.ZERO = Kotlin.Long.fromInt(0);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.ONE = Kotlin.Long.fromInt(1);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.NEG_ONE = Kotlin.Long.fromInt(-1);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.MAX_VALUE =\n    Kotlin.Long.fromBits(0xFFFFFFFF | 0, 0x7FFFFFFF | 0);\n\n\n/** @type {!Kotlin.Long} */\nKotlin.Long.MIN_VALUE = Kotlin.Long.fromBits(0, 0x80000000 | 0);\n\n\n/**\n * @type {!Kotlin.Long}\n * @private\n */\nKotlin.Long.TWO_PWR_24_ = Kotlin.Long.fromInt(1 << 24);\n\n\n/** @return {number} The value, assuming it is a 32-bit integer. */\nKotlin.Long.prototype.toInt = function() {\n  return this.low_;\n};\n\n\n/** @return {number} The closest floating-point representation to this value. */\nKotlin.Long.prototype.toNumber = function() {\n  return this.high_ * Kotlin.Long.TWO_PWR_32_DBL_ +\n         this.getLowBitsUnsigned();\n};\n\n/** @return {number} The 32-bit hashCode of this value. */\nKotlin.Long.prototype.hashCode = function() {\n  return this.high_ ^ this.low_;\n};\n\n/**\n * @param {number=} opt_radix The radix in which the text should be written.\n * @return {string} The textual representation of this value.\n * @override\n */\nKotlin.Long.prototype.toString = function(opt_radix) {\n  var radix = opt_radix || 10;\n  if (radix < 2 || 36 < radix) {\n    throw Error('radix out of range: ' + radix);\n  }\n\n  if (this.isZero()) {\n    return '0';\n  }\n\n  if (this.isNegative()) {\n    if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n      // We need to change the Long value before it can be negated, so we remove\n      // the bottom-most digit in this base and then recurse to do the rest.\n      var radixLong = Kotlin.Long.fromNumber(radix);\n      var div = this.div(radixLong);\n      var rem = div.multiply(radixLong).subtract(this);\n      return div.toString(radix) + rem.toInt().toString(radix);\n    } else {\n      return '-' + this.negate().toString(radix);\n    }\n  }\n\n  // Do several (6) digits each time through the loop, so as to\n  // minimize the calls to the very expensive emulated div.\n  var radixToPower = Kotlin.Long.fromNumber(Math.pow(radix, 6));\n\n  var rem = this;\n  var result = '';\n  while (true) {\n    var remDiv = rem.div(radixToPower);\n    var intval = rem.subtract(remDiv.multiply(radixToPower)).toInt();\n    var digits = intval.toString(radix);\n\n    rem = remDiv;\n    if (rem.isZero()) {\n      return digits + result;\n    } else {\n      while (digits.length < 6) {\n        digits = '0' + digits;\n      }\n      result = '' + digits + result;\n    }\n  }\n};\n\n\n/** @return {number} The high 32-bits as a signed value. */\nKotlin.Long.prototype.getHighBits = function() {\n  return this.high_;\n};\n\n\n/** @return {number} The low 32-bits as a signed value. */\nKotlin.Long.prototype.getLowBits = function() {\n  return this.low_;\n};\n\n\n/** @return {number} The low 32-bits as an unsigned value. */\nKotlin.Long.prototype.getLowBitsUnsigned = function() {\n  return (this.low_ >= 0) ?\n      this.low_ : Kotlin.Long.TWO_PWR_32_DBL_ + this.low_;\n};\n\n\n/**\n * @return {number} Returns the number of bits needed to represent the absolute\n *     value of this Long.\n */\nKotlin.Long.prototype.getNumBitsAbs = function() {\n  if (this.isNegative()) {\n    if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n      return 64;\n    } else {\n      return this.negate().getNumBitsAbs();\n    }\n  } else {\n    var val = this.high_ != 0 ? this.high_ : this.low_;\n    for (var bit = 31; bit > 0; bit--) {\n      if ((val & (1 << bit)) != 0) {\n        break;\n      }\n    }\n    return this.high_ != 0 ? bit + 33 : bit + 1;\n  }\n};\n\n\n/** @return {boolean} Whether this value is zero. */\nKotlin.Long.prototype.isZero = function() {\n  return this.high_ == 0 && this.low_ == 0;\n};\n\n\n/** @return {boolean} Whether this value is negative. */\nKotlin.Long.prototype.isNegative = function() {\n  return this.high_ < 0;\n};\n\n\n/** @return {boolean} Whether this value is odd. */\nKotlin.Long.prototype.isOdd = function() {\n  return (this.low_ & 1) == 1;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long equals the other.\n */\nKotlin.Long.prototype.equalsLong = function(other) {\n  return (this.high_ == other.high_) && (this.low_ == other.low_);\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long does not equal the other.\n */\nKotlin.Long.prototype.notEqualsLong = function(other) {\n  return (this.high_ != other.high_) || (this.low_ != other.low_);\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is less than the other.\n */\nKotlin.Long.prototype.lessThan = function(other) {\n  return this.compare(other) < 0;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is less than or equal to the other.\n */\nKotlin.Long.prototype.lessThanOrEqual = function(other) {\n  return this.compare(other) <= 0;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is greater than the other.\n */\nKotlin.Long.prototype.greaterThan = function(other) {\n  return this.compare(other) > 0;\n};\n\n\n/**\n * @param {Kotlin.Long} other Long to compare against.\n * @return {boolean} Whether this Long is greater than or equal to the other.\n */\nKotlin.Long.prototype.greaterThanOrEqual = function(other) {\n  return this.compare(other) >= 0;\n};\n\n\n/**\n * Compares this Long with the given one.\n * @param {Kotlin.Long} other Long to compare against.\n * @return {number} 0 if they are the same, 1 if the this is greater, and -1\n *     if the given one is greater.\n */\nKotlin.Long.prototype.compare = function(other) {\n  if (this.equalsLong(other)) {\n    return 0;\n  }\n\n  var thisNeg = this.isNegative();\n  var otherNeg = other.isNegative();\n  if (thisNeg && !otherNeg) {\n    return -1;\n  }\n  if (!thisNeg && otherNeg) {\n    return 1;\n  }\n\n  // at this point, the signs are the same, so subtraction will not overflow\n  if (this.subtract(other).isNegative()) {\n    return -1;\n  } else {\n    return 1;\n  }\n};\n\n\n/** @return {!Kotlin.Long} The negation of this value. */\nKotlin.Long.prototype.negate = function() {\n  if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return Kotlin.Long.MIN_VALUE;\n  } else {\n    return this.not().add(Kotlin.Long.ONE);\n  }\n};\n\n\n/**\n * Returns the sum of this and the given Long.\n * @param {Kotlin.Long} other Long to add to this one.\n * @return {!Kotlin.Long} The sum of this and the given Long.\n */\nKotlin.Long.prototype.add = function(other) {\n  // Divide each number into 4 chunks of 16 bits, and then sum the chunks.\n\n  var a48 = this.high_ >>> 16;\n  var a32 = this.high_ & 0xFFFF;\n  var a16 = this.low_ >>> 16;\n  var a00 = this.low_ & 0xFFFF;\n\n  var b48 = other.high_ >>> 16;\n  var b32 = other.high_ & 0xFFFF;\n  var b16 = other.low_ >>> 16;\n  var b00 = other.low_ & 0xFFFF;\n\n  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += a00 + b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xFFFF;\n  c16 += a16 + b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c32 += a32 + b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c48 += a48 + b48;\n  c48 &= 0xFFFF;\n  return Kotlin.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);\n};\n\n\n/**\n * Returns the difference of this and the given Long.\n * @param {Kotlin.Long} other Long to subtract from this.\n * @return {!Kotlin.Long} The difference of this and the given Long.\n */\nKotlin.Long.prototype.subtract = function(other) {\n  return this.add(other.negate());\n};\n\n\n/**\n * Returns the product of this and the given long.\n * @param {Kotlin.Long} other Long to multiply with this.\n * @return {!Kotlin.Long} The product of this and the other.\n */\nKotlin.Long.prototype.multiply = function(other) {\n  if (this.isZero()) {\n    return Kotlin.Long.ZERO;\n  } else if (other.isZero()) {\n    return Kotlin.Long.ZERO;\n  }\n\n  if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return other.isOdd() ? Kotlin.Long.MIN_VALUE : Kotlin.Long.ZERO;\n  } else if (other.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return this.isOdd() ? Kotlin.Long.MIN_VALUE : Kotlin.Long.ZERO;\n  }\n\n  if (this.isNegative()) {\n    if (other.isNegative()) {\n      return this.negate().multiply(other.negate());\n    } else {\n      return this.negate().multiply(other).negate();\n    }\n  } else if (other.isNegative()) {\n    return this.multiply(other.negate()).negate();\n  }\n\n  // If both longs are small, use float multiplication\n  if (this.lessThan(Kotlin.Long.TWO_PWR_24_) &&\n      other.lessThan(Kotlin.Long.TWO_PWR_24_)) {\n    return Kotlin.Long.fromNumber(this.toNumber() * other.toNumber());\n  }\n\n  // Divide each long into 4 chunks of 16 bits, and then add up 4x4 products.\n  // We can skip products that would overflow.\n\n  var a48 = this.high_ >>> 16;\n  var a32 = this.high_ & 0xFFFF;\n  var a16 = this.low_ >>> 16;\n  var a00 = this.low_ & 0xFFFF;\n\n  var b48 = other.high_ >>> 16;\n  var b32 = other.high_ & 0xFFFF;\n  var b16 = other.low_ >>> 16;\n  var b00 = other.low_ & 0xFFFF;\n\n  var c48 = 0, c32 = 0, c16 = 0, c00 = 0;\n  c00 += a00 * b00;\n  c16 += c00 >>> 16;\n  c00 &= 0xFFFF;\n  c16 += a16 * b00;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c16 += a00 * b16;\n  c32 += c16 >>> 16;\n  c16 &= 0xFFFF;\n  c32 += a32 * b00;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += a16 * b16;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c32 += a00 * b32;\n  c48 += c32 >>> 16;\n  c32 &= 0xFFFF;\n  c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;\n  c48 &= 0xFFFF;\n  return Kotlin.Long.fromBits((c16 << 16) | c00, (c48 << 16) | c32);\n};\n\n\n/**\n * Returns this Long divided by the given one.\n * @param {Kotlin.Long} other Long by which to divide.\n * @return {!Kotlin.Long} This Long divided by the given one.\n */\nKotlin.Long.prototype.div = function(other) {\n  if (other.isZero()) {\n    throw Error('division by zero');\n  } else if (this.isZero()) {\n    return Kotlin.Long.ZERO;\n  }\n\n  if (this.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    if (other.equalsLong(Kotlin.Long.ONE) ||\n        other.equalsLong(Kotlin.Long.NEG_ONE)) {\n      return Kotlin.Long.MIN_VALUE;  // recall that -MIN_VALUE == MIN_VALUE\n    } else if (other.equalsLong(Kotlin.Long.MIN_VALUE)) {\n      return Kotlin.Long.ONE;\n    } else {\n      // At this point, we have |other| >= 2, so |this/other| < |MIN_VALUE|.\n      var halfThis = this.shiftRight(1);\n      var approx = halfThis.div(other).shiftLeft(1);\n      if (approx.equalsLong(Kotlin.Long.ZERO)) {\n        return other.isNegative() ? Kotlin.Long.ONE : Kotlin.Long.NEG_ONE;\n      } else {\n        var rem = this.subtract(other.multiply(approx));\n        var result = approx.add(rem.div(other));\n        return result;\n      }\n    }\n  } else if (other.equalsLong(Kotlin.Long.MIN_VALUE)) {\n    return Kotlin.Long.ZERO;\n  }\n\n  if (this.isNegative()) {\n    if (other.isNegative()) {\n      return this.negate().div(other.negate());\n    } else {\n      return this.negate().div(other).negate();\n    }\n  } else if (other.isNegative()) {\n    return this.div(other.negate()).negate();\n  }\n\n  // Repeat the following until the remainder is less than other:  find a\n  // floating-point that approximates remainder / other *from below*, add this\n  // into the result, and subtract it from the remainder.  It is critical that\n  // the approximate value is less than or equal to the real value so that the\n  // remainder never becomes negative.\n  var res = Kotlin.Long.ZERO;\n  var rem = this;\n  while (rem.greaterThanOrEqual(other)) {\n    // Approximate the result of division. This may be a little greater or\n    // smaller than the actual value.\n    var approx = Math.max(1, Math.floor(rem.toNumber() / other.toNumber()));\n\n    // We will tweak the approximate result by changing it in the 48-th digit or\n    // the smallest non-fractional digit, whichever is larger.\n    var log2 = Math.ceil(Math.log(approx) / Math.LN2);\n    var delta = (log2 <= 48) ? 1 : Math.pow(2, log2 - 48);\n\n    // Decrease the approximation until it is smaller than the remainder.  Note\n    // that if it is too large, the product overflows and is negative.\n    var approxRes = Kotlin.Long.fromNumber(approx);\n    var approxRem = approxRes.multiply(other);\n    while (approxRem.isNegative() || approxRem.greaterThan(rem)) {\n      approx -= delta;\n      approxRes = Kotlin.Long.fromNumber(approx);\n      approxRem = approxRes.multiply(other);\n    }\n\n    // We know the answer can't be zero... and actually, zero would cause\n    // infinite recursion since we would make no progress.\n    if (approxRes.isZero()) {\n      approxRes = Kotlin.Long.ONE;\n    }\n\n    res = res.add(approxRes);\n    rem = rem.subtract(approxRem);\n  }\n  return res;\n};\n\n\n/**\n * Returns this Long modulo the given one.\n * @param {Kotlin.Long} other Long by which to mod.\n * @return {!Kotlin.Long} This Long modulo the given one.\n */\nKotlin.Long.prototype.modulo = function(other) {\n  return this.subtract(this.div(other).multiply(other));\n};\n\n\n/** @return {!Kotlin.Long} The bitwise-NOT of this value. */\nKotlin.Long.prototype.not = function() {\n  return Kotlin.Long.fromBits(~this.low_, ~this.high_);\n};\n\n\n/**\n * Returns the bitwise-AND of this Long and the given one.\n * @param {Kotlin.Long} other The Long with which to AND.\n * @return {!Kotlin.Long} The bitwise-AND of this and the other.\n */\nKotlin.Long.prototype.and = function(other) {\n  return Kotlin.Long.fromBits(this.low_ & other.low_,\n                                 this.high_ & other.high_);\n};\n\n\n/**\n * Returns the bitwise-OR of this Long and the given one.\n * @param {Kotlin.Long} other The Long with which to OR.\n * @return {!Kotlin.Long} The bitwise-OR of this and the other.\n */\nKotlin.Long.prototype.or = function(other) {\n  return Kotlin.Long.fromBits(this.low_ | other.low_,\n                                 this.high_ | other.high_);\n};\n\n\n/**\n * Returns the bitwise-XOR of this Long and the given one.\n * @param {Kotlin.Long} other The Long with which to XOR.\n * @return {!Kotlin.Long} The bitwise-XOR of this and the other.\n */\nKotlin.Long.prototype.xor = function(other) {\n  return Kotlin.Long.fromBits(this.low_ ^ other.low_,\n                                 this.high_ ^ other.high_);\n};\n\n\n/**\n * Returns this Long with bits shifted to the left by the given amount.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Kotlin.Long} This shifted to the left by the given amount.\n */\nKotlin.Long.prototype.shiftLeft = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var low = this.low_;\n    if (numBits < 32) {\n      var high = this.high_;\n      return Kotlin.Long.fromBits(\n          low << numBits,\n          (high << numBits) | (low >>> (32 - numBits)));\n    } else {\n      return Kotlin.Long.fromBits(0, low << (numBits - 32));\n    }\n  }\n};\n\n\n/**\n * Returns this Long with bits shifted to the right by the given amount.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Kotlin.Long} This shifted to the right by the given amount.\n */\nKotlin.Long.prototype.shiftRight = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var high = this.high_;\n    if (numBits < 32) {\n      var low = this.low_;\n      return Kotlin.Long.fromBits(\n          (low >>> numBits) | (high << (32 - numBits)),\n          high >> numBits);\n    } else {\n      return Kotlin.Long.fromBits(\n          high >> (numBits - 32),\n          high >= 0 ? 0 : -1);\n    }\n  }\n};\n\n\n/**\n * Returns this Long with bits shifted to the right by the given amount, with\n * zeros placed into the new leading bits.\n * @param {number} numBits The number of bits by which to shift.\n * @return {!Kotlin.Long} This shifted to the right by the given amount, with\n *     zeros placed into the new leading bits.\n */\nKotlin.Long.prototype.shiftRightUnsigned = function(numBits) {\n  numBits &= 63;\n  if (numBits == 0) {\n    return this;\n  } else {\n    var high = this.high_;\n    if (numBits < 32) {\n      var low = this.low_;\n      return Kotlin.Long.fromBits(\n          (low >>> numBits) | (high << (32 - numBits)),\n          high >>> numBits);\n    } else if (numBits == 32) {\n      return Kotlin.Long.fromBits(high, 0);\n    } else {\n      return Kotlin.Long.fromBits(high >>> (numBits - 32), 0);\n    }\n  }\n};\n\n// Support for Kotlin\nKotlin.Long.prototype.equals = function (other) {\n    return other instanceof Kotlin.Long && this.equalsLong(other);\n};\n\nKotlin.Long.prototype.compareTo_11rb$ = Kotlin.Long.prototype.compare;\n\nKotlin.Long.prototype.inc = function() {\n    return this.add(Kotlin.Long.ONE);\n};\n\nKotlin.Long.prototype.dec = function() {\n    return this.add(Kotlin.Long.NEG_ONE);\n};\n\nKotlin.Long.prototype.valueOf = function() {\n    return this.toNumber();\n};\n\nKotlin.Long.prototype.unaryPlus = function() {\n    return this;\n};\n\nKotlin.Long.prototype.unaryMinus = Kotlin.Long.prototype.negate;\nKotlin.Long.prototype.inv = Kotlin.Long.prototype.not;\n\nKotlin.Long.prototype.rangeTo = function (other) {\n    return new Kotlin.kotlin.ranges.LongRange(this, other);\n};","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\n@PublishedApi\nexternal internal fun <T> Array(size: Int): Array<T>\n\n@JsName(\"newArray\")\nfun <T> newArray(size: Int, initValue: T) = fillArrayVal(Array<T>(size), initValue)\n\n@JsName(\"newArrayF\")\ninline fun <T> arrayWithFun(size: Int, init: (Int) -> T) = fillArrayFun(Array<T>(size), init)\n\n@JsName(\"fillArray\")\ninline fun <T> fillArrayFun(array: Array<T>, init: (Int) -> T): Array<T> {\n    for (i in 0..array.size - 1) {\n        array[i] = init(i)\n    }\n    return array\n}\n\n@JsName(\"booleanArray\")\nfun booleanArray(size: Int, init: dynamic): Array<Boolean> {\n    val result: dynamic = Array<Boolean>(size)\n    result.`$type$` = \"BooleanArray\"\n    return when (init) {\n        null, true -> fillArrayVal(result, false)\n        false -> result\n        else -> fillArrayFun<Boolean>(result, init)\n    }\n}\n\n@JsName(\"booleanArrayF\")\ninline fun booleanArrayWithFun(size: Int, init: (Int) -> Boolean): Array<Boolean> = fillArrayFun(booleanArray(size, false), init)\n\n@JsName(\"charArray\")\n@Suppress(\"UNUSED_PARAMETER\")\nfun charArray(size: Int, init: dynamic): Array<Char> {\n    val result = js(\"new Uint16Array(size)\")\n    result.`$type$` = \"CharArray\"\n    return when (init) {\n        null, true, false -> result // For consistency\n        else -> fillArrayFun<Char>(result, init)\n    }\n}\n\n@JsName(\"charArrayF\")\ninline fun charArrayWithFun(size: Int, init: (Int) -> Char): Array<Char> {\n    val array = charArray(size, null)\n    for (i in 0..array.size - 1) {\n        @Suppress(\"UNUSED_VARIABLE\") // used in js block\n        val value = init(i)\n        js(\"array[i] = value;\")\n    }\n    return array\n}\n\n@JsName(\"untypedCharArrayF\")\ninline fun untypedCharArrayWithFun(size: Int, init: (Int) -> Char): Array<Char> {\n    val array = Array<Char>(size)\n    for (i in 0..array.size - 1) {\n        @Suppress(\"UNUSED_VARIABLE\") // used in js block\n        val value = init(i)\n        js(\"array[i] = value;\")\n    }\n    return array\n}\n\n@JsName(\"longArray\")\nfun longArray(size: Int, init: dynamic): Array<Long> {\n    val result: dynamic = Array<Long>(size)\n    result.`$type$` = \"LongArray\"\n    return when (init) {\n        null, true -> fillArrayVal(result, 0L)\n        false -> result\n        else -> fillArrayFun<Long>(result, init)\n    }\n}\n\n@JsName(\"longArrayF\")\ninline fun longArrayWithFun(size: Int, init: (Int) -> Long): Array<Long> = fillArrayFun(longArray(size, false), init)\n\nprivate fun <T> fillArrayVal(array: Array<T>, initValue: T): Array<T> {\n    for (i in 0..array.size - 1) {\n        array[i] = initValue\n    }\n    return array\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\npublic class Enum<T : Enum<T>> : Comparable<Enum<T>> {\n    @JsName(\"name$\") private var _name: String = \"\"\n    @JsName(\"ordinal$\") private var _ordinal: Int = 0\n\n    val name: String\n        get() = _name\n\n    val ordinal: Int\n        get() = _ordinal\n\n    override fun compareTo(other: Enum<T>) = ordinal.compareTo(other.ordinal)\n\n    override fun equals(other: Any?) = this === other\n\n    override fun hashCode(): Int = js(\"Kotlin.identityHashCode\")(this)\n\n    override fun toString() = name\n\n    companion object\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js.internal\n\n@JsName(\"DoubleCompanionObject\")\ninternal object DoubleCompanionObject {\n    @JsName(\"MIN_VALUE\")\n    const val MIN_VALUE: Double = 4.9E-324\n\n    @JsName(\"MAX_VALUE\")\n    const val MAX_VALUE: Double = 1.7976931348623157E308\n\n    @JsName(\"POSITIVE_INFINITY\")\n    @Suppress(\"DIVISION_BY_ZERO\")\n    const val POSITIVE_INFINITY: Double = 1.0 / 0.0\n\n    @JsName(\"NEGATIVE_INFINITY\")\n    @Suppress(\"DIVISION_BY_ZERO\")\n    const val NEGATIVE_INFINITY: Double = -1.0 / 0.0\n\n    @JsName(\"NaN\")\n    @Suppress(\"DIVISION_BY_ZERO\")\n    const val NaN: Double = -(0.0 / 0.0)\n\n    @JsName(\"SIZE_BYTES\")\n    const val SIZE_BYTES = 8\n\n    @JsName(\"SIZE_BITS\")\n    const val SIZE_BITS = 64\n}\n\n@JsName(\"FloatCompanionObject\")\ninternal  object FloatCompanionObject {\n    @JsName(\"MIN_VALUE\")\n    const val MIN_VALUE: Float = 1.4E-45F\n\n    @JsName(\"MAX_VALUE\")\n    const val MAX_VALUE: Float = 3.4028235E38F\n\n    @JsName(\"POSITIVE_INFINITY\")\n    @Suppress(\"DIVISION_BY_ZERO\")\n    const val POSITIVE_INFINITY: Float = 1.0F / 0.0F\n\n    @JsName(\"NEGATIVE_INFINITY\")\n    @Suppress(\"DIVISION_BY_ZERO\")\n    const val NEGATIVE_INFINITY: Float = -1.0F / 0.0F\n\n    @JsName(\"NaN\")\n    @Suppress(\"DIVISION_BY_ZERO\")\n    const val NaN: Float = -(0.0F / 0.0F)\n\n    @JsName(\"SIZE_BYTES\")\n    const val SIZE_BYTES = 4\n\n    @JsName(\"SIZE_BITS\")\n    const val SIZE_BITS = 32\n}\n\n@JsName(\"IntCompanionObject\")\ninternal  object IntCompanionObject {\n    @JsName(\"MIN_VALUE\")\n    val MIN_VALUE: Int = -2147483647 - 1\n\n    @JsName(\"MAX_VALUE\")\n    val MAX_VALUE: Int = 2147483647\n\n    @JsName(\"SIZE_BYTES\")\n    const val SIZE_BYTES = 4\n\n    @JsName(\"SIZE_BITS\")\n    const val SIZE_BITS = 32\n}\n\n@JsName(\"LongCompanionObject\")\ninternal  object LongCompanionObject {\n    @JsName(\"MIN_VALUE\")\n    val MIN_VALUE: Long = js(\"Kotlin.Long.MIN_VALUE\")\n\n    @JsName(\"MAX_VALUE\")\n    val MAX_VALUE: Long = js(\"Kotlin.Long.MAX_VALUE\")\n\n    @JsName(\"SIZE_BYTES\")\n    const val SIZE_BYTES = 8\n\n    @JsName(\"SIZE_BITS\")\n    const val SIZE_BITS = 64\n}\n\n@JsName(\"ShortCompanionObject\")\ninternal  object ShortCompanionObject {\n    @JsName(\"MIN_VALUE\")\n    val MIN_VALUE: Short = -32768\n\n    @JsName(\"MAX_VALUE\")\n    val MAX_VALUE: Short = 32767\n\n    @JsName(\"SIZE_BYTES\")\n    const val SIZE_BYTES = 2\n\n    @JsName(\"SIZE_BITS\")\n    const val SIZE_BITS = 16\n}\n\n@JsName(\"ByteCompanionObject\")\ninternal  object ByteCompanionObject {\n    @JsName(\"MIN_VALUE\")\n    val MIN_VALUE: Byte = -128\n\n    @JsName(\"MAX_VALUE\")\n    val MAX_VALUE: Byte = 127\n\n    @JsName(\"SIZE_BYTES\")\n    const val SIZE_BYTES = 1\n\n    @JsName(\"SIZE_BITS\")\n    const val SIZE_BITS = 8\n}\n\n@JsName(\"CharCompanionObject\")\ninternal  object CharCompanionObject {\n    @JsName(\"MIN_VALUE\")\n    public const val MIN_VALUE: Char = '\\u0000'\n\n    @JsName(\"MAX_VALUE\")\n    public const val MAX_VALUE: Char = '\\uFFFF'\n\n    @JsName(\"MIN_HIGH_SURROGATE\")\n    public const val MIN_HIGH_SURROGATE: Char = '\\uD800'\n\n    @JsName(\"MAX_HIGH_SURROGATE\")\n    public const val MAX_HIGH_SURROGATE: Char = '\\uDBFF'\n\n    @JsName(\"MIN_LOW_SURROGATE\")\n    public const val MIN_LOW_SURROGATE: Char = '\\uDC00'\n\n    @JsName(\"MAX_LOW_SURROGATE\")\n    public const val MAX_LOW_SURROGATE: Char = '\\uDFFF'\n\n    @JsName(\"MIN_SURROGATE\")\n    public const val MIN_SURROGATE: Char = MIN_HIGH_SURROGATE\n\n    @JsName(\"MAX_SURROGATE\")\n    public const val MAX_SURROGATE: Char = MAX_LOW_SURROGATE\n\n    @JsName(\"SIZE_BYTES\")\n    const val SIZE_BYTES = 2\n\n    @JsName(\"SIZE_BITS\")\n    const val SIZE_BITS = 16\n}\n\ninternal  object StringCompanionObject {}\n\ninternal  object BooleanCompanionObject {}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"ArraysKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component1(): Byte {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component1(): Short {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component1(): Int {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component1(): Long {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component1(): Float {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component1(): Double {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component1(): Boolean {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component1(): Char {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component2(): Byte {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component2(): Short {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component2(): Int {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component2(): Long {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component2(): Float {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component2(): Double {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component2(): Boolean {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component2(): Char {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component3(): Byte {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component3(): Short {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component3(): Int {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component3(): Long {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component3(): Float {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component3(): Double {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component3(): Boolean {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component3(): Char {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component4(): Byte {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component4(): Short {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component4(): Int {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component4(): Long {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component4(): Float {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component4(): Double {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component4(): Boolean {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component4(): Char {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Array<out T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ByteArray.component5(): Byte {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun ShortArray.component5(): Short {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun IntArray.component5(): Int {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun LongArray.component5(): Long {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun FloatArray.component5(): Float {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun DoubleArray.component5(): Double {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun BooleanArray.component5(): Boolean {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharArray.component5(): Char {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.contains(element: T): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun ByteArray.contains(element: Byte): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun ShortArray.contains(element: Short): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun IntArray.contains(element: Int): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun LongArray.contains(element: Long): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'any { it == element }' instead to continue using this behavior, or '.asList().contains(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"any { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.6\")\n@Suppress(\"DEPRECATION_ERROR\")\npublic operator fun FloatArray.contains(element: Float): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'any { it == element }' instead to continue using this behavior, or '.asList().contains(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"any { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.6\")\n@Suppress(\"DEPRECATION_ERROR\")\npublic operator fun DoubleArray.contains(element: Double): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun BooleanArray.contains(element: Boolean): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns `true` if [element] is found in the array.\n */\npublic operator fun CharArray.contains(element: Char): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun <T> Array<out T>.elementAt(index: Int): T\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun ByteArray.elementAt(index: Int): Byte\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun ShortArray.elementAt(index: Int): Short\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun IntArray.elementAt(index: Int): Int\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun LongArray.elementAt(index: Int): Long\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun FloatArray.elementAt(index: Int): Float\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun DoubleArray.elementAt(index: Int): Double\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun BooleanArray.elementAt(index: Int): Boolean\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun CharArray.elementAt(index: Int): Char\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Byte): Byte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Short): Short {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Int): Int {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Long): Long {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Float): Float {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Double): Double {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.elementAtOrNull(index: Int): Byte? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.elementAtOrNull(index: Int): Short? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.elementAtOrNull(index: Int): Int? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.elementAtOrNull(index: Int): Long? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.elementAtOrNull(index: Int): Float? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.elementAtOrNull(index: Int): Double? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.elementAtOrNull(index: Int): Boolean? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.elementAtOrNull(index: Int): Char? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.find(predicate: (Byte) -> Boolean): Byte? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.find(predicate: (Short) -> Boolean): Short? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.find(predicate: (Int) -> Boolean): Int? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.find(predicate: (Long) -> Boolean): Long? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.find(predicate: (Float) -> Boolean): Float? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.find(predicate: (Double) -> Boolean): Double? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.find(predicate: (Boolean) -> Boolean): Boolean? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.find(predicate: (Char) -> Boolean): Char? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.findLast(predicate: (Byte) -> Boolean): Byte? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.findLast(predicate: (Short) -> Boolean): Short? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.findLast(predicate: (Int) -> Boolean): Int? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.findLast(predicate: (Long) -> Boolean): Long? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.findLast(predicate: (Float) -> Boolean): Float? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.findLast(predicate: (Double) -> Boolean): Double? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.findLast(predicate: (Boolean) -> Boolean): Boolean? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.findLast(predicate: (Char) -> Boolean): Char? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun <T> Array<out T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ByteArray.first(): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun ShortArray.first(): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun IntArray.first(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun LongArray.first(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun FloatArray.first(): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun DoubleArray.first(): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun BooleanArray.first(): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\npublic fun CharArray.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Array<out T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ByteArray.first(predicate: (Byte) -> Boolean): Byte {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun ShortArray.first(predicate: (Short) -> Boolean): Short {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun IntArray.first(predicate: (Int) -> Boolean): Int {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun LongArray.first(predicate: (Long) -> Boolean): Long {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun FloatArray.first(predicate: (Float) -> Boolean): Float {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun DoubleArray.first(predicate: (Double) -> Boolean): Double {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun BooleanArray.first(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun CharArray.first(predicate: (Char) -> Boolean): Char {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this array in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Array<out T>.firstNotNullOf(transform: (T) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the array was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this array in iteration order,\n * or `null` if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Array<out T>.firstNotNullOfOrNull(transform: (T) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun <T> Array<out T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun ByteArray.firstOrNull(): Byte? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun ShortArray.firstOrNull(): Short? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun IntArray.firstOrNull(): Int? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun LongArray.firstOrNull(): Long? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun FloatArray.firstOrNull(): Float? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun DoubleArray.firstOrNull(): Double? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun BooleanArray.firstOrNull(): Boolean? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\npublic fun CharArray.firstOrNull(): Char? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Array<out T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun ByteArray.firstOrNull(predicate: (Byte) -> Boolean): Byte? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun ShortArray.firstOrNull(predicate: (Short) -> Boolean): Short? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun IntArray.firstOrNull(predicate: (Int) -> Boolean): Int? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun LongArray.firstOrNull(predicate: (Long) -> Boolean): Long? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun FloatArray.firstOrNull(predicate: (Float) -> Boolean): Float? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun DoubleArray.firstOrNull(predicate: (Double) -> Boolean): Double? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun BooleanArray.firstOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun CharArray.firstOrNull(predicate: (Char) -> Boolean): Char? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.getOrElse(index: Int, defaultValue: (Int) -> Byte): Byte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.getOrElse(index: Int, defaultValue: (Int) -> Short): Short {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.getOrElse(index: Int, defaultValue: (Int) -> Int): Int {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.getOrElse(index: Int, defaultValue: (Int) -> Long): Long {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.getOrElse(index: Int, defaultValue: (Int) -> Float): Float {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.getOrElse(index: Int, defaultValue: (Int) -> Double): Double {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.getOrElse(index: Int, defaultValue: (Int) -> Boolean): Boolean {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.getOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun <T> Array<out T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun ByteArray.getOrNull(index: Int): Byte? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun ShortArray.getOrNull(index: Int): Short? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun IntArray.getOrNull(index: Int): Int? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun LongArray.getOrNull(index: Int): Long? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun FloatArray.getOrNull(index: Int): Float? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun DoubleArray.getOrNull(index: Int): Double? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun BooleanArray.getOrNull(index: Int): Boolean? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun CharArray.getOrNull(index: Int): Char? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.indexOf(element: T): Int {\n    if (element == null) {\n        for (index in indices) {\n            if (this[index] == null) {\n                return index\n            }\n        }\n    } else {\n        for (index in indices) {\n            if (element == this[index]) {\n                return index\n            }\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun ByteArray.indexOf(element: Byte): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun ShortArray.indexOf(element: Short): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun IntArray.indexOf(element: Int): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun LongArray.indexOf(element: Long): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfFirst { it == element }' instead to continue using this behavior, or '.asList().indexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfFirst { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.6\")\npublic fun FloatArray.indexOf(element: Float): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfFirst { it == element }' instead to continue using this behavior, or '.asList().indexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfFirst { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.6\")\npublic fun DoubleArray.indexOf(element: Double): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun BooleanArray.indexOf(element: Boolean): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\npublic fun CharArray.indexOf(element: Char): Int {\n    for (index in indices) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun <T> Array<out T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ByteArray.indexOfFirst(predicate: (Byte) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ShortArray.indexOfFirst(predicate: (Short) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun IntArray.indexOfFirst(predicate: (Int) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun LongArray.indexOfFirst(predicate: (Long) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun FloatArray.indexOfFirst(predicate: (Float) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun DoubleArray.indexOfFirst(predicate: (Double) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun BooleanArray.indexOfFirst(predicate: (Boolean) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun CharArray.indexOfFirst(predicate: (Char) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun <T> Array<out T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ByteArray.indexOfLast(predicate: (Byte) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun ShortArray.indexOfLast(predicate: (Short) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun IntArray.indexOfLast(predicate: (Int) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun LongArray.indexOfLast(predicate: (Long) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun FloatArray.indexOfLast(predicate: (Float) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun DoubleArray.indexOfLast(predicate: (Double) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun BooleanArray.indexOfLast(predicate: (Boolean) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\npublic inline fun CharArray.indexOfLast(predicate: (Char) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Array<out T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ByteArray.last(): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ShortArray.last(): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun IntArray.last(): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun LongArray.last(): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun FloatArray.last(): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun DoubleArray.last(): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun BooleanArray.last(): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun CharArray.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Array<out T>.last(predicate: (T) -> Boolean): T {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ByteArray.last(predicate: (Byte) -> Boolean): Byte {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ShortArray.last(predicate: (Short) -> Boolean): Short {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun IntArray.last(predicate: (Int) -> Boolean): Int {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun LongArray.last(predicate: (Long) -> Boolean): Long {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun FloatArray.last(predicate: (Float) -> Boolean): Float {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun DoubleArray.last(predicate: (Double) -> Boolean): Double {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun BooleanArray.last(predicate: (Boolean) -> Boolean): Boolean {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun CharArray.last(predicate: (Char) -> Boolean): Char {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Array<out T>.lastIndexOf(element: T): Int {\n    if (element == null) {\n        for (index in indices.reversed()) {\n            if (this[index] == null) {\n                return index\n            }\n        }\n    } else {\n        for (index in indices.reversed()) {\n            if (element == this[index]) {\n                return index\n            }\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun ByteArray.lastIndexOf(element: Byte): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun ShortArray.lastIndexOf(element: Short): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun IntArray.lastIndexOf(element: Int): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun LongArray.lastIndexOf(element: Long): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfLast { it == element }' instead to continue using this behavior, or '.asList().lastIndexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfLast { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.6\")\npublic fun FloatArray.lastIndexOf(element: Float): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@Deprecated(\"The function has unclear behavior when searching for NaN or zero values and will be removed soon. Use 'indexOfLast { it == element }' instead to continue using this behavior, or '.asList().lastIndexOf(element: T)' to get the same search behavior as in a list.\", ReplaceWith(\"indexOfLast { it == element }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.6\")\npublic fun DoubleArray.lastIndexOf(element: Double): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun BooleanArray.lastIndexOf(element: Boolean): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\npublic fun CharArray.lastIndexOf(element: Char): Int {\n    for (index in indices.reversed()) {\n        if (element == this[index]) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Array<out T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ByteArray.lastOrNull(): Byte? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun ShortArray.lastOrNull(): Short? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun IntArray.lastOrNull(): Int? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun LongArray.lastOrNull(): Long? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun FloatArray.lastOrNull(): Float? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun DoubleArray.lastOrNull(): Double? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun BooleanArray.lastOrNull(): Boolean? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun CharArray.lastOrNull(): Char? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Array<out T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ByteArray.lastOrNull(predicate: (Byte) -> Boolean): Byte? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun ShortArray.lastOrNull(predicate: (Short) -> Boolean): Short? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun IntArray.lastOrNull(predicate: (Int) -> Boolean): Int? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun LongArray.lastOrNull(predicate: (Long) -> Boolean): Long? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun FloatArray.lastOrNull(predicate: (Float) -> Boolean): Float? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun DoubleArray.lastOrNull(predicate: (Double) -> Boolean): Double? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun BooleanArray.lastOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun CharArray.lastOrNull(predicate: (Char) -> Boolean): Char? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.random(): Byte {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.random(): Short {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.random(): Int {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.random(): Long {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.random(): Float {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.random(): Double {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.random(): Boolean {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Array<out T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun ByteArray.random(random: Random): Byte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun ShortArray.random(random: Random): Short {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun IntArray.random(random: Random): Int {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun LongArray.random(random: Random): Long {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun FloatArray.random(random: Random): Float {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun DoubleArray.random(random: Random): Double {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun BooleanArray.random(random: Random): Boolean {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharArray.random(random: Random): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.randomOrNull(): T? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.randomOrNull(): Byte? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.randomOrNull(): Short? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.randomOrNull(): Int? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.randomOrNull(): Long? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.randomOrNull(): Float? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.randomOrNull(): Double? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.randomOrNull(): Boolean? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> Array<out T>.randomOrNull(random: Random): T? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun ByteArray.randomOrNull(random: Random): Byte? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun ShortArray.randomOrNull(random: Random): Short? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun IntArray.randomOrNull(random: Random): Int? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun LongArray.randomOrNull(random: Random): Long? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun FloatArray.randomOrNull(random: Random): Float? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun DoubleArray.randomOrNull(random: Random): Double? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun BooleanArray.randomOrNull(random: Random): Boolean? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun CharArray.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun <T> Array<out T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun ByteArray.single(): Byte {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun ShortArray.single(): Short {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun IntArray.single(): Int {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun LongArray.single(): Long {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun FloatArray.single(): Float {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun DoubleArray.single(): Double {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun BooleanArray.single(): Boolean {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\npublic fun CharArray.single(): Char {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"Array is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Array has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Array<out T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun ByteArray.single(predicate: (Byte) -> Boolean): Byte {\n    var single: Byte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Byte\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun ShortArray.single(predicate: (Short) -> Boolean): Short {\n    var single: Short? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Short\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun IntArray.single(predicate: (Int) -> Boolean): Int {\n    var single: Int? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Int\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun LongArray.single(predicate: (Long) -> Boolean): Long {\n    var single: Long? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Long\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun FloatArray.single(predicate: (Float) -> Boolean): Float {\n    var single: Float? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Float\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun DoubleArray.single(predicate: (Double) -> Boolean): Double {\n    var single: Double? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Double\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun BooleanArray.single(predicate: (Boolean) -> Boolean): Boolean {\n    var single: Boolean? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Boolean\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun CharArray.single(predicate: (Char) -> Boolean): Char {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Char\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun <T> Array<out T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun ByteArray.singleOrNull(): Byte? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun ShortArray.singleOrNull(): Short? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun IntArray.singleOrNull(): Int? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun LongArray.singleOrNull(): Long? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun FloatArray.singleOrNull(): Float? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun DoubleArray.singleOrNull(): Double? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun BooleanArray.singleOrNull(): Boolean? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\npublic fun CharArray.singleOrNull(): Char? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Array<out T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun ByteArray.singleOrNull(predicate: (Byte) -> Boolean): Byte? {\n    var single: Byte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun ShortArray.singleOrNull(predicate: (Short) -> Boolean): Short? {\n    var single: Short? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun IntArray.singleOrNull(predicate: (Int) -> Boolean): Int? {\n    var single: Int? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun LongArray.singleOrNull(predicate: (Long) -> Boolean): Long? {\n    var single: Long? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun FloatArray.singleOrNull(predicate: (Float) -> Boolean): Float? {\n    var single: Float? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun DoubleArray.singleOrNull(predicate: (Double) -> Boolean): Double? {\n    var single: Double? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun BooleanArray.singleOrNull(predicate: (Boolean) -> Boolean): Boolean? {\n    var single: Boolean? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun CharArray.singleOrNull(predicate: (Char) -> Boolean): Char? {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Array<out T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ByteArray.drop(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ShortArray.drop(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun IntArray.drop(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun LongArray.drop(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun FloatArray.drop(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun DoubleArray.drop(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun BooleanArray.drop(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharArray.drop(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Array<out T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ByteArray.dropLast(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun ShortArray.dropLast(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun IntArray.dropLast(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun LongArray.dropLast(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun FloatArray.dropLast(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun DoubleArray.dropLast(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun BooleanArray.dropLast(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun CharArray.dropLast(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Array<out T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ByteArray.dropLastWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ShortArray.dropLastWhile(predicate: (Short) -> Boolean): List<Short> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun IntArray.dropLastWhile(predicate: (Int) -> Boolean): List<Int> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun LongArray.dropLastWhile(predicate: (Long) -> Boolean): List<Long> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun FloatArray.dropLastWhile(predicate: (Float) -> Boolean): List<Float> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun DoubleArray.dropLastWhile(predicate: (Double) -> Boolean): List<Double> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun BooleanArray.dropLastWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharArray.dropLastWhile(predicate: (Char) -> Boolean): List<Char> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Array<out T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ByteArray.dropWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    var yielding = false\n    val list = ArrayList<Byte>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun ShortArray.dropWhile(predicate: (Short) -> Boolean): List<Short> {\n    var yielding = false\n    val list = ArrayList<Short>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun IntArray.dropWhile(predicate: (Int) -> Boolean): List<Int> {\n    var yielding = false\n    val list = ArrayList<Int>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun LongArray.dropWhile(predicate: (Long) -> Boolean): List<Long> {\n    var yielding = false\n    val list = ArrayList<Long>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun FloatArray.dropWhile(predicate: (Float) -> Boolean): List<Float> {\n    var yielding = false\n    val list = ArrayList<Float>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun DoubleArray.dropWhile(predicate: (Double) -> Boolean): List<Double> {\n    var yielding = false\n    val list = ArrayList<Double>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun BooleanArray.dropWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    var yielding = false\n    val list = ArrayList<Boolean>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun CharArray.dropWhile(predicate: (Char) -> Boolean): List<Char> {\n    var yielding = false\n    val list = ArrayList<Char>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Array<out T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ByteArray.filter(predicate: (Byte) -> Boolean): List<Byte> {\n    return filterTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ShortArray.filter(predicate: (Short) -> Boolean): List<Short> {\n    return filterTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun IntArray.filter(predicate: (Int) -> Boolean): List<Int> {\n    return filterTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun LongArray.filter(predicate: (Long) -> Boolean): List<Long> {\n    return filterTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun FloatArray.filter(predicate: (Float) -> Boolean): List<Float> {\n    return filterTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun DoubleArray.filter(predicate: (Double) -> Boolean): List<Double> {\n    return filterTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun BooleanArray.filter(predicate: (Boolean) -> Boolean): List<Boolean> {\n    return filterTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun CharArray.filter(predicate: (Char) -> Boolean): List<Char> {\n    return filterTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun <T> Array<out T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun ByteArray.filterIndexed(predicate: (index: Int, Byte) -> Boolean): List<Byte> {\n    return filterIndexedTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun ShortArray.filterIndexed(predicate: (index: Int, Short) -> Boolean): List<Short> {\n    return filterIndexedTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun IntArray.filterIndexed(predicate: (index: Int, Int) -> Boolean): List<Int> {\n    return filterIndexedTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun LongArray.filterIndexed(predicate: (index: Int, Long) -> Boolean): List<Long> {\n    return filterIndexedTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun FloatArray.filterIndexed(predicate: (index: Int, Float) -> Boolean): List<Float> {\n    return filterIndexedTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun DoubleArray.filterIndexed(predicate: (index: Int, Double) -> Boolean): List<Double> {\n    return filterIndexedTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun BooleanArray.filterIndexed(predicate: (index: Int, Boolean) -> Boolean): List<Boolean> {\n    return filterIndexedTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun CharArray.filterIndexed(predicate: (index: Int, Char) -> Boolean): List<Char> {\n    return filterIndexedTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterIndexedTo(destination: C, predicate: (index: Int, Byte) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterIndexedTo(destination: C, predicate: (index: Int, Short) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterIndexedTo(destination: C, predicate: (index: Int, Int) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterIndexedTo(destination: C, predicate: (index: Int, Long) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterIndexedTo(destination: C, predicate: (index: Int, Float) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterIndexedTo(destination: C, predicate: (index: Int, Double) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterIndexedTo(destination: C, predicate: (index: Int, Boolean) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterIndexedTo(destination: C, predicate: (index: Int, Char) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Array<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Array<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Array<out T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ByteArray.filterNot(predicate: (Byte) -> Boolean): List<Byte> {\n    return filterNotTo(ArrayList<Byte>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun ShortArray.filterNot(predicate: (Short) -> Boolean): List<Short> {\n    return filterNotTo(ArrayList<Short>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun IntArray.filterNot(predicate: (Int) -> Boolean): List<Int> {\n    return filterNotTo(ArrayList<Int>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun LongArray.filterNot(predicate: (Long) -> Boolean): List<Long> {\n    return filterNotTo(ArrayList<Long>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun FloatArray.filterNot(predicate: (Float) -> Boolean): List<Float> {\n    return filterNotTo(ArrayList<Float>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun DoubleArray.filterNot(predicate: (Double) -> Boolean): List<Double> {\n    return filterNotTo(ArrayList<Double>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun BooleanArray.filterNot(predicate: (Boolean) -> Boolean): List<Boolean> {\n    return filterNotTo(ArrayList<Boolean>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun CharArray.filterNot(predicate: (Char) -> Boolean): List<Char> {\n    return filterNotTo(ArrayList<Char>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Array<out T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Array<out T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterNotTo(destination: C, predicate: (Byte) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterNotTo(destination: C, predicate: (Short) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterNotTo(destination: C, predicate: (Int) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterNotTo(destination: C, predicate: (Long) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterNotTo(destination: C, predicate: (Float) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterNotTo(destination: C, predicate: (Double) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterNotTo(destination: C, predicate: (Boolean) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterNotTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Array<out T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Byte>> ByteArray.filterTo(destination: C, predicate: (Byte) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Short>> ShortArray.filterTo(destination: C, predicate: (Short) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Int>> IntArray.filterTo(destination: C, predicate: (Int) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Long>> LongArray.filterTo(destination: C, predicate: (Long) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Float>> FloatArray.filterTo(destination: C, predicate: (Float) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Double>> DoubleArray.filterTo(destination: C, predicate: (Double) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Boolean>> BooleanArray.filterTo(destination: C, predicate: (Boolean) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : MutableCollection<in Char>> CharArray.filterTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> Array<out T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun ByteArray.slice(indices: IntRange): List<Byte> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun ShortArray.slice(indices: IntRange): List<Short> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun IntArray.slice(indices: IntRange): List<Int> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun LongArray.slice(indices: IntRange): List<Long> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun FloatArray.slice(indices: IntRange): List<Float> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun DoubleArray.slice(indices: IntRange): List<Double> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun BooleanArray.slice(indices: IntRange): List<Boolean> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun CharArray.slice(indices: IntRange): List<Char> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> Array<out T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun ByteArray.slice(indices: Iterable<Int>): List<Byte> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Byte>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun ShortArray.slice(indices: Iterable<Int>): List<Short> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Short>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun IntArray.slice(indices: Iterable<Int>): List<Int> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Int>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun LongArray.slice(indices: Iterable<Int>): List<Long> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Long>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun FloatArray.slice(indices: Iterable<Int>): List<Float> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Float>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun DoubleArray.slice(indices: Iterable<Int>): List<Double> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Double>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun BooleanArray.slice(indices: Iterable<Int>): List<Boolean> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Boolean>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun CharArray.slice(indices: Iterable<Int>): List<Char> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<Char>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun <T> Array<T>.sliceArray(indices: Collection<Int>): Array<T> {\n    val result = arrayOfNulls(this, indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun ByteArray.sliceArray(indices: Collection<Int>): ByteArray {\n    val result = ByteArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun ShortArray.sliceArray(indices: Collection<Int>): ShortArray {\n    val result = ShortArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun IntArray.sliceArray(indices: Collection<Int>): IntArray {\n    val result = IntArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun LongArray.sliceArray(indices: Collection<Int>): LongArray {\n    val result = LongArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun FloatArray.sliceArray(indices: Collection<Int>): FloatArray {\n    val result = FloatArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun DoubleArray.sliceArray(indices: Collection<Int>): DoubleArray {\n    val result = DoubleArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun BooleanArray.sliceArray(indices: Collection<Int>): BooleanArray {\n    val result = BooleanArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\npublic fun CharArray.sliceArray(indices: Collection<Int>): CharArray {\n    val result = CharArray(indices.size)\n    var targetIndex = 0\n    for (sourceIndex in indices) {\n        result[targetIndex++] = this[sourceIndex]\n    }\n    return result\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun <T> Array<T>.sliceArray(indices: IntRange): Array<T> {\n    if (indices.isEmpty()) return copyOfRange(0, 0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun ByteArray.sliceArray(indices: IntRange): ByteArray {\n    if (indices.isEmpty()) return ByteArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun ShortArray.sliceArray(indices: IntRange): ShortArray {\n    if (indices.isEmpty()) return ShortArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun IntArray.sliceArray(indices: IntRange): IntArray {\n    if (indices.isEmpty()) return IntArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun LongArray.sliceArray(indices: IntRange): LongArray {\n    if (indices.isEmpty()) return LongArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun FloatArray.sliceArray(indices: IntRange): FloatArray {\n    if (indices.isEmpty()) return FloatArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun DoubleArray.sliceArray(indices: IntRange): DoubleArray {\n    if (indices.isEmpty()) return DoubleArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun BooleanArray.sliceArray(indices: IntRange): BooleanArray {\n    if (indices.isEmpty()) return BooleanArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\npublic fun CharArray.sliceArray(indices: IntRange): CharArray {\n    if (indices.isEmpty()) return CharArray(0)\n    return copyOfRange(indices.start, indices.endInclusive + 1)\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Array<out T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ByteArray.take(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Byte>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ShortArray.take(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Short>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun IntArray.take(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Int>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun LongArray.take(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Long>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun FloatArray.take(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Float>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun DoubleArray.take(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Double>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun BooleanArray.take(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Boolean>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharArray.take(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<Char>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Array<out T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<T>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ByteArray.takeLast(n: Int): List<Byte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Byte>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun ShortArray.takeLast(n: Int): List<Short> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Short>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun IntArray.takeLast(n: Int): List<Int> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Int>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun LongArray.takeLast(n: Int): List<Long> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Long>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun FloatArray.takeLast(n: Int): List<Float> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Float>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun DoubleArray.takeLast(n: Int): List<Double> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Double>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun BooleanArray.takeLast(n: Int): List<Boolean> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Boolean>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun CharArray.takeLast(n: Int): List<Char> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<Char>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Array<out T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ByteArray.takeLastWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ShortArray.takeLastWhile(predicate: (Short) -> Boolean): List<Short> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun IntArray.takeLastWhile(predicate: (Int) -> Boolean): List<Int> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun LongArray.takeLastWhile(predicate: (Long) -> Boolean): List<Long> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun FloatArray.takeLastWhile(predicate: (Float) -> Boolean): List<Float> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun DoubleArray.takeLastWhile(predicate: (Double) -> Boolean): List<Double> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun BooleanArray.takeLastWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharArray.takeLastWhile(predicate: (Char) -> Boolean): List<Char> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Array<out T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ByteArray.takeWhile(predicate: (Byte) -> Boolean): List<Byte> {\n    val list = ArrayList<Byte>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun ShortArray.takeWhile(predicate: (Short) -> Boolean): List<Short> {\n    val list = ArrayList<Short>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun IntArray.takeWhile(predicate: (Int) -> Boolean): List<Int> {\n    val list = ArrayList<Int>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun LongArray.takeWhile(predicate: (Long) -> Boolean): List<Long> {\n    val list = ArrayList<Long>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun FloatArray.takeWhile(predicate: (Float) -> Boolean): List<Float> {\n    val list = ArrayList<Float>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun DoubleArray.takeWhile(predicate: (Double) -> Boolean): List<Double> {\n    val list = ArrayList<Double>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun BooleanArray.takeWhile(predicate: (Boolean) -> Boolean): List<Boolean> {\n    val list = ArrayList<Boolean>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun CharArray.takeWhile(predicate: (Char) -> Boolean): List<Char> {\n    val list = ArrayList<Char>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun <T> Array<T>.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun ByteArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun ShortArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun IntArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun LongArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun FloatArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun DoubleArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun BooleanArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements in the array in-place.\n */\npublic fun CharArray.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val midPoint = (fromIndex + toIndex) / 2\n    if (fromIndex == midPoint) return\n    var reverseIndex = toIndex - 1\n    for (index in fromIndex until midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Array<out T>.reversed(): List<T> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun ByteArray.reversed(): List<Byte> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun ShortArray.reversed(): List<Short> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun IntArray.reversed(): List<Int> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun LongArray.reversed(): List<Long> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun FloatArray.reversed(): List<Float> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun DoubleArray.reversed(): List<Double> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun BooleanArray.reversed(): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun CharArray.reversed(): List<Char> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun <T> Array<T>.reversedArray(): Array<T> {\n    if (isEmpty()) return this\n    val result = arrayOfNulls(this, size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun ByteArray.reversedArray(): ByteArray {\n    if (isEmpty()) return this\n    val result = ByteArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun ShortArray.reversedArray(): ShortArray {\n    if (isEmpty()) return this\n    val result = ShortArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun IntArray.reversedArray(): IntArray {\n    if (isEmpty()) return this\n    val result = IntArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun LongArray.reversedArray(): LongArray {\n    if (isEmpty()) return this\n    val result = LongArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun FloatArray.reversedArray(): FloatArray {\n    if (isEmpty()) return this\n    val result = FloatArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun DoubleArray.reversedArray(): DoubleArray {\n    if (isEmpty()) return this\n    val result = DoubleArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun BooleanArray.reversedArray(): BooleanArray {\n    if (isEmpty()) return this\n    val result = BooleanArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\npublic fun CharArray.reversedArray(): CharArray {\n    if (isEmpty()) return this\n    val result = CharArray(size)\n    val lastIndex = lastIndex\n    for (i in 0..lastIndex)\n        result[lastIndex - i] = this[i]\n    return result\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Sorts elements in the array in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the array in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun ByteArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun ShortArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun IntArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun LongArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun FloatArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun DoubleArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\npublic fun CharArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sorted(): List<T> {\n    return sortedArray().asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun ByteArray.sorted(): List<Byte> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun ShortArray.sorted(): List<Short> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun IntArray.sorted(): List<Int> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun LongArray.sorted(): List<Long> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun FloatArray.sorted(): List<Float> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun DoubleArray.sorted(): List<Double> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\npublic fun CharArray.sorted(): List<Char> {\n    return toTypedArray().apply { sort() }.asList()\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<T>.sortedArray(): Array<T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun ByteArray.sortedArray(): ByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun ShortArray.sortedArray(): ShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun IntArray.sortedArray(): IntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun LongArray.sortedArray(): LongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun FloatArray.sortedArray(): FloatArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun DoubleArray.sortedArray(): DoubleArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\npublic fun CharArray.sortedArray(): CharArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<T>.sortedArrayDescending(): Array<T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortWith(reverseOrder()) }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun ByteArray.sortedArrayDescending(): ByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun ShortArray.sortedArrayDescending(): ShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun IntArray.sortedArrayDescending(): IntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun LongArray.sortedArrayDescending(): LongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun FloatArray.sortedArrayDescending(): FloatArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun DoubleArray.sortedArrayDescending(): DoubleArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\npublic fun CharArray.sortedArrayDescending(): CharArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sortedArrayWith(comparator: Comparator<in T>): Array<out T> {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortWith(comparator) }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> ByteArray.sortedBy(crossinline selector: (Byte) -> R?): List<Byte> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> ShortArray.sortedBy(crossinline selector: (Short) -> R?): List<Short> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> IntArray.sortedBy(crossinline selector: (Int) -> R?): List<Int> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> LongArray.sortedBy(crossinline selector: (Long) -> R?): List<Long> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> FloatArray.sortedBy(crossinline selector: (Float) -> R?): List<Float> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> DoubleArray.sortedBy(crossinline selector: (Double) -> R?): List<Double> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> BooleanArray.sortedBy(crossinline selector: (Boolean) -> R?): List<Boolean> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <R : Comparable<R>> CharArray.sortedBy(crossinline selector: (Char) -> R?): List<Char> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Array<out T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ByteArray.sortedByDescending(crossinline selector: (Byte) -> R?): List<Byte> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> ShortArray.sortedByDescending(crossinline selector: (Short) -> R?): List<Short> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> IntArray.sortedByDescending(crossinline selector: (Int) -> R?): List<Int> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> LongArray.sortedByDescending(crossinline selector: (Long) -> R?): List<Long> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> FloatArray.sortedByDescending(crossinline selector: (Float) -> R?): List<Float> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> DoubleArray.sortedByDescending(crossinline selector: (Double) -> R?): List<Double> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> BooleanArray.sortedByDescending(crossinline selector: (Boolean) -> R?): List<Boolean> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n */\npublic inline fun <R : Comparable<R>> CharArray.sortedByDescending(crossinline selector: (Char) -> R?): List<Char> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Array<out T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun ByteArray.sortedDescending(): List<Byte> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun ShortArray.sortedDescending(): List<Short> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun IntArray.sortedDescending(): List<Int> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun LongArray.sortedDescending(): List<Long> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun FloatArray.sortedDescending(): List<Float> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun DoubleArray.sortedDescending(): List<Double> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n */\npublic fun CharArray.sortedDescending(): List<Char> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Array<out T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    return sortedArrayWith(comparator).asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun ByteArray.sortedWith(comparator: Comparator<in Byte>): List<Byte> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun ShortArray.sortedWith(comparator: Comparator<in Short>): List<Short> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun IntArray.sortedWith(comparator: Comparator<in Int>): List<Int> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun LongArray.sortedWith(comparator: Comparator<in Long>): List<Long> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun FloatArray.sortedWith(comparator: Comparator<in Float>): List<Float> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun DoubleArray.sortedWith(comparator: Comparator<in Double>): List<Double> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun BooleanArray.sortedWith(comparator: Comparator<in Boolean>): List<Boolean> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n */\npublic fun CharArray.sortedWith(comparator: Comparator<in Char>): List<Char> {\n    return toTypedArray().apply { sortWith(comparator) }.asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun <T> Array<out T>.asList(): List<T>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun ByteArray.asList(): List<Byte>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun ShortArray.asList(): List<Short>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun IntArray.asList(): List<Int>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun LongArray.asList(): List<Long>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun FloatArray.asList(): List<Float>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun DoubleArray.asList(): List<Double>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun BooleanArray.asList(): List<Boolean>\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic expect fun CharArray.asList(): List<Char>\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect infix fun <T> Array<out T>.contentDeepEquals(other: Array<out T>): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The specified arrays are also considered deeply equal if both are `null`.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun <T> Array<out T>?.contentDeepEquals(other: Array<out T>?): Boolean\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect fun <T> Array<out T>.contentDeepHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentDeepHashCode(): Int\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic expect fun <T> Array<out T>.contentDeepToString(): String\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentDeepToString(): String\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun <T> Array<out T>.contentEquals(other: Array<out T>): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun ByteArray.contentEquals(other: ByteArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun ShortArray.contentEquals(other: ShortArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun IntArray.contentEquals(other: IntArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun LongArray.contentEquals(other: LongArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun FloatArray.contentEquals(other: FloatArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun DoubleArray.contentEquals(other: DoubleArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun BooleanArray.contentEquals(other: BooleanArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect infix fun CharArray.contentEquals(other: CharArray): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun <T> Array<out T>?.contentEquals(other: Array<out T>?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun ByteArray?.contentEquals(other: ByteArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun ShortArray?.contentEquals(other: ShortArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun IntArray?.contentEquals(other: IntArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun LongArray?.contentEquals(other: LongArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun FloatArray?.contentEquals(other: FloatArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun DoubleArray?.contentEquals(other: DoubleArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun BooleanArray?.contentEquals(other: BooleanArray?): Boolean\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\npublic expect infix fun CharArray?.contentEquals(other: CharArray?): Boolean\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun <T> Array<out T>.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ByteArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ShortArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun IntArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun LongArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun FloatArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun DoubleArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun BooleanArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun CharArray.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun BooleanArray?.contentHashCode(): Int\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray?.contentHashCode(): Int\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun <T> Array<out T>.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ByteArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun ShortArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun IntArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun LongArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun FloatArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun DoubleArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun BooleanArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic expect fun CharArray.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T> Array<out T>?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun BooleanArray?.contentToString(): String\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray?.contentToString(): String\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun <T> Array<out T>.copyInto(destination: Array<T>, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): Array<T>\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ByteArray.copyInto(destination: ByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ByteArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ShortArray.copyInto(destination: ShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ShortArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun IntArray.copyInto(destination: IntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): IntArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun LongArray.copyInto(destination: LongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): LongArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun FloatArray.copyInto(destination: FloatArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): FloatArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun DoubleArray.copyInto(destination: DoubleArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): DoubleArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun BooleanArray.copyInto(destination: BooleanArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): BooleanArray\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\npublic expect fun CharArray.copyInto(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): CharArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOf(): Array<T>\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun ByteArray.copyOf(): ByteArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun ShortArray.copyOf(): ShortArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun IntArray.copyOf(): IntArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun LongArray.copyOf(): LongArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun FloatArray.copyOf(): FloatArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun DoubleArray.copyOf(): DoubleArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun BooleanArray.copyOf(): BooleanArray\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic expect fun CharArray.copyOf(): CharArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun ByteArray.copyOf(newSize: Int): ByteArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun ShortArray.copyOf(newSize: Int): ShortArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun IntArray.copyOf(newSize: Int): IntArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun LongArray.copyOf(newSize: Int): LongArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun FloatArray.copyOf(newSize: Int): FloatArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun DoubleArray.copyOf(newSize: Int): DoubleArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `false` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `false` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun BooleanArray.copyOf(newSize: Int): BooleanArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with null char (`\\u0000`) values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with null char (`\\u0000`) values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic expect fun CharArray.copyOf(newSize: Int): CharArray\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `null` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `null` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizingCopyOf\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOf(newSize: Int): Array<T?>\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.copyOfRange(fromIndex: Int, toIndex: Int): Array<T>\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun ByteArray.copyOfRange(fromIndex: Int, toIndex: Int): ByteArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun ShortArray.copyOfRange(fromIndex: Int, toIndex: Int): ShortArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun IntArray.copyOfRange(fromIndex: Int, toIndex: Int): IntArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun LongArray.copyOfRange(fromIndex: Int, toIndex: Int): LongArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun FloatArray.copyOfRange(fromIndex: Int, toIndex: Int): FloatArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun <T> Array<T>.fill(element: T, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ByteArray.fill(element: Byte, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun ShortArray.fill(element: Short, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun IntArray.fill(element: Int, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun LongArray.fill(element: Long, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun FloatArray.fill(element: Float, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun DoubleArray.fill(element: Double, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun BooleanArray.fill(element: Boolean, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\npublic expect fun CharArray.fill(element: Char, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val <T> Array<out T>.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val ByteArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val ShortArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val IntArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val LongArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val FloatArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val DoubleArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val BooleanArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns the range of valid indices for the array.\n */\npublic val CharArray.indices: IntRange\n    get() = IntRange(0, lastIndex)\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.isEmpty(): Boolean {\n    return size == 0\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if the array is not empty.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.isNotEmpty(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns the last valid index for the array.\n */\npublic val <T> Array<out T>.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val ByteArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val ShortArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val IntArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val LongArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val FloatArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val DoubleArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val BooleanArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns the last valid index for the array.\n */\npublic val CharArray.lastIndex: Int\n    get() = size - 1\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(element: T): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun ByteArray.plus(element: Byte): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun ShortArray.plus(element: Short): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun IntArray.plus(element: Int): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun LongArray.plus(element: Long): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun FloatArray.plus(element: Float): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun DoubleArray.plus(element: Double): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun BooleanArray.plus(element: Boolean): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\npublic expect operator fun CharArray.plus(element: Char): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(elements: Collection<T>): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun ShortArray.plus(elements: Collection<Short>): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun IntArray.plus(elements: Collection<Int>): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun LongArray.plus(elements: Collection<Long>): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun FloatArray.plus(elements: Collection<Float>): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic expect operator fun CharArray.plus(elements: Collection<Char>): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect operator fun <T> Array<T>.plus(elements: Array<out T>): Array<T>\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun ByteArray.plus(elements: ByteArray): ByteArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun ShortArray.plus(elements: ShortArray): ShortArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun IntArray.plus(elements: IntArray): IntArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun LongArray.plus(elements: LongArray): LongArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun FloatArray.plus(elements: FloatArray): FloatArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\npublic expect operator fun CharArray.plus(elements: CharArray): CharArray\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun <T> Array<T>.plusElement(element: T): Array<T>\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun IntArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun LongArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun ByteArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun ShortArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun DoubleArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun FloatArray.sort(): Unit\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic expect fun CharArray.sort(): Unit\n\n/**\n * Sorts the array in-place according to the natural order of its elements.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Arrays.Sorting.sortArrayOfComparable\n */\npublic expect fun <T : Comparable<T>> Array<out T>.sort(): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArrayOfComparable\n */\n@SinceKotlin(\"1.4\")\npublic expect fun <T : Comparable<T>> Array<out T>.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ByteArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun ShortArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun IntArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun LongArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun FloatArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun DoubleArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\npublic expect fun CharArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sortWith(reverseOrder(), fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic expect fun <T> Array<out T>.sortWith(comparator: Comparator<in T>): Unit\n\n/**\n * Sorts a range in the array in-place with the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic expect fun <T> Array<out T>.sortWith(comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Unit\n\n/**\n * Returns an array of Boolean containing all of the elements of this generic array.\n */\npublic fun Array<out Boolean>.toBooleanArray(): BooleanArray {\n    return BooleanArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this generic array.\n */\npublic fun Array<out Byte>.toByteArray(): ByteArray {\n    return ByteArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Char containing all of the elements of this generic array.\n */\npublic fun Array<out Char>.toCharArray(): CharArray {\n    return CharArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Double containing all of the elements of this generic array.\n */\npublic fun Array<out Double>.toDoubleArray(): DoubleArray {\n    return DoubleArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Float containing all of the elements of this generic array.\n */\npublic fun Array<out Float>.toFloatArray(): FloatArray {\n    return FloatArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Int containing all of the elements of this generic array.\n */\npublic fun Array<out Int>.toIntArray(): IntArray {\n    return IntArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Long containing all of the elements of this generic array.\n */\npublic fun Array<out Long>.toLongArray(): LongArray {\n    return LongArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of Short containing all of the elements of this generic array.\n */\npublic fun Array<out Short>.toShortArray(): ShortArray {\n    return ShortArray(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun ByteArray.toTypedArray(): Array<Byte>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun ShortArray.toTypedArray(): Array<Short>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun IntArray.toTypedArray(): Array<Int>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun LongArray.toTypedArray(): Array<Long>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun FloatArray.toTypedArray(): Array<Float>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun DoubleArray.toTypedArray(): Array<Double>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun BooleanArray.toTypedArray(): Array<Boolean>\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic expect fun CharArray.toTypedArray(): Array<Char>\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <T, K, V> Array<out T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> ByteArray.associate(transform: (Byte) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> ShortArray.associate(transform: (Short) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> IntArray.associate(transform: (Int) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> LongArray.associate(transform: (Long) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> FloatArray.associate(transform: (Float) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> DoubleArray.associate(transform: (Double) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> BooleanArray.associate(transform: (Boolean) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitives\n */\npublic inline fun <K, V> CharArray.associate(transform: (Char) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <T, K> Array<out T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> ByteArray.associateBy(keySelector: (Byte) -> K): Map<K, Byte> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Byte>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> ShortArray.associateBy(keySelector: (Short) -> K): Map<K, Short> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Short>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> IntArray.associateBy(keySelector: (Int) -> K): Map<K, Int> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Int>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> LongArray.associateBy(keySelector: (Long) -> K): Map<K, Long> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Long>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> FloatArray.associateBy(keySelector: (Float) -> K): Map<K, Float> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Float>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> DoubleArray.associateBy(keySelector: (Double) -> K): Map<K, Double> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Double>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> BooleanArray.associateBy(keySelector: (Boolean) -> K): Map<K, Boolean> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Boolean>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the elements from the given array indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesBy\n */\npublic inline fun <K> CharArray.associateBy(keySelector: (Char) -> K): Map<K, Char> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Char>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <T, K, V> Array<out T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> ByteArray.associateBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> ShortArray.associateBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> IntArray.associateBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> LongArray.associateBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> FloatArray.associateBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> DoubleArray.associateBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> BooleanArray.associateBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByWithValueTransform\n */\npublic inline fun <K, V> CharArray.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V> {\n    val capacity = mapCapacity(size).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Array<out T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Byte>> ByteArray.associateByTo(destination: M, keySelector: (Byte) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Short>> ShortArray.associateByTo(destination: M, keySelector: (Short) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Int>> IntArray.associateByTo(destination: M, keySelector: (Int) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Long>> LongArray.associateByTo(destination: M, keySelector: (Long) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Float>> FloatArray.associateByTo(destination: M, keySelector: (Float) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Double>> DoubleArray.associateByTo(destination: M, keySelector: (Double) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Boolean>> BooleanArray.associateByTo(destination: M, keySelector: (Boolean) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given array\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Char>> CharArray.associateByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateByTo(destination: M, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateByTo(destination: M, keySelector: (Short) -> K, valueTransform: (Short) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateByTo(destination: M, keySelector: (Int) -> K, valueTransform: (Int) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateByTo(destination: M, keySelector: (Long) -> K, valueTransform: (Long) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateByTo(destination: M, keySelector: (Float) -> K, valueTransform: (Float) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateByTo(destination: M, keySelector: (Double) -> K, valueTransform: (Double) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateByTo(destination: M, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given array.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Array<out T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ByteArray.associateTo(destination: M, transform: (Byte) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> ShortArray.associateTo(destination: M, transform: (Short) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> IntArray.associateTo(destination: M, transform: (Int) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> LongArray.associateTo(destination: M, transform: (Long) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> FloatArray.associateTo(destination: M, transform: (Float) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> DoubleArray.associateTo(destination: M, transform: (Double) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> BooleanArray.associateTo(destination: M, transform: (Boolean) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given array.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Arrays.Transformations.associateArrayOfPrimitivesTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharArray.associateTo(destination: M, transform: (Char) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <K, V> Array<out K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> ByteArray.associateWith(valueSelector: (Byte) -> V): Map<Byte, V> {\n    val result = LinkedHashMap<Byte, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> ShortArray.associateWith(valueSelector: (Short) -> V): Map<Short, V> {\n    val result = LinkedHashMap<Short, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> IntArray.associateWith(valueSelector: (Int) -> V): Map<Int, V> {\n    val result = LinkedHashMap<Int, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> LongArray.associateWith(valueSelector: (Long) -> V): Map<Long, V> {\n    val result = LinkedHashMap<Long, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> FloatArray.associateWith(valueSelector: (Float) -> V): Map<Float, V> {\n    val result = LinkedHashMap<Float, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> DoubleArray.associateWith(valueSelector: (Double) -> V): Map<Double, V> {\n    val result = LinkedHashMap<Double, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> BooleanArray.associateWith(valueSelector: (Boolean) -> V): Map<Boolean, V> {\n    val result = LinkedHashMap<Boolean, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V> CharArray.associateWith(valueSelector: (Char) -> V): Map<Char, V> {\n    val result = LinkedHashMap<Char, V>(mapCapacity(size.coerceAtMost(128)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Array<out K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Byte, in V>> ByteArray.associateWithTo(destination: M, valueSelector: (Byte) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Short, in V>> ShortArray.associateWithTo(destination: M, valueSelector: (Short) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Int, in V>> IntArray.associateWithTo(destination: M, valueSelector: (Int) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Long, in V>> LongArray.associateWithTo(destination: M, valueSelector: (Long) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Float, in V>> FloatArray.associateWithTo(destination: M, valueSelector: (Float) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Double, in V>> DoubleArray.associateWithTo(destination: M, valueSelector: (Double) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Boolean, in V>> BooleanArray.associateWithTo(destination: M, valueSelector: (Boolean) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in Char, in V>> CharArray.associateWithTo(destination: M, valueSelector: (Char) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Array<out T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Byte>> ByteArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Short>> ShortArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Int>> IntArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Long>> LongArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Float>> FloatArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Double>> DoubleArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Boolean>> BooleanArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Char>> CharArray.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun <T> Array<out T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun ByteArray.toHashSet(): HashSet<Byte> {\n    return toCollection(HashSet<Byte>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun ShortArray.toHashSet(): HashSet<Short> {\n    return toCollection(HashSet<Short>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun IntArray.toHashSet(): HashSet<Int> {\n    return toCollection(HashSet<Int>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun LongArray.toHashSet(): HashSet<Long> {\n    return toCollection(HashSet<Long>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun FloatArray.toHashSet(): HashSet<Float> {\n    return toCollection(HashSet<Float>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun DoubleArray.toHashSet(): HashSet<Double> {\n    return toCollection(HashSet<Double>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun BooleanArray.toHashSet(): HashSet<Boolean> {\n    return toCollection(HashSet<Boolean>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun CharArray.toHashSet(): HashSet<Char> {\n    return toCollection(HashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Array<out T>.toList(): List<T> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun ByteArray.toList(): List<Byte> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun ShortArray.toList(): List<Short> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun IntArray.toList(): List<Int> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun LongArray.toList(): List<Long> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun FloatArray.toList(): List<Float> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun DoubleArray.toList(): List<Double> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun BooleanArray.toList(): List<Boolean> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun CharArray.toList(): List<Char> {\n    return when (size) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun <T> Array<out T>.toMutableList(): MutableList<T> {\n    return ArrayList(this.asCollection())\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun ByteArray.toMutableList(): MutableList<Byte> {\n    val list = ArrayList<Byte>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun ShortArray.toMutableList(): MutableList<Short> {\n    val list = ArrayList<Short>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun IntArray.toMutableList(): MutableList<Int> {\n    val list = ArrayList<Int>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun LongArray.toMutableList(): MutableList<Long> {\n    val list = ArrayList<Long>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun FloatArray.toMutableList(): MutableList<Float> {\n    val list = ArrayList<Float>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun DoubleArray.toMutableList(): MutableList<Double> {\n    val list = ArrayList<Double>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun BooleanArray.toMutableList(): MutableList<Boolean> {\n    val list = ArrayList<Boolean>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this array.\n */\npublic fun CharArray.toMutableList(): MutableList<Char> {\n    val list = ArrayList<Char>(size)\n    for (item in this) list.add(item)\n    return list\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun <T> Array<out T>.toSet(): Set<T> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ByteArray.toSet(): Set<Byte> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Byte>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ShortArray.toSet(): Set<Short> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Short>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun IntArray.toSet(): Set<Int> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Int>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun LongArray.toSet(): Set<Long> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Long>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun FloatArray.toSet(): Set<Float> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Float>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun DoubleArray.toSet(): Set<Double> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Double>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun BooleanArray.toSet(): Set<Boolean> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Boolean>(mapCapacity(size)))\n    }\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun CharArray.toSet(): Set<Char> {\n    return when (size) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n    }\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <T, R> Array<out T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> ByteArray.flatMap(transform: (Byte) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> ShortArray.flatMap(transform: (Short) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> IntArray.flatMap(transform: (Int) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> LongArray.flatMap(transform: (Long) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> FloatArray.flatMap(transform: (Float) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> DoubleArray.flatMap(transform: (Double) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> BooleanArray.flatMap(transform: (Boolean) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> CharArray.flatMap(transform: (Char) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <T, R> Array<out T>.flatMap(transform: (T) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.flatMapIndexed(transform: (index: Int, Byte) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.flatMapIndexed(transform: (index: Int, Short) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.flatMapIndexed(transform: (index: Int, Int) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.flatMapIndexed(transform: (index: Int, Long) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.flatMapIndexed(transform: (index: Int, Float) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.flatMapIndexed(transform: (index: Int, Double) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.flatMapIndexed(transform: (index: Int, Boolean) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.flatMapIndexed(transform: (index: Int, Char) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.flatMapIndexedTo(destination: C, transform: (index: Int, Byte) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.flatMapIndexedTo(destination: C, transform: (index: Int, Short) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> IntArray.flatMapIndexedTo(destination: C, transform: (index: Int, Int) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> LongArray.flatMapIndexedTo(destination: C, transform: (index: Int, Long) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.flatMapIndexedTo(destination: C, transform: (index: Int, Float) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.flatMapIndexedTo(destination: C, transform: (index: Int, Double) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.flatMapIndexedTo(destination: C, transform: (index: Int, Boolean) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> CharArray.flatMapIndexedTo(destination: C, transform: (index: Int, Char) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.flatMapTo(destination: C, transform: (Byte) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.flatMapTo(destination: C, transform: (Short) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.flatMapTo(destination: C, transform: (Int) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.flatMapTo(destination: C, transform: (Long) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.flatMapTo(destination: C, transform: (Float) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.flatMapTo(destination: C, transform: (Double) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.flatMapTo(destination: C, transform: (Boolean) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.flatMapTo(destination: C, transform: (Char) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Array<out T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> ByteArray.groupBy(keySelector: (Byte) -> K): Map<K, List<Byte>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Byte>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> ShortArray.groupBy(keySelector: (Short) -> K): Map<K, List<Short>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Short>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> IntArray.groupBy(keySelector: (Int) -> K): Map<K, List<Int>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Int>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> LongArray.groupBy(keySelector: (Long) -> K): Map<K, List<Long>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Long>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> FloatArray.groupBy(keySelector: (Float) -> K): Map<K, List<Float>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Float>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> DoubleArray.groupBy(keySelector: (Double) -> K): Map<K, List<Double>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Double>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> BooleanArray.groupBy(keySelector: (Boolean) -> K): Map<K, List<Boolean>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Boolean>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> CharArray.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Char>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Array<out T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> ByteArray.groupBy(keySelector: (Byte) -> K, valueTransform: (Byte) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> ShortArray.groupBy(keySelector: (Short) -> K, valueTransform: (Short) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> IntArray.groupBy(keySelector: (Int) -> K, valueTransform: (Int) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> LongArray.groupBy(keySelector: (Long) -> K, valueTransform: (Long) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> FloatArray.groupBy(keySelector: (Float) -> K, valueTransform: (Float) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> DoubleArray.groupBy(keySelector: (Double) -> K, valueTransform: (Double) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> BooleanArray.groupBy(keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> CharArray.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Array<out T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Byte>>> ByteArray.groupByTo(destination: M, keySelector: (Byte) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Byte>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Short>>> ShortArray.groupByTo(destination: M, keySelector: (Short) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Short>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Int>>> IntArray.groupByTo(destination: M, keySelector: (Int) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Int>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Long>>> LongArray.groupByTo(destination: M, keySelector: (Long) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Long>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Float>>> FloatArray.groupByTo(destination: M, keySelector: (Float) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Float>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Double>>> DoubleArray.groupByTo(destination: M, keySelector: (Double) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Double>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Boolean>>> BooleanArray.groupByTo(destination: M, keySelector: (Boolean) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Boolean>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharArray.groupByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Char>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Array<out T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ByteArray.groupByTo(destination: M, keySelector: (Byte) -> K, valueTransform: (Byte) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ShortArray.groupByTo(destination: M, keySelector: (Short) -> K, valueTransform: (Short) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> IntArray.groupByTo(destination: M, keySelector: (Int) -> K, valueTransform: (Int) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> LongArray.groupByTo(destination: M, keySelector: (Long) -> K, valueTransform: (Long) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> FloatArray.groupByTo(destination: M, keySelector: (Float) -> K, valueTransform: (Float) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> DoubleArray.groupByTo(destination: M, keySelector: (Double) -> K, valueTransform: (Double) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> BooleanArray.groupByTo(destination: M, keySelector: (Boolean) -> K, valueTransform: (Boolean) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharArray.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from an array to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Array<out T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Array<out T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> ByteArray.map(transform: (Byte) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> ShortArray.map(transform: (Short) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> IntArray.map(transform: (Int) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> LongArray.map(transform: (Long) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> FloatArray.map(transform: (Float) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> DoubleArray.map(transform: (Double) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> BooleanArray.map(transform: (Boolean) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <R> CharArray.map(transform: (Char) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Array<out T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> ByteArray.mapIndexed(transform: (index: Int, Byte) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> ShortArray.mapIndexed(transform: (index: Int, Short) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> IntArray.mapIndexed(transform: (index: Int, Int) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> LongArray.mapIndexed(transform: (index: Int, Long) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> FloatArray.mapIndexed(transform: (index: Int, Float) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> DoubleArray.mapIndexed(transform: (index: Int, Double) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> BooleanArray.mapIndexed(transform: (index: Int, Boolean) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R> CharArray.mapIndexed(transform: (index: Int, Char) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Array<out T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Array<out T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.mapIndexedTo(destination: C, transform: (index: Int, Byte) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.mapIndexedTo(destination: C, transform: (index: Int, Short) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.mapIndexedTo(destination: C, transform: (index: Int, Int) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.mapIndexedTo(destination: C, transform: (index: Int, Long) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.mapIndexedTo(destination: C, transform: (index: Int, Float) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.mapIndexedTo(destination: C, transform: (index: Int, Double) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.mapIndexedTo(destination: C, transform: (index: Int, Boolean) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.mapIndexedTo(destination: C, transform: (index: Int, Char) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <T, R : Any> Array<out T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original array\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Array<out T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Array<out T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ByteArray.mapTo(destination: C, transform: (Byte) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> ShortArray.mapTo(destination: C, transform: (Short) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> IntArray.mapTo(destination: C, transform: (Int) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> LongArray.mapTo(destination: C, transform: (Long) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> FloatArray.mapTo(destination: C, transform: (Float) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> DoubleArray.mapTo(destination: C, transform: (Double) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> BooleanArray.mapTo(destination: C, transform: (Boolean) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharArray.mapTo(destination: C, transform: (Char) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Array<out T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun ByteArray.withIndex(): Iterable<IndexedValue<Byte>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun ShortArray.withIndex(): Iterable<IndexedValue<Short>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun IntArray.withIndex(): Iterable<IndexedValue<Int>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun LongArray.withIndex(): Iterable<IndexedValue<Long>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun FloatArray.withIndex(): Iterable<IndexedValue<Float>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun DoubleArray.withIndex(): Iterable<IndexedValue<Double>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun BooleanArray.withIndex(): Iterable<IndexedValue<Boolean>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun CharArray.withIndex(): Iterable<IndexedValue<Char>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * Among equal elements of the given array, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Array<out T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun ByteArray.distinct(): List<Byte> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun ShortArray.distinct(): List<Short> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun IntArray.distinct(): List<Int> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun LongArray.distinct(): List<Long> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun FloatArray.distinct(): List<Float> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun DoubleArray.distinct(): List<Double> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun BooleanArray.distinct(): List<Boolean> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only distinct elements from the given array.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun CharArray.distinct(): List<Char> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given array with equal keys, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <T, K> Array<out T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> ByteArray.distinctBy(selector: (Byte) -> K): List<Byte> {\n    val set = HashSet<K>()\n    val list = ArrayList<Byte>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> ShortArray.distinctBy(selector: (Short) -> K): List<Short> {\n    val set = HashSet<K>()\n    val list = ArrayList<Short>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> IntArray.distinctBy(selector: (Int) -> K): List<Int> {\n    val set = HashSet<K>()\n    val list = ArrayList<Int>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> LongArray.distinctBy(selector: (Long) -> K): List<Long> {\n    val set = HashSet<K>()\n    val list = ArrayList<Long>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> FloatArray.distinctBy(selector: (Float) -> K): List<Float> {\n    val set = HashSet<K>()\n    val list = ArrayList<Float>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> DoubleArray.distinctBy(selector: (Double) -> K): List<Double> {\n    val set = HashSet<K>()\n    val list = ArrayList<Double>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> BooleanArray.distinctBy(selector: (Boolean) -> K): List<Boolean> {\n    val set = HashSet<K>()\n    val list = ArrayList<Boolean>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a list containing only elements from the given array\n * having distinct keys returned by the given [selector] function.\n * \n * The elements in the resulting list are in the same order as they were in the source array.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <K> CharArray.distinctBy(selector: (Char) -> K): List<Char> {\n    val set = HashSet<K>()\n    val list = ArrayList<Char>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Array<out T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun ByteArray.intersect(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun ShortArray.intersect(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun IntArray.intersect(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun LongArray.intersect(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun FloatArray.intersect(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun DoubleArray.intersect(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun BooleanArray.intersect(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by both this array and the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun CharArray.intersect(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun <T> Array<out T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ByteArray.subtract(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun ShortArray.subtract(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun IntArray.subtract(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun LongArray.subtract(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun FloatArray.subtract(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun DoubleArray.subtract(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun BooleanArray.subtract(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this array and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic infix fun CharArray.subtract(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun <T> Array<out T>.toMutableSet(): MutableSet<T> {\n    return toCollection(LinkedHashSet<T>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ByteArray.toMutableSet(): MutableSet<Byte> {\n    return toCollection(LinkedHashSet<Byte>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun ShortArray.toMutableSet(): MutableSet<Short> {\n    return toCollection(LinkedHashSet<Short>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun IntArray.toMutableSet(): MutableSet<Int> {\n    return toCollection(LinkedHashSet<Int>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun LongArray.toMutableSet(): MutableSet<Long> {\n    return toCollection(LinkedHashSet<Long>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun FloatArray.toMutableSet(): MutableSet<Float> {\n    return toCollection(LinkedHashSet<Float>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun DoubleArray.toMutableSet(): MutableSet<Double> {\n    return toCollection(LinkedHashSet<Double>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun BooleanArray.toMutableSet(): MutableSet<Boolean> {\n    return toCollection(LinkedHashSet<Boolean>(mapCapacity(size)))\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given array.\n * \n * The returned set preserves the element iteration order of the original array.\n */\npublic fun CharArray.toMutableSet(): MutableSet<Char> {\n    return toCollection(LinkedHashSet<Char>(mapCapacity(size.coerceAtMost(128))))\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Array<out T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun ByteArray.union(other: Iterable<Byte>): Set<Byte> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun ShortArray.union(other: Iterable<Short>): Set<Short> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun IntArray.union(other: Iterable<Int>): Set<Int> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun LongArray.union(other: Iterable<Long>): Set<Long> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun FloatArray.union(other: Iterable<Float>): Set<Float> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun DoubleArray.union(other: Iterable<Double>): Set<Double> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun BooleanArray.union(other: Iterable<Boolean>): Set<Boolean> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original array.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun CharArray.union(other: Iterable<Char>): Set<Char> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Array<out T>.all(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun ByteArray.all(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun ShortArray.all(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun IntArray.all(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun LongArray.all(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun FloatArray.all(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun DoubleArray.all(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun BooleanArray.all(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun CharArray.all(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Array<out T>.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun ByteArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun ShortArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun IntArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun LongArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun FloatArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun DoubleArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun BooleanArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun CharArray.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Array<out T>.any(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun ByteArray.any(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun ShortArray.any(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun IntArray.any(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun LongArray.any(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun FloatArray.any(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun DoubleArray.any(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun BooleanArray.any(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun CharArray.any(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements in this array.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Array<out T>.count(predicate: (T) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun ByteArray.count(predicate: (Byte) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun ShortArray.count(predicate: (Short) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun IntArray.count(predicate: (Int) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun LongArray.count(predicate: (Long) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun FloatArray.count(predicate: (Float) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun DoubleArray.count(predicate: (Double) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun BooleanArray.count(predicate: (Boolean) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun CharArray.count(predicate: (Char) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.fold(initial: R, operation: (acc: R, Byte) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.fold(initial: R, operation: (acc: R, Short) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.fold(initial: R, operation: (acc: R, Int) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.fold(initial: R, operation: (acc: R, Long) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.fold(initial: R, operation: (acc: R, Float) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.fold(initial: R, operation: (acc: R, Double) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.fold(initial: R, operation: (acc: R, Boolean) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.fold(initial: R, operation: (acc: R, Char) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldRight(initial: R, operation: (Byte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldRight(initial: R, operation: (Short, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldRight(initial: R, operation: (Int, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldRight(initial: R, operation: (Long, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldRight(initial: R, operation: (Float, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldRight(initial: R, operation: (Double, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldRight(initial: R, operation: (Boolean, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldRight(initial: R, operation: (Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Array<out T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ByteArray.foldRightIndexed(initial: R, operation: (index: Int, Byte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> ShortArray.foldRightIndexed(initial: R, operation: (index: Int, Short, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> IntArray.foldRightIndexed(initial: R, operation: (index: Int, Int, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> LongArray.foldRightIndexed(initial: R, operation: (index: Int, Long, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> FloatArray.foldRightIndexed(initial: R, operation: (index: Int, Float, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> DoubleArray.foldRightIndexed(initial: R, operation: (index: Int, Double, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> BooleanArray.foldRightIndexed(initial: R, operation: (index: Int, Boolean, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharArray.foldRightIndexed(initial: R, operation: (index: Int, Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun <T> Array<out T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun ByteArray.forEach(action: (Byte) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun ShortArray.forEach(action: (Short) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun IntArray.forEach(action: (Int) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun LongArray.forEach(action: (Long) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun FloatArray.forEach(action: (Float) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun DoubleArray.forEach(action: (Double) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun BooleanArray.forEach(action: (Boolean) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\npublic inline fun CharArray.forEach(action: (Char) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun <T> Array<out T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun ByteArray.forEachIndexed(action: (index: Int, Byte) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun ShortArray.forEachIndexed(action: (index: Int, Short) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun IntArray.forEachIndexed(action: (index: Int, Int) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun LongArray.forEachIndexed(action: (index: Int, Long) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun FloatArray.forEachIndexed(action: (index: Int, Float) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun DoubleArray.forEachIndexed(action: (index: Int, Double) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun BooleanArray.forEachIndexed(action: (index: Int, Boolean) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun CharArray.forEachIndexed(action: (index: Int, Char) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.1\")\npublic fun Array<out Double>.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.1\")\npublic fun Array<out Float>.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun <T : Comparable<T>> Array<out T>.max(): T? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun ByteArray.max(): Byte? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun ShortArray.max(): Short? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun IntArray.max(): Int? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun LongArray.max(): Long? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun FloatArray.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun DoubleArray.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun CharArray.max(): Char? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxBy(selector: (T) -> R): T? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic inline fun <R : Comparable<R>> ByteArray.maxBy(selector: (Byte) -> R): Byte? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic inline fun <R : Comparable<R>> ShortArray.maxBy(selector: (Short) -> R): Short? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic inline fun <R : Comparable<R>> IntArray.maxBy(selector: (Int) -> R): Int? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic inline fun <R : Comparable<R>> LongArray.maxBy(selector: (Long) -> R): Long? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic inline fun <R : Comparable<R>> FloatArray.maxBy(selector: (Float) -> R): Float? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic inline fun <R : Comparable<R>> DoubleArray.maxBy(selector: (Double) -> R): Double? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic inline fun <R : Comparable<R>> BooleanArray.maxBy(selector: (Boolean) -> R): Boolean? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic inline fun <R : Comparable<R>> CharArray.maxBy(selector: (Char) -> R): Char? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxByOrNull(selector: (T) -> R): T? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ByteArray.maxByOrNull(selector: (Byte) -> R): Byte? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ShortArray.maxByOrNull(selector: (Short) -> R): Short? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> IntArray.maxByOrNull(selector: (Int) -> R): Int? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> LongArray.maxByOrNull(selector: (Long) -> R): Long? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> FloatArray.maxByOrNull(selector: (Float) -> R): Float? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> DoubleArray.maxByOrNull(selector: (Double) -> R): Double? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> BooleanArray.maxByOrNull(selector: (Boolean) -> R): Boolean? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharArray.maxByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOf(selector: (T) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOf(selector: (Byte) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOf(selector: (Short) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOf(selector: (Int) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOf(selector: (Long) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOf(selector: (Float) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOf(selector: (Double) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOf(selector: (Boolean) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOf(selector: (T) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOf(selector: (Byte) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOf(selector: (Short) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOf(selector: (Int) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOf(selector: (Long) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOf(selector: (Float) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOf(selector: (Double) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOf(selector: (Boolean) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxOf(selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.maxOf(selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.maxOf(selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.maxOf(selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.maxOf(selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.maxOf(selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.maxOf(selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.maxOf(selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.maxOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOfOrNull(selector: (Byte) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOfOrNull(selector: (Short) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOfOrNull(selector: (Int) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOfOrNull(selector: (Long) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOfOrNull(selector: (Float) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOfOrNull(selector: (Double) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOfOrNull(selector: (Boolean) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.maxOfOrNull(selector: (Byte) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.maxOfOrNull(selector: (Short) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.maxOfOrNull(selector: (Int) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.maxOfOrNull(selector: (Long) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.maxOfOrNull(selector: (Float) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.maxOfOrNull(selector: (Double) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.maxOfOrNull(selector: (Boolean) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.maxOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.maxOfOrNull(selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.maxOfOrNull(selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.maxOfOrNull(selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.maxOfOrNull(selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.maxOfOrNull(selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.maxOfOrNull(selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.maxOfOrNull(selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.maxOfOrNull(selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.maxOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.maxOfWith(comparator: Comparator<in R>, selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.maxOfWith(comparator: Comparator<in R>, selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.maxOfWith(comparator: Comparator<in R>, selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.maxOfWith(comparator: Comparator<in R>, selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.maxOfWith(comparator: Comparator<in R>, selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.maxOfWith(comparator: Comparator<in R>, selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.maxOfWith(comparator: Comparator<in R>, selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.maxOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Double>.maxOrNull(): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Float>.maxOrNull(): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.maxOrNull(): T? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.maxOrNull(): Byte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.maxOrNull(): Short? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.maxOrNull(): Int? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.maxOrNull(): Long? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.maxOrNull(): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.maxOrNull(): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.maxOrNull(): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun <T> Array<out T>.maxWith(comparator: Comparator<in T>): T? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun ByteArray.maxWith(comparator: Comparator<in Byte>): Byte? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun ShortArray.maxWith(comparator: Comparator<in Short>): Short? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun IntArray.maxWith(comparator: Comparator<in Int>): Int? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun LongArray.maxWith(comparator: Comparator<in Long>): Long? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun FloatArray.maxWith(comparator: Comparator<in Float>): Float? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun DoubleArray.maxWith(comparator: Comparator<in Double>): Double? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun BooleanArray.maxWith(comparator: Comparator<in Boolean>): Boolean? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun CharArray.maxWith(comparator: Comparator<in Char>): Char? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<out T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.maxWithOrNull(comparator: Comparator<in Byte>): Byte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.maxWithOrNull(comparator: Comparator<in Short>): Short? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.maxWithOrNull(comparator: Comparator<in Int>): Int? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.maxWithOrNull(comparator: Comparator<in Long>): Long? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.maxWithOrNull(comparator: Comparator<in Float>): Float? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.maxWithOrNull(comparator: Comparator<in Double>): Double? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.maxWithOrNull(comparator: Comparator<in Boolean>): Boolean? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.maxWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.1\")\npublic fun Array<out Double>.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.1\")\npublic fun Array<out Float>.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun <T : Comparable<T>> Array<out T>.min(): T? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun ByteArray.min(): Byte? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun ShortArray.min(): Short? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun IntArray.min(): Int? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun LongArray.min(): Long? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun FloatArray.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun DoubleArray.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun CharArray.min(): Char? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.minBy(selector: (T) -> R): T? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic inline fun <R : Comparable<R>> ByteArray.minBy(selector: (Byte) -> R): Byte? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic inline fun <R : Comparable<R>> ShortArray.minBy(selector: (Short) -> R): Short? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic inline fun <R : Comparable<R>> IntArray.minBy(selector: (Int) -> R): Int? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic inline fun <R : Comparable<R>> LongArray.minBy(selector: (Long) -> R): Long? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic inline fun <R : Comparable<R>> FloatArray.minBy(selector: (Float) -> R): Float? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic inline fun <R : Comparable<R>> DoubleArray.minBy(selector: (Double) -> R): Double? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic inline fun <R : Comparable<R>> BooleanArray.minBy(selector: (Boolean) -> R): Boolean? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic inline fun <R : Comparable<R>> CharArray.minBy(selector: (Char) -> R): Char? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Array<out T>.minByOrNull(selector: (T) -> R): T? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ByteArray.minByOrNull(selector: (Byte) -> R): Byte? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> ShortArray.minByOrNull(selector: (Short) -> R): Short? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> IntArray.minByOrNull(selector: (Int) -> R): Int? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> LongArray.minByOrNull(selector: (Long) -> R): Long? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> FloatArray.minByOrNull(selector: (Float) -> R): Float? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> DoubleArray.minByOrNull(selector: (Double) -> R): Double? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> BooleanArray.minByOrNull(selector: (Boolean) -> R): Boolean? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharArray.minByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOf(selector: (T) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOf(selector: (Byte) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOf(selector: (Short) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOf(selector: (Int) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOf(selector: (Long) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOf(selector: (Float) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOf(selector: (Double) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOf(selector: (Boolean) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOf(selector: (T) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOf(selector: (Byte) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOf(selector: (Short) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOf(selector: (Int) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOf(selector: (Long) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOf(selector: (Float) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOf(selector: (Double) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOf(selector: (Boolean) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.minOf(selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.minOf(selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.minOf(selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.minOf(selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.minOf(selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.minOf(selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.minOf(selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.minOf(selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.minOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOfOrNull(selector: (T) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOfOrNull(selector: (Byte) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOfOrNull(selector: (Short) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOfOrNull(selector: (Int) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOfOrNull(selector: (Long) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOfOrNull(selector: (Float) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOfOrNull(selector: (Double) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOfOrNull(selector: (Boolean) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.minOfOrNull(selector: (T) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.minOfOrNull(selector: (Byte) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.minOfOrNull(selector: (Short) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.minOfOrNull(selector: (Int) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.minOfOrNull(selector: (Long) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.minOfOrNull(selector: (Float) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.minOfOrNull(selector: (Double) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.minOfOrNull(selector: (Boolean) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.minOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Array<out T>.minOfOrNull(selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ByteArray.minOfOrNull(selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ShortArray.minOfOrNull(selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> IntArray.minOfOrNull(selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> LongArray.minOfOrNull(selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> FloatArray.minOfOrNull(selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> DoubleArray.minOfOrNull(selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> BooleanArray.minOfOrNull(selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharArray.minOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.minOfWith(comparator: Comparator<in R>, selector: (Byte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.minOfWith(comparator: Comparator<in R>, selector: (Short) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.minOfWith(comparator: Comparator<in R>, selector: (Int) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.minOfWith(comparator: Comparator<in R>, selector: (Long) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.minOfWith(comparator: Comparator<in R>, selector: (Float) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.minOfWith(comparator: Comparator<in R>, selector: (Double) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.minOfWith(comparator: Comparator<in R>, selector: (Boolean) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.minOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Array<out T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Byte) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Short) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Int) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Long) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Float) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Double) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Boolean) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Double>.minOrNull(): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Array<out Float>.minOrNull(): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Array<out T>.minOrNull(): T? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.minOrNull(): Byte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.minOrNull(): Short? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.minOrNull(): Int? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.minOrNull(): Long? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.minOrNull(): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.minOrNull(): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.minOrNull(): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun <T> Array<out T>.minWith(comparator: Comparator<in T>): T? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun ByteArray.minWith(comparator: Comparator<in Byte>): Byte? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun ShortArray.minWith(comparator: Comparator<in Short>): Short? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun IntArray.minWith(comparator: Comparator<in Int>): Int? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun LongArray.minWith(comparator: Comparator<in Long>): Long? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun FloatArray.minWith(comparator: Comparator<in Float>): Float? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun DoubleArray.minWith(comparator: Comparator<in Double>): Double? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun BooleanArray.minWith(comparator: Comparator<in Boolean>): Boolean? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun CharArray.minWith(comparator: Comparator<in Char>): Char? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Array<out T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ByteArray.minWithOrNull(comparator: Comparator<in Byte>): Byte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun ShortArray.minWithOrNull(comparator: Comparator<in Short>): Short? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun IntArray.minWithOrNull(comparator: Comparator<in Int>): Int? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun LongArray.minWithOrNull(comparator: Comparator<in Long>): Long? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun FloatArray.minWithOrNull(comparator: Comparator<in Float>): Float? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun DoubleArray.minWithOrNull(comparator: Comparator<in Double>): Double? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun BooleanArray.minWithOrNull(comparator: Comparator<in Boolean>): Boolean? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharArray.minWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Array<out T>.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun ByteArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun ShortArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun IntArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun LongArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun FloatArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun DoubleArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun BooleanArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun CharArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Array<out T>.none(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun ByteArray.none(predicate: (Byte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun ShortArray.none(predicate: (Short) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun IntArray.none(predicate: (Int) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun LongArray.none(predicate: (Long) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun FloatArray.none(predicate: (Float) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun DoubleArray.none(predicate: (Double) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun BooleanArray.none(predicate: (Boolean) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun CharArray.none(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.onEach(action: (T) -> Unit): Array<out T> {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.onEach(action: (Byte) -> Unit): ByteArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.onEach(action: (Short) -> Unit): ShortArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.onEach(action: (Int) -> Unit): IntArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.onEach(action: (Long) -> Unit): LongArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.onEach(action: (Float) -> Unit): FloatArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.onEach(action: (Double) -> Unit): DoubleArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.onEach(action: (Boolean) -> Unit): BooleanArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.onEach(action: (Char) -> Unit): CharArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.onEachIndexed(action: (index: Int, T) -> Unit): Array<out T> {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.onEachIndexed(action: (index: Int, Byte) -> Unit): ByteArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.onEachIndexed(action: (index: Int, Short) -> Unit): ShortArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.onEachIndexed(action: (index: Int, Int) -> Unit): IntArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.onEachIndexed(action: (index: Int, Long) -> Unit): LongArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.onEachIndexed(action: (index: Int, Float) -> Unit): FloatArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.onEachIndexed(action: (index: Int, Double) -> Unit): DoubleArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.onEachIndexed(action: (index: Int, Boolean) -> Unit): BooleanArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.onEachIndexed(action: (index: Int, Char) -> Unit): CharArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Array<out T>.reduce(operation: (acc: S, T) -> S): S {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ByteArray.reduce(operation: (acc: Byte, Byte) -> Byte): Byte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ShortArray.reduce(operation: (acc: Short, Short) -> Short): Short {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun IntArray.reduce(operation: (acc: Int, Int) -> Int): Int {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun LongArray.reduce(operation: (acc: Long, Long) -> Long): Long {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun FloatArray.reduce(operation: (acc: Float, Float) -> Float): Float {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun DoubleArray.reduce(operation: (acc: Double, Double) -> Double): Double {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun BooleanArray.reduce(operation: (acc: Boolean, Boolean) -> Boolean): Boolean {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharArray.reduce(operation: (acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Array<out T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ByteArray.reduceIndexed(operation: (index: Int, acc: Byte, Byte) -> Byte): Byte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun ShortArray.reduceIndexed(operation: (index: Int, acc: Short, Short) -> Short): Short {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun IntArray.reduceIndexed(operation: (index: Int, acc: Int, Int) -> Int): Int {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun LongArray.reduceIndexed(operation: (index: Int, acc: Long, Long) -> Long): Long {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun FloatArray.reduceIndexed(operation: (index: Int, acc: Float, Float) -> Float): Float {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun DoubleArray.reduceIndexed(operation: (index: Int, acc: Double, Double) -> Double): Double {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun BooleanArray.reduceIndexed(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): Boolean {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharArray.reduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    if (isEmpty())\n        return null\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ByteArray.reduceIndexedOrNull(operation: (index: Int, acc: Byte, Byte) -> Byte): Byte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ShortArray.reduceIndexedOrNull(operation: (index: Int, acc: Short, Short) -> Short): Short? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun IntArray.reduceIndexedOrNull(operation: (index: Int, acc: Int, Int) -> Int): Int? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun LongArray.reduceIndexedOrNull(operation: (index: Int, acc: Long, Long) -> Long): Long? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun FloatArray.reduceIndexedOrNull(operation: (index: Int, acc: Float, Float) -> Float): Float? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun DoubleArray.reduceIndexedOrNull(operation: (index: Int, acc: Double, Double) -> Double): Double? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun BooleanArray.reduceIndexedOrNull(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): Boolean? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharArray.reduceIndexedOrNull(operation: (index: Int, acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    if (isEmpty())\n        return null\n    var accumulator: S = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ByteArray.reduceOrNull(operation: (acc: Byte, Byte) -> Byte): Byte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ShortArray.reduceOrNull(operation: (acc: Short, Short) -> Short): Short? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun IntArray.reduceOrNull(operation: (acc: Int, Int) -> Int): Int? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun LongArray.reduceOrNull(operation: (acc: Long, Long) -> Long): Long? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun FloatArray.reduceOrNull(operation: (acc: Float, Float) -> Float): Float? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun DoubleArray.reduceOrNull(operation: (acc: Double, Double) -> Double): Double? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun BooleanArray.reduceOrNull(operation: (acc: Boolean, Boolean) -> Boolean): Boolean? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharArray.reduceOrNull(operation: (acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> Array<out T>.reduceRight(operation: (T, acc: S) -> S): S {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ByteArray.reduceRight(operation: (Byte, acc: Byte) -> Byte): Byte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ShortArray.reduceRight(operation: (Short, acc: Short) -> Short): Short {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun IntArray.reduceRight(operation: (Int, acc: Int) -> Int): Int {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun LongArray.reduceRight(operation: (Long, acc: Long) -> Long): Long {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun FloatArray.reduceRight(operation: (Float, acc: Float) -> Float): Float {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun DoubleArray.reduceRight(operation: (Double, acc: Double) -> Double): Double {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun BooleanArray.reduceRight(operation: (Boolean, acc: Boolean) -> Boolean): Boolean {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharArray.reduceRight(operation: (Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> Array<out T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ByteArray.reduceRightIndexed(operation: (index: Int, Byte, acc: Byte) -> Byte): Byte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun ShortArray.reduceRightIndexed(operation: (index: Int, Short, acc: Short) -> Short): Short {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun IntArray.reduceRightIndexed(operation: (index: Int, Int, acc: Int) -> Int): Int {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun LongArray.reduceRightIndexed(operation: (index: Int, Long, acc: Long) -> Long): Long {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun FloatArray.reduceRightIndexed(operation: (index: Int, Float, acc: Float) -> Float): Float {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun DoubleArray.reduceRightIndexed(operation: (index: Int, Double, acc: Double) -> Double): Double {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun BooleanArray.reduceRightIndexed(operation: (index: Int, Boolean, acc: Boolean) -> Boolean): Boolean {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharArray.reduceRightIndexed(operation: (index: Int, Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.reduceRightIndexedOrNull(operation: (index: Int, T, acc: S) -> S): S? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ByteArray.reduceRightIndexedOrNull(operation: (index: Int, Byte, acc: Byte) -> Byte): Byte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun ShortArray.reduceRightIndexedOrNull(operation: (index: Int, Short, acc: Short) -> Short): Short? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun IntArray.reduceRightIndexedOrNull(operation: (index: Int, Int, acc: Int) -> Int): Int? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun LongArray.reduceRightIndexedOrNull(operation: (index: Int, Long, acc: Long) -> Long): Long? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun FloatArray.reduceRightIndexedOrNull(operation: (index: Int, Float, acc: Float) -> Float): Float? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun DoubleArray.reduceRightIndexedOrNull(operation: (index: Int, Double, acc: Double) -> Double): Double? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun BooleanArray.reduceRightIndexedOrNull(operation: (index: Int, Boolean, acc: Boolean) -> Boolean): Boolean? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharArray.reduceRightIndexedOrNull(operation: (index: Int, Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.reduceRightOrNull(operation: (T, acc: S) -> S): S? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator: S = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ByteArray.reduceRightOrNull(operation: (Byte, acc: Byte) -> Byte): Byte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun ShortArray.reduceRightOrNull(operation: (Short, acc: Short) -> Short): Short? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun IntArray.reduceRightOrNull(operation: (Int, acc: Int) -> Int): Int? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun LongArray.reduceRightOrNull(operation: (Long, acc: Long) -> Long): Long? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun FloatArray.reduceRightOrNull(operation: (Float, acc: Float) -> Float): Float? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun DoubleArray.reduceRightOrNull(operation: (Double, acc: Double) -> Double): Double? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun BooleanArray.reduceRightOrNull(operation: (Boolean, acc: Boolean) -> Boolean): Boolean? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharArray.reduceRightOrNull(operation: (Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Array<out T>.runningFold(initial: R, operation: (acc: R, T) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.runningFold(initial: R, operation: (acc: R, Byte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.runningFold(initial: R, operation: (acc: R, Short) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.runningFold(initial: R, operation: (acc: R, Int) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.runningFold(initial: R, operation: (acc: R, Long) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.runningFold(initial: R, operation: (acc: R, Float) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.runningFold(initial: R, operation: (acc: R, Double) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.runningFold(initial: R, operation: (acc: R, Boolean) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.runningFold(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Array<out T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Array<out T>.runningReduce(operation: (acc: S, T) -> S): List<S> {\n    if (isEmpty()) return emptyList()\n    var accumulator: S = this[0]\n    val result = ArrayList<S>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.runningReduce(operation: (acc: Byte, Byte) -> Byte): List<Byte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Byte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.runningReduce(operation: (acc: Short, Short) -> Short): List<Short> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Short>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.runningReduce(operation: (acc: Int, Int) -> Int): List<Int> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Int>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.runningReduce(operation: (acc: Long, Long) -> Long): List<Long> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Long>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.runningReduce(operation: (acc: Float, Float) -> Float): List<Float> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Float>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.runningReduce(operation: (acc: Double, Double) -> Double): List<Double> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Double>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.runningReduce(operation: (acc: Boolean, Boolean) -> Boolean): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Boolean>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.runningReduce(operation: (acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Array<out T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    if (isEmpty()) return emptyList()\n    var accumulator: S = this[0]\n    val result = ArrayList<S>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.runningReduceIndexed(operation: (index: Int, acc: Byte, Byte) -> Byte): List<Byte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Byte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.runningReduceIndexed(operation: (index: Int, acc: Short, Short) -> Short): List<Short> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Short>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.runningReduceIndexed(operation: (index: Int, acc: Int, Int) -> Int): List<Int> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Int>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.runningReduceIndexed(operation: (index: Int, acc: Long, Long) -> Long): List<Long> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Long>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.runningReduceIndexed(operation: (index: Int, acc: Float, Float) -> Float): List<Float> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Float>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.runningReduceIndexed(operation: (index: Int, acc: Double, Double) -> Double): List<Double> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Double>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.runningReduceIndexed(operation: (index: Int, acc: Boolean, Boolean) -> Boolean): List<Boolean> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Boolean>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.runningReduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Array<out T>.scan(initial: R, operation: (acc: R, T) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.scan(initial: R, operation: (acc: R, Byte) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.scan(initial: R, operation: (acc: R, Short) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.scan(initial: R, operation: (acc: R, Int) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.scan(initial: R, operation: (acc: R, Long) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.scan(initial: R, operation: (acc: R, Float) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.scan(initial: R, operation: (acc: R, Double) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.scan(initial: R, operation: (acc: R, Boolean) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.scan(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Array<out T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ByteArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Byte) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ShortArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Short) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> IntArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Int) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> LongArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Long) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> FloatArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Float) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> DoubleArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Double) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> BooleanArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Boolean) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharArray.scanIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Array<out T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun ByteArray.sumBy(selector: (Byte) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun ShortArray.sumBy(selector: (Short) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun IntArray.sumBy(selector: (Int) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun LongArray.sumBy(selector: (Long) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun FloatArray.sumBy(selector: (Float) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun DoubleArray.sumBy(selector: (Double) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun BooleanArray.sumBy(selector: (Boolean) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun CharArray.sumBy(selector: (Char) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Array<out T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun ByteArray.sumByDouble(selector: (Byte) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun ShortArray.sumByDouble(selector: (Short) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun IntArray.sumByDouble(selector: (Int) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun LongArray.sumByDouble(selector: (Long) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun FloatArray.sumByDouble(selector: (Float) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun DoubleArray.sumByDouble(selector: (Double) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun BooleanArray.sumByDouble(selector: (Boolean) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun CharArray.sumByDouble(selector: (Char) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Array<out T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sumOf(selector: (Byte) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sumOf(selector: (Short) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sumOf(selector: (Int) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sumOf(selector: (Long) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sumOf(selector: (Float) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sumOf(selector: (Double) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun BooleanArray.sumOf(selector: (Boolean) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sumOf(selector: (Char) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Array<T?>.requireNoNulls(): Array<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Array<T>\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun <T> Array<out T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun ByteArray.partition(predicate: (Byte) -> Boolean): Pair<List<Byte>, List<Byte>> {\n    val first = ArrayList<Byte>()\n    val second = ArrayList<Byte>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun ShortArray.partition(predicate: (Short) -> Boolean): Pair<List<Short>, List<Short>> {\n    val first = ArrayList<Short>()\n    val second = ArrayList<Short>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun IntArray.partition(predicate: (Int) -> Boolean): Pair<List<Int>, List<Int>> {\n    val first = ArrayList<Int>()\n    val second = ArrayList<Int>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun LongArray.partition(predicate: (Long) -> Boolean): Pair<List<Long>, List<Long>> {\n    val first = ArrayList<Long>()\n    val second = ArrayList<Long>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun FloatArray.partition(predicate: (Float) -> Boolean): Pair<List<Float>, List<Float>> {\n    val first = ArrayList<Float>()\n    val second = ArrayList<Float>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun DoubleArray.partition(predicate: (Double) -> Boolean): Pair<List<Double>, List<Double>> {\n    val first = ArrayList<Double>()\n    val second = ArrayList<Double>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun BooleanArray.partition(predicate: (Boolean) -> Boolean): Pair<List<Boolean>, List<Boolean>> {\n    val first = ArrayList<Boolean>()\n    val second = ArrayList<Boolean>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original array into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Arrays.Transformations.partitionArrayOfPrimitives\n */\npublic inline fun CharArray.partition(predicate: (Char) -> Boolean): Pair<List<Char>, List<Char>> {\n    val first = ArrayList<Char>()\n    val second = ArrayList<Char>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Array<out T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ByteArray.zip(other: Array<out R>): List<Pair<Byte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ShortArray.zip(other: Array<out R>): List<Pair<Short, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> IntArray.zip(other: Array<out R>): List<Pair<Int, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> LongArray.zip(other: Array<out R>): List<Pair<Long, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> FloatArray.zip(other: Array<out R>): List<Pair<Float, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> DoubleArray.zip(other: Array<out R>): List<Pair<Double, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> BooleanArray.zip(other: Array<out R>): List<Pair<Boolean, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> CharArray.zip(other: Array<out R>): List<Pair<Char, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Array<out T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ByteArray.zip(other: Array<out R>, transform: (a: Byte, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ShortArray.zip(other: Array<out R>, transform: (a: Short, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> IntArray.zip(other: Array<out R>, transform: (a: Int, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> LongArray.zip(other: Array<out R>, transform: (a: Long, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> FloatArray.zip(other: Array<out R>, transform: (a: Float, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> DoubleArray.zip(other: Array<out R>, transform: (a: Double, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> BooleanArray.zip(other: Array<out R>, transform: (a: Boolean, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> CharArray.zip(other: Array<out R>, transform: (a: Char, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Array<out T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ByteArray.zip(other: Iterable<R>): List<Pair<Byte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> ShortArray.zip(other: Iterable<R>): List<Pair<Short, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> IntArray.zip(other: Iterable<R>): List<Pair<Int, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> LongArray.zip(other: Iterable<R>): List<Pair<Long, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> FloatArray.zip(other: Iterable<R>): List<Pair<Float, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> DoubleArray.zip(other: Iterable<R>): List<Pair<Double, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> BooleanArray.zip(other: Iterable<R>): List<Pair<Boolean, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <R> CharArray.zip(other: Iterable<R>): List<Pair<Char, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Array<out T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ByteArray.zip(other: Iterable<R>, transform: (a: Byte, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> ShortArray.zip(other: Iterable<R>, transform: (a: Short, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> IntArray.zip(other: Iterable<R>, transform: (a: Int, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> LongArray.zip(other: Iterable<R>, transform: (a: Long, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> FloatArray.zip(other: Iterable<R>, transform: (a: Float, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> DoubleArray.zip(other: Iterable<R>, transform: (a: Double, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> BooleanArray.zip(other: Iterable<R>, transform: (a: Boolean, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <R, V> CharArray.zip(other: Iterable<R>, transform: (a: Char, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun ByteArray.zip(other: ByteArray): List<Pair<Byte, Byte>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun ShortArray.zip(other: ShortArray): List<Pair<Short, Short>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun IntArray.zip(other: IntArray): List<Pair<Int, Int>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun LongArray.zip(other: LongArray): List<Pair<Long, Long>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun FloatArray.zip(other: FloatArray): List<Pair<Float, Float>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun DoubleArray.zip(other: DoubleArray): List<Pair<Double, Double>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun BooleanArray.zip(other: BooleanArray): List<Pair<Boolean, Boolean>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun CharArray.zip(other: CharArray): List<Pair<Char, Char>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> ByteArray.zip(other: ByteArray, transform: (a: Byte, b: Byte) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> ShortArray.zip(other: ShortArray, transform: (a: Short, b: Short) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> IntArray.zip(other: IntArray, transform: (a: Int, b: Int) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> LongArray.zip(other: LongArray, transform: (a: Long, b: Long) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> FloatArray.zip(other: FloatArray, transform: (a: Float, b: Float) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> DoubleArray.zip(other: DoubleArray, transform: (a: Double, b: Double) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> BooleanArray.zip(other: BooleanArray, transform: (a: Boolean, b: Boolean) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <V> CharArray.zip(other: CharArray, transform: (a: Char, b: Char) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Array<out T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> ByteArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Byte) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> ShortArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Short) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> IntArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Int) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> LongArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Long) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> FloatArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Float) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> DoubleArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Double) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> BooleanArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Boolean) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element.toString())\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <A : Appendable> CharArray.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Char) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            if (transform != null)\n                buffer.append(transform(element))\n            else\n                buffer.append(element)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Array<out T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun ByteArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Byte) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun ShortArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Short) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun IntArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Int) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun LongArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Long) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun FloatArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Float) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun DoubleArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Double) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun BooleanArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Boolean) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun CharArray.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((Char) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun <T> Array<out T>.asIterable(): Iterable<T> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun ByteArray.asIterable(): Iterable<Byte> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun ShortArray.asIterable(): Iterable<Short> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun IntArray.asIterable(): Iterable<Int> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun LongArray.asIterable(): Iterable<Long> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun FloatArray.asIterable(): Iterable<Float> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun DoubleArray.asIterable(): Iterable<Double> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun BooleanArray.asIterable(): Iterable<Boolean> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original array returning its elements when being iterated.\n */\npublic fun CharArray.asIterable(): Iterable<Char> {\n    if (isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun <T> Array<out T>.asSequence(): Sequence<T> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun ByteArray.asSequence(): Sequence<Byte> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun ShortArray.asSequence(): Sequence<Short> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun IntArray.asSequence(): Sequence<Int> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun LongArray.asSequence(): Sequence<Long> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun FloatArray.asSequence(): Sequence<Float> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun DoubleArray.asSequence(): Sequence<Double> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun BooleanArray.asSequence(): Sequence<Boolean> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original array returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromArray\n */\npublic fun CharArray.asSequence(): Sequence<Char> {\n    if (isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Array<out Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Array<out Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Array<out Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Array<out Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Array<out Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Array<out Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun ByteArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun ShortArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun IntArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun LongArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun FloatArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the array.\n */\npublic fun DoubleArray.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        ++count\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Array<out Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Array<out Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Array<out Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Array<out Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Array<out Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Array<out Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun ByteArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun ShortArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun IntArray.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun LongArray.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun FloatArray.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\npublic fun DoubleArray.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"RangesKt\")\n\npackage kotlin.ranges\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun IntRange.random(): Int {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun LongRange.random(): Long {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharRange.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun IntRange.random(random: Random): Int {\n    try {\n        return random.nextInt(this)\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun LongRange.random(random: Random): Long {\n    try {\n        return random.nextLong(this)\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness.\n * \n * @throws IllegalArgumentException if this range is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharRange.random(random: Random): Char {\n    try {\n        return random.nextInt(first.code, last.code + 1).toChar()\n    } catch(e: IllegalArgumentException) {\n        throw NoSuchElementException(e.message)\n    }\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun IntRange.randomOrNull(): Int? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun LongRange.randomOrNull(): Long? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharRange.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun IntRange.randomOrNull(random: Random): Int? {\n    if (isEmpty())\n        return null\n    return random.nextInt(this)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun LongRange.randomOrNull(random: Random): Long? {\n    if (isEmpty())\n        return null\n    return random.nextLong(this)\n}\n\n/**\n * Returns a random element from this range using the specified source of randomness, or `null` if this range is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun CharRange.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return random.nextInt(first.code, last.code + 1).toChar()\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun IntRange.contains(element: Int?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun LongRange.contains(element: Long?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Returns `true` if this range contains the specified [element].\n * \n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun CharRange.contains(element: Char?): Boolean {\n    return element != null && contains(element)\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Byte): Boolean {\n    return contains(value.toInt())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Byte): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Byte): Boolean {\n    return contains(value.toShort())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Byte): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Byte): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Double): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Double): Boolean {\n    return value.toLongExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Double): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Double): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Double): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Float): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Float): Boolean {\n    return value.toLongExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Float): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Float): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Float): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Int): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Int): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Int): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Int): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Int): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Long): Boolean {\n    return value.toIntExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Long): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"shortRangeContains\")\npublic operator fun ClosedRange<Short>.contains(value: Long): Boolean {\n    return value.toShortExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Long): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Long): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"intRangeContains\")\npublic operator fun ClosedRange<Int>.contains(value: Short): Boolean {\n    return contains(value.toInt())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"longRangeContains\")\npublic operator fun ClosedRange<Long>.contains(value: Short): Boolean {\n    return contains(value.toLong())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@kotlin.jvm.JvmName(\"byteRangeContains\")\npublic operator fun ClosedRange<Byte>.contains(value: Short): Boolean {\n    return value.toByteExactOrNull().let { if (it != null) contains(it) else false }\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"doubleRangeContains\")\npublic operator fun ClosedRange<Double>.contains(value: Short): Boolean {\n    return contains(value.toDouble())\n}\n\n/**\n * Checks if the specified [value] belongs to this range.\n */\n@Deprecated(\"This `contains` operation mixing integer and floating point arguments has ambiguous semantics and is going to be removed.\")\n@DeprecatedSinceKotlin(warningSince = \"1.3\", errorSince = \"1.4\", hiddenSince = \"1.5\")\n@kotlin.jvm.JvmName(\"floatRangeContains\")\npublic operator fun ClosedRange<Float>.contains(value: Short): Boolean {\n    return contains(value.toFloat())\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this, to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Byte): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Byte): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Char.downTo(to: Char): CharProgression {\n    return CharProgression.fromClosedRange(this, to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this, to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Int): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Int): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to, -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this, to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Long): LongProgression {\n    return LongProgression.fromClosedRange(this.toLong(), to, -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Int.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this, to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Long.downTo(to: Short): LongProgression {\n    return LongProgression.fromClosedRange(this, to.toLong(), -1L)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Byte.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression from this value down to the specified [to] value with the step -1.\n * \n * The [to] value should be less than or equal to `this` value.\n * If the [to] value is greater than `this` value the returned progression is empty.\n */\npublic infix fun Short.downTo(to: Short): IntProgression {\n    return IntProgression.fromClosedRange(this.toInt(), to.toInt(), -1)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun IntProgression.reversed(): IntProgression {\n    return IntProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun LongProgression.reversed(): LongProgression {\n    return LongProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range in the opposite direction with the same step.\n */\npublic fun CharProgression.reversed(): CharProgression {\n    return CharProgression.fromClosedRange(last, first, -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun IntProgression.step(step: Int): IntProgression {\n    checkStepIsPositive(step > 0, step)\n    return IntProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun LongProgression.step(step: Long): LongProgression {\n    checkStepIsPositive(step > 0, step)\n    return LongProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\n/**\n * Returns a progression that goes over the same range with the given step.\n */\npublic infix fun CharProgression.step(step: Int): CharProgression {\n    checkStepIsPositive(step > 0, step)\n    return CharProgression.fromClosedRange(first, last, if (this.step > 0) step else -step)\n}\n\ninternal fun Int.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toInt()..Byte.MAX_VALUE.toInt()) this.toByte() else null\n}\n\ninternal fun Long.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toLong()..Byte.MAX_VALUE.toLong()) this.toByte() else null\n}\n\ninternal fun Short.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toShort()..Byte.MAX_VALUE.toShort()) this.toByte() else null\n}\n\ninternal fun Double.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toDouble()..Byte.MAX_VALUE.toDouble()) this.toInt().toByte() else null\n}\n\ninternal fun Float.toByteExactOrNull(): Byte? {\n    return if (this in Byte.MIN_VALUE.toFloat()..Byte.MAX_VALUE.toFloat()) this.toInt().toByte() else null\n}\n\ninternal fun Long.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toLong()..Int.MAX_VALUE.toLong()) this.toInt() else null\n}\n\ninternal fun Double.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toDouble()..Int.MAX_VALUE.toDouble()) this.toInt() else null\n}\n\ninternal fun Float.toIntExactOrNull(): Int? {\n    return if (this in Int.MIN_VALUE.toFloat()..Int.MAX_VALUE.toFloat()) this.toInt() else null\n}\n\ninternal fun Double.toLongExactOrNull(): Long? {\n    return if (this in Long.MIN_VALUE.toDouble()..Long.MAX_VALUE.toDouble()) this.toLong() else null\n}\n\ninternal fun Float.toLongExactOrNull(): Long? {\n    return if (this in Long.MIN_VALUE.toFloat()..Long.MAX_VALUE.toFloat()) this.toLong() else null\n}\n\ninternal fun Int.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toInt()..Short.MAX_VALUE.toInt()) this.toShort() else null\n}\n\ninternal fun Long.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toLong()..Short.MAX_VALUE.toLong()) this.toShort() else null\n}\n\ninternal fun Double.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toDouble()..Short.MAX_VALUE.toDouble()) this.toInt().toShort() else null\n}\n\ninternal fun Float.toShortExactOrNull(): Short? {\n    return if (this in Short.MIN_VALUE.toFloat()..Short.MAX_VALUE.toFloat()) this.toInt().toShort() else null\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Byte): IntRange {\n    return this .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Byte): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Byte): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Byte): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Char.until(to: Char): CharRange {\n    if (to <= '\\u0000') return CharRange.EMPTY\n    return this .. (to - 1).toChar()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Int): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this.toInt() .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Int): IntRange {\n    if (to <= Int.MIN_VALUE) return IntRange.EMPTY\n    return this.toInt() .. (to - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Long): LongRange {\n    if (to <= Long.MIN_VALUE) return LongRange.EMPTY\n    return this.toLong() .. (to - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Int.until(to: Short): IntRange {\n    return this .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Long.until(to: Short): LongRange {\n    return this .. (to.toLong() - 1).toLong()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Byte.until(to: Short): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Returns a range from this value up to but excluding the specified [to] value.\n * \n * If the [to] value is less than or equal to `this` value, then the returned range is empty.\n */\npublic infix fun Short.until(to: Short): IntRange {\n    return this.toInt() .. (to.toInt() - 1).toInt()\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeastComparable\n */\npublic fun <T : Comparable<T>> T.coerceAtLeast(minimumValue: T): T {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Byte.coerceAtLeast(minimumValue: Byte): Byte {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Short.coerceAtLeast(minimumValue: Short): Short {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Int.coerceAtLeast(minimumValue: Int): Int {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Long.coerceAtLeast(minimumValue: Long): Long {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Float.coerceAtLeast(minimumValue: Float): Float {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not less than the specified [minimumValue].\n * \n * @return this value if it's greater than or equal to the [minimumValue] or the [minimumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtLeast\n */\npublic fun Double.coerceAtLeast(minimumValue: Double): Double {\n    return if (this < minimumValue) minimumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMostComparable\n */\npublic fun <T : Comparable<T>> T.coerceAtMost(maximumValue: T): T {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Byte.coerceAtMost(maximumValue: Byte): Byte {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Short.coerceAtMost(maximumValue: Short): Short {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Int.coerceAtMost(maximumValue: Int): Int {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Long.coerceAtMost(maximumValue: Long): Long {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Float.coerceAtMost(maximumValue: Float): Float {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value is not greater than the specified [maximumValue].\n * \n * @return this value if it's less than or equal to the [maximumValue] or the [maximumValue] otherwise.\n * \n * @sample samples.comparisons.ComparableOps.coerceAtMost\n */\npublic fun Double.coerceAtMost(maximumValue: Double): Double {\n    return if (this > maximumValue) maximumValue else this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceInComparable\n */\npublic fun <T : Comparable<T>> T.coerceIn(minimumValue: T?, maximumValue: T?): T {\n    if (minimumValue !== null && maximumValue !== null) {\n        if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n        if (this < minimumValue) return minimumValue\n        if (this > maximumValue) return maximumValue\n    }\n    else {\n        if (minimumValue !== null && this < minimumValue) return minimumValue\n        if (maximumValue !== null && this > maximumValue) return maximumValue\n    }\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Byte.coerceIn(minimumValue: Byte, maximumValue: Byte): Byte {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Short.coerceIn(minimumValue: Short, maximumValue: Short): Short {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Int.coerceIn(minimumValue: Int, maximumValue: Int): Int {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Long.coerceIn(minimumValue: Long, maximumValue: Long): Long {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Float.coerceIn(minimumValue: Float, maximumValue: Float): Float {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified range [minimumValue]..[maximumValue].\n * \n * @return this value if it's in the range, or [minimumValue] if this value is less than [minimumValue], or [maximumValue] if this value is greater than [maximumValue].\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Double.coerceIn(minimumValue: Double, maximumValue: Double): Double {\n    if (minimumValue > maximumValue) throw IllegalArgumentException(\"Cannot coerce value to an empty range: maximum $maximumValue is less than minimum $minimumValue.\")\n    if (this < minimumValue) return minimumValue\n    if (this > maximumValue) return maximumValue\n    return this\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceInFloatingPointRange\n */\n@SinceKotlin(\"1.1\")\npublic fun <T : Comparable<T>> T.coerceIn(range: ClosedFloatingPointRange<T>): T {\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        // this < start equiv to this <= start && !(this >= start)\n        range.lessThanOrEquals(this, range.start) && !range.lessThanOrEquals(range.start, this) -> range.start\n        // this > end equiv to this >= end && !(this <= end)\n        range.lessThanOrEquals(range.endInclusive, this) && !range.lessThanOrEquals(this, range.endInclusive) -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceInComparable\n */\npublic fun <T : Comparable<T>> T.coerceIn(range: ClosedRange<T>): T {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<T>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Int.coerceIn(range: ClosedRange<Int>): Int {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<Int>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n/**\n * Ensures that this value lies in the specified [range].\n * \n * @return this value if it's in the [range], or `range.start` if this value is less than `range.start`, or `range.endInclusive` if this value is greater than `range.endInclusive`.\n * \n * @sample samples.comparisons.ComparableOps.coerceIn\n */\npublic fun Long.coerceIn(range: ClosedRange<Long>): Long {\n    if (range is ClosedFloatingPointRange) {\n        return this.coerceIn<Long>(range)\n    }\n    if (range.isEmpty()) throw IllegalArgumentException(\"Cannot coerce value to an empty range: $range.\")\n    return when {\n        this < range.start -> range.start\n        this > range.endInclusive -> range.endInclusive\n        else -> this\n    }\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@JvmInline\npublic value class UByte @PublishedApi internal constructor(@PublishedApi internal val data: Byte) : Comparable<UByte> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UByte can have.\n         */\n        public const val MIN_VALUE: UByte = UByte(0)\n\n        /**\n         * A constant holding the maximum value an instance of UByte can have.\n         */\n        public const val MAX_VALUE: UByte = UByte(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UByte in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 1\n\n        /**\n         * The number of bits used to represent an instance of UByte in a binary form.\n         */\n        public const val SIZE_BITS: Int = 8\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UByte): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.toUInt().compareTo(other)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = this.toUInt().plus(other)\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = this.toUInt().minus(other)\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = this.toUInt().times(other)\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = this.toUInt().div(other)\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.toUInt().rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.toUInt().rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = this.toUInt().rem(other)\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UByte): UInt = this.toUInt().floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UShort): UInt = this.toUInt().floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UInt): UInt = this.toUInt().floorDiv(other)\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: ULong): ULong = this.toULong().floorDiv(other)\n\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UByte): UByte = this.toUInt().mod(other.toUInt()).toUByte()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UShort): UShort = this.toUInt().mod(other.toUInt()).toUShort()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UInt): UInt = this.toUInt().mod(other)\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: ULong): ULong = this.toULong().mod(other)\n\n    /**\n     * Returns this value incremented by one.\n     *\n     * @sample samples.misc.Builtins.inc\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UByte = UByte(data.inc())\n\n    /**\n     * Returns this value decremented by one.\n     *\n     * @sample samples.misc.Builtins.dec\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UByte = UByte(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UByte): UIntRange = UIntRange(this.toUInt(), other.toUInt())\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UByte): UByte = UByte(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UByte): UByte = UByte(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UByte): UByte = UByte(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UByte = UByte(data.inv())\n\n    /**\n     * Converts this [UByte] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UByte`. Otherwise the result is negative.\n     *\n     * The resulting `Byte` value has the same binary representation as this `UByte` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data\n    /**\n     * Converts this [UByte] value to [Short].\n     *\n     * The resulting `Short` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Short` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 8 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort() and 0xFF\n    /**\n     * Converts this [UByte] value to [Int].\n     *\n     * The resulting `Int` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Int` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 24 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt() and 0xFF\n    /**\n     * Converts this [UByte] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `Long` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 56 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFF\n\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = this\n    /**\n     * Converts this [UByte] value to [UShort].\n     *\n     * The resulting `UShort` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `UShort` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 8 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = UShort(data.toShort() and 0xFF)\n    /**\n     * Converts this [UByte] value to [UInt].\n     *\n     * The resulting `UInt` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `UInt` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 24 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = UInt(data.toInt() and 0xFF)\n    /**\n     * Converts this [UByte] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UByte`.\n     *\n     * The least significant 8 bits of the resulting `ULong` value are the same as the bits of this `UByte` value,\n     * whereas the most significant 56 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFF)\n\n    /**\n     * Converts this [UByte] value to [Float].\n     *\n     * The resulting `Float` value represents the same numerical value as this `UByte`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toInt().toFloat()\n    /**\n     * Converts this [UByte] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UByte`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = this.toInt().toDouble()\n\n    public override fun toString(): String = toInt().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UByte].\n *\n * If this value is positive, the resulting `UByte` value represents the same numerical value as this `Byte`.\n *\n * The resulting `UByte` value has the same binary representation as this `Byte` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUByte(): UByte = UByte(this)\n/**\n * Converts this [Short] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Short`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Short` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUByte(): UByte = UByte(this.toByte())\n/**\n * Converts this [Int] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Int`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Int` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUByte(): UByte = UByte(this.toByte())\n/**\n * Converts this [Long] value to [UByte].\n *\n * If this value is positive and less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UByte` value is represented by the least significant 8 bits of this `Long` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUByte(): UByte = UByte(this.toByte())\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@JvmInline\npublic value class UInt @PublishedApi internal constructor(@PublishedApi internal val data: Int) : Comparable<UInt> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UInt can have.\n         */\n        public const val MIN_VALUE: UInt = UInt(0)\n\n        /**\n         * A constant holding the maximum value an instance of UInt can have.\n         */\n        public const val MAX_VALUE: UInt = UInt(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UInt in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 4\n\n        /**\n         * The number of bits used to represent an instance of UInt in a binary form.\n         */\n        public const val SIZE_BITS: Int = 32\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.compareTo(other.toUInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.compareTo(other.toUInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UInt): Int = uintCompare(this.data, other.data)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = UInt(this.data.plus(other.data))\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = UInt(this.data.minus(other.data))\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = UInt(this.data.times(other.data))\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = uintDivide(this, other)\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = uintRemainder(this, other)\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UByte): UInt = this.floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UShort): UInt = this.floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UInt): UInt = div(other)\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: ULong): ULong = this.toULong().floorDiv(other)\n\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UByte): UByte = this.mod(other.toUInt()).toUByte()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UShort): UShort = this.mod(other.toUInt()).toUShort()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UInt): UInt = rem(other)\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: ULong): ULong = this.toULong().mod(other)\n\n    /**\n     * Returns this value incremented by one.\n     *\n     * @sample samples.misc.Builtins.inc\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UInt = UInt(data.inc())\n\n    /**\n     * Returns this value decremented by one.\n     *\n     * @sample samples.misc.Builtins.dec\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UInt = UInt(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UInt): UIntRange = UIntRange(this, other)\n\n    /**\n     * Shifts this value left by the [bitCount] number of bits.\n     *\n     * Note that only the five lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..31`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shl(bitCount: Int): UInt = UInt(data shl bitCount)\n\n    /**\n     * Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with zeros.\n     *\n     * Note that only the five lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..31`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shr(bitCount: Int): UInt = UInt(data ushr bitCount)\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UInt): UInt = UInt(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UInt): UInt = UInt(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UInt): UInt = UInt(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UInt = UInt(data.inv())\n\n    /**\n     * Converts this [UInt] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `UInt` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [UInt] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `Short` value is represented by the least significant 16 bits of this `UInt` value.\n     * Note that the resulting `Short` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort()\n    /**\n     * Converts this [UInt] value to [Int].\n     *\n     * If this value is less than or equals to [Int.MAX_VALUE], the resulting `Int` value represents\n     * the same numerical value as this `UInt`. Otherwise the result is negative.\n     *\n     * The resulting `Int` value has the same binary representation as this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data\n    /**\n     * Converts this [UInt] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UInt`.\n     *\n     * The least significant 32 bits of the resulting `Long` value are the same as the bits of this `UInt` value,\n     * whereas the most significant 32 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFFFF_FFFF\n\n    /**\n     * Converts this [UInt] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /**\n     * Converts this [UInt] value to [UShort].\n     *\n     * If this value is less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n     * the same numerical value as this `UInt`.\n     *\n     * The resulting `UShort` value is represented by the least significant 16 bits of this `UInt` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = data.toUShort()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = this\n    /**\n     * Converts this [UInt] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UInt`.\n     *\n     * The least significant 32 bits of the resulting `ULong` value are the same as the bits of this `UInt` value,\n     * whereas the most significant 32 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFFFF_FFFF)\n\n    /**\n     * Converts this [UInt] value to [Float].\n     *\n     * The resulting value is the closest `Float` to this `UInt` value.\n     * In case when this `UInt` value is exactly between two `Float`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toDouble().toFloat()\n    /**\n     * Converts this [UInt] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UInt`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = uintToDouble(data)\n\n    public override fun toString(): String = toLong().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `UInt` value are the same as the bits of this `Byte` value,\n * whereas the most significant 24 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUInt(): UInt = UInt(this.toInt())\n/**\n * Converts this [Short] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Short`.\n *\n * The least significant 16 bits of the resulting `UInt` value are the same as the bits of this `Short` value,\n * whereas the most significant 16 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUInt(): UInt = UInt(this.toInt())\n/**\n * Converts this [Int] value to [UInt].\n *\n * If this value is positive, the resulting `UInt` value represents the same numerical value as this `Int`.\n *\n * The resulting `UInt` value has the same binary representation as this `Int` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUInt(): UInt = UInt(this)\n/**\n * Converts this [Long] value to [UInt].\n *\n * If this value is positive and less than or equals to [UInt.MAX_VALUE], the resulting `UInt` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UInt` value is represented by the least significant 32 bits of this `Long` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUInt(): UInt = UInt(this.toInt())\n\n/**\n * Converts this [Float] value to [UInt].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Float` value is negative or `NaN`, [UInt.MAX_VALUE] if it's bigger than `UInt.MAX_VALUE`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Float.toUInt(): UInt = doubleToUInt(this.toDouble())\n/**\n * Converts this [Double] value to [UInt].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is negative or `NaN`, [UInt.MAX_VALUE] if it's bigger than `UInt.MAX_VALUE`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Double.toUInt(): UInt = doubleToUInt(this)\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@JvmInline\npublic value class UShort @PublishedApi internal constructor(@PublishedApi internal val data: Short) : Comparable<UShort> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of UShort can have.\n         */\n        public const val MIN_VALUE: UShort = UShort(0)\n\n        /**\n         * A constant holding the maximum value an instance of UShort can have.\n         */\n        public const val MAX_VALUE: UShort = UShort(-1)\n\n        /**\n         * The number of bytes used to represent an instance of UShort in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 2\n\n        /**\n         * The number of bits used to represent an instance of UShort in a binary form.\n         */\n        public const val SIZE_BITS: Int = 16\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: UShort): Int = this.toInt().compareTo(other.toInt())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.toUInt().compareTo(other)\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: ULong): Int = this.toULong().compareTo(other)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): UInt = this.toUInt().plus(other.toUInt())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): UInt = this.toUInt().plus(other)\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = this.toULong().plus(other)\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): UInt = this.toUInt().minus(other.toUInt())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): UInt = this.toUInt().minus(other)\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = this.toULong().minus(other)\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): UInt = this.toUInt().times(other.toUInt())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): UInt = this.toUInt().times(other)\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = this.toULong().times(other)\n\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): UInt = this.toUInt().div(other.toUInt())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): UInt = this.toUInt().div(other)\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = this.toULong().div(other)\n\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): UInt = this.toUInt().rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): UInt = this.toUInt().rem(other.toUInt())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): UInt = this.toUInt().rem(other)\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = this.toULong().rem(other)\n\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UByte): UInt = this.toUInt().floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UShort): UInt = this.toUInt().floorDiv(other.toUInt())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UInt): UInt = this.toUInt().floorDiv(other)\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: ULong): ULong = this.toULong().floorDiv(other)\n\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UByte): UByte = this.toUInt().mod(other.toUInt()).toUByte()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UShort): UShort = this.toUInt().mod(other.toUInt()).toUShort()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UInt): UInt = this.toUInt().mod(other)\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: ULong): ULong = this.toULong().mod(other)\n\n    /**\n     * Returns this value incremented by one.\n     *\n     * @sample samples.misc.Builtins.inc\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): UShort = UShort(data.inc())\n\n    /**\n     * Returns this value decremented by one.\n     *\n     * @sample samples.misc.Builtins.dec\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): UShort = UShort(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: UShort): UIntRange = UIntRange(this.toUInt(), other.toUInt())\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: UShort): UShort = UShort(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: UShort): UShort = UShort(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: UShort): UShort = UShort(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): UShort = UShort(data.inv())\n\n    /**\n     * Converts this [UShort] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `UShort`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `UShort` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [UShort] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `UShort`. Otherwise the result is negative.\n     *\n     * The resulting `Short` value has the same binary representation as this `UShort` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data\n    /**\n     * Converts this [UShort] value to [Int].\n     *\n     * The resulting `Int` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `Int` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 16 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt() and 0xFFFF\n    /**\n     * Converts this [UShort] value to [Long].\n     *\n     * The resulting `Long` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `Long` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 48 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data.toLong() and 0xFFFF\n\n    /**\n     * Converts this [UShort] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `UShort`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `UShort` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = this\n    /**\n     * Converts this [UShort] value to [UInt].\n     *\n     * The resulting `UInt` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `UInt` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 16 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = UInt(data.toInt() and 0xFFFF)\n    /**\n     * Converts this [UShort] value to [ULong].\n     *\n     * The resulting `ULong` value represents the same numerical value as this `UShort`.\n     *\n     * The least significant 16 bits of the resulting `ULong` value are the same as the bits of this `UShort` value,\n     * whereas the most significant 48 bits are filled with zeros.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = ULong(data.toLong() and 0xFFFF)\n\n    /**\n     * Converts this [UShort] value to [Float].\n     *\n     * The resulting `Float` value represents the same numerical value as this `UShort`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toInt().toFloat()\n    /**\n     * Converts this [UShort] value to [Double].\n     *\n     * The resulting `Double` value represents the same numerical value as this `UShort`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = this.toInt().toDouble()\n\n    public override fun toString(): String = toInt().toString()\n\n}\n\n/**\n * Converts this [Byte] value to [UShort].\n *\n * If this value is positive, the resulting `UShort` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `UShort` value are the same as the bits of this `Byte` value,\n * whereas the most significant 8 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toUShort(): UShort = UShort(this.toShort())\n/**\n * Converts this [Short] value to [UShort].\n *\n * If this value is positive, the resulting `UShort` value represents the same numerical value as this `Short`.\n *\n * The resulting `UShort` value has the same binary representation as this `Short` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Short.toUShort(): UShort = UShort(this)\n/**\n * Converts this [Int] value to [UShort].\n *\n * If this value is positive and less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n * the same numerical value as this `Int`.\n *\n * The resulting `UShort` value is represented by the least significant 16 bits of this `Int` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Int.toUShort(): UShort = UShort(this.toShort())\n/**\n * Converts this [Long] value to [UShort].\n *\n * If this value is positive and less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n * the same numerical value as this `Long`.\n *\n * The resulting `UShort` value is represented by the least significant 16 bits of this `Long` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Long.toUShort(): UShort = UShort(this.toShort())\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\n/**\n * A range of values of type `Char`.\n */\npublic class CharRange(start: Char, endInclusive: Char) : CharProgression(start, endInclusive, 1), ClosedRange<Char> {\n    override val start: Char get() = first\n    override val endInclusive: Char get() = last\n\n    override fun contains(value: Char): Boolean = first <= value && value <= last\n\n    /** \n     * Checks whether the range is empty.\n     *\n     * The range is empty if its start value is greater than the end value.\n     */\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is CharRange && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * first.code + last.code)\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type Char. */\n        public val EMPTY: CharRange = CharRange(1.toChar(), 0.toChar())\n    }\n}\n\n/**\n * A range of values of type `Int`.\n */\npublic class IntRange(start: Int, endInclusive: Int) : IntProgression(start, endInclusive, 1), ClosedRange<Int> {\n    override val start: Int get() = first\n    override val endInclusive: Int get() = last\n\n    override fun contains(value: Int): Boolean = first <= value && value <= last\n\n    /** \n     * Checks whether the range is empty.\n     *\n     * The range is empty if its start value is greater than the end value.\n     */\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is IntRange && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * first + last)\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type Int. */\n        public val EMPTY: IntRange = IntRange(1, 0)\n    }\n}\n\n/**\n * A range of values of type `Long`.\n */\npublic class LongRange(start: Long, endInclusive: Long) : LongProgression(start, endInclusive, 1), ClosedRange<Long> {\n    override val start: Long get() = first\n    override val endInclusive: Long get() = last\n\n    override fun contains(value: Long): Boolean = first <= value && value <= last\n\n    /** \n     * Checks whether the range is empty.\n     *\n     * The range is empty if its start value is greater than the end value.\n     */\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is LongRange && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (first xor (first ushr 32)) + (last xor (last ushr 32))).toInt()\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type Long. */\n        public val EMPTY: LongRange = LongRange(1, 0)\n    }\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\nimport kotlin.random.Random\n\ninternal object EmptyIterator : ListIterator<Nothing> {\n    override fun hasNext(): Boolean = false\n    override fun hasPrevious(): Boolean = false\n    override fun nextIndex(): Int = 0\n    override fun previousIndex(): Int = -1\n    override fun next(): Nothing = throw NoSuchElementException()\n    override fun previous(): Nothing = throw NoSuchElementException()\n}\n\ninternal object EmptyList : List<Nothing>, Serializable, RandomAccess {\n    private const val serialVersionUID: Long = -7390468764508069838L\n\n    override fun equals(other: Any?): Boolean = other is List<*> && other.isEmpty()\n    override fun hashCode(): Int = 1\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun get(index: Int): Nothing = throw IndexOutOfBoundsException(\"Empty list doesn't contain element at index $index.\")\n    override fun indexOf(element: Nothing): Int = -1\n    override fun lastIndexOf(element: Nothing): Int = -1\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun listIterator(): ListIterator<Nothing> = EmptyIterator\n    override fun listIterator(index: Int): ListIterator<Nothing> {\n        if (index != 0) throw IndexOutOfBoundsException(\"Index: $index\")\n        return EmptyIterator\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<Nothing> {\n        if (fromIndex == 0 && toIndex == 0) return this\n        throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex\")\n    }\n\n    private fun readResolve(): Any = EmptyList\n}\n\ninternal fun <T> Array<out T>.asCollection(): Collection<T> = ArrayAsCollection(this, isVarargs = false)\n\nprivate class ArrayAsCollection<T>(val values: Array<out T>, val isVarargs: Boolean) : Collection<T> {\n    override val size: Int get() = values.size\n    override fun isEmpty(): Boolean = values.isEmpty()\n    override fun contains(element: T): Boolean = values.contains(element)\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n    override fun iterator(): Iterator<T> = values.iterator()\n    // override hidden toArray implementation to prevent copying of values array\n    public fun toArray(): Array<out Any?> = values.copyToArrayOfAny(isVarargs)\n}\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\npublic fun <T> emptyList(): List<T> = EmptyList\n\n/**\n * Returns a new read-only list of given elements.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.readOnlyList\n */\npublic fun <T> listOf(vararg elements: T): List<T> = if (elements.size > 0) elements.asList() else emptyList()\n\n/**\n * Returns an empty read-only list.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.emptyReadOnlyList\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> listOf(): List<T> = emptyList()\n\n/**\n * Returns an empty new [MutableList].\n * @sample samples.collections.Collections.Lists.emptyMutableList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableListOf(): MutableList<T> = ArrayList()\n\n/**\n * Returns an empty new [ArrayList].\n * @sample samples.collections.Collections.Lists.emptyArrayList\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> arrayListOf(): ArrayList<T> = ArrayList()\n\n/**\n * Returns a new [MutableList] with the given elements.\n * @sample samples.collections.Collections.Lists.mutableList\n */\npublic fun <T> mutableListOf(vararg elements: T): MutableList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new [ArrayList] with the given elements.\n * @sample samples.collections.Collections.Lists.arrayList\n */\npublic fun <T> arrayListOf(vararg elements: T): ArrayList<T> =\n    if (elements.size == 0) ArrayList() else ArrayList(ArrayAsCollection(elements, isVarargs = true))\n\n/**\n * Returns a new read-only list either of single given element, if it is not null, or empty list if the element is null. The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(element: T?): List<T> = if (element != null) listOf(element) else emptyList()\n\n/**\n * Returns a new read-only list only of those given elements, that are not null.  The returned list is serializable (JVM).\n * @sample samples.collections.Collections.Lists.listOfNotNull\n */\npublic fun <T : Any> listOfNotNull(vararg elements: T?): List<T> = elements.filterNotNull()\n\n/**\n * Creates a new read-only list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.readOnlyListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> List(size: Int, init: (index: Int) -> T): List<T> = MutableList(size, init)\n\n/**\n * Creates a new mutable list with the specified [size], where each element is calculated by calling the specified\n * [init] function.\n *\n * The function [init] is called for each list element sequentially starting from the first one.\n * It should return the value for a list element given its index.\n *\n * @sample samples.collections.Collections.Lists.mutableListFromInitializer\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList(size: Int, init: (index: Int) -> T): MutableList<T> {\n    val list = ArrayList<T>(size)\n    repeat(size) { index -> list.add(init(index)) }\n    return list\n}\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * The returned list is serializable (JVM).\n *\n * @sample samples.collections.Builders.Lists.buildListSample\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(@BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Builds a new read-only [List] by populating a [MutableList] using the given [builderAction]\n * and returning a read-only list with the same elements.\n *\n * The list passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * The returned list is serializable (JVM).\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Lists.buildListSampleWithCapacity\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildList(capacity: Int, @BuilderInference builderAction: MutableList<E>.() -> Unit): List<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildListInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E>\n\n/**\n * Returns an [IntRange] of the valid indices for this collection.\n * @sample samples.collections.Collections.Collections.indicesOfCollection\n */\npublic val Collection<*>.indices: IntRange\n    get() = 0..size - 1\n\n/**\n * Returns the index of the last item in the list or -1 if the list is empty.\n *\n * @sample samples.collections.Collections.Lists.lastIndexOfList\n */\npublic val <T> List<T>.lastIndex: Int\n    get() = this.size - 1\n\n/**\n * Returns `true` if the collection is not empty.\n * @sample samples.collections.Collections.Collections.collectionIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable collection is either null or empty.\n * @sample samples.collections.Collections.Collections.collectionIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.isEmpty()\n}\n\n/**\n * Returns this Collection if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Collections.collectionOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>?.orEmpty(): Collection<T> = this ?: emptyList()\n\n/**\n * Returns this List if it's not `null` and the empty list otherwise.\n * @sample samples.collections.Collections.Lists.listOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>?.orEmpty(): List<T> = this ?: emptyList()\n\n/**\n * Returns this collection if it's not empty\n * or the result of calling [defaultValue] function if the collection is empty.\n *\n * @sample samples.collections.Collections.Collections.collectionIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : Collection<*>, C : R =\n    if (isEmpty()) defaultValue() else this\n\n\n/**\n * Checks if all elements in the specified collection are contained in this collection.\n *\n * Allows to overcome type-safety restriction of `containsAll` that requires to pass a collection of type `Collection<E>`.\n * @sample samples.collections.Collections.Collections.collectionContainsAll\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> Collection<T>.containsAll(elements: Collection<T>): Boolean = this.containsAll(elements)\n\n\n/**\n * Returns a new list with the elements of this list randomly shuffled\n * using the specified [random] instance as the source of randomness.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Iterable<T>.shuffled(random: Random): List<T> = toMutableList().apply { shuffle(random) }\n\n\ninternal fun <T> List<T>.optimizeReadOnlyList() = when (size) {\n    0 -> emptyList()\n    1 -> listOf(this[0])\n    else -> this\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of its elements,\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchOnComparable\n * @sample samples.collections.Collections.Lists.binarySearchWithBoundaries\n */\npublic fun <T : Comparable<T>> List<T?>.binarySearch(element: T?, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = compareValues(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for the provided [element] using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the specified [comparator],\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements equal to the specified [element], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted according to the specified [comparator].\n * @sample samples.collections.Collections.Lists.binarySearchWithComparator\n */\npublic fun <T> List<T>.binarySearch(element: T, comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparator.compare(midVal, element)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Searches this list or its range for an element having the key returned by the specified [selector] function\n * equal to the provided [key] value using the binary search algorithm.\n * The list is expected to be sorted into ascending order according to the Comparable natural ordering of keys of its elements.\n * otherwise the result is undefined.\n *\n * If the list contains multiple elements with the specified [key], there is no guarantee which one will be found.\n *\n * `null` value is considered to be less than any non-null value.\n *\n * @return the index of the element with the specified [key], if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchByKey\n */\npublic inline fun <T, K : Comparable<K>> List<T>.binarySearchBy(\n    key: K?,\n    fromIndex: Int = 0,\n    toIndex: Int = size,\n    crossinline selector: (T) -> K?\n): Int =\n    binarySearch(fromIndex, toIndex) { compareValues(selector(it), key) }\n\n// do not introduce this overload --- too rare\n//public fun <T, K> List<T>.binarySearchBy(key: K, comparator: Comparator<K>, fromIndex: Int = 0, toIndex: Int = size(), selector: (T) -> K): Int =\n//        binarySearch(fromIndex, toIndex) { comparator.compare(selector(it), key) }\n\n\n/**\n * Searches this list or its range for an element for which the given [comparison] function returns zero using the binary search algorithm.\n *\n * The list is expected to be sorted so that the signs of the [comparison] function's return values ascend on the list elements,\n * i.e. negative values come before zero and zeroes come before positive values.\n * Otherwise, the result is undefined.\n *\n * If the list contains multiple elements for which [comparison] returns zero, there is no guarantee which one will be found.\n *\n * @param comparison function that returns zero when called on the list element being searched.\n * On the elements coming before the target element, the function must return negative values;\n * on the elements coming after the target element, the function must return positive values.\n *\n * @return the index of the found element, if it is contained in the list within the specified range;\n * otherwise, the inverted insertion point `(-insertion point - 1)`.\n * The insertion point is defined as the index at which the element should be inserted,\n * so that the list (or the specified subrange of list) still remains sorted.\n * @sample samples.collections.Collections.Lists.binarySearchWithComparisonFunction\n */\npublic fun <T> List<T>.binarySearch(fromIndex: Int = 0, toIndex: Int = size, comparison: (T) -> Int): Int {\n    rangeCheck(size, fromIndex, toIndex)\n\n    var low = fromIndex\n    var high = toIndex - 1\n\n    while (low <= high) {\n        val mid = (low + high).ushr(1) // safe from overflows\n        val midVal = get(mid)\n        val cmp = comparison(midVal)\n\n        if (cmp < 0)\n            low = mid + 1\n        else if (cmp > 0)\n            high = mid - 1\n        else\n            return mid // key found\n    }\n    return -(low + 1)  // key not found\n}\n\n/**\n * Checks that `from` and `to` are in\n * the range of [0..size] and throws an appropriate exception, if they aren't.\n */\nprivate fun rangeCheck(size: Int, fromIndex: Int, toIndex: Int) {\n    when {\n        fromIndex > toIndex -> throw IllegalArgumentException(\"fromIndex ($fromIndex) is greater than toIndex ($toIndex).\")\n        fromIndex < 0 -> throw IndexOutOfBoundsException(\"fromIndex ($fromIndex) is less than zero.\")\n        toIndex > size -> throw IndexOutOfBoundsException(\"toIndex ($toIndex) is greater than size ($size).\")\n    }\n}\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkIndexOverflow(index: Int): Int\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal expect fun checkCountOverflow(count: Int): Int\n\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwIndexOverflow() { throw ArithmeticException(\"Index overflow has happened.\") }\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun throwCountOverflow() { throw ArithmeticException(\"Count overflow has happened.\") }\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\nprivate object EmptyMap : Map<Any?, Nothing>, Serializable {\n    private const val serialVersionUID: Long = 8246714829545688274\n\n    override fun equals(other: Any?): Boolean = other is Map<*, *> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"{}\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n\n    override fun containsKey(key: Any?): Boolean = false\n    override fun containsValue(value: Nothing): Boolean = false\n    override fun get(key: Any?): Nothing? = null\n    override val entries: Set<Map.Entry<Any?, Nothing>> get() = EmptySet\n    override val keys: Set<Any?> get() = EmptySet\n    override val values: Collection<Nothing> get() = EmptyList\n\n    private fun readResolve(): Any = EmptyMap\n}\n\n/**\n * Returns an empty read-only map of specified type.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\npublic fun <K, V> emptyMap(): Map<K, V> = @Suppress(\"UNCHECKED_CAST\") (EmptyMap as Map<K, V>)\n\n/**\n * Returns a new read-only map with the specified contents, given as a list of pairs\n * where the first value is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * The returned map is serializable (JVM).\n *\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic fun <K, V> mapOf(vararg pairs: Pair<K, V>): Map<K, V> =\n    if (pairs.size > 0) pairs.toMap(LinkedHashMap(mapCapacity(pairs.size))) else emptyMap()\n\n/**\n * Returns an empty read-only map.\n *\n * The returned map is serializable (JVM).\n * @sample samples.collections.Maps.Instantiation.emptyReadOnlyMap\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mapOf(): Map<K, V> = emptyMap()\n\n/**\n * Returns an empty new [MutableMap].\n *\n * The returned map preserves the entry iteration order.\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> mutableMapOf(): MutableMap<K, V> = LinkedHashMap()\n\n/**\n * Returns a new [MutableMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.mutableMapFromPairs\n * @sample samples.collections.Maps.Instantiation.emptyMutableMap\n */\npublic fun <K, V> mutableMapOf(vararg pairs: Pair<K, V>): MutableMap<K, V> =\n    LinkedHashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [HashMap].\n *\n * @sample samples.collections.Maps.Instantiation.emptyHashMap\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> hashMapOf(): HashMap<K, V> = HashMap<K, V>()\n\n/**\n * Returns a new [HashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * @sample samples.collections.Maps.Instantiation.hashMapFromPairs\n */\npublic fun <K, V> hashMapOf(vararg pairs: Pair<K, V>): HashMap<K, V> = HashMap<K, V>(mapCapacity(pairs.size)).apply { putAll(pairs) }\n\n/**\n * Returns an empty new [LinkedHashMap].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> linkedMapOf(): LinkedHashMap<K, V> = LinkedHashMap<K, V>()\n\n/**\n * Returns a new [LinkedHashMap] with the specified contents, given as a list of pairs\n * where the first component is the key and the second is the value.\n *\n * If multiple pairs have the same key, the resulting map will contain the value from the last of those pairs.\n *\n * Entries of the map are iterated in the order they were specified.\n *\n * @sample samples.collections.Maps.Instantiation.linkedMapFromPairs\n */\npublic fun <K, V> linkedMapOf(vararg pairs: Pair<K, V>): LinkedHashMap<K, V> = pairs.toMap(LinkedHashMap(mapCapacity(pairs.size)))\n\n/**\n * Builds a new read-only [Map] by populating a [MutableMap] using the given [builderAction]\n * and returning a read-only map with the same key-value pairs.\n *\n * The map passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * Entries of the map are iterated in the order they were added by the [builderAction].\n *\n * The returned map is serializable (JVM).\n *\n * @sample samples.collections.Builders.Maps.buildMapSample\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> buildMap(@BuilderInference builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildMapInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal expect inline fun <K, V> buildMapInternal(builderAction: MutableMap<K, V>.() -> Unit): Map<K, V>\n\n/**\n * Builds a new read-only [Map] by populating a [MutableMap] using the given [builderAction]\n * and returning a read-only map with the same key-value pairs.\n *\n * The map passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of pairs added in the [builderAction].\n *\n * Entries of the map are iterated in the order they were added by the [builderAction].\n *\n * The returned map is serializable (JVM).\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Maps.buildMapSample\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> buildMap(capacity: Int, @BuilderInference builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildMapInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal expect inline fun <K, V> buildMapInternal(capacity: Int, builderAction: MutableMap<K, V>.() -> Unit): Map<K, V>\n\n/**\n * Calculate the initial capacity of a map.\n */\n@PublishedApi\ninternal expect fun mapCapacity(expectedSize: Int): Int\n\n/**\n * Returns `true` if this map is not empty.\n * @sample samples.collections.Maps.Usage.mapIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.isNotEmpty(): Boolean = !isEmpty()\n\n/**\n * Returns `true` if this nullable map is either null or empty.\n * @sample samples.collections.Maps.Usage.mapIsNullOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || isEmpty()\n}\n\n/**\n * Returns the [Map] if its not `null`, or the empty [Map] otherwise.\n *\n * @sample samples.collections.Maps.Usage.mapOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>?.orEmpty(): Map<K, V> = this ?: emptyMap()\n\n/**\n * Returns this map if it's not empty\n * or the result of calling [defaultValue] function if the map is empty.\n *\n * @sample samples.collections.Maps.Usage.mapIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <M, R> M.ifEmpty(defaultValue: () -> R): R where M : Map<*, *>, M : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Checks if the map contains the given key.\n *\n * This method allows to use the `x in map` syntax for checking whether an object is contained in the map.\n *\n * @sample samples.collections.Maps.Usage.containsKey\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.contains(key: K): Boolean = containsKey(key)\n\n/**\n * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <@kotlin.internal.OnlyInputTypes K, V> Map<out K, V>.get(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, V>).get(key)\n\n/**\n * Allows to use the index operator for storing values in a mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.set(key: K, value: V): Unit {\n    put(key, value)\n}\n\n/**\n * Returns `true` if the map contains the specified [key].\n *\n * Allows to overcome type-safety restriction of `containsKey` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K> Map<out K, *>.containsKey(key: K): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as Map<K, *>).containsKey(key)\n\n/**\n * Returns `true` if the map maps one or more keys to the specified [value].\n *\n * Allows to overcome type-safety restriction of `containsValue` that requires to pass a value of type `V`.\n *\n * @sample samples.collections.Maps.Usage.containsValue\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\n@kotlin.internal.InlineOnly\npublic inline fun <K, @kotlin.internal.OnlyInputTypes V> Map<K, V>.containsValue(value: V): Boolean = this.containsValue(value)\n\n\n/**\n * Removes the specified key and its corresponding value from this map.\n *\n * @return the previous value associated with the key, or `null` if the key was not present in the map.\n\n * Allows to overcome type-safety restriction of `remove` that requires to pass a key of type `K`.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes K, V> MutableMap<out K, V>.remove(key: K): V? =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableMap<K, V>).remove(key)\n\n/**\n * Returns the key component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component1(): K = key\n\n/**\n * Returns the value component of the map entry.\n *\n * This method allows to use destructuring declarations when working with maps, for example:\n * ```\n * for ((key, value) in map) {\n *     // do something with the key and the value\n * }\n * ```\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map.Entry<K, V>.component2(): V = value\n\n/**\n * Converts entry to [Pair] with key being first component and value being second.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map.Entry<K, V>.toPair(): Pair<K, V> = Pair(key, value)\n\n/**\n * Returns the value for the given key, or the result of the [defaultValue] function if there was no entry for the given key.\n *\n * @sample samples.collections.Maps.Usage.getOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<K, V>.getOrElse(key: K, defaultValue: () -> V): V = get(key) ?: defaultValue()\n\n\ninternal inline fun <K, V> Map<K, V>.getOrElseNullable(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    if (value == null && !containsKey(key)) {\n        return defaultValue()\n    } else {\n        @Suppress(\"UNCHECKED_CAST\")\n        return value as V\n    }\n}\n\n/**\n * Returns the value for the given [key] or throws an exception if there is no such key in the map.\n *\n * If the map was created by [withDefault], resorts to its `defaultValue` provider function\n * instead of throwing an exception.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and\n * no implicit default value was provided for that map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<K, V>.getValue(key: K): V = getOrImplicitDefault(key)\n\n/**\n * Returns the value for the given key. If the key is not found in the map, calls the [defaultValue] function,\n * puts its result into the map under the given key and returns it.\n *\n * Note that the operation is not guaranteed to be atomic if the map is being modified concurrently.\n *\n * @sample samples.collections.Maps.Usage.getOrPut\n */\npublic inline fun <K, V> MutableMap<K, V>.getOrPut(key: K, defaultValue: () -> V): V {\n    val value = get(key)\n    return if (value == null) {\n        val answer = defaultValue()\n        put(key, answer)\n        answer\n    } else {\n        value\n    }\n}\n\n/**\n * Returns an [Iterator] over the entries in the [Map].\n *\n * @sample samples.collections.Maps.Usage.forOverEntries\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> Map<out K, V>.iterator(): Iterator<Map.Entry<K, V>> = entries.iterator()\n\n/**\n * Returns a [MutableIterator] over the mutable entries in the [MutableMap].\n *\n */\n@kotlin.jvm.JvmName(\"mutableIterator\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.iterator(): MutableIterator<MutableMap.MutableEntry<K, V>> = entries.iterator()\n\n/**\n * Populates the given [destination] map with entries having the keys of this map and the values obtained\n * by applying the [transform] function to each entry in this [Map].\n */\npublic inline fun <K, V, R, M : MutableMap<in K, in R>> Map<out K, V>.mapValuesTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, { it.key }, transform)\n}\n\n/**\n * Populates the given [destination] map with entries having the keys obtained\n * by applying the [transform] function to each entry in this [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n */\npublic inline fun <K, V, R, M : MutableMap<in R, in V>> Map<out K, V>.mapKeysTo(destination: M, transform: (Map.Entry<K, V>) -> R): M {\n    return entries.associateByTo(destination, transform, { it.value })\n}\n\n/**\n * Puts all the given [pairs] into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Array<out Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given collection into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Iterable<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Puts all the elements of the given sequence into this [MutableMap] with the first component in the pair being the key and the second the value.\n */\npublic fun <K, V> MutableMap<in K, in V>.putAll(pairs: Sequence<Pair<K, V>>): Unit {\n    for ((key, value) in pairs) {\n        put(key, value)\n    }\n}\n\n/**\n * Returns a new map with entries having the keys of this map and the values obtained by applying the [transform]\n * function to each entry in this [Map].\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapValues\n */\npublic inline fun <K, V, R> Map<out K, V>.mapValues(transform: (Map.Entry<K, V>) -> R): Map<K, R> {\n    return mapValuesTo(LinkedHashMap<K, R>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a new Map with entries having the keys obtained by applying the [transform] function to each entry in this\n * [Map] and the values of this map.\n *\n * In case if any two entries are mapped to the equal keys, the value of the latter one will overwrite\n * the value associated with the former one.\n *\n * The returned map preserves the entry iteration order of the original map.\n *\n * @sample samples.collections.Maps.Transformations.mapKeys\n */\npublic inline fun <K, V, R> Map<out K, V>.mapKeys(transform: (Map.Entry<K, V>) -> R): Map<R, V> {\n    return mapKeysTo(LinkedHashMap<R, V>(mapCapacity(size)), transform) // .optimizeReadOnlyMap()\n}\n\n/**\n * Returns a map containing all key-value pairs with keys matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterKeys\n */\npublic inline fun <K, V> Map<out K, V>.filterKeys(predicate: (K) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.key)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n/**\n * Returns a map containing all key-value pairs with values matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n *  @sample samples.collections.Maps.Filtering.filterValues\n */\npublic inline fun <K, V> Map<out K, V>.filterValues(predicate: (V) -> Boolean): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    for (entry in this) {\n        if (predicate(entry.value)) {\n            result.put(entry.key, entry.value)\n        }\n    }\n    return result\n}\n\n\n/**\n * Appends all entries matching the given [predicate] into the mutable map given as [destination] parameter.\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filter\n */\npublic inline fun <K, V> Map<out K, V>.filter(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Appends all entries not matching the given [predicate] into the given [destination].\n *\n * @return the destination map.\n * @sample samples.collections.Maps.Filtering.filterNotTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.filterNotTo(destination: M, predicate: (Map.Entry<K, V>) -> Boolean): M {\n    for (element in this) {\n        if (!predicate(element)) {\n            destination.put(element.key, element.value)\n        }\n    }\n    return destination\n}\n\n/**\n * Returns a new map containing all key-value pairs not matching the given [predicate].\n *\n * The returned map preserves the entry iteration order of the original map.\n * @sample samples.collections.Maps.Filtering.filterNot\n */\npublic inline fun <K, V> Map<out K, V>.filterNot(predicate: (Map.Entry<K, V>) -> Boolean): Map<K, V> {\n    return filterNotTo(LinkedHashMap<K, V>(), predicate)\n}\n\n/**\n * Returns a new map containing all key-value pairs from the given collection of pairs.\n *\n * The returned map preserves the entry iteration order of the original collection.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Iterable<Pair<K, V>>.toMap(): Map<K, V> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyMap()\n            1 -> mapOf(if (this is List) this[0] else iterator().next())\n            else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n        }\n    }\n    return toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given collection of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Iterable<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given array of pairs.\n *\n * The returned map preserves the entry iteration order of the original array.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Array<out Pair<K, V>>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> mapOf(this[0])\n    else -> toMap(LinkedHashMap<K, V>(mapCapacity(size)))\n}\n\n/**\n *  Populates and returns the [destination] mutable map with key-value pairs from the given array of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Array<out Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new map containing all key-value pairs from the given sequence of pairs.\n *\n * The returned map preserves the entry iteration order of the original sequence.\n * If any of two pairs would have the same key the last one gets added to the map.\n */\npublic fun <K, V> Sequence<Pair<K, V>>.toMap(): Map<K, V> = toMap(LinkedHashMap<K, V>()).optimizeReadOnlyMap()\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given sequence of pairs.\n */\npublic fun <K, V, M : MutableMap<in K, in V>> Sequence<Pair<K, V>>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Returns a new read-only map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMap(): Map<K, V> = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMap()\n    else -> toMutableMap()\n}\n\n/**\n * Returns a new mutable map containing all key-value pairs from the original map.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V> Map<out K, V>.toMutableMap(): MutableMap<K, V> = LinkedHashMap(this)\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs from the given map.\n */\n@SinceKotlin(\"1.1\")\npublic fun <K, V, M : MutableMap<in K, in V>> Map<out K, V>.toMap(destination: M): M =\n    destination.apply { putAll(this@toMap) }\n\n/**\n * Creates a new read-only map by replacing or adding an entry to this map from a given key-value [pair].\n *\n * The returned map preserves the entry iteration order of the original map.\n * The [pair] is iterated in the end if it has a unique key.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pair: Pair<K, V>): Map<K, V> =\n    if (this.isEmpty()) mapOf(pair) else LinkedHashMap(this).apply { put(pair.first, pair.second) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given collection of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] collection.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Iterable<Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given array of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] array.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Array<out Pair<K, V>>): Map<K, V> =\n    if (this.isEmpty()) pairs.toMap() else LinkedHashMap(this).apply { putAll(pairs) }\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from a given sequence of key-value [pairs].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those [pairs] with unique keys are iterated in the end in the order of [pairs] sequence.\n */\npublic operator fun <K, V> Map<out K, V>.plus(pairs: Sequence<Pair<K, V>>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(pairs) }.optimizeReadOnlyMap()\n\n/**\n * Creates a new read-only map by replacing or adding entries to this map from another [map].\n *\n * The returned map preserves the entry iteration order of the original map.\n * Those entries of another [map] that are missing in this map are iterated in the end in the order of that [map].\n */\npublic operator fun <K, V> Map<out K, V>.plus(map: Map<out K, V>): Map<K, V> =\n    LinkedHashMap(this).apply { putAll(map) }\n\n\n/**\n * Appends or replaces the given [pair] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pair: Pair<K, V>) {\n    put(pair.first, pair.second)\n}\n\n/**\n * Appends or replaces all pairs from the given collection of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Iterable<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given array of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Array<out Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all pairs from the given sequence of [pairs] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(pairs: Sequence<Pair<K, V>>) {\n    putAll(pairs)\n}\n\n/**\n * Appends or replaces all entries from the given [map] in this mutable map.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<in K, in V>.plusAssign(map: Map<K, V>) {\n    putAll(map)\n}\n\n/**\n * Returns a map containing all entries of the original map except the entry with the given [key].\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(key: K): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(key) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] collection.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Iterable<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] array.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Array<out K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Returns a map containing all entries of the original map except those entries\n * the keys of which are contained in the given [keys] sequence.\n *\n * The returned map preserves the entry iteration order of the original map.\n */\n@SinceKotlin(\"1.1\")\npublic operator fun <K, V> Map<out K, V>.minus(keys: Sequence<K>): Map<K, V> =\n    this.toMutableMap().apply { minusAssign(keys) }.optimizeReadOnlyMap()\n\n/**\n * Removes the entry with the given [key] from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(key: K) {\n    remove(key)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] collection from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Iterable<K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries the keys of which are contained in the given [keys] array from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Array<out K>) {\n    this.keys.removeAll(keys)\n}\n\n/**\n * Removes all entries from the keys of which are contained in the given [keys] sequence from this mutable map.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <K, V> MutableMap<K, V>.minusAssign(keys: Sequence<K>) {\n    this.keys.removeAll(keys)\n}\n\n\n// do not expose for now @PublishedApi\ninternal fun <K, V> Map<K, V>.optimizeReadOnlyMap() = when (size) {\n    0 -> emptyMap()\n    1 -> toSingletonMapOrSelf()\n    else -> this\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SetsKt\")\n@file:OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n\npackage kotlin.collections\n\nimport kotlin.contracts.*\n\ninternal object EmptySet : Set<Nothing>, Serializable {\n    private const val serialVersionUID: Long = 3406603774387020532\n\n    override fun equals(other: Any?): Boolean = other is Set<*> && other.isEmpty()\n    override fun hashCode(): Int = 0\n    override fun toString(): String = \"[]\"\n\n    override val size: Int get() = 0\n    override fun isEmpty(): Boolean = true\n    override fun contains(element: Nothing): Boolean = false\n    override fun containsAll(elements: Collection<Nothing>): Boolean = elements.isEmpty()\n\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n\n    private fun readResolve(): Any = EmptySet\n}\n\n\n/**\n * Returns an empty read-only set.  The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.emptyReadOnlySet\n */\npublic fun <T> emptySet(): Set<T> = EmptySet\n\n/**\n * Returns a new read-only set with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.readOnlySet\n */\npublic fun <T> setOf(vararg elements: T): Set<T> = if (elements.size > 0) elements.toSet() else emptySet()\n\n/**\n * Returns an empty read-only set.  The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.emptyReadOnlySet\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> setOf(): Set<T> = emptySet()\n\n/**\n * Returns an empty new [MutableSet].\n *\n * The returned set preserves the element iteration order.\n * @sample samples.collections.Collections.Sets.emptyMutableSet\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> mutableSetOf(): MutableSet<T> = LinkedHashSet()\n\n/**\n * Returns a new [MutableSet] with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * @sample samples.collections.Collections.Sets.mutableSet\n */\npublic fun <T> mutableSetOf(vararg elements: T): MutableSet<T> = elements.toCollection(LinkedHashSet(mapCapacity(elements.size)))\n\n/** Returns an empty new [HashSet]. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> hashSetOf(): HashSet<T> = HashSet()\n\n/** Returns a new [HashSet] with the given elements. */\npublic fun <T> hashSetOf(vararg elements: T): HashSet<T> = elements.toCollection(HashSet(mapCapacity(elements.size)))\n\n/**\n * Returns an empty new [LinkedHashSet].\n * @sample samples.collections.Collections.Sets.emptyLinkedHashSet\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> linkedSetOf(): LinkedHashSet<T> = LinkedHashSet()\n\n/**\n * Returns a new [LinkedHashSet] with the given elements.\n * Elements of the set are iterated in the order they were specified.\n * @sample samples.collections.Collections.Sets.linkedHashSet\n */\npublic fun <T> linkedSetOf(vararg elements: T): LinkedHashSet<T> = elements.toCollection(LinkedHashSet(mapCapacity(elements.size)))\n\n/**\n * Returns a new read-only set either with single given element, if it is not null, or empty set if the element is null.\n * The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.setOfNotNull\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Any> setOfNotNull(element: T?): Set<T> = if (element != null) setOf(element) else emptySet()\n\n/**\n * Returns a new read-only set only with those given elements, that are not null.\n * Elements of the set are iterated in the order they were specified.\n * The returned set is serializable (JVM).\n * @sample samples.collections.Collections.Sets.setOfNotNull\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Any> setOfNotNull(vararg elements: T?): Set<T> {\n    return elements.filterNotNullTo(LinkedHashSet())\n}\n\n/**\n * Builds a new read-only [Set] by populating a [MutableSet] using the given [builderAction]\n * and returning a read-only set with the same elements.\n *\n * The set passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * Elements of the set are iterated in the order they were added by the [builderAction].\n *\n * The returned set is serializable (JVM).\n *\n * @sample samples.collections.Builders.Sets.buildSetSample\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildSet(@BuilderInference builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildSetInternal(builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildSetInternal(builderAction: MutableSet<E>.() -> Unit): Set<E>\n\n/**\n * Builds a new read-only [Set] by populating a [MutableSet] using the given [builderAction]\n * and returning a read-only set with the same elements.\n *\n * The set passed as a receiver to the [builderAction] is valid only inside that function.\n * Using it outside of the function produces an unspecified behavior.\n *\n * [capacity] is used to hint the expected number of elements added in the [builderAction].\n *\n * Elements of the set are iterated in the order they were added by the [builderAction].\n *\n * The returned set is serializable (JVM).\n *\n * @throws IllegalArgumentException if the given [capacity] is negative.\n *\n * @sample samples.collections.Builders.Sets.buildSetSample\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <E> buildSet(capacity: Int, @BuilderInference builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return buildSetInternal(capacity, builderAction)\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal expect inline fun <E> buildSetInternal(capacity: Int, builderAction: MutableSet<E>.() -> Unit): Set<E>\n\n\n/** Returns this Set if it's not `null` and the empty set otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Set<T>?.orEmpty(): Set<T> = this ?: emptySet()\n\ninternal fun <T> Set<T>.optimizeReadOnlySet() = when (size) {\n    0 -> emptySet()\n    1 -> setOf(iterator().next())\n    else -> this\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n@file:Suppress(\"PLATFORM_CLASS_MAPPED_TO_KOTLIN\")\n\npackage kotlin.text\n\n/**\n * Parses the string as a signed [Byte] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toByteOrNull(): Byte? = toByteOrNull(radix = 10)\n\n/**\n * Parses the string as a signed [Byte] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toByteOrNull(radix: Int): Byte? {\n    val int = this.toIntOrNull(radix) ?: return null\n    if (int < Byte.MIN_VALUE || int > Byte.MAX_VALUE) return null\n    return int.toByte()\n}\n\n/**\n * Parses the string as a [Short] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toShortOrNull(): Short? = toShortOrNull(radix = 10)\n\n/**\n * Parses the string as a [Short] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toShortOrNull(radix: Int): Short? {\n    val int = this.toIntOrNull(radix) ?: return null\n    if (int < Short.MIN_VALUE || int > Short.MAX_VALUE) return null\n    return int.toShort()\n}\n\n/**\n * Parses the string as an [Int] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toIntOrNull(): Int? = toIntOrNull(radix = 10)\n\n/**\n * Parses the string as an [Int] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toIntOrNull(radix: Int): Int? {\n    checkRadix(radix)\n\n    val length = this.length\n    if (length == 0) return null\n\n    val start: Int\n    val isNegative: Boolean\n    val limit: Int\n\n    val firstChar = this[0]\n    if (firstChar < '0') {  // Possible leading sign\n        if (length == 1) return null  // non-digit (possible sign) only, no digits after\n\n        start = 1\n\n        if (firstChar == '-') {\n            isNegative = true\n            limit = Int.MIN_VALUE\n        } else if (firstChar == '+') {\n            isNegative = false\n            limit = -Int.MAX_VALUE\n        } else\n            return null\n    } else {\n        start = 0\n        isNegative = false\n        limit = -Int.MAX_VALUE\n    }\n\n\n    val limitForMaxRadix = (-Int.MAX_VALUE) / 36\n\n    var limitBeforeMul = limitForMaxRadix\n    var result = 0\n    for (i in start until length) {\n        val digit = digitOf(this[i], radix)\n\n        if (digit < 0) return null\n        if (result < limitBeforeMul) {\n            if (limitBeforeMul == limitForMaxRadix) {\n                limitBeforeMul = limit / radix\n\n                if (result < limitBeforeMul) {\n                    return null\n                }\n            } else {\n                return null\n            }\n        }\n\n        result *= radix\n\n        if (result < limit + digit) return null\n\n        result -= digit\n    }\n\n    return if (isNegative) result else -result\n}\n\n/**\n * Parses the string as a [Long] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toLongOrNull(): Long? = toLongOrNull(radix = 10)\n\n/**\n * Parses the string as a [Long] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\n@SinceKotlin(\"1.1\")\npublic fun String.toLongOrNull(radix: Int): Long? {\n    checkRadix(radix)\n\n    val length = this.length\n    if (length == 0) return null\n\n    val start: Int\n    val isNegative: Boolean\n    val limit: Long\n\n    val firstChar = this[0]\n    if (firstChar < '0') {  // Possible leading sign\n        if (length == 1) return null  // non-digit (possible sign) only, no digits after\n\n        start = 1\n\n        if (firstChar == '-') {\n            isNegative = true\n            limit = Long.MIN_VALUE\n        } else if (firstChar == '+') {\n            isNegative = false\n            limit = -Long.MAX_VALUE\n        } else\n            return null\n    } else {\n        start = 0\n        isNegative = false\n        limit = -Long.MAX_VALUE\n    }\n\n\n    val limitForMaxRadix = (-Long.MAX_VALUE) / 36\n\n    var limitBeforeMul = limitForMaxRadix\n    var result = 0L\n    for (i in start until length) {\n        val digit = digitOf(this[i], radix)\n\n        if (digit < 0) return null\n        if (result < limitBeforeMul) {\n            if (limitBeforeMul == limitForMaxRadix) {\n                limitBeforeMul = limit / radix\n\n                if (result < limitBeforeMul) {\n                    return null\n                }\n            } else {\n                return null\n            }\n        }\n\n        result *= radix\n\n        if (result < limit + digit) return null\n\n        result -= digit\n    }\n\n    return if (isNegative) result else -result\n}\n\n\ninternal fun numberFormatError(input: String): Nothing = throw NumberFormatException(\"Invalid number format: '$input'\")\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.time\n\nimport kotlin.contracts.*\nimport kotlin.jvm.JvmInline\nimport kotlin.math.*\n\n/**\n * Represents the amount of time one instant of time is away from another instant.\n *\n * A negative duration is possible in a situation when the second instant is earlier than the first one.\n *\n * The type can store duration values up to 146 years with nanosecond precision,\n * and up to 146 million years with millisecond precision.\n * If a duration-returning operation provided in `kotlin.time` produces a duration value that doesn't fit into the above range,\n * the returned `Duration` is infinite.\n *\n * An infinite duration value [Duration.INFINITE] can be used to represent infinite timeouts.\n *\n * To construct a duration use either the extension function [toDuration],\n * or the extension properties [hours], [minutes], [seconds], and so on,\n * available on [Int], [Long], and [Double] numeric types.\n *\n * To get the value of this duration expressed in a particular [duration units][DurationUnit]\n * use the functions [toInt], [toLong], and [toDouble]\n * or the properties [inWholeHours], [inWholeMinutes], [inWholeSeconds], [inWholeNanoseconds], and so on.\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalTime::class)\n@JvmInline\npublic value class Duration internal constructor(private val rawValue: Long) : Comparable<Duration> {\n\n    private val value: Long get() = rawValue shr 1\n    private inline val unitDiscriminator: Int get() = rawValue.toInt() and 1\n    private fun isInNanos() = unitDiscriminator == 0\n    private fun isInMillis() = unitDiscriminator == 1\n    private val storageUnit get() = if (isInNanos()) DurationUnit.NANOSECONDS else DurationUnit.MILLISECONDS\n\n    init {\n        if (durationAssertionsEnabled) {\n            if (isInNanos()) {\n                if (value !in -MAX_NANOS..MAX_NANOS) throw AssertionError(\"$value ns is out of nanoseconds range\")\n            } else {\n                if (value !in -MAX_MILLIS..MAX_MILLIS) throw AssertionError(\"$value ms is out of milliseconds range\")\n                if (value in -MAX_NANOS_IN_MILLIS..MAX_NANOS_IN_MILLIS) throw AssertionError(\"$value ms is denormalized\")\n            }\n        }\n    }\n\n    companion object {\n        /** The duration equal to exactly 0 seconds. */\n        public val ZERO: Duration = Duration(0L)\n\n        /** The duration whose value is positive infinity. It is useful for representing timeouts that should never expire. */\n        public val INFINITE: Duration = durationOfMillis(MAX_MILLIS)\n        internal val NEG_INFINITE: Duration = durationOfMillis(-MAX_MILLIS)\n\n        /** Converts the given time duration [value] expressed in the specified [sourceUnit] into the specified [targetUnit]. */\n        @ExperimentalTime\n        public fun convert(value: Double, sourceUnit: DurationUnit, targetUnit: DurationUnit): Double =\n            convertDurationUnit(value, sourceUnit, targetUnit)\n\n        // Duration construction extension properties in Duration companion scope\n\n        /** Returns a [Duration] equal to this [Int] number of nanoseconds. */\n        @kotlin.internal.InlineOnly\n        public inline val Int.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n        /** Returns a [Duration] equal to this [Long] number of nanoseconds. */\n        @kotlin.internal.InlineOnly\n        public inline val Long.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n        /**\n         * Returns a [Duration] equal to this [Double] number of nanoseconds.\n         *\n         * Depending on its magnitude, the value is rounded to an integer number of nanoseconds or milliseconds.\n         *\n         * @throws IllegalArgumentException if this [Double] value is `NaN`.\n         */\n        @kotlin.internal.InlineOnly\n        public inline val Double.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n\n        /** Returns a [Duration] equal to this [Int] number of microseconds. */\n        @kotlin.internal.InlineOnly\n        public inline val Int.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n        /** Returns a [Duration] equal to this [Long] number of microseconds. */\n        @kotlin.internal.InlineOnly\n        public inline val Long.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n        /**\n         * Returns a [Duration] equal to this [Double] number of microseconds.\n         *\n         * Depending on its magnitude, the value is rounded to an integer number of nanoseconds or milliseconds.\n         *\n         * @throws IllegalArgumentException if this [Double] value is `NaN`.\n         */\n        @kotlin.internal.InlineOnly\n        public inline val Double.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n\n        /** Returns a [Duration] equal to this [Int] number of milliseconds. */\n        @kotlin.internal.InlineOnly\n        public inline val Int.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n        /** Returns a [Duration] equal to this [Long] number of milliseconds. */\n        @kotlin.internal.InlineOnly\n        public inline val Long.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n        /**\n         * Returns a [Duration] equal to this [Double] number of milliseconds.\n         *\n         * Depending on its magnitude, the value is rounded to an integer number of nanoseconds or milliseconds.\n         *\n         * @throws IllegalArgumentException if this [Double] value is `NaN`.\n         */\n        @kotlin.internal.InlineOnly\n        public inline val Double.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n\n        /** Returns a [Duration] equal to this [Int] number of seconds. */\n        @kotlin.internal.InlineOnly\n        public inline val Int.seconds get() = toDuration(DurationUnit.SECONDS)\n\n        /** Returns a [Duration] equal to this [Long] number of seconds. */\n        @kotlin.internal.InlineOnly\n        public inline val Long.seconds get() = toDuration(DurationUnit.SECONDS)\n\n        /**\n         * Returns a [Duration] equal to this [Double] number of seconds.\n         *\n         * Depending on its magnitude, the value is rounded to an integer number of nanoseconds or milliseconds.\n         *\n         * @throws IllegalArgumentException if this [Double] value is `NaN`.\n         */\n        @kotlin.internal.InlineOnly\n        public inline val Double.seconds get() = toDuration(DurationUnit.SECONDS)\n\n\n        /** Returns a [Duration] equal to this [Int] number of minutes. */\n        @kotlin.internal.InlineOnly\n        public inline val Int.minutes get() = toDuration(DurationUnit.MINUTES)\n\n        /** Returns a [Duration] equal to this [Long] number of minutes. */\n        @kotlin.internal.InlineOnly\n        public inline val Long.minutes get() = toDuration(DurationUnit.MINUTES)\n\n        /**\n         * Returns a [Duration] equal to this [Double] number of minutes.\n         *\n         * Depending on its magnitude, the value is rounded to an integer number of nanoseconds or milliseconds.\n         *\n         * @throws IllegalArgumentException if this [Double] value is `NaN`.\n         */\n        @kotlin.internal.InlineOnly\n        public inline val Double.minutes get() = toDuration(DurationUnit.MINUTES)\n\n\n        /** Returns a [Duration] equal to this [Int] number of hours. */\n        @kotlin.internal.InlineOnly\n        public inline val Int.hours get() = toDuration(DurationUnit.HOURS)\n\n        /** Returns a [Duration] equal to this [Long] number of hours. */\n        @kotlin.internal.InlineOnly\n        public inline val Long.hours get() = toDuration(DurationUnit.HOURS)\n\n        /**\n         * Returns a [Duration] equal to this [Double] number of hours.\n         *\n         * Depending on its magnitude, the value is rounded to an integer number of nanoseconds or milliseconds.\n         *\n         * @throws IllegalArgumentException if this [Double] value is `NaN`.\n         */\n        @kotlin.internal.InlineOnly\n        public inline val Double.hours get() = toDuration(DurationUnit.HOURS)\n\n\n        /** Returns a [Duration] equal to this [Int] number of days. */\n        @kotlin.internal.InlineOnly\n        public inline val Int.days get() = toDuration(DurationUnit.DAYS)\n\n        /** Returns a [Duration] equal to this [Long] number of days. */\n        @kotlin.internal.InlineOnly\n        public inline val Long.days get() = toDuration(DurationUnit.DAYS)\n\n        /**\n         * Returns a [Duration] equal to this [Double] number of days.\n         *\n         * Depending on its magnitude, the value is rounded to an integer number of nanoseconds or milliseconds.\n         *\n         * @throws IllegalArgumentException if this [Double] value is `NaN`.\n         */\n        @kotlin.internal.InlineOnly\n        public inline val Double.days get() = toDuration(DurationUnit.DAYS)\n\n\n        // deprecated static factory functions\n\n        /** Returns a [Duration] representing the specified [value] number of nanoseconds. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Int.nanoseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.nanoseconds\", \"kotlin.time.Duration.Companion.nanoseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun nanoseconds(value: Int): Duration = value.toDuration(DurationUnit.NANOSECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of nanoseconds. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Long.nanoseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.nanoseconds\", \"kotlin.time.Duration.Companion.nanoseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun nanoseconds(value: Long): Duration = value.toDuration(DurationUnit.NANOSECONDS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of nanoseconds.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Double.nanoseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.nanoseconds\", \"kotlin.time.Duration.Companion.nanoseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun nanoseconds(value: Double): Duration = value.toDuration(DurationUnit.NANOSECONDS)\n\n\n        /** Returns a [Duration] representing the specified [value] number of microseconds. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Int.microseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.microseconds\", \"kotlin.time.Duration.Companion.microseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun microseconds(value: Int): Duration = value.toDuration(DurationUnit.MICROSECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of microseconds. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Long.microseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.microseconds\", \"kotlin.time.Duration.Companion.microseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun microseconds(value: Long): Duration = value.toDuration(DurationUnit.MICROSECONDS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of microseconds.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Double.microseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.microseconds\", \"kotlin.time.Duration.Companion.microseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun microseconds(value: Double): Duration = value.toDuration(DurationUnit.MICROSECONDS)\n\n\n        /** Returns a [Duration] representing the specified [value] number of milliseconds. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Int.milliseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.milliseconds\", \"kotlin.time.Duration.Companion.milliseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun milliseconds(value: Int): Duration = value.toDuration(DurationUnit.MILLISECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of milliseconds. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Long.milliseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.milliseconds\", \"kotlin.time.Duration.Companion.milliseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun milliseconds(value: Long): Duration = value.toDuration(DurationUnit.MILLISECONDS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of milliseconds.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Double.milliseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.milliseconds\", \"kotlin.time.Duration.Companion.milliseconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun milliseconds(value: Double): Duration = value.toDuration(DurationUnit.MILLISECONDS)\n\n\n        /** Returns a [Duration] representing the specified [value] number of seconds. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Int.seconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.seconds\", \"kotlin.time.Duration.Companion.seconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun seconds(value: Int): Duration = value.toDuration(DurationUnit.SECONDS)\n\n        /** Returns a [Duration] representing the specified [value] number of seconds. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Long.seconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.seconds\", \"kotlin.time.Duration.Companion.seconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun seconds(value: Long): Duration = value.toDuration(DurationUnit.SECONDS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of seconds.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Double.seconds' extension property from Duration.Companion instead.\", ReplaceWith(\"value.seconds\", \"kotlin.time.Duration.Companion.seconds\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun seconds(value: Double): Duration = value.toDuration(DurationUnit.SECONDS)\n\n\n        /** Returns a [Duration] representing the specified [value] number of minutes. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Int.minutes' extension property from Duration.Companion instead.\", ReplaceWith(\"value.minutes\", \"kotlin.time.Duration.Companion.minutes\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun minutes(value: Int): Duration = value.toDuration(DurationUnit.MINUTES)\n\n        /** Returns a [Duration] representing the specified [value] number of minutes. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Long.minutes' extension property from Duration.Companion instead.\", ReplaceWith(\"value.minutes\", \"kotlin.time.Duration.Companion.minutes\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun minutes(value: Long): Duration = value.toDuration(DurationUnit.MINUTES)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of minutes.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Double.minutes' extension property from Duration.Companion instead.\", ReplaceWith(\"value.minutes\", \"kotlin.time.Duration.Companion.minutes\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun minutes(value: Double): Duration = value.toDuration(DurationUnit.MINUTES)\n\n\n        /** Returns a [Duration] representing the specified [value] number of hours. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Int.hours' extension property from Duration.Companion instead.\", ReplaceWith(\"value.hours\", \"kotlin.time.Duration.Companion.hours\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun hours(value: Int): Duration = value.toDuration(DurationUnit.HOURS)\n\n        /** Returns a [Duration] representing the specified [value] number of hours. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Long.hours' extension property from Duration.Companion instead.\", ReplaceWith(\"value.hours\", \"kotlin.time.Duration.Companion.hours\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun hours(value: Long): Duration = value.toDuration(DurationUnit.HOURS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of hours.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Double.hours' extension property from Duration.Companion instead.\", ReplaceWith(\"value.hours\", \"kotlin.time.Duration.Companion.hours\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun hours(value: Double): Duration = value.toDuration(DurationUnit.HOURS)\n\n\n        /** Returns a [Duration] representing the specified [value] number of days. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Int.days' extension property from Duration.Companion instead.\", ReplaceWith(\"value.days\", \"kotlin.time.Duration.Companion.days\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun days(value: Int): Duration = value.toDuration(DurationUnit.DAYS)\n\n        /** Returns a [Duration] representing the specified [value] number of days. */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Long.days' extension property from Duration.Companion instead.\", ReplaceWith(\"value.days\", \"kotlin.time.Duration.Companion.days\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun days(value: Long): Duration = value.toDuration(DurationUnit.DAYS)\n\n        /**\n         * Returns a [Duration] representing the specified [value] number of days.\n         *\n         * @throws IllegalArgumentException if the provided `Double` [value] is `NaN`.\n         */\n        @SinceKotlin(\"1.5\")\n        @ExperimentalTime\n        @Deprecated(\"Use 'Double.days' extension property from Duration.Companion instead.\", ReplaceWith(\"value.days\", \"kotlin.time.Duration.Companion.days\"))\n        @DeprecatedSinceKotlin(warningSince = \"1.6\")\n        public fun days(value: Double): Duration = value.toDuration(DurationUnit.DAYS)\n\n        /**\n         * Parses a string that represents a duration and returns the parsed [Duration] value.\n         *\n         * The following formats are accepted:\n         *\n         * - ISO-8601 Duration format, e.g. `P1DT2H3M4.058S`, see [toIsoString] and [parseIsoString].\n         * - The format of string returned by the default [Duration.toString] and `toString` in a specific unit,\n         *   e.g. `10s`, `1h 30m` or `-(1h 30m)`.\n         *\n         * @throws IllegalArgumentException if the string doesn't represent a duration in any of the supported formats.\n         * @sample samples.time.Durations.parse\n         */\n        public fun parse(value: String): Duration = try {\n            parseDuration(value, strictIso = false)\n        } catch (e: IllegalArgumentException) {\n            throw IllegalArgumentException(\"Invalid duration string format: '$value'.\", e)\n        }\n\n        /**\n         * Parses a string that represents a duration in ISO-8601 format and returns the parsed [Duration] value.\n         *\n         * @throws IllegalArgumentException if the string doesn't represent a duration in ISO-8601 format.\n         * @sample samples.time.Durations.parseIsoString\n         */\n        public fun parseIsoString(value: String): Duration = try {\n            parseDuration(value, strictIso = true)\n        } catch (e: IllegalArgumentException) {\n            throw IllegalArgumentException(\"Invalid ISO duration string format: '$value'.\", e)\n        }\n\n        /**\n         * Parses a string that represents a duration and returns the parsed [Duration] value,\n         * or `null` if the string doesn't represent a duration in any of the supported formats.\n         *\n         * The following formats are accepted:\n         *\n         * - ISO-8601 Duration format, e.g. `P1DT2H3M4.058S`, see [toIsoString] and [parseIsoString].\n         * - The format of string returned by the default [Duration.toString] and `toString` in a specific unit,\n         *   e.g. `10s`, `1h 30m` or `-(1h 30m)`.\n         *   @sample samples.time.Durations.parse\n         */\n        public fun parseOrNull(value: String): Duration? = try {\n            parseDuration(value, strictIso = false)\n        } catch (e: IllegalArgumentException) {\n            null\n        }\n\n        /**\n         * Parses a string that represents a duration in ISO-8601 format and returns the parsed [Duration] value,\n         * or `null` if the string doesn't represent a duration in ISO-8601 format.\n         * @sample samples.time.Durations.parseIsoString\n         */\n        public fun parseIsoStringOrNull(value: String): Duration? = try {\n            parseDuration(value, strictIso = true)\n        } catch (e: IllegalArgumentException) {\n            null\n        }\n    }\n\n    // arithmetic operators\n\n    /** Returns the negative of this value. */\n    public operator fun unaryMinus(): Duration = durationOf(-value, unitDiscriminator)\n\n    /**\n     * Returns a duration whose value is the sum of this and [other] duration values.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when adding infinite durations of different sign.\n     */\n    public operator fun plus(other: Duration): Duration {\n        when {\n            this.isInfinite() -> {\n                if (other.isFinite() || (this.rawValue xor other.rawValue >= 0))\n                    return this\n                else\n                    throw IllegalArgumentException(\"Summing infinite durations of different signs yields an undefined result.\")\n            }\n            other.isInfinite() -> return other\n        }\n\n        return when {\n            this.unitDiscriminator == other.unitDiscriminator -> {\n                val result = this.value + other.value // never overflows long, but can overflow long63\n                when {\n                    isInNanos() ->\n                        durationOfNanosNormalized(result)\n                    else ->\n                        durationOfMillisNormalized(result)\n                }\n            }\n            this.isInMillis() ->\n                addValuesMixedRanges(this.value, other.value)\n            else ->\n                addValuesMixedRanges(other.value, this.value)\n        }\n    }\n\n    private fun addValuesMixedRanges(thisMillis: Long, otherNanos: Long): Duration {\n        val otherMillis = nanosToMillis(otherNanos)\n        val resultMillis = thisMillis + otherMillis\n        return if (resultMillis in -MAX_NANOS_IN_MILLIS..MAX_NANOS_IN_MILLIS) {\n            val otherNanoRemainder = otherNanos - millisToNanos(otherMillis)\n            durationOfNanos(millisToNanos(resultMillis) + otherNanoRemainder)\n        } else {\n            durationOfMillis(resultMillis.coerceIn(-MAX_MILLIS, MAX_MILLIS))\n        }\n    }\n\n    /**\n     * Returns a duration whose value is the difference between this and [other] duration values.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when subtracting infinite durations of the same sign.\n     */\n    public operator fun minus(other: Duration): Duration = this + (-other)\n\n    /**\n     * Returns a duration whose value is this duration value multiplied by the given [scale] number.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when multiplying an infinite duration by zero.\n     */\n    public operator fun times(scale: Int): Duration {\n        if (isInfinite()) {\n            return when {\n                scale == 0 -> throw IllegalArgumentException(\"Multiplying infinite duration by zero yields an undefined result.\")\n                scale > 0 -> this\n                else -> -this\n            }\n        }\n        if (scale == 0) return ZERO\n\n        val value = value\n        val result = value * scale\n        return if (isInNanos()) {\n            if (value in (MAX_NANOS / Int.MIN_VALUE)..(-MAX_NANOS / Int.MIN_VALUE)) {\n                // can't overflow nanos range for any scale\n                durationOfNanos(result)\n            } else {\n                if (result / scale == value) {\n                    durationOfNanosNormalized(result)\n                } else {\n                    val millis = nanosToMillis(value)\n                    val remNanos = value - millisToNanos(millis)\n                    val resultMillis = millis * scale\n                    val totalMillis = resultMillis + nanosToMillis(remNanos * scale)\n                    if (resultMillis / scale == millis && totalMillis xor resultMillis >= 0) {\n                        durationOfMillis(totalMillis.coerceIn(-MAX_MILLIS..MAX_MILLIS))\n                    } else {\n                        if (value.sign * scale.sign > 0) INFINITE else NEG_INFINITE\n                    }\n                }\n            }\n        } else {\n            if (result / scale == value) {\n                durationOfMillis(result.coerceIn(-MAX_MILLIS..MAX_MILLIS))\n            } else {\n                if (value.sign * scale.sign > 0) INFINITE else NEG_INFINITE\n            }\n        }\n    }\n\n    /**\n     * Returns a duration whose value is this duration value multiplied by the given [scale] number.\n     *\n     * The operation may involve rounding when the result cannot be represented exactly with a [Double] number.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when multiplying an infinite duration by zero.\n     */\n    public operator fun times(scale: Double): Duration {\n        val intScale = scale.roundToInt()\n        if (intScale.toDouble() == scale) {\n            return times(intScale)\n        }\n\n        val unit = storageUnit\n        val result = toDouble(unit) * scale\n        return result.toDuration(unit)\n    }\n\n    /**\n     * Returns a duration whose value is this duration value divided by the given [scale] number.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when dividing zero duration by zero.\n     */\n    public operator fun div(scale: Int): Duration {\n        if (scale == 0) {\n            return when {\n                isPositive() -> INFINITE\n                isNegative() -> NEG_INFINITE\n                else -> throw IllegalArgumentException(\"Dividing zero duration by zero yields an undefined result.\")\n            }\n        }\n        if (isInNanos()) {\n            return durationOfNanos(value / scale)\n        } else {\n            if (isInfinite())\n                return this * scale.sign\n\n            val result = value / scale\n\n            if (result in -MAX_NANOS_IN_MILLIS..MAX_NANOS_IN_MILLIS) {\n                val rem = millisToNanos(value - (result * scale)) / scale\n                return durationOfNanos(millisToNanos(result) + rem)\n            }\n            return durationOfMillis(result)\n        }\n    }\n\n    /**\n     * Returns a duration whose value is this duration value divided by the given [scale] number.\n     *\n     * @throws IllegalArgumentException if the operation results in an undefined value for the given arguments,\n     * e.g. when dividing an infinite duration by infinity or zero duration by zero.\n     */\n    public operator fun div(scale: Double): Duration {\n        val intScale = scale.roundToInt()\n        if (intScale.toDouble() == scale && intScale != 0) {\n            return div(intScale)\n        }\n\n        val unit = storageUnit\n        val result = toDouble(unit) / scale\n        return result.toDuration(unit)\n    }\n\n    /** Returns a number that is the ratio of this and [other] duration values. */\n    public operator fun div(other: Duration): Double {\n        val coarserUnit = maxOf(this.storageUnit, other.storageUnit)\n        return this.toDouble(coarserUnit) / other.toDouble(coarserUnit)\n    }\n\n    /** Returns true, if the duration value is less than zero. */\n    public fun isNegative(): Boolean = rawValue < 0\n\n    /** Returns true, if the duration value is greater than zero. */\n    public fun isPositive(): Boolean = rawValue > 0\n\n    /** Returns true, if the duration value is infinite. */\n    public fun isInfinite(): Boolean = rawValue == INFINITE.rawValue || rawValue == NEG_INFINITE.rawValue\n\n    /** Returns true, if the duration value is finite. */\n    public fun isFinite(): Boolean = !isInfinite()\n\n    /** Returns the absolute value of this value. The returned value is always non-negative. */\n    public val absoluteValue: Duration get() = if (isNegative()) -this else this\n\n    override fun compareTo(other: Duration): Int {\n        val compareBits = this.rawValue xor other.rawValue\n        if (compareBits < 0 || compareBits.toInt() and 1 == 0) // different signs or same sign/same range\n            return this.rawValue.compareTo(other.rawValue)\n        // same sign/different ranges\n        val r = this.unitDiscriminator - other.unitDiscriminator // compare ranges\n        return if (isNegative()) -r else r\n    }\n\n\n    // splitting to components\n\n    /**\n     * Splits this duration into days, hours, minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration, and its absolute value is less than 60;\n     * - `hours` represents the whole number of hours in this duration, and its absolute value is less than 24;\n     * - `days` represents the whole number of days in this duration.\n     *\n     *   Infinite durations are represented as either [Long.MAX_VALUE] days, or [Long.MIN_VALUE] days (depending on the sign of infinity),\n     *   and zeroes in the lower components.\n     */\n    public inline fun <T> toComponents(action: (days: Long, hours: Int, minutes: Int, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(inWholeDays, hoursComponent, minutesComponent, secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into hours, minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration, and its absolute value is less than 60;\n     * - `hours` represents the whole number of hours in this duration.\n     *\n     *   Infinite durations are represented as either [Long.MAX_VALUE] hours, or [Long.MIN_VALUE] hours (depending on the sign of infinity),\n     *   and zeroes in the lower components.\n     */\n    public inline fun <T> toComponents(action: (hours: Long, minutes: Int, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(inWholeHours, minutesComponent, secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into minutes, seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration, and its absolute value is less than 60;\n     * - `minutes` represents the whole number of minutes in this duration.\n     *\n     *   Infinite durations are represented as either [Long.MAX_VALUE] minutes, or [Long.MIN_VALUE] minutes (depending on the sign of infinity),\n     *   and zeroes in the lower components.\n     */\n    public inline fun <T> toComponents(action: (minutes: Long, seconds: Int, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(inWholeMinutes, secondsComponent, nanosecondsComponent)\n    }\n\n    /**\n     * Splits this duration into seconds, and nanoseconds and executes the given [action] with these components.\n     * The result of [action] is returned as the result of this function.\n     *\n     * - `nanoseconds` represents the whole number of nanoseconds in this duration, and its absolute value is less than 1_000_000_000;\n     * - `seconds` represents the whole number of seconds in this duration.\n     *\n     *   Infinite durations are represented as either [Long.MAX_VALUE] seconds, or [Long.MIN_VALUE] seconds (depending on the sign of infinity),\n     *   and zero nanoseconds.\n     */\n    public inline fun <T> toComponents(action: (seconds: Long, nanoseconds: Int) -> T): T {\n        contract { callsInPlace(action, InvocationKind.EXACTLY_ONCE) }\n        return action(inWholeSeconds, nanosecondsComponent)\n    }\n\n    @PublishedApi\n    internal val hoursComponent: Int\n        get() = if (isInfinite()) 0 else (inWholeHours % 24).toInt()\n\n    @PublishedApi\n    internal val minutesComponent: Int\n        get() = if (isInfinite()) 0 else (inWholeMinutes % 60).toInt()\n\n    @PublishedApi\n    internal val secondsComponent: Int\n        get() = if (isInfinite()) 0 else (inWholeSeconds % 60).toInt()\n\n    @PublishedApi\n    internal val nanosecondsComponent: Int\n        get() = when {\n            isInfinite() -> 0\n            isInMillis() -> millisToNanos(value % 1_000).toInt()\n            else -> (value % 1_000_000_000).toInt()\n        }\n\n\n    // conversion to units\n\n    /**\n     * Returns the value of this duration expressed as a [Double] number of the specified [unit].\n     *\n     * The operation may involve rounding when the result cannot be represented exactly with a [Double] number.\n     *\n     * An infinite duration value is converted either to [Double.POSITIVE_INFINITY] or [Double.NEGATIVE_INFINITY] depending on its sign.\n     */\n    public fun toDouble(unit: DurationUnit): Double {\n        return when (rawValue) {\n            INFINITE.rawValue -> Double.POSITIVE_INFINITY\n            NEG_INFINITE.rawValue -> Double.NEGATIVE_INFINITY\n            else -> {\n                // TODO: whether it's ok to convert to Double before scaling\n                convertDurationUnit(value.toDouble(), storageUnit, unit)\n            }\n        }\n    }\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of the specified [unit].\n     *\n     * If the result doesn't fit in the range of [Long] type, it is coerced into that range:\n     * - [Long.MIN_VALUE] is returned if it's less than `Long.MIN_VALUE`,\n     * - [Long.MAX_VALUE] is returned if it's greater than `Long.MAX_VALUE`.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public fun toLong(unit: DurationUnit): Long {\n        return when (rawValue) {\n            INFINITE.rawValue -> Long.MAX_VALUE\n            NEG_INFINITE.rawValue -> Long.MIN_VALUE\n            else -> convertDurationUnit(value, storageUnit, unit)\n        }\n    }\n\n    /**\n     * Returns the value of this duration expressed as an [Int] number of the specified [unit].\n     *\n     * If the result doesn't fit in the range of [Int] type, it is coerced into that range:\n     * - [Int.MIN_VALUE] is returned if it's less than `Int.MIN_VALUE`,\n     * - [Int.MAX_VALUE] is returned if it's greater than `Int.MAX_VALUE`.\n     *\n     * An infinite duration value is converted either to [Int.MAX_VALUE] or [Int.MIN_VALUE] depending on its sign.\n     */\n    public fun toInt(unit: DurationUnit): Int =\n        toLong(unit).coerceIn(Int.MIN_VALUE.toLong(), Int.MAX_VALUE.toLong()).toInt()\n\n    /** The value of this duration expressed as a [Double] number of days. */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeDays property instead or convert toDouble(DAYS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.DAYS)\"))\n    public val inDays: Double get() = toDouble(DurationUnit.DAYS)\n\n    /** The value of this duration expressed as a [Double] number of hours. */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeHours property instead or convert toDouble(HOURS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.HOURS)\"))\n    public val inHours: Double get() = toDouble(DurationUnit.HOURS)\n\n    /** The value of this duration expressed as a [Double] number of minutes. */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeMinutes property instead or convert toDouble(MINUTES) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.MINUTES)\"))\n    public val inMinutes: Double get() = toDouble(DurationUnit.MINUTES)\n\n    /** The value of this duration expressed as a [Double] number of seconds. */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeSeconds property instead or convert toDouble(SECONDS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.SECONDS)\"))\n    public val inSeconds: Double get() = toDouble(DurationUnit.SECONDS)\n\n    /** The value of this duration expressed as a [Double] number of milliseconds. */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeMilliseconds property instead or convert toDouble(MILLISECONDS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.MILLISECONDS)\"))\n    public val inMilliseconds: Double get() = toDouble(DurationUnit.MILLISECONDS)\n\n    /** The value of this duration expressed as a [Double] number of microseconds. */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeMicroseconds property instead or convert toDouble(MICROSECONDS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.MICROSECONDS)\"))\n    public val inMicroseconds: Double get() = toDouble(DurationUnit.MICROSECONDS)\n\n    /** The value of this duration expressed as a [Double] number of nanoseconds. */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeNanoseconds property instead or convert toDouble(NANOSECONDS) if a double value is required.\", ReplaceWith(\"toDouble(DurationUnit.NANOSECONDS)\"))\n    public val inNanoseconds: Double get() = toDouble(DurationUnit.NANOSECONDS)\n\n\n    /**\n     * The value of this duration expressed as a [Long] number of days.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public val inWholeDays: Long\n        get() = toLong(DurationUnit.DAYS)\n\n    /**\n     * The value of this duration expressed as a [Long] number of hours.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public val inWholeHours: Long\n        get() = toLong(DurationUnit.HOURS)\n\n    /**\n     * The value of this duration expressed as a [Long] number of minutes.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public val inWholeMinutes: Long\n        get() = toLong(DurationUnit.MINUTES)\n\n    /**\n     * The value of this duration expressed as a [Long] number of seconds.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public val inWholeSeconds: Long\n        get() = toLong(DurationUnit.SECONDS)\n\n    /**\n     * The value of this duration expressed as a [Long] number of milliseconds.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public val inWholeMilliseconds: Long\n        get() {\n            return if (isInMillis() && isFinite()) value else toLong(DurationUnit.MILLISECONDS)\n        }\n\n    /**\n     * The value of this duration expressed as a [Long] number of microseconds.\n     *\n     * If the result doesn't fit in the range of [Long] type, it is coerced into that range:\n     * - [Long.MIN_VALUE] is returned if it's less than `Long.MIN_VALUE`,\n     * - [Long.MAX_VALUE] is returned if it's greater than `Long.MAX_VALUE`.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public val inWholeMicroseconds: Long\n        get() = toLong(DurationUnit.MICROSECONDS)\n\n    /**\n     * The value of this duration expressed as a [Long] number of nanoseconds.\n     *\n     * If the result doesn't fit in the range of [Long] type, it is coerced into that range:\n     * - [Long.MIN_VALUE] is returned if it's less than `Long.MIN_VALUE`,\n     * - [Long.MAX_VALUE] is returned if it's greater than `Long.MAX_VALUE`.\n     *\n     * An infinite duration value is converted either to [Long.MAX_VALUE] or [Long.MIN_VALUE] depending on its sign.\n     */\n    public val inWholeNanoseconds: Long\n        get() {\n            val value = value\n            return when {\n                isInNanos() -> value\n                value > Long.MAX_VALUE / NANOS_IN_MILLIS -> Long.MAX_VALUE\n                value < Long.MIN_VALUE / NANOS_IN_MILLIS -> Long.MIN_VALUE\n                else -> millisToNanos(value)\n            }\n        }\n\n    // shortcuts\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of nanoseconds.\n     *\n     * If the value doesn't fit in the range of [Long] type, it is coerced into that range, see the conversion [Double.toLong] for details.\n     *\n     * The range of durations that can be expressed as a `Long` number of nanoseconds is approximately 292 years.\n     */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeNanoseconds property instead.\", ReplaceWith(\"this.inWholeNanoseconds\"))\n    public fun toLongNanoseconds(): Long = inWholeNanoseconds\n\n    /**\n     * Returns the value of this duration expressed as a [Long] number of milliseconds.\n     *\n     * The value is coerced to the range of [Long] type, if it doesn't fit in that range, see the conversion [Double.toLong] for details.\n     *\n     * The range of durations that can be expressed as a `Long` number of milliseconds is approximately 292 million years.\n     */\n    @ExperimentalTime\n    @Deprecated(\"Use inWholeMilliseconds property instead.\", ReplaceWith(\"this.inWholeMilliseconds\"))\n    public fun toLongMilliseconds(): Long = inWholeMilliseconds\n\n    /**\n     * Returns a string representation of this duration value\n     * expressed as a combination of numeric components, each in its own unit.\n     *\n     * Each component is a number followed by the unit abbreviated name: `d`, `h`, `m`, `s`:\n     * `5h`, `1d 12h`, `1h 0m 30.340s`.\n     * The last component, usually seconds, can be a number with a fractional part.\n     *\n     * If the duration is less than a second, it is represented as a single number\n     * with one of sub-second units: `ms` (milliseconds), `us` (microseconds), or `ns` (nanoseconds):\n     * `140.884ms`, `500us`, `24ns`.\n     *\n     * A negative duration is prefixed with `-` sign and, if it consists of multiple components, surrounded with parentheses:\n     * `-12m` and `-(1h 30m)`.\n     *\n     * Special cases:\n     *  - an infinite duration is formatted as `\"Infinity\"` or `\"-Infinity\"` without a unit.\n     *\n     * It's recommended to use [toIsoString] that uses more strict ISO-8601 format instead of this `toString`\n     * when you want to convert a duration to a string in cases of serialization, interchange, etc.\n     *\n     * @sample samples.time.Durations.toStringDefault\n     */\n    override fun toString(): String = when (rawValue) {\n        0L -> \"0s\"\n        INFINITE.rawValue -> \"Infinity\"\n        NEG_INFINITE.rawValue -> \"-Infinity\"\n        else -> {\n            val isNegative = isNegative()\n            buildString {\n                if (isNegative) append('-')\n                absoluteValue.toComponents { days, hours, minutes, seconds, nanoseconds ->\n                    val hasDays = days != 0L\n                    val hasHours = hours != 0\n                    val hasMinutes = minutes != 0\n                    val hasSeconds = seconds != 0 || nanoseconds != 0\n                    var components = 0\n                    if (hasDays) {\n                        append(days).append('d')\n                        components++\n                    }\n                    if (hasHours || (hasDays && (hasMinutes || hasSeconds))) {\n                        if (components++ > 0) append(' ')\n                        append(hours).append('h')\n                    }\n                    if (hasMinutes || (hasSeconds && (hasHours || hasDays))) {\n                        if (components++ > 0) append(' ')\n                        append(minutes).append('m')\n                    }\n                    if (hasSeconds) {\n                        if (components++ > 0) append(' ')\n                        when {\n                            seconds != 0 || hasDays || hasHours || hasMinutes ->\n                                appendFractional(seconds, nanoseconds, 9, \"s\", isoZeroes = false)\n                            nanoseconds >= 1_000_000 ->\n                                appendFractional(nanoseconds / 1_000_000, nanoseconds % 1_000_000, 6, \"ms\", isoZeroes = false)\n                            nanoseconds >= 1_000 ->\n                                appendFractional(nanoseconds / 1_000, nanoseconds % 1_000, 3, \"us\", isoZeroes = false)\n                            else ->\n                                append(nanoseconds).append(\"ns\")\n                        }\n                    }\n                    if (isNegative && components > 1) insert(1, '(').append(')')\n                }\n            }\n        }\n    }\n\n    private fun StringBuilder.appendFractional(whole: Int, fractional: Int, fractionalSize: Int, unit: String, isoZeroes: Boolean) {\n        append(whole)\n        if (fractional != 0) {\n            append('.')\n            val fracString = fractional.toString().padStart(fractionalSize, '0')\n            val nonZeroDigits = fracString.indexOfLast { it != '0' } + 1\n            when {\n                !isoZeroes && nonZeroDigits < 3 -> appendRange(fracString, 0, nonZeroDigits)\n                else -> appendRange(fracString, 0, ((nonZeroDigits + 2) / 3) * 3)\n            }\n        }\n        append(unit)\n    }\n\n    /**\n     * Returns a string representation of this duration value expressed in the given [unit]\n     * and formatted with the specified [decimals] number of digits after decimal point.\n     *\n     * Special cases:\n     *  - an infinite duration is formatted as `\"Infinity\"` or `\"-Infinity\"` without a unit.\n     *\n     * @param decimals the number of digits after decimal point to show. The value must be non-negative.\n     * No more than 12 decimals will be shown, even if a larger number is requested.\n     *\n     * @return the value of duration in the specified [unit] followed by that unit abbreviated name: `d`, `h`, `m`, `s`, `ms`, `us`, or `ns`.\n     *\n     * @throws IllegalArgumentException if [decimals] is less than zero.\n     *\n     * @sample samples.time.Durations.toStringDecimals\n     */\n    public fun toString(unit: DurationUnit, decimals: Int = 0): String {\n        require(decimals >= 0) { \"decimals must be not negative, but was $decimals\" }\n        val number = toDouble(unit)\n        if (number.isInfinite()) return number.toString()\n        return formatToExactDecimals(number, decimals.coerceAtMost(12)) + unit.shortName()\n    }\n\n\n    /**\n     * Returns an ISO-8601 based string representation of this duration.\n     *\n     * The returned value is presented in the format `PThHmMs.fS`, where `h`, `m`, `s` are the integer components of this duration (see [toComponents])\n     * and `f` is a fractional part of second. Depending on the roundness of the value the fractional part can be formatted with either\n     * 0, 3, 6, or 9 decimal digits.\n     *\n     * The infinite duration is represented as `\"PT9999999999999H\"` which is larger than any possible finite duration in Kotlin.\n     *\n     * Negative durations are indicated with the sign `-` in the beginning of the returned string, for example, `\"-PT5M30S\"`.\n     *\n     * @sample samples.time.Durations.toIsoString\n     */\n    public fun toIsoString(): String = buildString {\n        if (isNegative()) append('-')\n        append(\"PT\")\n        this@Duration.absoluteValue.toComponents { hours, minutes, seconds, nanoseconds ->\n            @Suppress(\"NAME_SHADOWING\")\n            var hours = hours\n            if (isInfinite()) {\n                // use large enough value instead of Long.MAX_VALUE\n                hours = 9_999_999_999_999\n            }\n            val hasHours = hours != 0L\n            val hasSeconds = seconds != 0 || nanoseconds != 0\n            val hasMinutes = minutes != 0 || (hasSeconds && hasHours)\n            if (hasHours) {\n                append(hours).append('H')\n            }\n            if (hasMinutes) {\n                append(minutes).append('M')\n            }\n            if (hasSeconds || (!hasHours && !hasMinutes)) {\n                appendFractional(seconds, nanoseconds, 9, \"S\", isoZeroes = true)\n            }\n        }\n    }\n\n}\n\n// constructing from number of units\n// extension functions\n\n/** Returns a [Duration] equal to this [Int] number of the specified [unit]. */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalTime::class)\npublic fun Int.toDuration(unit: DurationUnit): Duration {\n    return if (unit <= DurationUnit.SECONDS) {\n        durationOfNanos(convertDurationUnitOverflow(this.toLong(), unit, DurationUnit.NANOSECONDS))\n    } else\n        toLong().toDuration(unit)\n}\n\n/** Returns a [Duration] equal to this [Long] number of the specified [unit]. */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalTime::class)\npublic fun Long.toDuration(unit: DurationUnit): Duration {\n    val maxNsInUnit = convertDurationUnitOverflow(MAX_NANOS, DurationUnit.NANOSECONDS, unit)\n    if (this in -maxNsInUnit..maxNsInUnit) {\n        return durationOfNanos(convertDurationUnitOverflow(this, unit, DurationUnit.NANOSECONDS))\n    } else {\n        val millis = convertDurationUnit(this, unit, DurationUnit.MILLISECONDS)\n        return durationOfMillis(millis.coerceIn(-MAX_MILLIS, MAX_MILLIS))\n    }\n}\n\n/**\n * Returns a [Duration] equal to this [Double] number of the specified [unit].\n *\n * Depending on its magnitude, the value is rounded to an integer number of nanoseconds or milliseconds.\n *\n * @throws IllegalArgumentException if this `Double` value is `NaN`.\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalTime::class)\npublic fun Double.toDuration(unit: DurationUnit): Duration {\n    val valueInNs = convertDurationUnit(this, unit, DurationUnit.NANOSECONDS)\n    require(!valueInNs.isNaN()) { \"Duration value cannot be NaN.\" }\n    val nanos = valueInNs.roundToLong()\n    return if (nanos in -MAX_NANOS..MAX_NANOS) {\n        durationOfNanos(nanos)\n    } else {\n        val millis = convertDurationUnit(this, unit, DurationUnit.MILLISECONDS).roundToLong()\n        durationOfMillisNormalized(millis)\n    }\n}\n\n// constructing from number of units\n// deprecated extension properties\n\n/** Returns a [Duration] equal to this [Int] number of nanoseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Int.nanoseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.nanoseconds\", \"kotlin.time.Duration.Companion.nanoseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Int.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of nanoseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Long.nanoseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.nanoseconds\", \"kotlin.time.Duration.Companion.nanoseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Long.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of nanoseconds.\n *\n * @throws IllegalArgumentException if this [Double] value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Double.nanoseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.nanoseconds\", \"kotlin.time.Duration.Companion.nanoseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Double.nanoseconds get() = toDuration(DurationUnit.NANOSECONDS)\n\n\n/** Returns a [Duration] equal to this [Int] number of microseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Int.microseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.microseconds\", \"kotlin.time.Duration.Companion.microseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Int.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of microseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Long.microseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.microseconds\", \"kotlin.time.Duration.Companion.microseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Long.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of microseconds.\n *\n * @throws IllegalArgumentException if this [Double] value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Double.microseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.microseconds\", \"kotlin.time.Duration.Companion.microseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Double.microseconds get() = toDuration(DurationUnit.MICROSECONDS)\n\n\n/** Returns a [Duration] equal to this [Int] number of milliseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Int.milliseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.milliseconds\", \"kotlin.time.Duration.Companion.milliseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Int.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of milliseconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Long.milliseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.milliseconds\", \"kotlin.time.Duration.Companion.milliseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Long.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of milliseconds.\n *\n * @throws IllegalArgumentException if this [Double] value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Double.milliseconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.milliseconds\", \"kotlin.time.Duration.Companion.milliseconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Double.milliseconds get() = toDuration(DurationUnit.MILLISECONDS)\n\n\n/** Returns a [Duration] equal to this [Int] number of seconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Int.seconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.seconds\", \"kotlin.time.Duration.Companion.seconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Int.seconds get() = toDuration(DurationUnit.SECONDS)\n\n/** Returns a [Duration] equal to this [Long] number of seconds. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Long.seconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.seconds\", \"kotlin.time.Duration.Companion.seconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Long.seconds get() = toDuration(DurationUnit.SECONDS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of seconds.\n *\n * @throws IllegalArgumentException if this [Double] value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Double.seconds' extension property from Duration.Companion instead.\", ReplaceWith(\"this.seconds\", \"kotlin.time.Duration.Companion.seconds\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Double.seconds get() = toDuration(DurationUnit.SECONDS)\n\n\n/** Returns a [Duration] equal to this [Int] number of minutes. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Int.minutes' extension property from Duration.Companion instead.\", ReplaceWith(\"this.minutes\", \"kotlin.time.Duration.Companion.minutes\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Int.minutes get() = toDuration(DurationUnit.MINUTES)\n\n/** Returns a [Duration] equal to this [Long] number of minutes. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Long.minutes' extension property from Duration.Companion instead.\", ReplaceWith(\"this.minutes\", \"kotlin.time.Duration.Companion.minutes\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Long.minutes get() = toDuration(DurationUnit.MINUTES)\n\n/**\n * Returns a [Duration] equal to this [Double] number of minutes.\n *\n * @throws IllegalArgumentException if this [Double] value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Double.minutes' extension property from Duration.Companion instead.\", ReplaceWith(\"this.minutes\", \"kotlin.time.Duration.Companion.minutes\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Double.minutes get() = toDuration(DurationUnit.MINUTES)\n\n\n/** Returns a [Duration] equal to this [Int] number of hours. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Int.hours' extension property from Duration.Companion instead.\", ReplaceWith(\"this.hours\", \"kotlin.time.Duration.Companion.hours\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Int.hours get() = toDuration(DurationUnit.HOURS)\n\n/** Returns a [Duration] equal to this [Long] number of hours. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Long.hours' extension property from Duration.Companion instead.\", ReplaceWith(\"this.hours\", \"kotlin.time.Duration.Companion.hours\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Long.hours get() = toDuration(DurationUnit.HOURS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of hours.\n *\n * @throws IllegalArgumentException if this [Double] value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Double.hours' extension property from Duration.Companion instead.\", ReplaceWith(\"this.hours\", \"kotlin.time.Duration.Companion.hours\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Double.hours get() = toDuration(DurationUnit.HOURS)\n\n\n/** Returns a [Duration] equal to this [Int] number of days. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Int.days' extension property from Duration.Companion instead.\", ReplaceWith(\"this.days\", \"kotlin.time.Duration.Companion.days\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Int.days get() = toDuration(DurationUnit.DAYS)\n\n/** Returns a [Duration] equal to this [Long] number of days. */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Long.days' extension property from Duration.Companion instead.\", ReplaceWith(\"this.days\", \"kotlin.time.Duration.Companion.days\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Long.days get() = toDuration(DurationUnit.DAYS)\n\n/**\n * Returns a [Duration] equal to this [Double] number of days.\n *\n * @throws IllegalArgumentException if this [Double] value is `NaN`.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalTime\n@Deprecated(\"Use 'Double.days' extension property from Duration.Companion instead.\", ReplaceWith(\"this.days\", \"kotlin.time.Duration.Companion.days\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic val Double.days get() = toDuration(DurationUnit.DAYS)\n\n\n/** Returns a duration whose value is the specified [duration] value multiplied by this number. */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalTime::class)\n@kotlin.internal.InlineOnly\npublic inline operator fun Int.times(duration: Duration): Duration = duration * this\n\n/**\n * Returns a duration whose value is the specified [duration] value multiplied by this number.\n *\n * The operation may involve rounding when the result cannot be represented exactly with a [Double] number.\n *\n * @throws IllegalArgumentException if the operation results in a `NaN` value.\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalTime::class)\n@kotlin.internal.InlineOnly\npublic inline operator fun Double.times(duration: Duration): Duration = duration * this\n\n\n\nprivate fun parseDuration(value: String, strictIso: Boolean): Duration {\n    var length = value.length\n    if (length == 0) throw IllegalArgumentException(\"The string is empty\")\n    var index = 0\n    var result = Duration.ZERO\n    val infinityString = \"Infinity\"\n    when (value[index]) {\n        '+', '-' -> index++\n    }\n    val hasSign = index > 0\n    val isNegative = hasSign && value.startsWith('-')\n    when {\n        length <= index ->\n            throw IllegalArgumentException(\"No components\")\n        value[index] == 'P' -> {\n            if (++index == length) throw IllegalArgumentException()\n            val nonDigitSymbols = \"+-.\"\n            var isTimeComponent = false\n            var prevUnit: DurationUnit? = null\n            while (index < length) {\n                if (value[index] == 'T') {\n                    if (isTimeComponent || ++index == length) throw IllegalArgumentException()\n                    isTimeComponent = true\n                    continue\n                }\n                val component = value.substringWhile(index) { it in '0'..'9' || it in nonDigitSymbols }\n                if (component.isEmpty()) throw IllegalArgumentException()\n                index += component.length\n                val unitChar = value.getOrElse(index) { throw IllegalArgumentException(\"Missing unit for value $component\") }\n                index++\n                val unit = durationUnitByIsoChar(unitChar, isTimeComponent)\n                if (prevUnit != null && prevUnit <= unit) throw IllegalArgumentException(\"Unexpected order of duration components\")\n                prevUnit = unit\n                val dotIndex = component.indexOf('.')\n                if (unit == DurationUnit.SECONDS && dotIndex > 0) {\n                    val whole = component.substring(0, dotIndex)\n                    result += parseOverLongIsoComponent(whole).toDuration(unit)\n                    result += component.substring(dotIndex).toDouble().toDuration(unit)\n                } else {\n                    result += parseOverLongIsoComponent(component).toDuration(unit)\n                }\n            }\n        }\n        strictIso ->\n            throw IllegalArgumentException()\n        value.regionMatches(index, infinityString, 0, length = maxOf(length - index, infinityString.length), ignoreCase = true) -> {\n            result = Duration.INFINITE\n        }\n        else -> {\n            // parse default string format\n            var prevUnit: DurationUnit? = null\n            var afterFirst = false\n            var allowSpaces = !hasSign\n            if (hasSign && value[index] == '(' && value.last() == ')') {\n                allowSpaces = true\n                if (++index == --length) throw IllegalArgumentException(\"No components\")\n            }\n            while (index < length) {\n                if (afterFirst && allowSpaces) {\n                    index = value.skipWhile(index) { it == ' ' }\n                }\n                afterFirst = true\n                val component = value.substringWhile(index) { it in '0'..'9' || it == '.' }\n                if (component.isEmpty()) throw IllegalArgumentException()\n                index += component.length\n                val unitName = value.substringWhile(index) { it in 'a'..'z' }\n                index += unitName.length\n                val unit = durationUnitByShortName(unitName)\n                if (prevUnit != null && prevUnit <= unit) throw IllegalArgumentException(\"Unexpected order of duration components\")\n                prevUnit = unit\n                val dotIndex = component.indexOf('.')\n                if (dotIndex > 0) {\n                    val whole = component.substring(0, dotIndex)\n                    result += whole.toLong().toDuration(unit)\n                    result += component.substring(dotIndex).toDouble().toDuration(unit)\n                    if (index < length) throw IllegalArgumentException(\"Fractional component must be last\")\n                } else {\n                    result += component.toLong().toDuration(unit)\n                }\n            }\n        }\n    }\n    return if (isNegative) -result else result\n}\n\n\nprivate fun parseOverLongIsoComponent(value: String): Long {\n    val length = value.length\n    var startIndex = 0\n    if (length > 0 && value[0] in \"+-\") startIndex++\n    if ((length - startIndex) > 16 && (startIndex..value.lastIndex).all { value[it] in '0'..'9' }) {\n        // all chars are digits, but more than ceiling(log10(MAX_MILLIS / 1000)) of them\n        return if (value[0] == '-') Long.MIN_VALUE else Long.MAX_VALUE\n    }\n    // TODO: replace with just toLong after min JDK becomes 8\n    return if (value.startsWith(\"+\")) value.drop(1).toLong() else value.toLong()\n}\n\n\n\nprivate inline fun String.substringWhile(startIndex: Int, predicate: (Char) -> Boolean): String =\n    substring(startIndex, skipWhile(startIndex, predicate))\n\nprivate inline fun String.skipWhile(startIndex: Int, predicate: (Char) -> Boolean): Int {\n    var i = startIndex\n    while (i < length && predicate(this[i])) i++\n    return i\n}\n\n\n\n\n\n// The ranges are chosen so that they are:\n// - symmetric relative to zero: this greatly simplifies operations with sign, e.g. unaryMinus and minus.\n// - non-overlapping, but adjacent: the first value that doesn't fit in nanos range, can be exactly represented in millis.\n\ninternal const val NANOS_IN_MILLIS = 1_000_000\n// maximum number duration can store in nanosecond range\ninternal const val MAX_NANOS = Long.MAX_VALUE / 2 / NANOS_IN_MILLIS * NANOS_IN_MILLIS - 1 // ends in ..._999_999\n// maximum number duration can store in millisecond range, also encodes an infinite value\ninternal const val MAX_MILLIS = Long.MAX_VALUE / 2\n// MAX_NANOS expressed in milliseconds\nprivate const val MAX_NANOS_IN_MILLIS = MAX_NANOS / NANOS_IN_MILLIS\n\nprivate fun nanosToMillis(nanos: Long): Long = nanos / NANOS_IN_MILLIS\nprivate fun millisToNanos(millis: Long): Long = millis * NANOS_IN_MILLIS\n\nprivate fun durationOfNanos(normalNanos: Long) = Duration(normalNanos shl 1)\nprivate fun durationOfMillis(normalMillis: Long) = Duration((normalMillis shl 1) + 1)\nprivate fun durationOf(normalValue: Long, unitDiscriminator: Int) = Duration((normalValue shl 1) + unitDiscriminator)\nprivate fun durationOfNanosNormalized(nanos: Long) =\n    if (nanos in -MAX_NANOS..MAX_NANOS) {\n        durationOfNanos(nanos)\n    } else {\n        durationOfMillis(nanosToMillis(nanos))\n    }\n\nprivate fun durationOfMillisNormalized(millis: Long) =\n    if (millis in -MAX_NANOS_IN_MILLIS..MAX_NANOS_IN_MILLIS) {\n        durationOfNanos(millisToNanos(millis))\n    } else {\n        durationOfMillis(millis.coerceIn(-MAX_MILLIS, MAX_MILLIS))\n    }\n\ninternal expect val durationAssertionsEnabled: Boolean\n\ninternal expect fun formatToExactDecimals(value: Double, decimals: Int): String\ninternal expect fun formatUpToDecimals(value: Double, decimals: Int): String","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:kotlin.jvm.JvmName(\"UnsignedKt\")\npackage kotlin\n\n@PublishedApi\ninternal fun uintCompare(v1: Int, v2: Int): Int = (v1 xor Int.MIN_VALUE).compareTo(v2 xor Int.MIN_VALUE)\n@PublishedApi\ninternal fun ulongCompare(v1: Long, v2: Long): Int = (v1 xor Long.MIN_VALUE).compareTo(v2 xor Long.MIN_VALUE)\n\n@PublishedApi\ninternal fun uintDivide(v1: UInt, v2: UInt): UInt = (v1.toLong() / v2.toLong()).toUInt()\n@PublishedApi\ninternal fun uintRemainder(v1: UInt, v2: UInt): UInt = (v1.toLong() % v2.toLong()).toUInt()\n\n// Division and remainder are based on Guava's UnsignedLongs implementation\n// Copyright 2011 The Guava Authors\n\n@PublishedApi\ninternal fun ulongDivide(v1: ULong, v2: ULong): ULong {\n    val dividend = v1.toLong()\n    val divisor = v2.toLong()\n    if (divisor < 0) { // i.e., divisor >= 2^63:\n        return if (v1 < v2) ULong(0) else ULong(1)\n    }\n\n    // Optimization - use signed division if both dividend and divisor < 2^63\n    if (dividend >= 0) {\n        return ULong(dividend / divisor)\n    }\n\n    // Otherwise, approximate the quotient, check, and correct if necessary.\n    val quotient = ((dividend ushr 1) / divisor) shl 1\n    val rem = dividend - quotient * divisor\n    return ULong(quotient + if (ULong(rem) >= ULong(divisor)) 1 else 0)\n\n}\n\n@PublishedApi\ninternal fun ulongRemainder(v1: ULong, v2: ULong): ULong {\n    val dividend = v1.toLong()\n    val divisor = v2.toLong()\n    if (divisor < 0) { // i.e., divisor >= 2^63:\n        return if (v1 < v2) {\n            v1 // dividend < divisor\n        } else {\n            v1 - v2 // dividend >= divisor\n        }\n    }\n\n    // Optimization - use signed modulus if both dividend and divisor < 2^63\n    if (dividend >= 0) {\n        return ULong(dividend % divisor)\n    }\n\n    // Otherwise, approximate the quotient, check, and correct if necessary.\n    val quotient = ((dividend ushr 1) / divisor) shl 1\n    val rem = dividend - quotient * divisor\n    return ULong(rem - if (ULong(rem) >= ULong(divisor)) divisor else 0)\n}\n\n@PublishedApi\ninternal fun doubleToUInt(v: Double): UInt = when {\n    v.isNaN() -> 0u\n    v <= UInt.MIN_VALUE.toDouble() -> UInt.MIN_VALUE\n    v >= UInt.MAX_VALUE.toDouble() -> UInt.MAX_VALUE\n    v <= Int.MAX_VALUE -> v.toInt().toUInt()\n    else -> (v - Int.MAX_VALUE).toInt().toUInt() + Int.MAX_VALUE.toUInt()      // Int.MAX_VALUE < v < UInt.MAX_VALUE\n}\n\n@PublishedApi\ninternal fun doubleToULong(v: Double): ULong = when {\n    v.isNaN() -> 0u\n    v <= ULong.MIN_VALUE.toDouble() -> ULong.MIN_VALUE\n    v >= ULong.MAX_VALUE.toDouble() -> ULong.MAX_VALUE\n    v < Long.MAX_VALUE -> v.toLong().toULong()\n\n    // Real values from Long.MAX_VALUE to (Long.MAX_VALUE + 1) are not representable in Double, so don't handle them.\n    else -> (v - 9223372036854775808.0).toLong().toULong() + 9223372036854775808uL      // Long.MAX_VALUE + 1 < v < ULong.MAX_VALUE\n}\n\n\n@PublishedApi\ninternal fun uintToDouble(v: Int): Double = (v and Int.MAX_VALUE).toDouble() + (v ushr 31 shl 30).toDouble() * 2\n\n@PublishedApi\ninternal fun ulongToDouble(v: Long): Double = (v ushr 11).toDouble() * 2048 + (v and 2047)\n\n\ninternal fun ulongToString(v: Long): String = ulongToString(v, 10)\n\ninternal fun ulongToString(v: Long, base: Int): String {\n    if (v >= 0) return v.toString(base)\n\n    var quotient = ((v ushr 1) / base) shl 1\n    var rem = v - quotient * base\n    if (rem >= base) {\n        rem -= base\n        quotient += 1\n    }\n    return quotient.toString(base) + rem.toString(base)\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SequencesKt\")\n\npackage kotlin.sequences\n\nimport kotlin.random.Random\n\n/**\n * Given an [iterator] function constructs a [Sequence] that returns values through the [Iterator]\n * provided by that function.\n * The values are evaluated lazily, and the sequence is potentially infinite.\n *\n * @sample samples.collections.Sequences.Building.sequenceFromIterator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence(crossinline iterator: () -> Iterator<T>): Sequence<T> = object : Sequence<T> {\n    override fun iterator(): Iterator<T> = iterator()\n}\n\n/**\n * Creates a sequence that returns all elements from this iterator. The sequence is constrained to be iterated only once.\n *\n * @sample samples.collections.Sequences.Building.sequenceFromIterator\n */\npublic fun <T> Iterator<T>.asSequence(): Sequence<T> = Sequence { this }.constrainOnce()\n\n/**\n * Creates a sequence that returns the specified values.\n *\n * @sample samples.collections.Sequences.Building.sequenceOfValues\n */\npublic fun <T> sequenceOf(vararg elements: T): Sequence<T> = if (elements.isEmpty()) emptySequence() else elements.asSequence()\n\n/**\n * Returns an empty sequence.\n */\npublic fun <T> emptySequence(): Sequence<T> = EmptySequence\n\nprivate object EmptySequence : Sequence<Nothing>, DropTakeSequence<Nothing> {\n    override fun iterator(): Iterator<Nothing> = EmptyIterator\n    override fun drop(n: Int) = EmptySequence\n    override fun take(n: Int) = EmptySequence\n}\n\n/**\n * Returns this sequence if it's not `null` and the empty sequence otherwise.\n * @sample samples.collections.Sequences.Usage.sequenceOrEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>?.orEmpty(): Sequence<T> = this ?: emptySequence()\n\n\n/**\n * Returns a sequence that iterates through the elements either of this sequence\n * or, if this sequence turns out to be empty, of the sequence returned by [defaultValue] function.\n *\n * @sample samples.collections.Sequences.Usage.sequenceIfEmpty\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Sequence<T>.ifEmpty(defaultValue: () -> Sequence<T>): Sequence<T> = sequence {\n    val iterator = this@ifEmpty.iterator()\n    if (iterator.hasNext()) {\n        yieldAll(iterator)\n    } else {\n        yieldAll(defaultValue())\n    }\n}\n\n/**\n * Returns a sequence of all elements from all sequences in this sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n *\n * @sample samples.collections.Sequences.Transformations.flattenSequenceOfSequences\n */\npublic fun <T> Sequence<Sequence<T>>.flatten(): Sequence<T> = flatten { it.iterator() }\n\n/**\n * Returns a sequence of all elements from all iterables in this sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n *\n * @sample samples.collections.Sequences.Transformations.flattenSequenceOfLists\n */\n@kotlin.jvm.JvmName(\"flattenSequenceOfIterable\")\npublic fun <T> Sequence<Iterable<T>>.flatten(): Sequence<T> = flatten { it.iterator() }\n\nprivate fun <T, R> Sequence<T>.flatten(iterator: (T) -> Iterator<R>): Sequence<R> {\n    if (this is TransformingSequence<*, *>) {\n        return (this as TransformingSequence<*, T>).flatten(iterator)\n    }\n    return FlatteningSequence(this, { it }, iterator)\n}\n\n/**\n * Returns a pair of lists, where\n * *first* list is built from the first values of each pair from this sequence,\n * *second* list is built from the second values of each pair from this sequence.\n *\n * The operation is _terminal_.\n *\n * @sample samples.collections.Sequences.Transformations.unzip\n */\npublic fun <T, R> Sequence<Pair<T, R>>.unzip(): Pair<List<T>, List<R>> {\n    val listT = ArrayList<T>()\n    val listR = ArrayList<R>()\n    for (pair in this) {\n        listT.add(pair.first)\n        listR.add(pair.second)\n    }\n    return listT to listR\n}\n\n/**\n * Returns a sequence that yields elements of this sequence randomly shuffled.\n *\n * Note that every iteration of the sequence returns elements in a different order.\n *\n * The operation is _intermediate_ and _stateful_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.shuffled(): Sequence<T> = shuffled(Random)\n\n/**\n * Returns a sequence that yields elements of this sequence randomly shuffled\n * using the specified [random] instance as the source of randomness.\n *\n * Note that every iteration of the sequence returns elements in a different order.\n *\n * The operation is _intermediate_ and _stateful_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.shuffled(random: Random): Sequence<T> = sequence<T> {\n    val buffer = toMutableList()\n    while (buffer.isNotEmpty()) {\n        val j = random.nextInt(buffer.size)\n        val last = buffer.removeLast()\n        val value = if (j < buffer.size) buffer.set(j, last) else last\n        yield(value)\n    }\n}\n\n\n/**\n * A sequence that returns the values from the underlying [sequence] that either match or do not match\n * the specified [predicate].\n *\n * @param sendWhen If `true`, values for which the predicate returns `true` are returned. Otherwise,\n * values for which the predicate returns `false` are returned\n */\ninternal class FilteringSequence<T>(\n    private val sequence: Sequence<T>,\n    private val sendWhen: Boolean = true,\n    private val predicate: (T) -> Boolean\n) : Sequence<T> {\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var nextItem: T? = null\n\n        private fun calcNext() {\n            while (iterator.hasNext()) {\n                val item = iterator.next()\n                if (predicate(item) == sendWhen) {\n                    nextItem = item\n                    nextState = 1\n                    return\n                }\n            }\n            nextState = 0\n        }\n\n        override fun next(): T {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem\n            nextItem = null\n            nextState = -1\n            @Suppress(\"UNCHECKED_CAST\")\n            return result as T\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * A sequence which returns the results of applying the given [transformer] function to the values\n * in the underlying [sequence].\n */\n\ninternal class TransformingSequence<T, R>\nconstructor(private val sequence: Sequence<T>, private val transformer: (T) -> R) : Sequence<R> {\n    override fun iterator(): Iterator<R> = object : Iterator<R> {\n        val iterator = sequence.iterator()\n        override fun next(): R {\n            return transformer(iterator.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator.hasNext()\n        }\n    }\n\n    internal fun <E> flatten(iterator: (R) -> Iterator<E>): Sequence<E> {\n        return FlatteningSequence<T, R, E>(sequence, transformer, iterator)\n    }\n}\n\n/**\n * A sequence which returns the results of applying the given [transformer] function to the values\n * in the underlying [sequence], where the transformer function takes the index of the value in the underlying\n * sequence along with the value itself.\n */\ninternal class TransformingIndexedSequence<T, R>\nconstructor(private val sequence: Sequence<T>, private val transformer: (Int, T) -> R) : Sequence<R> {\n    override fun iterator(): Iterator<R> = object : Iterator<R> {\n        val iterator = sequence.iterator()\n        var index = 0\n        override fun next(): R {\n            return transformer(checkIndexOverflow(index++), iterator.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence which combines values from the underlying [sequence] with their indices and returns them as\n * [IndexedValue] objects.\n */\ninternal class IndexingSequence<T>\nconstructor(private val sequence: Sequence<T>) : Sequence<IndexedValue<T>> {\n    override fun iterator(): Iterator<IndexedValue<T>> = object : Iterator<IndexedValue<T>> {\n        val iterator = sequence.iterator()\n        var index = 0\n        override fun next(): IndexedValue<T> {\n            return IndexedValue(checkIndexOverflow(index++), iterator.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence which takes the values from two parallel underlying sequences, passes them to the given\n * [transform] function and returns the values returned by that function. The sequence stops returning\n * values as soon as one of the underlying sequences stops returning values.\n */\ninternal class MergingSequence<T1, T2, V>\nconstructor(\n    private val sequence1: Sequence<T1>,\n    private val sequence2: Sequence<T2>,\n    private val transform: (T1, T2) -> V\n) : Sequence<V> {\n    override fun iterator(): Iterator<V> = object : Iterator<V> {\n        val iterator1 = sequence1.iterator()\n        val iterator2 = sequence2.iterator()\n        override fun next(): V {\n            return transform(iterator1.next(), iterator2.next())\n        }\n\n        override fun hasNext(): Boolean {\n            return iterator1.hasNext() && iterator2.hasNext()\n        }\n    }\n}\n\ninternal class FlatteningSequence<T, R, E>\nconstructor(\n    private val sequence: Sequence<T>,\n    private val transformer: (T) -> R,\n    private val iterator: (R) -> Iterator<E>\n) : Sequence<E> {\n    override fun iterator(): Iterator<E> = object : Iterator<E> {\n        val iterator = sequence.iterator()\n        var itemIterator: Iterator<E>? = null\n\n        override fun next(): E {\n            if (!ensureItemIterator())\n                throw NoSuchElementException()\n            return itemIterator!!.next()\n        }\n\n        override fun hasNext(): Boolean {\n            return ensureItemIterator()\n        }\n\n        private fun ensureItemIterator(): Boolean {\n            if (itemIterator?.hasNext() == false)\n                itemIterator = null\n\n            while (itemIterator == null) {\n                if (!iterator.hasNext()) {\n                    return false\n                } else {\n                    val element = iterator.next()\n                    val nextItemIterator = iterator(transformer(element))\n                    if (nextItemIterator.hasNext()) {\n                        itemIterator = nextItemIterator\n                        return true\n                    }\n                }\n            }\n            return true\n        }\n    }\n}\n\ninternal fun <T, C, R> flatMapIndexed(source: Sequence<T>, transform: (Int, T) -> C, iterator: (C) -> Iterator<R>): Sequence<R> =\n    sequence {\n        var index = 0\n        for (element in source) {\n            val result = transform(checkIndexOverflow(index++), element)\n            yieldAll(iterator(result))\n        }\n    }\n\n/**\n * A sequence that supports drop(n) and take(n) operations\n */\ninternal interface DropTakeSequence<T> : Sequence<T> {\n    fun drop(n: Int): Sequence<T>\n    fun take(n: Int): Sequence<T>\n}\n\n/**\n * A sequence that skips [startIndex] values from the underlying [sequence]\n * and stops returning values right before [endIndex], i.e. stops at `endIndex - 1`\n */\ninternal class SubSequence<T>(\n    private val sequence: Sequence<T>,\n    private val startIndex: Int,\n    private val endIndex: Int\n) : Sequence<T>, DropTakeSequence<T> {\n\n    init {\n        require(startIndex >= 0) { \"startIndex should be non-negative, but is $startIndex\" }\n        require(endIndex >= 0) { \"endIndex should be non-negative, but is $endIndex\" }\n        require(endIndex >= startIndex) { \"endIndex should be not less than startIndex, but was $endIndex < $startIndex\" }\n    }\n\n    private val count: Int get() = endIndex - startIndex\n\n    override fun drop(n: Int): Sequence<T> = if (n >= count) emptySequence() else SubSequence(sequence, startIndex + n, endIndex)\n    override fun take(n: Int): Sequence<T> = if (n >= count) this else SubSequence(sequence, startIndex, startIndex + n)\n\n    override fun iterator() = object : Iterator<T> {\n\n        val iterator = sequence.iterator()\n        var position = 0\n\n        // Shouldn't be called from constructor to avoid premature iteration\n        private fun drop() {\n            while (position < startIndex && iterator.hasNext()) {\n                iterator.next()\n                position++\n            }\n        }\n\n        override fun hasNext(): Boolean {\n            drop()\n            return (position < endIndex) && iterator.hasNext()\n        }\n\n        override fun next(): T {\n            drop()\n            if (position >= endIndex)\n                throw NoSuchElementException()\n            position++\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * A sequence that returns at most [count] values from the underlying [sequence], and stops returning values\n * as soon as that count is reached.\n */\ninternal class TakeSequence<T>(\n    private val sequence: Sequence<T>,\n    private val count: Int\n) : Sequence<T>, DropTakeSequence<T> {\n\n    init {\n        require(count >= 0) { \"count must be non-negative, but was $count.\" }\n    }\n\n    override fun drop(n: Int): Sequence<T> = if (n >= count) emptySequence() else SubSequence(sequence, n, count)\n    override fun take(n: Int): Sequence<T> = if (n >= count) this else TakeSequence(sequence, n)\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        var left = count\n        val iterator = sequence.iterator()\n\n        override fun next(): T {\n            if (left == 0)\n                throw NoSuchElementException()\n            left--\n            return iterator.next()\n        }\n\n        override fun hasNext(): Boolean {\n            return left > 0 && iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence that returns values from the underlying [sequence] while the [predicate] function returns\n * `true`, and stops returning values once the function returns `false` for the next element.\n */\ninternal class TakeWhileSequence<T>\nconstructor(\n    private val sequence: Sequence<T>,\n    private val predicate: (T) -> Boolean\n) : Sequence<T> {\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var nextItem: T? = null\n\n        private fun calcNext() {\n            if (iterator.hasNext()) {\n                val item = iterator.next()\n                if (predicate(item)) {\n                    nextState = 1\n                    nextItem = item\n                    return\n                }\n            }\n            nextState = 0\n        }\n\n        override fun next(): T {\n            if (nextState == -1)\n                calcNext() // will change nextState\n            if (nextState == 0)\n                throw NoSuchElementException()\n            @Suppress(\"UNCHECKED_CAST\")\n            val result = nextItem as T\n\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext() // will change nextState\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * A sequence that skips the specified number of values from the underlying [sequence] and returns\n * all values after that.\n */\ninternal class DropSequence<T>(\n    private val sequence: Sequence<T>,\n    private val count: Int\n) : Sequence<T>, DropTakeSequence<T> {\n    init {\n        require(count >= 0) { \"count must be non-negative, but was $count.\" }\n    }\n\n    override fun drop(n: Int): Sequence<T> = (count + n).let { n1 -> if (n1 < 0) DropSequence(this, n) else DropSequence(sequence, n1) }\n    override fun take(n: Int): Sequence<T> = (count + n).let { n1 -> if (n1 < 0) TakeSequence(this, n) else SubSequence(sequence, count, n1) }\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var left = count\n\n        // Shouldn't be called from constructor to avoid premature iteration\n        private fun drop() {\n            while (left > 0 && iterator.hasNext()) {\n                iterator.next()\n                left--\n            }\n        }\n\n        override fun next(): T {\n            drop()\n            return iterator.next()\n        }\n\n        override fun hasNext(): Boolean {\n            drop()\n            return iterator.hasNext()\n        }\n    }\n}\n\n/**\n * A sequence that skips the values from the underlying [sequence] while the given [predicate] returns `true` and returns\n * all values after that.\n */\ninternal class DropWhileSequence<T>\nconstructor(\n    private val sequence: Sequence<T>,\n    private val predicate: (T) -> Boolean\n) : Sequence<T> {\n\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        val iterator = sequence.iterator()\n        var dropState: Int = -1 // -1 for not dropping, 1 for nextItem, 0 for normal iteration\n        var nextItem: T? = null\n\n        private fun drop() {\n            while (iterator.hasNext()) {\n                val item = iterator.next()\n                if (!predicate(item)) {\n                    nextItem = item\n                    dropState = 1\n                    return\n                }\n            }\n            dropState = 0\n        }\n\n        override fun next(): T {\n            if (dropState == -1)\n                drop()\n\n            if (dropState == 1) {\n                @Suppress(\"UNCHECKED_CAST\")\n                val result = nextItem as T\n                nextItem = null\n                dropState = 0\n                return result\n            }\n            return iterator.next()\n        }\n\n        override fun hasNext(): Boolean {\n            if (dropState == -1)\n                drop()\n            return dropState == 1 || iterator.hasNext()\n        }\n    }\n}\n\ninternal class DistinctSequence<T, K>(private val source: Sequence<T>, private val keySelector: (T) -> K) : Sequence<T> {\n    override fun iterator(): Iterator<T> = DistinctIterator(source.iterator(), keySelector)\n}\n\nprivate class DistinctIterator<T, K>(private val source: Iterator<T>, private val keySelector: (T) -> K) : AbstractIterator<T>() {\n    private val observed = HashSet<K>()\n\n    override fun computeNext() {\n        while (source.hasNext()) {\n            val next = source.next()\n            val key = keySelector(next)\n\n            if (observed.add(key)) {\n                setNext(next)\n                return\n            }\n        }\n\n        done()\n    }\n}\n\n\nprivate class GeneratorSequence<T : Any>(private val getInitialValue: () -> T?, private val getNextValue: (T) -> T?) : Sequence<T> {\n    override fun iterator(): Iterator<T> = object : Iterator<T> {\n        var nextItem: T? = null\n        var nextState: Int = -2 // -2 for initial unknown, -1 for next unknown, 0 for done, 1 for continue\n\n        private fun calcNext() {\n            nextItem = if (nextState == -2) getInitialValue() else getNextValue(nextItem!!)\n            nextState = if (nextItem == null) 0 else 1\n        }\n\n        override fun next(): T {\n            if (nextState < 0)\n                calcNext()\n\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as T\n            // Do not clean nextItem (to avoid keeping reference on yielded instance) -- need to keep state for getNextValue\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState < 0)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a wrapper sequence that provides values of this sequence, but ensures it can be iterated only one time.\n *\n * The operation is _intermediate_ and _stateless_.\n *\n * [IllegalStateException] is thrown on iterating the returned sequence for the second time and the following times.\n *\n */\npublic fun <T> Sequence<T>.constrainOnce(): Sequence<T> {\n    // as? does not work in js\n    //return this as? ConstrainedOnceSequence<T> ?: ConstrainedOnceSequence(this)\n    return if (this is ConstrainedOnceSequence<T>) this else ConstrainedOnceSequence(this)\n}\n\n\n/**\n * Returns a sequence which invokes the function to calculate the next value on each iteration until the function returns `null`.\n *\n * The returned sequence is constrained to be iterated only once.\n *\n * @see constrainOnce\n * @see kotlin.sequences.sequence\n *\n * @sample samples.collections.Sequences.Building.generateSequence\n */\npublic fun <T : Any> generateSequence(nextFunction: () -> T?): Sequence<T> {\n    return GeneratorSequence(nextFunction, { nextFunction() }).constrainOnce()\n}\n\n/**\n * Returns a sequence defined by the starting value [seed] and the function [nextFunction],\n * which is invoked to calculate the next value based on the previous one on each iteration.\n *\n * The sequence produces values until it encounters first `null` value.\n * If [seed] is `null`, an empty sequence is produced.\n *\n * The sequence can be iterated multiple times, each time starting with [seed].\n *\n * @see kotlin.sequences.sequence\n *\n * @sample samples.collections.Sequences.Building.generateSequenceWithSeed\n */\n@kotlin.internal.LowPriorityInOverloadResolution\npublic fun <T : Any> generateSequence(seed: T?, nextFunction: (T) -> T?): Sequence<T> =\n    if (seed == null)\n        EmptySequence\n    else\n        GeneratorSequence({ seed }, nextFunction)\n\n/**\n * Returns a sequence defined by the function [seedFunction], which is invoked to produce the starting value,\n * and the [nextFunction], which is invoked to calculate the next value based on the previous one on each iteration.\n *\n * The sequence produces values until it encounters first `null` value.\n * If [seedFunction] returns `null`, an empty sequence is produced.\n *\n * The sequence can be iterated multiple times.\n *\n * @see kotlin.sequences.sequence\n *\n * @sample samples.collections.Sequences.Building.generateSequenceWithLazySeed\n */\npublic fun <T : Any> generateSequence(seedFunction: () -> T?, nextFunction: (T) -> T?): Sequence<T> =\n    GeneratorSequence(seedFunction, nextFunction)\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 1.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component1(): T {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 2.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component2(): T {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 3.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component3(): T {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 4.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component4(): T {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the list.\n * \n * Throws an [IndexOutOfBoundsException] if the size of this list is less than 5.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> List<T>.component5(): T {\n    return get(4)\n}\n\n/**\n * Returns `true` if [element] is found in the collection.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.contains(element: T): Boolean {\n    if (this is Collection)\n        return contains(element)\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Iterable<T>.elementAt(index: Int): T {\n    if (this is List)\n        return get(index)\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Collection doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAt(index: Int): T {\n    return get(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Iterable<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (this is List)\n        return this.getOrElse(index, defaultValue)\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this collection.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Iterable<T>.elementAtOrNull(index: Int): T? {\n    if (this is List)\n        return this.getOrNull(index)\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.elementAtOrNull(index: Int): T? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the collection is empty.\n */\npublic fun <T> Iterable<T>.first(): T {\n    when (this) {\n        is List -> return this.first()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the list is empty.\n */\npublic fun <T> List<T>.first(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\npublic inline fun <T> Iterable<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this collection in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Iterable<T>.firstNotNullOf(transform: (T) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the collection was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this collection in iteration order,\n * or `null` if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Iterable<T>.firstNotNullOfOrNull(transform: (T) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first element, or `null` if the collection is empty.\n */\npublic fun <T> Iterable<T>.firstOrNull(): T? {\n    when (this) {\n        is List -> {\n            if (isEmpty())\n                return null\n            else\n                return this[0]\n        }\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            return iterator.next()\n        }\n    }\n}\n\n/**\n * Returns the first element, or `null` if the list is empty.\n */\npublic fun <T> List<T>.firstOrNull(): T? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\npublic inline fun <T> Iterable<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this list.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> List<T>.getOrElse(index: Int, defaultValue: (Int) -> T): T {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this list.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun <T> List<T>.getOrNull(index: Int): T? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.indexOf(element: T): Int {\n    if (this is List) return this.indexOf(element)\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns first index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.indexOf(element: T): Int {\n    return indexOf(element)\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the collection does not contain such element.\n */\npublic inline fun <T> Iterable<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the list does not contain such element.\n */\npublic inline fun <T> List<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (predicate(iterator.previous())) {\n            return iterator.nextIndex()\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the collection is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Iterable<T>.last(): T {\n    when (this) {\n        is List -> return this.last()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the list is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> List<T>.last(): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"List is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Iterable<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> List<T>.last(predicate: (T) -> Boolean): T {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"List contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the collection does not contain element.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Iterable<T>.lastIndexOf(element: T): Int {\n    if (this is List) return this.lastIndexOf(element)\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns last index of [element], or -1 if the list does not contain element.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning, extension takes precedence in some cases\npublic fun <@kotlin.internal.OnlyInputTypes T> List<T>.lastIndexOf(element: T): Int {\n    return lastIndexOf(element)\n}\n\n/**\n * Returns the last element, or `null` if the collection is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Iterable<T>.lastOrNull(): T? {\n    when (this) {\n        is List -> return if (isEmpty()) null else this[size - 1]\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            var last = iterator.next()\n            while (iterator.hasNext())\n                last = iterator.next()\n            return last\n        }\n    }\n}\n\n/**\n * Returns the last element, or `null` if the list is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> List<T>.lastOrNull(): T? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Iterable<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> List<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    val iterator = this.listIterator(size)\n    while (iterator.hasPrevious()) {\n        val element = iterator.previous()\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this collection.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.random(): T {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness.\n * \n * @throws NoSuchElementException if this collection is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> Collection<T>.random(random: Random): T {\n    if (isEmpty())\n        throw NoSuchElementException(\"Collection is empty.\")\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this collection, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.randomOrNull(): T? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this collection using the specified source of randomness, or `null` if this collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> Collection<T>.randomOrNull(random: Random): T? {\n    if (isEmpty())\n        return null\n    return elementAt(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.single(): T {\n    when (this) {\n        is List -> return this.single()\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                throw NoSuchElementException(\"Collection is empty.\")\n            val single = iterator.next()\n            if (iterator.hasNext())\n                throw IllegalArgumentException(\"Collection has more than one element.\")\n            return single\n        }\n    }\n}\n\n/**\n * Returns the single element, or throws an exception if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.single(): T {\n    return when (size) {\n        0 -> throw NoSuchElementException(\"List is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"List has more than one element.\")\n    }\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\npublic inline fun <T> Iterable<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Collection contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Collection contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the collection is empty or has more than one element.\n */\npublic fun <T> Iterable<T>.singleOrNull(): T? {\n    when (this) {\n        is List -> return if (size == 1) this[0] else null\n        else -> {\n            val iterator = iterator()\n            if (!iterator.hasNext())\n                return null\n            val single = iterator.next()\n            if (iterator.hasNext())\n                return null\n            return single\n        }\n    }\n}\n\n/**\n * Returns single element, or `null` if the list is empty or has more than one element.\n */\npublic fun <T> List<T>.singleOrNull(): T? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\npublic inline fun <T> Iterable<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Iterable<T>.drop(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return toList()\n    val list: ArrayList<T>\n    if (this is Collection<*>) {\n        val resultSize = size - n\n        if (resultSize <= 0)\n            return emptyList()\n        if (resultSize == 1)\n            return listOf(last())\n        list = ArrayList<T>(resultSize)\n        if (this is List<T>) {\n            if (this is RandomAccess) {\n                for (index in n until size)\n                    list.add(this[index])\n            } else {\n                for (item in listIterator(n))\n                    list.add(item)\n            }\n            return list\n        }\n    }\n    else {\n        list = ArrayList<T>()\n    }\n    var count = 0\n    for (item in this) {\n        if (count >= n) list.add(item) else ++count\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> List<T>.dropLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> List<T>.dropLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            if (!predicate(iterator.previous())) {\n                return take(iterator.nextIndex() + 1)\n            }\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic inline fun <T> Iterable<T>.dropWhile(predicate: (T) -> Boolean): List<T> {\n    var yielding = false\n    val list = ArrayList<T>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filter(predicate: (T) -> Boolean): List<T> {\n    return filterTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun <T> Iterable<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): List<T> {\n    return filterIndexedTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements that are instances of specified type parameter R.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Iterable<*>.filterIsInstance(): List<@kotlin.internal.NoInfer R> {\n    return filterIsInstanceTo(ArrayList<R>())\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Iterable<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic inline fun <T> Iterable<T>.filterNot(predicate: (T) -> Boolean): List<T> {\n    return filterNotTo(ArrayList<T>(), predicate)\n}\n\n/**\n * Returns a list containing all elements that are not `null`.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Iterable<T?>.filterNotNull(): List<T> {\n    return filterNotNullTo(ArrayList<T>())\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Iterable<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Iterable<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\npublic fun <T> List<T>.slice(indices: IntRange): List<T> {\n    if (indices.isEmpty()) return listOf()\n    return this.subList(indices.start, indices.endInclusive + 1).toList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\npublic fun <T> List<T>.slice(indices: Iterable<Int>): List<T> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<T>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Iterable<T>.take(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (this is Collection<T>) {\n        if (n >= size) return toList()\n        if (n == 1) return listOf(first())\n    }\n    var count = 0\n    val list = ArrayList<T>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list.optimizeReadOnlyList()\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> List<T>.takeLast(n: Int): List<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(last())\n    val list = ArrayList<T>(n)\n    if (this is RandomAccess) {\n        for (index in size - n until size)\n            list.add(this[index])\n    } else {\n        for (item in listIterator(size - n))\n            list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> List<T>.takeLastWhile(predicate: (T) -> Boolean): List<T> {\n    if (isEmpty())\n        return emptyList()\n    val iterator = listIterator(size)\n    while (iterator.hasPrevious()) {\n        if (!predicate(iterator.previous())) {\n            iterator.next()\n            val expectedSize = size - iterator.nextIndex()\n            if (expectedSize == 0) return emptyList()\n            return ArrayList<T>(expectedSize).apply {\n                while (iterator.hasNext())\n                    add(iterator.next())\n            }\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic inline fun <T> Iterable<T>.takeWhile(predicate: (T) -> Boolean): List<T> {\n    val list = ArrayList<T>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the list in-place.\n */\npublic expect fun <T> MutableList<T>.reverse(): Unit\n\n/**\n * Returns a list with elements in reversed order.\n */\npublic fun <T> Iterable<T>.reversed(): List<T> {\n    if (this is Collection && size <= 1) return toList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Randomly shuffles elements in this list in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> MutableList<T>.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        this[j] = this.set(i, this[j])\n    }\n}\n\n/**\n * Sorts elements in the list in-place according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortBy(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareBy(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> MutableList<T>.sortByDescending(crossinline selector: (T) -> R?): Unit {\n    if (size > 1) sortWith(compareByDescending(selector))\n}\n\n/**\n * Sorts elements in the list in-place descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> MutableList<T>.sortDescending(): Unit {\n    sortWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sorted(): List<T> {\n    if (this is Collection) {\n        if (size <= 1) return this.toList()\n        @Suppress(\"UNCHECKED_CAST\")\n        return (toTypedArray<Comparable<T>>() as Array<T>).apply { sort() }.asList()\n    }\n    return toMutableList().apply { sort() }\n}\n\n/**\n * Returns a list of all elements sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedBy(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic inline fun <T, R : Comparable<R>> Iterable<T>.sortedByDescending(crossinline selector: (T) -> R?): List<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T : Comparable<T>> Iterable<T>.sortedDescending(): List<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a list of all elements sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic fun <T> Iterable<T>.sortedWith(comparator: Comparator<in T>): List<T> {\n    if (this is Collection) {\n       if (size <= 1) return this.toList()\n       @Suppress(\"UNCHECKED_CAST\")\n       return (toTypedArray<Any?>() as Array<T>).apply { sortWith(comparator) }.asList()\n    }\n    return toMutableList().apply { sortWith(comparator) }\n}\n\n/**\n * Returns an array of Boolean containing all of the elements of this collection.\n */\npublic fun Collection<Boolean>.toBooleanArray(): BooleanArray {\n    val result = BooleanArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Byte containing all of the elements of this collection.\n */\npublic fun Collection<Byte>.toByteArray(): ByteArray {\n    val result = ByteArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Char containing all of the elements of this collection.\n */\npublic fun Collection<Char>.toCharArray(): CharArray {\n    val result = CharArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Double containing all of the elements of this collection.\n */\npublic fun Collection<Double>.toDoubleArray(): DoubleArray {\n    val result = DoubleArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Float containing all of the elements of this collection.\n */\npublic fun Collection<Float>.toFloatArray(): FloatArray {\n    val result = FloatArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Int containing all of the elements of this collection.\n */\npublic fun Collection<Int>.toIntArray(): IntArray {\n    val result = IntArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Long containing all of the elements of this collection.\n */\npublic fun Collection<Long>.toLongArray(): LongArray {\n    val result = LongArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns an array of Short containing all of the elements of this collection.\n */\npublic fun Collection<Short>.toShortArray(): ShortArray {\n    val result = ShortArray(size)\n    var index = 0\n    for (element in this)\n        result[index++] = element\n    return result\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associate\n */\npublic inline fun <T, K, V> Iterable<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given collection indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateBy\n */\npublic inline fun <T, K> Iterable<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, T>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateByWithValueTransform\n */\npublic inline fun <T, K, V> Iterable<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    val capacity = mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given collection\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given collection.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given collection.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.collections.Collections.Transformations.associateTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Iterable<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given collection and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original collection.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Iterable<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>(mapCapacity(collectionSizeOrDefault(10)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given collection,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Iterable<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n */\npublic fun <T, C : MutableCollection<in T>> Iterable<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n */\npublic fun <T> Iterable<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>(mapCapacity(collectionSizeOrDefault(12))))\n}\n\n/**\n * Returns a [List] containing all elements.\n */\npublic fun <T> Iterable<T>.toList(): List<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptyList()\n            1 -> listOf(if (this is List) get(0) else iterator().next())\n            else -> this.toMutableList()\n        }\n    }\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Iterable<T>.toMutableList(): MutableList<T> {\n    if (this is Collection<T>)\n        return this.toMutableList()\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this collection.\n */\npublic fun <T> Collection<T>.toMutableList(): MutableList<T> {\n    return ArrayList(this)\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toSet(): Set<T> {\n    if (this is Collection) {\n        return when (size) {\n            0 -> emptySet()\n            1 -> setOf(if (this is List) this[0] else iterator().next())\n            else -> toCollection(LinkedHashSet<T>(mapCapacity(size)))\n        }\n    }\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <T, R> Iterable<T>.flatMap(transform: (T) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original collection, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Iterable<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original collection.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Iterable<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original collection by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original collection\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Iterable<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a collection to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Iterable<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic inline fun <T, R> Iterable<T>.map(transform: (T) -> R): List<R> {\n    return mapTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R> Iterable<T>.mapIndexed(transform: (index: Int, T) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(collectionSizeOrDefault(10)), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original collection.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any> Iterable<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original collection\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each element in the original collection.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <T, R : Any> Iterable<T>.mapNotNull(transform: (T) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each element in the original collection\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Iterable<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original collection\n * and appends the results to the given [destination].\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Iterable<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original collection\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\npublic fun <T> Iterable<T>.withIndex(): Iterable<IndexedValue<T>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a list containing only distinct elements from the given collection.\n * \n * Among equal elements of the given collection, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Iterable<T>.distinct(): List<T> {\n    return this.toMutableSet().toList()\n}\n\n/**\n * Returns a list containing only elements from the given collection\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given collection with equal keys, only the first one will be present in the resulting list.\n * The elements in the resulting list are in the same order as they were in the source collection.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic inline fun <T, K> Iterable<T>.distinctBy(selector: (T) -> K): List<T> {\n    val set = HashSet<K>()\n    val list = ArrayList<T>()\n    for (e in this) {\n        val key = selector(e)\n        if (set.add(key))\n            list.add(e)\n    }\n    return list\n}\n\n/**\n * Returns a set containing all elements that are contained by both this collection and the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n * \n * To get a set containing all elements that are contained at least in one of these collections use [union].\n */\npublic infix fun <T> Iterable<T>.intersect(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.retainAll(other)\n    return set\n}\n\n/**\n * Returns a set containing all elements that are contained by this collection and not contained by the specified collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic infix fun <T> Iterable<T>.subtract(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.removeAll(other)\n    return set\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given collection.\n * \n * The returned set preserves the element iteration order of the original collection.\n */\npublic fun <T> Iterable<T>.toMutableSet(): MutableSet<T> {\n    return when (this) {\n        is Collection<T> -> LinkedHashSet(this)\n        else -> toCollection(LinkedHashSet<T>())\n    }\n}\n\n/**\n * Returns a set containing all distinct elements from both collections.\n * \n * The returned set preserves the element iteration order of the original collection.\n * Those elements of the [other] collection that are unique are iterated in the end\n * in the order of the [other] collection.\n * \n * To get a set containing all elements that are contained in both collections use [intersect].\n */\npublic infix fun <T> Iterable<T>.union(other: Iterable<T>): Set<T> {\n    val set = this.toMutableSet()\n    set.addAll(other)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Iterable<T>.all(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if collection has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Iterable<T>.any(): Boolean {\n    if (this is Collection) return !isEmpty()\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Iterable<T>.any(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this collection.\n */\npublic fun <T> Iterable<T>.count(): Int {\n    if (this is Collection) return size\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements in this collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\npublic inline fun <T> Iterable<T>.count(predicate: (T) -> Boolean): Int {\n    if (this is Collection && isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the collection is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Returns the specified [initial] value if the collection is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\npublic inline fun <T, R> Iterable<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the list is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRight(initial: R, operation: (T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            accumulator = operation(iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Returns the specified [initial] value if the list is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <T, R> List<T>.foldRightIndexed(initial: R, operation: (index: Int, T, acc: R) -> R): R {\n    var accumulator = initial\n    if (!isEmpty()) {\n        val iterator = listIterator(size)\n        while (iterator.hasPrevious()) {\n            val index = iterator.previousIndex()\n            accumulator = operation(index, iterator.previous(), accumulator)\n        }\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <T> Iterable<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\npublic inline fun <T> Iterable<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun <T : Comparable<T>> Iterable<T>.max(): T? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxBy(selector: (T) -> R): T? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.maxOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Double>.maxOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Float>.maxOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.maxOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun <T> Iterable<T>.maxWith(comparator: Comparator<in T>): T? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Iterable<T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Double>.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.1\")\npublic fun Iterable<Float>.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun <T : Comparable<T>> Iterable<T>.min(): T? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minBy(selector: (T) -> R): T? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Iterable<T>.minOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection.\n * \n * @throws NoSuchElementException if the collection is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the collection or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Iterable<T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Double>.minOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic fun Iterable<Float>.minOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Iterable<T>.minOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun <T> Iterable<T>.minWith(comparator: Comparator<in T>): T? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Iterable<T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the collection has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Iterable<T>.none(): Boolean {\n    if (this is Collection) return isEmpty()\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Iterable<T>.none(predicate: (T) -> Boolean): Boolean {\n    if (this is Collection && isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the collection itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, C : Iterable<T>> C.onEach(action: (T) -> Unit): C {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the collection itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, C : Iterable<T>> C.onEachIndexed(action: (index: Int, T) -> Unit): C {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this collection is empty. If the collection can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Throws an exception if this collection is empty. If the collection can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Iterable<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty collection can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original collection.\n * \n * Returns `null` if the collection is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Iterable<T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the collection is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Iterable<T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this list is empty. If the list can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRight(operation: (T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Throws an exception if this list is empty. If the list can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun <S, T : S> List<T>.reduceRightIndexed(operation: (index: Int, T, acc: S) -> S): S {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        throw UnsupportedOperationException(\"Empty list can't be reduced.\")\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original list and current accumulator value.\n * \n * Returns `null` if the list is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> List<T>.reduceRightIndexedOrNull(operation: (index: Int, T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        val index = iterator.previousIndex()\n        accumulator = operation(index, iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the list is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> List<T>.reduceRightOrNull(operation: (T, acc: S) -> S): S? {\n    val iterator = listIterator(size)\n    if (!iterator.hasPrevious())\n        return null\n    var accumulator: S = iterator.previous()\n    while (iterator.hasPrevious()) {\n        accumulator = operation(iterator.previous(), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Iterable<T>.runningFold(initial: R, operation: (acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R> Iterable<T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    val estimatedSize = collectionSizeOrDefault(9)\n    if (estimatedSize == 0) return listOf(initial)\n    val result = ArrayList<R>(estimatedSize + 1).apply { add(initial) }\n    var index = 0\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(index++, accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Iterable<T>.runningReduce(operation: (acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with the first element of this collection.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Iterable<T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): List<S> {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return emptyList()\n    var accumulator: S = iterator.next()\n    val result = ArrayList<S>(collectionSizeOrDefault(10)).apply { add(accumulator) }\n    var index = 1\n    while (iterator.hasNext()) {\n        accumulator = operation(index++, accumulator, iterator.next())\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Iterable<T>.scan(initial: R, operation: (acc: R, T) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original collection and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <T, R> Iterable<T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Iterable<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Iterable<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the collection.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> Iterable<T?>.requireNoNulls(): Iterable<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as Iterable<T>\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n */\npublic fun <T : Any> List<T?>.requireNoNulls(): List<T> {\n    for (element in this) {\n        if (element == null) {\n            throw IllegalArgumentException(\"null element found in $this.\")\n        }\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return this as List<T>\n}\n\n/**\n * Splits this collection into a list of lists each not exceeding the given [size].\n * \n * The last list in the resulting list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.chunked(size: Int): List<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this collection into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this collection.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.chunked(size: Int, transform: (List<T>) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\npublic operator fun <T> Iterable<T>.minus(element: T): List<T> {\n    val result = ArrayList<T>(collectionSizeOrDefault(10))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] array.\n * \n * Before Kotlin 1.6, the [elements] array may have been converted to a [HashSet] to speed up the operation, thus the elements were required to have\n * a correct and stable implementation of `hashCode()` that didn't change between successive invocations.\n * On JVM, you can enable this behavior back with the system property `kotlin.collections.convert_arg_to_set_in_removeAll` set to `true`.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Array<out T>): List<T> {\n    if (elements.isEmpty()) return this.toList()\n    val other = elements.convertToSetForSetOperation()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] collection.\n * \n * Before Kotlin 1.6, the [elements] collection may have been converted to a [HashSet] to speed up the operation, thus the elements were required to have\n * a correct and stable implementation of `hashCode()` that didn't change between successive invocations.\n * On JVM, you can enable this behavior back with the system property `kotlin.collections.convert_arg_to_set_in_removeAll` set to `true`.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Iterable<T>): List<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection except the elements contained in the given [elements] sequence.\n * \n * Before Kotlin 1.6, the [elements] sequence may have been converted to a [HashSet] to speed up the operation, thus the elements were required to have\n * a correct and stable implementation of `hashCode()` that didn't change between successive invocations.\n * On JVM, you can enable this behavior back with the system property `kotlin.collections.convert_arg_to_set_in_removeAll` set to `true`.\n */\npublic operator fun <T> Iterable<T>.minus(elements: Sequence<T>): List<T> {\n    val other = elements.convertToSetForSetOperation()\n    if (other.isEmpty())\n        return this.toList()\n    return this.filterNot { it in other }\n}\n\n/**\n * Returns a list containing all elements of the original collection without the first occurrence of the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.minusElement(element: T): List<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original collection into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n * \n * @sample samples.collections.Iterables.Operations.partition\n */\npublic inline fun <T> Iterable<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Iterable<T>.plus(element: T): List<T> {\n    if (this is Collection) return this.plus(element)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\npublic operator fun <T> Collection<T>.plus(element: T): List<T> {\n    val result = ArrayList<T>(size + 1)\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Array<out T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] array.\n */\npublic operator fun <T> Collection<T>.plus(elements: Array<out T>): List<T> {\n    val result = ArrayList<T>(this.size + elements.size)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Iterable<T>): List<T> {\n    if (this is Collection) return this.plus(elements)\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] collection.\n */\npublic operator fun <T> Collection<T>.plus(elements: Iterable<T>): List<T> {\n    if (elements is Collection) {\n        val result = ArrayList<T>(this.size + elements.size)\n        result.addAll(this)\n        result.addAll(elements)\n        return result\n    } else {\n        val result = ArrayList<T>(this)\n        result.addAll(elements)\n        return result\n    }\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Iterable<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>()\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then all elements of the given [elements] sequence.\n */\npublic operator fun <T> Collection<T>.plus(elements: Sequence<T>): List<T> {\n    val result = ArrayList<T>(this.size + 10)\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list containing all elements of the original collection and then the given [element].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Collection<T>.plusElement(element: T): List<T> {\n    return plus(element)\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this collection with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<List<T>> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<List<T>>(resultCapacity)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (windowSize < size && !partialWindows) break\n            result.add(List(windowSize) { this[it + index] })\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<List<T>>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = false).forEach {\n        result.add(it)\n    }\n    return result\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this collection with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this collection.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Iterable<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    if (this is RandomAccess && this is List) {\n        val thisSize = this.size\n        val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n        val result = ArrayList<R>(resultCapacity)\n        val window = MovingSubList(this)\n        var index = 0\n        while (index in 0 until thisSize) {\n            val windowSize = size.coerceAtMost(thisSize - index)\n            if (!partialWindows && windowSize < size) break\n            window.move(index, index + windowSize)\n            result.add(transform(window))\n            index += step\n        }\n        return result\n    }\n    val result = ArrayList<R>()\n    windowedIterator(iterator(), size, step, partialWindows, reuseBuffer = true).forEach {\n        result.add(transform(it))\n    }\n    return result\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Array<out R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Array<out R>, transform: (a: T, b: R) -> V): List<V> {\n    val arraySize = other.size\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in this) {\n        if (i >= arraySize) break\n        list.add(transform(element, other[i++]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] collection with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\npublic infix fun <T, R> Iterable<T>.zip(other: Iterable<R>): List<Pair<T, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` collection and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\npublic inline fun <T, R, V> Iterable<T>.zip(other: Iterable<R>, transform: (a: T, b: R) -> V): List<V> {\n    val first = iterator()\n    val second = other.iterator()\n    val list = ArrayList<V>(minOf(collectionSizeOrDefault(10), other.collectionSizeOrDefault(10)))\n    while (first.hasNext() && second.hasNext()) {\n        list.add(transform(first.next(), second.next()))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Iterable<T>.zipWithNext(): List<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this collection.\n * \n * The returned list is empty if this collection contains less than two elements.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <T, R> Iterable<T>.zipWithNext(transform: (a: T, b: T) -> R): List<R> {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return emptyList()\n    val result = mutableListOf<R>()\n    var current = iterator.next()\n    while (iterator.hasNext()) {\n        val next = iterator.next()\n        result.add(transform(current, next))\n        current = next\n    }\n    return result\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Iterable<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Iterable<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Returns this collection as an [Iterable].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable<T>.asIterable(): Iterable<T> {\n    return this\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original collection returning its elements when being iterated.\n * \n * @sample samples.collections.Sequences.Building.sequenceFromCollection\n */\npublic fun <T> Iterable<T>.asSequence(): Sequence<T> {\n    return Sequence { this.iterator() }\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Iterable<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Iterable<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Iterable<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Iterable<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Iterable<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the collection.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Iterable<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Iterable<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Iterable<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Iterable<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Iterable<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Iterable<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the collection.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Iterable<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\n/**\n * Given an [iterator] function constructs an [Iterable] instance that returns values through the [Iterator]\n * provided by that function.\n * @sample samples.collections.Iterables.Building.iterable\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Iterable(crossinline iterator: () -> Iterator<T>): Iterable<T> = object : Iterable<T> {\n    override fun iterator(): Iterator<T> = iterator()\n}\n\n/**\n * A wrapper over another [Iterable] (or any other object that can produce an [Iterator]) that returns\n * an indexing iterator.\n */\ninternal class IndexingIterable<out T>(private val iteratorFactory: () -> Iterator<T>) : Iterable<IndexedValue<T>> {\n    override fun iterator(): Iterator<IndexedValue<T>> = IndexingIterator(iteratorFactory())\n}\n\n\n/**\n * Returns the size of this iterable if it is known, or `null` otherwise.\n */\n@PublishedApi\ninternal fun <T> Iterable<T>.collectionSizeOrNull(): Int? = if (this is Collection<*>) this.size else null\n\n/**\n * Returns the size of this iterable if it is known, or the specified [default] value otherwise.\n */\n@PublishedApi\ninternal fun <T> Iterable<T>.collectionSizeOrDefault(default: Int): Int = if (this is Collection<*>) this.size else default\n\n\n/**\n * Returns a single list of all elements from all collections in the given collection.\n * @sample samples.collections.Iterables.Operations.flattenIterable\n */\npublic fun <T> Iterable<Iterable<T>>.flatten(): List<T> {\n    val result = ArrayList<T>()\n    for (element in this) {\n        result.addAll(element)\n    }\n    return result\n}\n\n/**\n * Returns a pair of lists, where\n * *first* list is built from the first values of each pair from this collection,\n * *second* list is built from the second values of each pair from this collection.\n * @sample samples.collections.Iterables.Operations.unzipIterable\n */\npublic fun <T, R> Iterable<Pair<T, R>>.unzip(): Pair<List<T>, List<R>> {\n    val expectedSize = collectionSizeOrDefault(10)\n    val listT = ArrayList<T>(expectedSize)\n    val listR = ArrayList<R>(expectedSize)\n    for (pair in this) {\n        listT.add(pair.first)\n        listR.add(pair.second)\n    }\n    return listT to listR\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SequencesKt\")\n\npackage kotlin.sequences\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns `true` if [element] is found in the sequence.\n *\n * The operation is _terminal_.\n */\npublic operator fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.contains(element: T): Boolean {\n    return indexOf(element) >= 0\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic fun <T> Sequence<T>.elementAt(index: Int): T {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"Sequence doesn't contain element at index $index.\") }\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\npublic fun <T> Sequence<T>.elementAtOrElse(index: Int, defaultValue: (Int) -> T): T {\n    if (index < 0)\n        return defaultValue(index)\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\npublic fun <T> Sequence<T>.elementAtOrNull(index: Int): T? {\n    if (index < 0)\n        return null\n    val iterator = iterator()\n    var count = 0\n    while (iterator.hasNext()) {\n        val element = iterator.next()\n        if (index == count++)\n            return element\n    }\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.find(predicate: (T) -> Boolean): T? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.findLast(predicate: (T) -> Boolean): T? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.first(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    return iterator.next()\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.first(predicate: (T) -> Boolean): T {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this sequence in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Sequence<T>.firstNotNullOf(transform: (T) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the sequence was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to elements of this sequence in iteration order,\n * or `null` if no non-null value was produced.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Any> Sequence<T>.firstNotNullOfOrNull(transform: (T) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first element, or `null` if the sequence is empty.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.firstOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    return iterator.next()\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.firstOrNull(predicate: (T) -> Boolean): T? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns first index of [element], or -1 if the sequence does not contain element.\n *\n * The operation is _terminal_.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.indexOf(element: T): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the sequence does not contain such element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.indexOfFirst(predicate: (T) -> Boolean): Int {\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            return index\n        index++\n    }\n    return -1\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the sequence does not contain such element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.indexOfLast(predicate: (T) -> Boolean): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (predicate(item))\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns the last element.\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if the sequence is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Sequence<T>.last(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    var last = iterator.next()\n    while (iterator.hasNext())\n        last = iterator.next()\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Sequence<T>.last(predicate: (T) -> Boolean): T {\n    var last: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return last as T\n}\n\n/**\n * Returns last index of [element], or -1 if the sequence does not contain element.\n *\n * The operation is _terminal_.\n */\npublic fun <@kotlin.internal.OnlyInputTypes T> Sequence<T>.lastIndexOf(element: T): Int {\n    var lastIndex = -1\n    var index = 0\n    for (item in this) {\n        checkIndexOverflow(index)\n        if (element == item)\n            lastIndex = index\n        index++\n    }\n    return lastIndex\n}\n\n/**\n * Returns the last element, or `null` if the sequence is empty.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic fun <T> Sequence<T>.lastOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    var last = iterator.next()\n    while (iterator.hasNext())\n        last = iterator.next()\n    return last\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Elements.last\n */\npublic inline fun <T> Sequence<T>.lastOrNull(predicate: (T) -> Boolean): T? {\n    var last: T? = null\n    for (element in this) {\n        if (predicate(element)) {\n            last = element\n        }\n    }\n    return last\n}\n\n/**\n * Returns the single element, or throws an exception if the sequence is empty or has more than one element.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.single(): T {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        throw NoSuchElementException(\"Sequence is empty.\")\n    val single = iterator.next()\n    if (iterator.hasNext())\n        throw IllegalArgumentException(\"Sequence has more than one element.\")\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.single(predicate: (T) -> Boolean): T {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Sequence contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Sequence contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as T\n}\n\n/**\n * Returns single element, or `null` if the sequence is empty or has more than one element.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.singleOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext())\n        return null\n    val single = iterator.next()\n    if (iterator.hasNext())\n        return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.singleOrNull(predicate: (T) -> Boolean): T? {\n    var single: T? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a sequence containing all elements except first [n] elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Sequence<T>.drop(n: Int): Sequence<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return when {\n        n == 0 -> this\n        this is DropTakeSequence -> this.drop(n)\n        else -> DropSequence(this, n)\n    }\n}\n\n/**\n * Returns a sequence containing all elements except first elements that satisfy the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\npublic fun <T> Sequence<T>.dropWhile(predicate: (T) -> Boolean): Sequence<T> {\n    return DropWhileSequence(this, predicate)\n}\n\n/**\n * Returns a sequence containing only elements matching the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic fun <T> Sequence<T>.filter(predicate: (T) -> Boolean): Sequence<T> {\n    return FilteringSequence(this, true, predicate)\n}\n\n/**\n * Returns a sequence containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic fun <T> Sequence<T>.filterIndexed(predicate: (index: Int, T) -> Boolean): Sequence<T> {\n    // TODO: Rewrite with generalized MapFilterIndexingSequence\n    return TransformingSequence(FilteringSequence(IndexingSequence(this), true, { predicate(it.index, it.value) }), { it.value })\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterIndexedTo(destination: C, predicate: (index: Int, T) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a sequence containing all elements that are instances of specified type parameter R.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstance\n */\npublic inline fun <reified R> Sequence<*>.filterIsInstance(): Sequence<@kotlin.internal.NoInfer R> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return filter { it is R } as Sequence<R>\n}\n\n/**\n * Appends all elements that are instances of specified type parameter R to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterIsInstanceTo\n */\npublic inline fun <reified R, C : MutableCollection<in R>> Sequence<*>.filterIsInstanceTo(destination: C): C {\n    for (element in this) if (element is R) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a sequence containing all elements not matching the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\npublic fun <T> Sequence<T>.filterNot(predicate: (T) -> Boolean): Sequence<T> {\n    return FilteringSequence(this, false, predicate)\n}\n\n/**\n * Returns a sequence containing all elements that are not `null`.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNull\n */\npublic fun <T : Any> Sequence<T?>.filterNotNull(): Sequence<T> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return filterNot { it == null } as Sequence<T>\n}\n\n/**\n * Appends all elements that are not `null` to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterNotNullTo\n */\npublic fun <C : MutableCollection<in T>, T : Any> Sequence<T?>.filterNotNullTo(destination: C): C {\n    for (element in this) if (element != null) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterNotTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <T, C : MutableCollection<in T>> Sequence<T>.filterTo(destination: C, predicate: (T) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a sequence containing first [n] elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Sequence<T>.take(n: Int): Sequence<T> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return when {\n        n == 0 -> emptySequence()\n        this is DropTakeSequence -> this.take(n)\n        else -> TakeSequence(this, n)\n    }\n}\n\n/**\n * Returns a sequence containing first elements satisfying the given [predicate].\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\npublic fun <T> Sequence<T>.takeWhile(predicate: (T) -> Boolean): Sequence<T> {\n    return TakeWhileSequence(this, predicate)\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.sorted(): Sequence<T> {\n    return object : Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val sortedList = this@sorted.toMutableList()\n            sortedList.sort()\n            return sortedList.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Sorting.sortedBy\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.sortedBy(crossinline selector: (T) -> R?): Sequence<T> {\n    return sortedWith(compareBy(selector))\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted descending according to natural sort order of the value returned by specified [selector] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic inline fun <T, R : Comparable<R>> Sequence<T>.sortedByDescending(crossinline selector: (T) -> R?): Sequence<T> {\n    return sortedWith(compareByDescending(selector))\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T : Comparable<T>> Sequence<T>.sortedDescending(): Sequence<T> {\n    return sortedWith(reverseOrder())\n}\n\n/**\n * Returns a sequence that yields elements of this sequence sorted according to the specified [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic fun <T> Sequence<T>.sortedWith(comparator: Comparator<in T>): Sequence<T> {\n    return object : Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val sortedList = this@sortedWith.toMutableList()\n            sortedList.sortWith(comparator)\n            return sortedList.iterator()\n        }\n    }\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to elements of the given sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associate\n */\npublic inline fun <T, K, V> Sequence<T>.associate(transform: (T) -> Pair<K, V>): Map<K, V> {\n    return associateTo(LinkedHashMap<K, V>(), transform)\n}\n\n/**\n * Returns a [Map] containing the elements from the given sequence indexed by the key\n * returned from [keySelector] function applied to each element.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateBy\n */\npublic inline fun <T, K> Sequence<T>.associateBy(keySelector: (T) -> K): Map<K, T> {\n    return associateByTo(LinkedHashMap<K, T>(), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to elements of the given sequence.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByWithValueTransform\n */\npublic inline fun <T, K, V> Sequence<T>.associateBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, V> {\n    return associateByTo(LinkedHashMap<K, V>(), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each element of the given sequence\n * and value is the element itself.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByTo\n */\npublic inline fun <T, K, M : MutableMap<in K, in T>> Sequence<T>.associateByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to elements of the given sequence.\n * \n * If any two elements would have the same key returned by [keySelector] the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateByToWithValueTransform\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Sequence<T>.associateByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each element of the given sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateTo\n */\npublic inline fun <T, K, V, M : MutableMap<in K, in V>> Sequence<T>.associateTo(destination: M, transform: (T) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are elements from the given sequence and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V> Sequence<K>.associateWith(valueSelector: (K) -> V): Map<K, V> {\n    val result = LinkedHashMap<K, V>()\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given sequence,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <K, V, M : MutableMap<in K, in V>> Sequence<K>.associateWithTo(destination: M, valueSelector: (K) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all elements to the given [destination] collection.\n *\n * The operation is _terminal_.\n */\npublic fun <T, C : MutableCollection<in T>> Sequence<T>.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toHashSet(): HashSet<T> {\n    return toCollection(HashSet<T>())\n}\n\n/**\n * Returns a [List] containing all elements.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toList(): List<T> {\n    return this.toMutableList().optimizeReadOnlyList()\n}\n\n/**\n * Returns a new [MutableList] filled with all elements of this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toMutableList(): MutableList<T> {\n    return toCollection(ArrayList<T>())\n}\n\n/**\n * Returns a [Set] of all elements.\n * \n * The returned set preserves the element iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toSet(): Set<T> {\n    return toCollection(LinkedHashSet<T>()).optimizeReadOnlySet()\n}\n\n/**\n * Returns a single sequence of all elements from results of [transform] function being invoked on each element of original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIterable\")\npublic fun <T, R> Sequence<T>.flatMap(transform: (T) -> Iterable<R>): Sequence<R> {\n    return FlatteningSequence(this, transform, Iterable<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements from results of [transform] function being invoked on each element of original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic fun <T, R> Sequence<T>.flatMap(transform: (T) -> Sequence<R>): Sequence<R> {\n    return FlatteningSequence(this, transform, Sequence<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\npublic fun <T, R> Sequence<T>.flatMapIndexed(transform: (index: Int, T) -> Iterable<R>): Sequence<R> {\n    return flatMapIndexed(this, transform, Iterable<R>::iterator)\n}\n\n/**\n * Returns a single sequence of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequence\")\npublic fun <T, R> Sequence<T>.flatMapIndexed(transform: (index: Int, T) -> Sequence<R>): Sequence<R> {\n    return flatMapIndexed(this, transform, Sequence<R>::iterator)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedSequenceTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapIndexedTo(destination: C, transform: (index: Int, T) -> Sequence<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(checkIndexOverflow(index++), element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIterableTo\")\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapTo(destination: C, transform: (T) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original sequence, to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.flatMapTo(destination: C, transform: (T) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original sequence by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K> Sequence<T>.groupBy(keySelector: (T) -> K): Map<K, List<T>> {\n    return groupByTo(LinkedHashMap<K, MutableList<T>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original sequence\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original sequence.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V> Sequence<T>.groupBy(keySelector: (T) -> K, valueTransform: (T) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original sequence by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <T, K, M : MutableMap<in K, MutableList<T>>> Sequence<T>.groupByTo(destination: M, keySelector: (T) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<T>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original sequence\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <T, K, V, M : MutableMap<in K, MutableList<V>>> Sequence<T>.groupByTo(destination: M, keySelector: (T) -> K, valueTransform: (T) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a sequence to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each element.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <T, K> Sequence<T>.groupingBy(crossinline keySelector: (T) -> K): Grouping<T, K> {\n    return object : Grouping<T, K> {\n        override fun sourceIterator(): Iterator<T> = this@groupingBy.iterator()\n        override fun keyOf(element: T): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to each element in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\npublic fun <T, R> Sequence<T>.map(transform: (T) -> R): Sequence<R> {\n    return TransformingSequence(this, transform)\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to each element and its index in the original sequence.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R> Sequence<T>.mapIndexed(transform: (index: Int, T) -> R): Sequence<R> {\n    return TransformingIndexedSequence(this, transform)\n}\n\n/**\n * Returns a sequence containing only the non-null results of applying the given [transform] function\n * to each element and its index in the original sequence.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T, R : Any> Sequence<T>.mapIndexedNotNull(transform: (index: Int, T) -> R?): Sequence<R> {\n    return TransformingIndexedSequence(this, transform).filterNotNull()\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original sequence\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Sequence<T>.mapIndexedNotNullTo(destination: C, transform: (index: Int, T) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original sequence\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.mapIndexedTo(destination: C, transform: (index: Int, T) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(checkIndexOverflow(index++), item))\n    return destination\n}\n\n/**\n * Returns a sequence containing only the non-null results of applying the given [transform] function\n * to each element in the original sequence.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic fun <T, R : Any> Sequence<T>.mapNotNull(transform: (T) -> R?): Sequence<R> {\n    return TransformingSequence(this, transform).filterNotNull()\n}\n\n/**\n * Applies the given [transform] function to each element in the original sequence\n * and appends only the non-null results to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R : Any, C : MutableCollection<in R>> Sequence<T>.mapNotNullTo(destination: C, transform: (T) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original sequence\n * and appends the results to the given [destination].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R, C : MutableCollection<in R>> Sequence<T>.mapTo(destination: C, transform: (T) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a sequence that wraps each element of the original sequence\n * into an [IndexedValue] containing the index of that element and the element itself.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T> Sequence<T>.withIndex(): Sequence<IndexedValue<T>> {\n    return IndexingSequence(this)\n}\n\n/**\n * Returns a sequence containing only distinct elements from the given sequence.\n * \n * Among equal elements of the given sequence, only the first one will be present in the resulting sequence.\n * The elements in the resulting sequence are in the same order as they were in the source sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T> Sequence<T>.distinct(): Sequence<T> {\n    return this.distinctBy { it }\n}\n\n/**\n * Returns a sequence containing only elements from the given sequence\n * having distinct keys returned by the given [selector] function.\n * \n * Among elements of the given sequence with equal keys, only the first one will be present in the resulting sequence.\n * The elements in the resulting sequence are in the same order as they were in the source sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.distinctAndDistinctBy\n */\npublic fun <T, K> Sequence<T>.distinctBy(selector: (T) -> K): Sequence<T> {\n    return DistinctSequence(this, selector)\n}\n\n/**\n * Returns a new [MutableSet] containing all distinct elements from the given sequence.\n * \n * The returned set preserves the element iteration order of the original sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.toMutableSet(): MutableSet<T> {\n    val set = LinkedHashSet<T>()\n    for (item in this) set.add(item)\n    return set\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <T> Sequence<T>.all(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if sequence has at least one element.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <T> Sequence<T>.any(): Boolean {\n    return iterator().hasNext()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <T> Sequence<T>.any(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements in this sequence.\n *\n * The operation is _terminal_.\n */\npublic fun <T> Sequence<T>.count(): Int {\n    var count = 0\n    for (element in this) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.count(predicate: (T) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) checkCountOverflow(++count)\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R> Sequence<T>.fold(initial: R, operation: (acc: R, T) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Returns the specified [initial] value if the sequence is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T, R> Sequence<T>.foldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.forEach(action: (T) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n *\n * The operation is _terminal_.\n */\npublic inline fun <T> Sequence<T>.forEachIndexed(action: (index: Int, T) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(checkIndexOverflow(index++), item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Double>.max(): Double? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Float>.max(): Float? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun <T : Comparable<T>> Sequence<T>.max(): T? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxBy(selector: (T) -> R): T? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxElem = iterator.next()\n    if (!iterator.hasNext()) return maxElem\n    var maxValue = selector(maxElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    } while (iterator.hasNext())\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.maxOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.maxOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.maxOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var maxValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Double>.maxOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Float>.maxOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        max = maxOf(max, e)\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Sequence<T>.maxOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun <T> Sequence<T>.maxWith(comparator: Comparator<in T>): T? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.maxWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var max = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Double>.min(): Double? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.1\")\npublic fun Sequence<Float>.min(): Float? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun <T : Comparable<T>> Sequence<T>.min(): T? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minBy(selector: (T) -> R): T? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minByOrNull(selector: (T) -> R): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minElem = iterator.next()\n    if (!iterator.hasNext()) return minElem\n    var minValue = selector(minElem)\n    do {\n        val e = iterator.next()\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    } while (iterator.hasNext())\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOf(selector: (T) -> Double): Double {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOf(selector: (T) -> Float): Float {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minOf(selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOfOrNull(selector: (T) -> Double): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minOfOrNull(selector: (T) -> Float): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R : Comparable<R>> Sequence<T>.minOfOrNull(selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence.\n * \n * @throws NoSuchElementException if the sequence is empty.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.minOfWith(comparator: Comparator<in R>, selector: (T) -> R): R {\n    val iterator = iterator()\n    if (!iterator.hasNext()) throw NoSuchElementException()\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the sequence or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> Sequence<T>.minOfWithOrNull(comparator: Comparator<in R>, selector: (T) -> R): R? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var minValue = selector(iterator.next())\n    while (iterator.hasNext()) {\n        val v = selector(iterator.next())\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Double>.minOrNull(): Double? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n * \n * If any of elements is `NaN` returns `NaN`.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun Sequence<Float>.minOrNull(): Float? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        min = minOf(min, e)\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T : Comparable<T>> Sequence<T>.minOrNull(): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun <T> Sequence<T>.minWith(comparator: Comparator<in T>): T? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.minWithOrNull(comparator: Comparator<in T>): T? {\n    val iterator = iterator()\n    if (!iterator.hasNext()) return null\n    var min = iterator.next()\n    while (iterator.hasNext()) {\n        val e = iterator.next()\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the sequence has no elements.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <T> Sequence<T>.none(): Boolean {\n    return !iterator().hasNext()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <T> Sequence<T>.none(predicate: (T) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns a sequence which performs the given [action] on each element of the original sequence as they pass through it.\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@SinceKotlin(\"1.1\")\npublic fun <T> Sequence<T>.onEach(action: (T) -> Unit): Sequence<T> {\n    return map {\n        action(it)\n        it\n    }\n}\n\n/**\n * Returns a sequence which performs the given [action] on each element of the original sequence as they pass through it.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@SinceKotlin(\"1.4\")\npublic fun <T> Sequence<T>.onEachIndexed(action: (index: Int, T) -> Unit): Sequence<T> {\n    return mapIndexed { index, element ->\n        action(index, element)\n        element\n    }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this sequence is empty. If the sequence can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Sequence<T>.reduce(operation: (acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty sequence can't be reduced.\")\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Throws an exception if this sequence is empty. If the sequence can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun <S, T : S> Sequence<T>.reduceIndexed(operation: (index: Int, acc: S, T) -> S): S {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) throw UnsupportedOperationException(\"Empty sequence can't be reduced.\")\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original sequence.\n * \n * Returns `null` if the sequence is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S, T : S> Sequence<T>.reduceIndexedOrNull(operation: (index: Int, acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var index = 1\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <S, T : S> Sequence<T>.reduceOrNull(operation: (acc: S, T) -> S): S? {\n    val iterator = this.iterator()\n    if (!iterator.hasNext()) return null\n    var accumulator: S = iterator.next()\n    while (iterator.hasNext()) {\n        accumulator = operation(accumulator, iterator.next())\n    }\n    return accumulator\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic fun <T, R> Sequence<T>.runningFold(initial: R, operation: (acc: R, T) -> R): Sequence<R> {\n    return sequence {\n        yield(initial)\n        var accumulator = initial\n        for (element in this@runningFold) {\n            accumulator = operation(accumulator, element)\n            yield(accumulator)\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic fun <T, R> Sequence<T>.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): Sequence<R> {\n    return sequence {\n        yield(initial)\n        var index = 0\n        var accumulator = initial\n        for (element in this@runningFoldIndexed) {\n            accumulator = operation(checkIndexOverflow(index++), accumulator, element)\n            yield(accumulator)\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * \n * @param [operation] function that takes current accumulator value and the element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <S, T : S> Sequence<T>.runningReduce(operation: (acc: S, T) -> S): Sequence<S> {\n    return sequence {\n        val iterator = iterator()\n        if (iterator.hasNext()) {\n            var accumulator: S = iterator.next()\n            yield(accumulator)\n            while (iterator.hasNext()) {\n                accumulator = operation(accumulator, iterator.next())\n                yield(accumulator)\n            }\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with the first element of this sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic fun <S, T : S> Sequence<T>.runningReduceIndexed(operation: (index: Int, acc: S, T) -> S): Sequence<S> {\n    return sequence {\n        val iterator = iterator()\n        if (iterator.hasNext()) {\n            var accumulator: S = iterator.next()\n            yield(accumulator)\n            var index = 1\n            while (iterator.hasNext()) {\n                accumulator = operation(checkIndexOverflow(index++), accumulator, iterator.next())\n                yield(accumulator)\n            }\n        }\n    }\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T, R> Sequence<T>.scan(initial: R, operation: (acc: R, T) -> R): Sequence<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a sequence containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting sequence.\n * The [initial] value should also be immutable (or should not be mutated)\n * as it may be passed to [operation] function later because of sequence's lazy nature.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T, R> Sequence<T>.scanIndexed(initial: R, operation: (index: Int, acc: R, T) -> R): Sequence<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Sequence<T>.sumBy(selector: (T) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun <T> Sequence<T>.sumByDouble(selector: (T) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the sequence.\n *\n * The operation is _terminal_.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.sumOf(selector: (T) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns an original collection containing all the non-`null` elements, throwing an [IllegalArgumentException] if there are any `null` elements.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic fun <T : Any> Sequence<T?>.requireNoNulls(): Sequence<T> {\n    return map { it ?: throw IllegalArgumentException(\"null element found in $this.\") }\n}\n\n/**\n * Splits this sequence into a sequence of lists each not exceeding the given [size].\n * \n * The last list in the resulting sequence may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.chunked(size: Int): Sequence<List<T>> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this sequence into several lists each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return sequence of results of the [transform] applied to an each list.\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last list may have fewer elements than the given [size].\n * \n * @param size the number of elements to take in each list, must be positive and can be greater than the number of elements in this sequence.\n *\n * The operation is _intermediate_ and _stateful_.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.chunked(size: Int, transform: (List<T>) -> R): Sequence<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence without the first occurrence of the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.minus(element: T): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            var removed = false\n            return this@minus.filter { if (!removed && it == element) { removed = true; false } else true }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] array.\n * \n * Note that the source sequence and the array being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * Before Kotlin 1.6, the [elements] array may have been converted to a [HashSet] to speed up the operation, thus the elements were required to have\n * a correct and stable implementation of `hashCode()` that didn't change between successive invocations.\n * On JVM, you can enable this behavior back with the system property `kotlin.collections.convert_arg_to_set_in_removeAll` set to `true`.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Array<out T>): Sequence<T> {\n    if (elements.isEmpty()) return this\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.convertToSetForSetOperation()\n            return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] collection.\n * \n * Note that the source sequence and the collection being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * Before Kotlin 1.6, the [elements] collection may have been converted to a [HashSet] to speed up the operation, thus the elements were required to have\n * a correct and stable implementation of `hashCode()` that didn't change between successive invocations.\n * On JVM, you can enable this behavior back with the system property `kotlin.collections.convert_arg_to_set_in_removeAll` set to `true`.\n *\n * The operation is _intermediate_ and _stateful_.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Iterable<T>): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.convertToSetForSetOperation()\n            if (other.isEmpty())\n                return this@minus.iterator()\n            else\n                return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of original sequence except the elements contained in the given [elements] sequence.\n * \n * Note that the source sequence and the sequence being subtracted are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n * \n * The operation is _intermediate_ for this sequence and _terminal_ and _stateful_ for the [elements] sequence.\n * \n * Before Kotlin 1.6, the [elements] sequence may have been converted to a [HashSet] to speed up the operation, thus the elements were required to have\n * a correct and stable implementation of `hashCode()` that didn't change between successive invocations.\n * On JVM, you can enable this behavior back with the system property `kotlin.collections.convert_arg_to_set_in_removeAll` set to `true`.\n */\npublic operator fun <T> Sequence<T>.minus(elements: Sequence<T>): Sequence<T> {\n    return object: Sequence<T> {\n        override fun iterator(): Iterator<T> {\n            val other = elements.convertToSetForSetOperation()\n            if (other.isEmpty())\n                return this@minus.iterator()\n            else\n                return this@minus.filterNot { it in other }.iterator()\n        }\n    }\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence without the first occurrence of the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.minusElement(element: T): Sequence<T> {\n    return minus(element)\n}\n\n/**\n * Splits the original sequence into pair of lists,\n * where *first* list contains elements for which [predicate] yielded `true`,\n * while *second* list contains elements for which [predicate] yielded `false`.\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Sequences.Transformations.partition\n */\npublic inline fun <T> Sequence<T>.partition(predicate: (T) -> Boolean): Pair<List<T>, List<T>> {\n    val first = ArrayList<T>()\n    val second = ArrayList<T>()\n    for (element in this) {\n        if (predicate(element)) {\n            first.add(element)\n        } else {\n            second.add(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence and then the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(element: T): Sequence<T> {\n    return sequenceOf(this, sequenceOf(element)).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] array.\n * \n * Note that the source sequence and the array being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Array<out T>): Sequence<T> {\n    return this.plus(elements.asList())\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] collection.\n * \n * Note that the source sequence and the collection being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Iterable<T>): Sequence<T> {\n    return sequenceOf(this, elements.asSequence()).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of original sequence and then all elements of the given [elements] sequence.\n * \n * Note that the source sequence and the sequence being added are iterated only when an `iterator` is requested from\n * the resulting sequence. Changing any of them between successive calls to `iterator` may affect the result.\n *\n * The operation is _intermediate_ and _stateless_.\n */\npublic operator fun <T> Sequence<T>.plus(elements: Sequence<T>): Sequence<T> {\n    return sequenceOf(this, elements).flatten()\n}\n\n/**\n * Returns a sequence containing all elements of the original sequence and then the given [element].\n *\n * The operation is _intermediate_ and _stateless_.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.plusElement(element: T): Sequence<T> {\n    return plus(element)\n}\n\n/**\n * Returns a sequence of snapshots of the window of the given [size]\n * sliding along this sequence with the given [step], where each\n * snapshot is a list.\n * \n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): Sequence<List<T>> {\n    return windowedSequence(size, step, partialWindows, reuseBuffer = false)\n}\n\n/**\n * Returns a sequence of results of applying the given [transform] function to\n * an each list representing a view over the window of the given [size]\n * sliding along this sequence with the given [step].\n * \n * Note that the list passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last lists may have fewer elements than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (List<T>) -> R): Sequence<R> {\n    return windowedSequence(size, step, partialWindows, reuseBuffer = true).map(transform)\n}\n\n/**\n * Returns a sequence of values built from the elements of `this` sequence and the [other] sequence with the same index.\n * The resulting sequence ends as soon as the shortest input sequence ends.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Sequences.Transformations.zip\n */\npublic infix fun <T, R> Sequence<T>.zip(other: Sequence<R>): Sequence<Pair<T, R>> {\n    return MergingSequence(this, other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a sequence of values built from the elements of `this` sequence and the [other] sequence with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The resulting sequence ends as soon as the shortest input sequence ends.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Sequences.Transformations.zipWithTransform\n */\npublic fun <T, R, V> Sequence<T>.zip(other: Sequence<R>, transform: (a: T, b: R) -> V): Sequence<V> {\n    return MergingSequence(this, other, transform)\n}\n\n/**\n * Returns a sequence of pairs of each two adjacent elements in this sequence.\n * \n * The returned sequence is empty if this sequence contains less than two elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun <T> Sequence<T>.zipWithNext(): Sequence<Pair<T, T>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a sequence containing the results of applying the given [transform] function\n * to an each pair of two adjacent elements in this sequence.\n * \n * The returned sequence is empty if this sequence contains less than two elements.\n *\n * The operation is _intermediate_ and _stateless_.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic fun <T, R> Sequence<T>.zipWithNext(transform: (a: T, b: T) -> R): Sequence<R> {\n    return sequence result@ {\n        val iterator = iterator()\n        if (!iterator.hasNext()) return@result\n        var current = iterator.next()\n        while (iterator.hasNext()) {\n            val next = iterator.next()\n            yield(transform(current, next))\n            current = next\n        }\n    }\n}\n\n/**\n * Appends the string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.joinTo\n */\npublic fun <T, A : Appendable> Sequence<T>.joinTo(buffer: A, separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): A {\n    buffer.append(prefix)\n    var count = 0\n    for (element in this) {\n        if (++count > 1) buffer.append(separator)\n        if (limit < 0 || count <= limit) {\n            buffer.appendElement(element, transform)\n        } else break\n    }\n    if (limit >= 0 && count > limit) buffer.append(truncated)\n    buffer.append(postfix)\n    return buffer\n}\n\n/**\n * Creates a string from all the elements separated using [separator] and using the given [prefix] and [postfix] if supplied.\n * \n * If the collection could be huge, you can specify a non-negative value of [limit], in which case only the first [limit]\n * elements will be appended, followed by the [truncated] string (which defaults to \"...\").\n *\n * The operation is _terminal_.\n * \n * @sample samples.collections.Collections.Transformations.joinToString\n */\npublic fun <T> Sequence<T>.joinToString(separator: CharSequence = \", \", prefix: CharSequence = \"\", postfix: CharSequence = \"\", limit: Int = -1, truncated: CharSequence = \"...\", transform: ((T) -> CharSequence)? = null): String {\n    return joinTo(StringBuilder(), separator, prefix, postfix, limit, truncated, transform).toString()\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original sequence returning its elements when being iterated.\n */\npublic fun <T> Sequence<T>.asIterable(): Iterable<T> {\n    return Iterable { this.iterator() }\n}\n\n/**\n * Returns this sequence as a [Sequence].\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Sequence<T>.asSequence(): Sequence<T> {\n    return this\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfByte\")\npublic fun Sequence<Byte>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfShort\")\npublic fun Sequence<Short>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfInt\")\npublic fun Sequence<Int>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfLong\")\npublic fun Sequence<Long>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfFloat\")\npublic fun Sequence<Float>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns an average value of elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"averageOfDouble\")\npublic fun Sequence<Double>.average(): Double {\n    var sum: Double = 0.0\n    var count: Int = 0\n    for (element in this) {\n        sum += element\n        checkCountOverflow(++count)\n    }\n    return if (count == 0) Double.NaN else sum / count\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfByte\")\npublic fun Sequence<Byte>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfShort\")\npublic fun Sequence<Short>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfInt\")\npublic fun Sequence<Int>.sum(): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfLong\")\npublic fun Sequence<Long>.sum(): Long {\n    var sum: Long = 0L\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfFloat\")\npublic fun Sequence<Float>.sum(): Float {\n    var sum: Float = 0.0f\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the sequence.\n *\n * The operation is _terminal_.\n */\n@kotlin.jvm.JvmName(\"sumOfDouble\")\npublic fun Sequence<Double>.sum(): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"PreconditionsKt\")\n\npackage kotlin\n\nimport kotlin.contracts.contract\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    require(value) { \"Failed requirement.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failRequireWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun require(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalArgumentException] if the [value] is null. Otherwise returns the not null value.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return requireNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalArgumentException] with the result of calling [lazyMessage] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failRequireNotNullWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> requireNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalArgumentException(message.toString())\n    } else {\n        return value\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean): Unit {\n    contract {\n        returns() implies value\n    }\n    check(value) { \"Check failed.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage] if the [value] is false.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun check(value: Boolean, lazyMessage: () -> Any): Unit {\n    contract {\n        returns() implies value\n    }\n    if (!value) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    }\n}\n\n/**\n * Throws an [IllegalStateException] if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?): T {\n    contract {\n        returns() implies (value != null)\n    }\n    return checkNotNull(value) { \"Required value was null.\" }\n}\n\n/**\n * Throws an [IllegalStateException] with the result of calling [lazyMessage]  if the [value] is null. Otherwise\n * returns the not null value.\n *\n * @sample samples.misc.Preconditions.failCheckWithLazyMessage\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Any> checkNotNull(value: T?, lazyMessage: () -> Any): T {\n    contract {\n        returns() implies (value != null)\n    }\n\n    if (value == null) {\n        val message = lazyMessage()\n        throw IllegalStateException(message.toString())\n    } else {\n        return value\n    }\n}\n\n\n/**\n * Throws an [IllegalStateException] with the given [message].\n *\n * @sample samples.misc.Preconditions.failWithError\n */\n@kotlin.internal.InlineOnly\npublic inline fun error(message: Any): Nothing = throw IllegalStateException(message.toString())\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.collections\n\n/** An iterator over a sequence of values of type `Byte`. */\npublic abstract class ByteIterator : Iterator<Byte> {\n    override final fun next() = nextByte()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextByte(): Byte\n}\n\n/** An iterator over a sequence of values of type `Char`. */\npublic abstract class CharIterator : Iterator<Char> {\n    override final fun next() = nextChar()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextChar(): Char\n}\n\n/** An iterator over a sequence of values of type `Short`. */\npublic abstract class ShortIterator : Iterator<Short> {\n    override final fun next() = nextShort()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextShort(): Short\n}\n\n/** An iterator over a sequence of values of type `Int`. */\npublic abstract class IntIterator : Iterator<Int> {\n    override final fun next() = nextInt()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextInt(): Int\n}\n\n/** An iterator over a sequence of values of type `Long`. */\npublic abstract class LongIterator : Iterator<Long> {\n    override final fun next() = nextLong()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextLong(): Long\n}\n\n/** An iterator over a sequence of values of type `Float`. */\npublic abstract class FloatIterator : Iterator<Float> {\n    override final fun next() = nextFloat()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextFloat(): Float\n}\n\n/** An iterator over a sequence of values of type `Double`. */\npublic abstract class DoubleIterator : Iterator<Double> {\n    override final fun next() = nextDouble()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextDouble(): Double\n}\n\n/** An iterator over a sequence of values of type `Boolean`. */\npublic abstract class BooleanIterator : Iterator<Boolean> {\n    override final fun next() = nextBoolean()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextBoolean(): Boolean\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\n/**\n * An iterator over a progression of values of type `Char`.\n * @property step the number by which the value is incremented on each step.\n */\ninternal class CharProgressionIterator(first: Char, last: Char, val step: Int) : CharIterator() {\n    private val finalElement: Int = last.code\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private var next: Int = if (hasNext) first.code else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextChar(): Char {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        }\n        else {\n            next += step\n        }\n        return value.toChar()\n    }\n}\n\n/**\n * An iterator over a progression of values of type `Int`.\n * @property step the number by which the value is incremented on each step.\n */\ninternal class IntProgressionIterator(first: Int, last: Int, val step: Int) : IntIterator() {\n    private val finalElement: Int = last\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private var next: Int = if (hasNext) first else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextInt(): Int {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        }\n        else {\n            next += step\n        }\n        return value\n    }\n}\n\n/**\n * An iterator over a progression of values of type `Long`.\n * @property step the number by which the value is incremented on each step.\n */\ninternal class LongProgressionIterator(first: Long, last: Long, val step: Long) : LongIterator() {\n    private val finalElement: Long = last\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private var next: Long = if (hasNext) first else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextLong(): Long {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        }\n        else {\n            next += step\n        }\n        return value\n    }\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n\n/**\n * Creates a Char with the specified [code], or throws an exception if the [code] is out of `Char.MIN_VALUE.code..Char.MAX_VALUE.code`.\n *\n * If the program that calls this function is written in a way that only valid [code] is passed as the argument,\n * using the overload that takes a [UShort] argument is preferable (`Char(intValue.toUShort())`).\n * That overload doesn't check validity of the argument, and may improve program performance when the function is called routinely inside a loop.\n *\n * @sample samples.text.Chars.charFromCode\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun Char(code: Int): Char {\n    if (code < Char.MIN_VALUE.code || code > Char.MAX_VALUE.code) {\n        throw IllegalArgumentException(\"Invalid Char code: $code\")\n    }\n    return code.toChar()\n}\n\n/**\n * Creates a Char with the specified [code].\n *\n * @sample samples.text.Chars.charFromCode\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"NO_ACTUAL_FOR_EXPECT\")\npublic expect fun Char(code: UShort): Char\n\n/**\n * Returns the code of this Char.\n *\n * Code of a Char is the value it was constructed with, and the UTF-16 code unit corresponding to this Char.\n *\n * @sample samples.text.Chars.code\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\n@Suppress(\"DEPRECATION\")\npublic inline val Char.code: Int get() = this.toInt()\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\nimport kotlin.internal.getProgressionLastElement\n\n/**\n * A progression of values of type `Char`.\n */\npublic open class CharProgression\n    internal constructor\n    (\n            start: Char,\n            endInclusive: Char,\n            step: Int\n    ) : Iterable<Char> {\n    init {\n        if (step == 0) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Int.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Int.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: Char = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: Char = getProgressionLastElement(start.code, endInclusive.code, step).toChar()\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Int = step\n\n    override fun iterator(): CharIterator = CharProgressionIterator(first, last, step)\n\n    /**\n     * Checks if the progression is empty.\n     *\n     * Progression with a positive step is empty if its first element is greater than the last element.\n     * Progression with a negative step is empty if its first element is less than the last element.\n     */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is CharProgression && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * first.code + last.code) + step)\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates CharProgression within the specified bounds of a closed range.\n         *\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Int.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: Char, rangeEnd: Char, step: Int): CharProgression = CharProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n/**\n * A progression of values of type `Int`.\n */\npublic open class IntProgression\n    internal constructor\n    (\n            start: Int,\n            endInclusive: Int,\n            step: Int\n    ) : Iterable<Int> {\n    init {\n        if (step == 0) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Int.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Int.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: Int = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: Int = getProgressionLastElement(start, endInclusive, step)\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Int = step\n\n    override fun iterator(): IntIterator = IntProgressionIterator(first, last, step)\n\n    /**\n     * Checks if the progression is empty.\n     *\n     * Progression with a positive step is empty if its first element is greater than the last element.\n     * Progression with a negative step is empty if its first element is less than the last element.\n     */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is IntProgression && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * first + last) + step)\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates IntProgression within the specified bounds of a closed range.\n         *\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Int.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: Int, rangeEnd: Int, step: Int): IntProgression = IntProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n/**\n * A progression of values of type `Long`.\n */\npublic open class LongProgression\n    internal constructor\n    (\n            start: Long,\n            endInclusive: Long,\n            step: Long\n    ) : Iterable<Long> {\n    init {\n        if (step == 0L) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Long.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Long.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: Long = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: Long = getProgressionLastElement(start, endInclusive, step)\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Long = step\n\n    override fun iterator(): LongIterator = LongProgressionIterator(first, last, step)\n\n    /**\n     * Checks if the progression is empty.\n     *\n     * Progression with a positive step is empty if its first element is greater than the last element.\n     * Progression with a negative step is empty if its first element is less than the last element.\n     */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is LongProgression && (isEmpty() && other.isEmpty() ||\n        first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * (first xor (first ushr 32)) + (last xor (last ushr 32))) + (step xor (step ushr 32))).toInt()\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates LongProgression within the specified bounds of a closed range.\n         *\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Long.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: Long, rangeEnd: Long, step: Long): LongProgression = LongProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\nimport kotlin.internal.PlatformDependent\n\n/**\n * Classes that inherit from this interface can be represented as a sequence of elements that can\n * be iterated over.\n * @param T the type of element being iterated over. The iterator is covariant in its element type.\n */\npublic interface Iterable<out T> {\n    /**\n     * Returns an iterator over the elements of this object.\n     */\n    public operator fun iterator(): Iterator<T>\n}\n\n/**\n * Classes that inherit from this interface can be represented as a sequence of elements that can\n * be iterated over and that supports removing elements during iteration.\n * @param T the type of element being iterated over. The mutable iterator is invariant in its element type.\n */\npublic interface MutableIterable<out T> : Iterable<T> {\n    /**\n     * Returns an iterator over the elements of this sequence that supports removing elements during iteration.\n     */\n    override fun iterator(): MutableIterator<T>\n}\n\n/**\n * A generic collection of elements. Methods in this interface support only read-only access to the collection;\n * read/write access is supported through the [MutableCollection] interface.\n * @param E the type of elements contained in the collection. The collection is covariant in its element type.\n */\npublic interface Collection<out E> : Iterable<E> {\n    // Query Operations\n    /**\n     * Returns the size of the collection.\n     */\n    public val size: Int\n\n    /**\n     * Returns `true` if the collection is empty (contains no elements), `false` otherwise.\n     */\n    public fun isEmpty(): Boolean\n\n    /**\n     * Checks if the specified element is contained in this collection.\n     */\n    public operator fun contains(element: @UnsafeVariance E): Boolean\n\n    override fun iterator(): Iterator<E>\n\n    // Bulk Operations\n    /**\n     * Checks if all elements in the specified collection are contained in this collection.\n     */\n    public fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean\n}\n\n/**\n * A generic collection of elements that supports adding and removing elements.\n *\n * @param E the type of elements contained in the collection. The mutable collection is invariant in its element type.\n */\npublic interface MutableCollection<E> : Collection<E>, MutableIterable<E> {\n    // Query Operations\n    override fun iterator(): MutableIterator<E>\n\n    // Modification Operations\n    /**\n     * Adds the specified element to the collection.\n     *\n     * @return `true` if the element has been added, `false` if the collection does not support duplicates\n     * and the element is already contained in the collection.\n     */\n    public fun add(element: E): Boolean\n\n    /**\n     * Removes a single instance of the specified element from this\n     * collection, if it is present.\n     *\n     * @return `true` if the element has been successfully removed; `false` if it was not present in the collection.\n     */\n    public fun remove(element: E): Boolean\n\n    // Bulk Modification Operations\n    /**\n     * Adds all of the elements of the specified collection to this collection.\n     *\n     * @return `true` if any of the specified elements was added to the collection, `false` if the collection was not modified.\n     */\n    public fun addAll(elements: Collection<E>): Boolean\n\n    /**\n     * Removes all of this collection's elements that are also contained in the specified collection.\n     *\n     * @return `true` if any of the specified elements was removed from the collection, `false` if the collection was not modified.\n     */\n    public fun removeAll(elements: Collection<E>): Boolean\n\n    /**\n     * Retains only the elements in this collection that are contained in the specified collection.\n     *\n     * @return `true` if any element was removed from the collection, `false` if the collection was not modified.\n     */\n    public fun retainAll(elements: Collection<E>): Boolean\n\n    /**\n     * Removes all elements from this collection.\n     */\n    public fun clear(): Unit\n}\n\n/**\n * A generic ordered collection of elements. Methods in this interface support only read-only access to the list;\n * read/write access is supported through the [MutableList] interface.\n * @param E the type of elements contained in the list. The list is covariant in its element type.\n */\npublic interface List<out E> : Collection<E> {\n    // Query Operations\n\n    override val size: Int\n    override fun isEmpty(): Boolean\n    override fun contains(element: @UnsafeVariance E): Boolean\n    override fun iterator(): Iterator<E>\n\n    // Bulk Operations\n    override fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean\n\n    // Positional Access Operations\n    /**\n     * Returns the element at the specified index in the list.\n     */\n    public operator fun get(index: Int): E\n\n    // Search Operations\n    /**\n     * Returns the index of the first occurrence of the specified element in the list, or -1 if the specified\n     * element is not contained in the list.\n     */\n    public fun indexOf(element: @UnsafeVariance E): Int\n\n    /**\n     * Returns the index of the last occurrence of the specified element in the list, or -1 if the specified\n     * element is not contained in the list.\n     */\n    public fun lastIndexOf(element: @UnsafeVariance E): Int\n\n    // List Iterators\n    /**\n     * Returns a list iterator over the elements in this list (in proper sequence).\n     */\n    public fun listIterator(): ListIterator<E>\n\n    /**\n     * Returns a list iterator over the elements in this list (in proper sequence), starting at the specified [index].\n     */\n    public fun listIterator(index: Int): ListIterator<E>\n\n    // View\n    /**\n     * Returns a view of the portion of this list between the specified [fromIndex] (inclusive) and [toIndex] (exclusive).\n     * The returned list is backed by this list, so non-structural changes in the returned list are reflected in this list, and vice-versa.\n     *\n     * Structural changes in the base list make the behavior of the view undefined.\n     */\n    public fun subList(fromIndex: Int, toIndex: Int): List<E>\n}\n\n/**\n * A generic ordered collection of elements that supports adding and removing elements.\n * @param E the type of elements contained in the list. The mutable list is invariant in its element type.\n */\npublic interface MutableList<E> : List<E>, MutableCollection<E> {\n    // Modification Operations\n    /**\n     * Adds the specified element to the end of this list.\n     *\n     * @return `true` because the list is always modified as the result of this operation.\n     */\n    override fun add(element: E): Boolean\n\n    override fun remove(element: E): Boolean\n\n    // Bulk Modification Operations\n    /**\n     * Adds all of the elements of the specified collection to the end of this list.\n     *\n     * The elements are appended in the order they appear in the [elements] collection.\n     *\n     * @return `true` if the list was changed as the result of the operation.\n     */\n    override fun addAll(elements: Collection<E>): Boolean\n\n    /**\n     * Inserts all of the elements of the specified collection [elements] into this list at the specified [index].\n     *\n     * @return `true` if the list was changed as the result of the operation.\n     */\n    public fun addAll(index: Int, elements: Collection<E>): Boolean\n\n    override fun removeAll(elements: Collection<E>): Boolean\n    override fun retainAll(elements: Collection<E>): Boolean\n    override fun clear(): Unit\n\n    // Positional Access Operations\n    /**\n     * Replaces the element at the specified position in this list with the specified element.\n     *\n     * @return the element previously at the specified position.\n     */\n    public operator fun set(index: Int, element: E): E\n\n    /**\n     * Inserts an element into the list at the specified [index].\n     */\n    public fun add(index: Int, element: E): Unit\n\n    /**\n     * Removes an element at the specified [index] from the list.\n     *\n     * @return the element that has been removed.\n     */\n    public fun removeAt(index: Int): E\n\n    // List Iterators\n    override fun listIterator(): MutableListIterator<E>\n\n    override fun listIterator(index: Int): MutableListIterator<E>\n\n    // View\n    override fun subList(fromIndex: Int, toIndex: Int): MutableList<E>\n}\n\n/**\n * A generic unordered collection of elements that does not support duplicate elements.\n * Methods in this interface support only read-only access to the set;\n * read/write access is supported through the [MutableSet] interface.\n * @param E the type of elements contained in the set. The set is covariant in its element type.\n */\npublic interface Set<out E> : Collection<E> {\n    // Query Operations\n\n    override val size: Int\n    override fun isEmpty(): Boolean\n    override fun contains(element: @UnsafeVariance E): Boolean\n    override fun iterator(): Iterator<E>\n\n    // Bulk Operations\n    override fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean\n}\n\n/**\n * A generic unordered collection of elements that does not support duplicate elements, and supports\n * adding and removing elements.\n * @param E the type of elements contained in the set. The mutable set is invariant in its element type.\n */\npublic interface MutableSet<E> : Set<E>, MutableCollection<E> {\n    // Query Operations\n    override fun iterator(): MutableIterator<E>\n\n    // Modification Operations\n\n    /**\n     * Adds the specified element to the set.\n     *\n     * @return `true` if the element has been added, `false` if the element is already contained in the set.\n     */\n    override fun add(element: E): Boolean\n\n    override fun remove(element: E): Boolean\n\n    // Bulk Modification Operations\n\n    override fun addAll(elements: Collection<E>): Boolean\n    override fun removeAll(elements: Collection<E>): Boolean\n    override fun retainAll(elements: Collection<E>): Boolean\n    override fun clear(): Unit\n}\n\n/**\n * A collection that holds pairs of objects (keys and values) and supports efficiently retrieving\n * the value corresponding to each key. Map keys are unique; the map holds only one value for each key.\n * Methods in this interface support only read-only access to the map; read-write access is supported through\n * the [MutableMap] interface.\n * @param K the type of map keys. The map is invariant in its key type, as it\n *          can accept key as a parameter (of [containsKey] for example) and return it in [keys] set.\n * @param V the type of map values. The map is covariant in its value type.\n */\npublic interface Map<K, out V> {\n    // Query Operations\n    /**\n     * Returns the number of key/value pairs in the map.\n     */\n    public val size: Int\n\n    /**\n     * Returns `true` if the map is empty (contains no elements), `false` otherwise.\n     */\n    public fun isEmpty(): Boolean\n\n    /**\n     * Returns `true` if the map contains the specified [key].\n     */\n    public fun containsKey(key: K): Boolean\n\n    /**\n     * Returns `true` if the map maps one or more keys to the specified [value].\n     */\n    public fun containsValue(value: @UnsafeVariance V): Boolean\n\n    /**\n     * Returns the value corresponding to the given [key], or `null` if such a key is not present in the map.\n     */\n    public operator fun get(key: K): V?\n\n    /**\n     * Returns the value corresponding to the given [key], or [defaultValue] if such a key is not present in the map.\n     *\n     * @since JDK 1.8\n     */\n    @SinceKotlin(\"1.1\")\n    @PlatformDependent\n    public fun getOrDefault(key: K, defaultValue: @UnsafeVariance V): V {\n        // See default implementation in JDK sources\n        throw NotImplementedError()\n    }\n\n    // Views\n    /**\n     * Returns a read-only [Set] of all keys in this map.\n     */\n    public val keys: Set<K>\n\n    /**\n     * Returns a read-only [Collection] of all values in this map. Note that this collection may contain duplicate values.\n     */\n    public val values: Collection<V>\n\n    /**\n     * Returns a read-only [Set] of all key/value pairs in this map.\n     */\n    public val entries: Set<Map.Entry<K, V>>\n\n    /**\n     * Represents a key/value pair held by a [Map].\n     */\n    public interface Entry<out K, out V> {\n        /**\n         * Returns the key of this key/value pair.\n         */\n        public val key: K\n\n        /**\n         * Returns the value of this key/value pair.\n         */\n        public val value: V\n    }\n}\n\n/**\n * A modifiable collection that holds pairs of objects (keys and values) and supports efficiently retrieving\n * the value corresponding to each key. Map keys are unique; the map holds only one value for each key.\n * @param K the type of map keys. The map is invariant in its key type.\n * @param V the type of map values. The mutable map is invariant in its value type.\n */\npublic interface MutableMap<K, V> : Map<K, V> {\n    // Modification Operations\n    /**\n     * Associates the specified [value] with the specified [key] in the map.\n     *\n     * @return the previous value associated with the key, or `null` if the key was not present in the map.\n     */\n    public fun put(key: K, value: V): V?\n\n    /**\n     * Removes the specified key and its corresponding value from this map.\n     *\n     * @return the previous value associated with the key, or `null` if the key was not present in the map.\n     */\n    public fun remove(key: K): V?\n\n    /**\n     * Removes the entry for the specified key only if it is mapped to the specified value.\n     *\n     * @return true if entry was removed\n     */\n    @SinceKotlin(\"1.1\")\n    @PlatformDependent\n    public fun remove(key: K, value: V): Boolean {\n        // See default implementation in JDK sources\n        return true\n    }\n\n    // Bulk Modification Operations\n    /**\n     * Updates this map with key/value pairs from the specified map [from].\n     */\n    public fun putAll(from: Map<out K, V>): Unit\n\n    /**\n     * Removes all elements from this map.\n     */\n    public fun clear(): Unit\n\n    // Views\n    /**\n     * Returns a [MutableSet] of all keys in this map.\n     */\n    override val keys: MutableSet<K>\n\n    /**\n     * Returns a [MutableCollection] of all values in this map. Note that this collection may contain duplicate values.\n     */\n    override val values: MutableCollection<V>\n\n    /**\n     * Returns a [MutableSet] of all key/value pairs in this map.\n     */\n    override val entries: MutableSet<MutableMap.MutableEntry<K, V>>\n\n    /**\n     * Represents a key/value pair held by a [MutableMap].\n     */\n    public interface MutableEntry<K, V> : Map.Entry<K, V> {\n        /**\n         * Changes the value associated with the key of this entry.\n         *\n         * @return the previous value corresponding to the key.\n         */\n        public fun setValue(newValue: V): V\n    }\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.ranges\n\n/**\n * Represents a range of values (for example, numbers or characters).\n * See the [Kotlin language documentation](https://kotlinlang.org/docs/reference/ranges.html) for more information.\n */\npublic interface ClosedRange<T: Comparable<T>> {\n    /**\n     * The minimum value in the range.\n     */\n    public val start: T\n\n    /**\n     * The maximum value in the range (inclusive).\n     */\n    public val endInclusive: T\n\n    /**\n     * Checks whether the specified [value] belongs to the range.\n     */\n    public operator fun contains(value: T): Boolean = value >= start && value <= endInclusive\n\n    /**\n     * Checks whether the range is empty.\n     *\n     * The range is empty if its start value is greater than the end value.\n     */\n    public fun isEmpty(): Boolean = start > endInclusive\n}\n","/*\n * Copyright 2010-2015 JetBrains s.r.o.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage kotlin\n\n/**\n * The type with only one value: the `Unit` object. This type corresponds to the `void` type in Java.\n */\npublic object Unit {\n    override fun toString() = \"kotlin.Unit\"\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.internal\n\n// a mod b (in arithmetical sense)\nprivate fun mod(a: Int, b: Int): Int {\n    val mod = a % b\n    return if (mod >= 0) mod else mod + b\n}\n\nprivate fun mod(a: Long, b: Long): Long {\n    val mod = a % b\n    return if (mod >= 0) mod else mod + b\n}\n\n// (a - b) mod c\nprivate fun differenceModulo(a: Int, b: Int, c: Int): Int {\n    return mod(mod(a, c) - mod(b, c), c)\n}\n\nprivate fun differenceModulo(a: Long, b: Long, c: Long): Long {\n    return mod(mod(a, c) - mod(b, c), c)\n}\n\n/**\n * Calculates the final element of a bounded arithmetic progression, i.e. the last element of the progression which is in the range\n * from [start] to [end] in case of a positive [step], or from [end] to [start] in case of a negative\n * [step].\n *\n * No validation on passed parameters is performed. The given parameters should satisfy the condition:\n *\n * - either `step > 0` and `start <= end`,\n * - or `step < 0` and `start >= end`.\n *\n * @param start first element of the progression\n * @param end ending bound for the progression\n * @param step increment, or difference of successive elements in the progression\n * @return the final element of the progression\n * @suppress\n */\n@PublishedApi\ninternal fun getProgressionLastElement(start: Int, end: Int, step: Int): Int = when {\n    step > 0 -> if (start >= end) end else end - differenceModulo(end, start, step)\n    step < 0 -> if (start <= end) end else end + differenceModulo(start, end, -step)\n    else -> throw kotlin.IllegalArgumentException(\"Step is zero.\")\n}\n\n/**\n * Calculates the final element of a bounded arithmetic progression, i.e. the last element of the progression which is in the range\n * from [start] to [end] in case of a positive [step], or from [end] to [start] in case of a negative\n * [step].\n *\n * No validation on passed parameters is performed. The given parameters should satisfy the condition:\n *\n * - either `step > 0` and `start <= end`,\n * - or `step < 0` and `start >= end`.\n *\n * @param start first element of the progression\n * @param end ending bound for the progression\n * @param step increment, or difference of successive elements in the progression\n * @return the final element of the progression\n * @suppress\n */\n@PublishedApi\ninternal fun getProgressionLastElement(start: Long, end: Long, step: Long): Long = when {\n    step > 0 -> if (start >= end) end else end - differenceModulo(end, start, step)\n    step < 0 -> if (start <= end) end else end + differenceModulo(start, end, -step)\n    else -> throw kotlin.IllegalArgumentException(\"Step is zero.\")\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@JsName(\"arrayIterator\")\ninternal fun arrayIterator(array: dynamic, type: String?) = when (type) {\n    null -> {\n        val arr: Array<dynamic> = array\n        object : Iterator<dynamic> {\n            var index = 0\n            override fun hasNext() = index < arr.size\n            override fun next() = if (index < arr.size) arr[index++] else throw NoSuchElementException(\"$index\")\n        }\n    }\n    \"BooleanArray\" -> booleanArrayIterator(array)\n    \"ByteArray\" -> byteArrayIterator(array)\n    \"ShortArray\" -> shortArrayIterator(array)\n    \"CharArray\" -> charArrayIterator(array)\n    \"IntArray\" -> intArrayIterator(array)\n    \"LongArray\" -> longArrayIterator(array)\n    \"FloatArray\" -> floatArrayIterator(array)\n    \"DoubleArray\" -> doubleArrayIterator(array)\n    else -> throw IllegalStateException(\"Unsupported type argument for arrayIterator: $type\")\n}\n\n@JsName(\"booleanArrayIterator\")\ninternal fun booleanArrayIterator(array: BooleanArray) = object : BooleanIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextBoolean() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"byteArrayIterator\")\ninternal fun byteArrayIterator(array: ByteArray) = object : ByteIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextByte() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"shortArrayIterator\")\ninternal fun shortArrayIterator(array: ShortArray) = object : ShortIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextShort() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"charArrayIterator\")\ninternal fun charArrayIterator(array: CharArray) = object : CharIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextChar() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"intArrayIterator\")\ninternal fun intArrayIterator(array: IntArray) = object : IntIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextInt() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"floatArrayIterator\")\ninternal fun floatArrayIterator(array: FloatArray) = object : FloatIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextFloat() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"doubleArrayIterator\")\ninternal fun doubleArrayIterator(array: DoubleArray) = object : DoubleIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextDouble() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"longArrayIterator\")\ninternal fun longArrayIterator(array: LongArray) = object : LongIterator() {\n    var index = 0\n    override fun hasNext() = index < array.size\n    override fun nextLong() = if (index < array.size) array[index++] else throw NoSuchElementException(\"$index\")\n}\n\n@JsName(\"PropertyMetadata\")\ninternal class PropertyMetadata(@JsName(\"callableName\") val name: String)\n\n@JsName(\"noWhenBranchMatched\")\ninternal fun noWhenBranchMatched(): Nothing = throw NoWhenBranchMatchedException()\n\n@JsName(\"subSequence\")\ninternal fun subSequence(c: CharSequence, startIndex: Int, endIndex: Int): CharSequence {\n    if (c is String) {\n        return c.substring(startIndex, endIndex)\n    } else {\n        return c.asDynamic().`subSequence_vux9f0$`(startIndex, endIndex)\n    }\n}\n\n@JsName(\"captureStack\")\ninternal fun captureStack(@Suppress(\"UNUSED_PARAMETER\") baseClass: JsClass<in Throwable>, instance: Throwable) {\n    if (js(\"Error\").captureStackTrace) {\n        // Using uncropped stack traces due to KT-37563.\n        // Precise stack traces are implemented in JS IR compiler and stdlib\n        js(\"Error\").captureStackTrace(instance);\n    } else {\n        instance.asDynamic().stack = js(\"new Error()\").stack;\n    }\n}\n\n@JsName(\"newThrowable\")\ninternal fun newThrowable(message: String?, cause: Throwable?): Throwable {\n    val throwable = js(\"new Error()\")\n    throwable.message = if (jsTypeOf(message) == \"undefined\") {\n        if (cause != null) cause.toString() else null\n    } else {\n        message\n    }\n    throwable.cause = cause\n    throwable.name = \"Throwable\"\n    return throwable\n}\n\n@JsName(\"BoxedChar\")\ninternal class BoxedChar(val c: Int) : Comparable<Int> {\n    override fun equals(other: Any?): Boolean {\n        return other is BoxedChar && c == other.c\n    }\n\n    override fun hashCode(): Int {\n        return c\n    }\n\n    override fun toString(): String {\n        return js(\"this.c\").unsafeCast<Char>().toString()\n    }\n\n    override fun compareTo(other: Int): Int {\n        return js(\"this.c - other\").unsafeCast<Int>()\n    }\n\n    @JsName(\"valueOf\")\n    public fun valueOf(): Int {\n        return c\n    }\n}\n\n@kotlin.internal.InlineOnly\ninternal inline fun <T> concat(args: Array<T>): T {\n    val typed = js(\"Array\")(args.size)\n    for (i in args.indices) {\n        val arr = args[i]\n        if (arr !is Array<*>) {\n            typed[i] = js(\"[]\").slice.call(arr)\n        } else {\n            typed[i] = arr\n        }\n    }\n    return js(\"[]\").concat.apply(js(\"[]\"), typed);\n}\n\n/** Concat regular Array's and TypedArray's into an Array.\n */\n@PublishedApi\n@JsName(\"arrayConcat\")\n@Suppress(\"UNUSED_PARAMETER\")\ninternal fun <T> arrayConcat(a: T, b: T): T {\n    return concat(js(\"arguments\"))\n}\n\n/** Concat primitive arrays. Main use: prepare vararg arguments.\n *  For compatibility with 1.1.0 the arguments may be a mixture of Array's and TypedArray's.\n *\n *  If the first argument is TypedArray (Byte-, Short-, Char-, Int-, Float-, and DoubleArray) returns a TypedArray, otherwise an Array.\n *  If the first argument has the $type$ property (Boolean-, Char-, and LongArray) copy its value to result.$type$.\n *  If the first argument is a regular Array without the $type$ property default to arrayConcat.\n */\n@PublishedApi\n@JsName(\"primitiveArrayConcat\")\n@Suppress(\"UNUSED_PARAMETER\")\ninternal fun <T> primitiveArrayConcat(a: T, b: T): T {\n    val args: Array<T> = js(\"arguments\")\n    if (a is Array<*> && a.asDynamic().`$type$` === undefined) {\n        return concat(args)\n    } else {\n        var size = 0\n        for (i in args.indices) {\n            size += args[i].asDynamic().length as Int\n        }\n        val result = js(\"new a.constructor(size)\")\n        kotlin.copyArrayType(a, result)\n        size = 0\n        for (i in args.indices) {\n            val arr = args[i].asDynamic()\n            for (j in 0 until arr.length) {\n                result[size++] = arr[j]\n            }\n        }\n        return result\n    }\n}\n\n@JsName(\"booleanArrayOf\")\ninternal fun booleanArrayOf() = withType(\"BooleanArray\", js(\"[].slice.call(arguments)\"))\n\n@JsName(\"charArrayOf\") // The arguments have to be slice'd here because of Rhino (see KT-16974)\ninternal fun charArrayOf() = withType(\"CharArray\", js(\"new Uint16Array([].slice.call(arguments))\"))\n\n@JsName(\"longArrayOf\")\ninternal fun longArrayOf() = withType(\"LongArray\", js(\"[].slice.call(arguments)\"))\n\n@JsName(\"withType\")\n@kotlin.internal.InlineOnly\ninternal inline fun withType(type: String, array: dynamic): dynamic {\n    array.`$type$` = type\n    return array\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED\n\n@SinceKotlin(\"1.3\")\n@JsName(\"CoroutineImpl\")\ninternal abstract class CoroutineImpl(private val resultContinuation: Continuation<Any?>) : Continuation<Any?> {\n    protected var state = 0\n    protected var exceptionState = 0\n    protected var result: Any? = null\n    protected var exception: Throwable? = null\n    protected var finallyPath: Array<Int>? = null\n\n    public override val context: CoroutineContext = resultContinuation.context\n\n    private var intercepted_: Continuation<Any?>? = null\n\n    public fun intercepted(): Continuation<Any?> =\n        intercepted_\n            ?: (context[ContinuationInterceptor]?.interceptContinuation(this) ?: this)\n                .also { intercepted_ = it }\n\n    override fun resumeWith(result: Result<Any?>) {\n        var current = this\n        var currentResult: Any? = result.getOrNull()\n        var currentException: Throwable? = result.exceptionOrNull()\n\n        // This loop unrolls recursion in current.resumeWith(param) to make saner and shorter stack traces on resume\n        while (true) {\n            with(current) {\n                val completion = resultContinuation\n\n                // Set result and exception fields in the current continuation\n                if (currentException == null) {\n                    this.result = currentResult\n                } else {\n                    state = exceptionState\n                    exception = currentException\n                }\n\n                try {\n                    val outcome = doResume()\n                    if (outcome === COROUTINE_SUSPENDED) return\n                    currentResult = outcome\n                    currentException = null\n                } catch (exception: dynamic) { // Catch all exceptions\n                    currentResult = null\n                    currentException = exception.unsafeCast<Throwable>()\n                }\n\n                releaseIntercepted() // this state machine instance is terminating\n\n                if (completion is CoroutineImpl) {\n                    // unrolling recursion via loop\n                    current = completion\n                } else {\n                    // top-level completion reached -- invoke and return\n                    currentException?.let {\n                        completion.resumeWithException(it)\n                    } ?: completion.resume(currentResult)\n                    return\n                }\n            }\n        }\n    }\n\n    private fun releaseIntercepted() {\n        val intercepted = intercepted_\n        if (intercepted != null && intercepted !== this) {\n            context[ContinuationInterceptor]!!.releaseInterceptedContinuation(intercepted)\n        }\n        this.intercepted_ = CompletedContinuation // just in case\n    }\n\n    protected abstract fun doResume(): Any?\n}\n\ninternal object CompletedContinuation : Continuation<Any?> {\n    override val context: CoroutineContext\n        get() = error(\"This continuation is already complete\")\n\n    override fun resumeWith(result: Result<Any?>) {\n        error(\"This continuation is already complete\")\n    }\n\n    override fun toString(): String = \"This continuation is already complete\"\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StandardKt\")\npackage kotlin\n\nimport kotlin.contracts.*\n\n/**\n * An exception is thrown to indicate that a method body remains to be implemented.\n */\npublic class NotImplementedError(message: String = \"An operation is not implemented.\") : Error(message)\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n */\n\n@kotlin.internal.InlineOnly\npublic inline fun TODO(): Nothing = throw NotImplementedError()\n\n/**\n * Always throws [NotImplementedError] stating that operation is not implemented.\n *\n * @param reason a string explaining why the implementation is missing.\n */\n@kotlin.internal.InlineOnly\npublic inline fun TODO(reason: String): Nothing = throw NotImplementedError(\"An operation is not implemented: $reason\")\n\n\n\n/**\n * Calls the specified function [block] and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <R> run(block: () -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#run).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.run(block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block()\n}\n\n/**\n * Calls the specified function [block] with the given [receiver] as its receiver and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#with).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> with(receiver: T, block: T.() -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return receiver.block()\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#apply).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> T.apply(block: T.() -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block()\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns `this` value.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#also).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.also(block: (T) -> Unit): T {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    block(this)\n    return this\n}\n\n/**\n * Calls the specified function [block] with `this` value as its argument and returns its result.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#let).\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, R> T.let(block: (T) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return block(this)\n}\n\n/**\n * Returns `this` value if it satisfies the given [predicate] or `null`, if it doesn't.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeIf(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (predicate(this)) this else null\n}\n\n/**\n * Returns `this` value if it _does not_ satisfy the given [predicate] or `null`, if it does.\n *\n * For detailed usage information see the documentation for [scope functions](https://kotlinlang.org/docs/reference/scope-functions.html#takeif-and-takeunless).\n */\n@kotlin.internal.InlineOnly\n@SinceKotlin(\"1.1\")\npublic inline fun <T> T.takeUnless(predicate: (T) -> Boolean): T? {\n    contract {\n        callsInPlace(predicate, InvocationKind.EXACTLY_ONCE)\n    }\n    return if (!predicate(this)) this else null\n}\n\n/**\n * Executes the given function [action] specified number of [times].\n *\n * A zero-based index of current iteration is passed as a parameter to [action].\n *\n * @sample samples.misc.ControlFlow.repeat\n */\n@kotlin.internal.InlineOnly\npublic inline fun repeat(times: Int, action: (Int) -> Unit) {\n    contract { callsInPlace(action) }\n\n    for (index in 0 until times) {\n        action(index)\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:Suppress(\"UNCHECKED_CAST\", \"RedundantVisibilityModifier\")\n\npackage kotlin\n\nimport kotlin.contracts.*\nimport kotlin.internal.InlineOnly\nimport kotlin.jvm.JvmField\nimport kotlin.jvm.JvmInline\nimport kotlin.jvm.JvmName\n\n/**\n * A discriminated union that encapsulates a successful outcome with a value of type [T]\n * or a failure with an arbitrary [Throwable] exception.\n */\n@SinceKotlin(\"1.3\")\n@JvmInline\npublic value class Result<out T> @PublishedApi internal constructor(\n    @PublishedApi\n    internal val value: Any?\n) : Serializable {\n    // discovery\n\n    /**\n     * Returns `true` if this instance represents a successful outcome.\n     * In this case [isFailure] returns `false`.\n     */\n    public val isSuccess: Boolean get() = value !is Failure\n\n    /**\n     * Returns `true` if this instance represents a failed outcome.\n     * In this case [isSuccess] returns `false`.\n     */\n    public val isFailure: Boolean get() = value is Failure\n\n    // value & exception retrieval\n\n    /**\n     * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or `null`\n     * if it is [failure][Result.isFailure].\n     *\n     * This function is a shorthand for `getOrElse { null }` (see [getOrElse]) or\n     * `fold(onSuccess = { it }, onFailure = { null })` (see [fold]).\n     */\n    @InlineOnly\n    public inline fun getOrNull(): T? =\n        when {\n            isFailure -> null\n            else -> value as T\n        }\n\n    /**\n     * Returns the encapsulated [Throwable] exception if this instance represents [failure][isFailure] or `null`\n     * if it is [success][isSuccess].\n     *\n     * This function is a shorthand for `fold(onSuccess = { null }, onFailure = { it })` (see [fold]).\n     */\n    public fun exceptionOrNull(): Throwable? =\n        when (value) {\n            is Failure -> value.exception\n            else -> null\n        }\n\n    /**\n     * Returns a string `Success(v)` if this instance represents [success][Result.isSuccess]\n     * where `v` is a string representation of the value or a string `Failure(x)` if\n     * it is [failure][isFailure] where `x` is a string representation of the exception.\n     */\n    public override fun toString(): String =\n        when (value) {\n            is Failure -> value.toString() // \"Failure($exception)\"\n            else -> \"Success($value)\"\n        }\n\n    // companion with constructors\n\n    /**\n     * Companion object for [Result] class that contains its constructor functions\n     * [success] and [failure].\n     */\n    public companion object {\n        /**\n         * Returns an instance that encapsulates the given [value] as successful value.\n         */\n        @Suppress(\"INAPPLICABLE_JVM_NAME\")\n        @InlineOnly\n        @JvmName(\"success\")\n        public inline fun <T> success(value: T): Result<T> =\n            Result(value)\n\n        /**\n         * Returns an instance that encapsulates the given [Throwable] [exception] as failure.\n         */\n        @Suppress(\"INAPPLICABLE_JVM_NAME\")\n        @InlineOnly\n        @JvmName(\"failure\")\n        public inline fun <T> failure(exception: Throwable): Result<T> =\n            Result(createFailure(exception))\n    }\n\n    internal class Failure(\n        @JvmField\n        val exception: Throwable\n    ) : Serializable {\n        override fun equals(other: Any?): Boolean = other is Failure && exception == other.exception\n        override fun hashCode(): Int = exception.hashCode()\n        override fun toString(): String = \"Failure($exception)\"\n    }\n}\n\n/**\n * Creates an instance of internal marker [Result.Failure] class to\n * make sure that this class is not exposed in ABI.\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun createFailure(exception: Throwable): Any =\n    Result.Failure(exception)\n\n/**\n * Throws exception if the result is failure. This internal function minimizes\n * inlined bytecode for [getOrThrow] and makes sure that in the future we can\n * add some exception-augmenting logic here (if needed).\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun Result<*>.throwOnFailure() {\n    if (value is Result.Failure) throw value.exception\n}\n\n/**\n * Calls the specified function [block] and returns its encapsulated result if invocation was successful,\n * catching any [Throwable] exception that was thrown from the [block] function execution and encapsulating it as a failure.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R> runCatching(block: () -> R): Result<R> {\n    return try {\n        Result.success(block())\n    } catch (e: Throwable) {\n        Result.failure(e)\n    }\n}\n\n/**\n * Calls the specified function [block] with `this` value as its receiver and returns its encapsulated result if invocation was successful,\n * catching any [Throwable] exception that was thrown from the [block] function execution and encapsulating it as a failure.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T, R> T.runCatching(block: T.() -> R): Result<R> {\n    return try {\n        Result.success(block())\n    } catch (e: Throwable) {\n        Result.failure(e)\n    }\n}\n\n// -- extensions ---\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or throws the encapsulated [Throwable] exception\n * if it is [failure][Result.isFailure].\n *\n * This function is a shorthand for `getOrElse { throw it }` (see [getOrElse]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.getOrThrow(): T {\n    throwOnFailure()\n    return value as T\n}\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or the\n * result of [onFailure] function for the encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [onFailure] function.\n *\n * This function is a shorthand for `fold(onSuccess = { it }, onFailure = onFailure)` (see [fold]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.getOrElse(onFailure: (exception: Throwable) -> R): R {\n    contract {\n        callsInPlace(onFailure, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> value as T\n        else -> onFailure(exception)\n    }\n}\n\n/**\n * Returns the encapsulated value if this instance represents [success][Result.isSuccess] or the\n * [defaultValue] if it is [failure][Result.isFailure].\n *\n * This function is a shorthand for `getOrElse { defaultValue }` (see [getOrElse]).\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.getOrDefault(defaultValue: R): R {\n    if (isFailure) return defaultValue\n    return value as T\n}\n\n/**\n * Returns the result of [onSuccess] for the encapsulated value if this instance represents [success][Result.isSuccess]\n * or the result of [onFailure] function for the encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [onSuccess] or by [onFailure] function.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.fold(\n    onSuccess: (value: T) -> R,\n    onFailure: (exception: Throwable) -> R\n): R {\n    contract {\n        callsInPlace(onSuccess, InvocationKind.AT_MOST_ONCE)\n        callsInPlace(onFailure, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> onSuccess(value as T)\n        else -> onFailure(exception)\n    }\n}\n\n// transformation\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated value\n * if this instance represents [success][Result.isSuccess] or the\n * original encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [transform] function.\n * See [mapCatching] for an alternative that encapsulates exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.map(transform: (value: T) -> R): Result<R> {\n    contract {\n        callsInPlace(transform, InvocationKind.AT_MOST_ONCE)\n    }\n    return when {\n        isSuccess -> Result.success(transform(value as T))\n        else -> Result(value)\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated value\n * if this instance represents [success][Result.isSuccess] or the\n * original encapsulated [Throwable] exception if it is [failure][Result.isFailure].\n *\n * This function catches any [Throwable] exception thrown by [transform] function and encapsulates it as a failure.\n * See [map] for an alternative that rethrows exceptions from `transform` function.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T> Result<T>.mapCatching(transform: (value: T) -> R): Result<R> {\n    return when {\n        isSuccess -> runCatching { transform(value as T) }\n        else -> Result(value)\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated [Throwable] exception\n * if this instance represents [failure][Result.isFailure] or the\n * original encapsulated value if it is [success][Result.isSuccess].\n *\n * Note, that this function rethrows any [Throwable] exception thrown by [transform] function.\n * See [recoverCatching] for an alternative that encapsulates exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.recover(transform: (exception: Throwable) -> R): Result<R> {\n    contract {\n        callsInPlace(transform, InvocationKind.AT_MOST_ONCE)\n    }\n    return when (val exception = exceptionOrNull()) {\n        null -> this\n        else -> Result.success(transform(exception))\n    }\n}\n\n/**\n * Returns the encapsulated result of the given [transform] function applied to the encapsulated [Throwable] exception\n * if this instance represents [failure][Result.isFailure] or the\n * original encapsulated value if it is [success][Result.isSuccess].\n *\n * This function catches any [Throwable] exception thrown by [transform] function and encapsulates it as a failure.\n * See [recover] for an alternative that rethrows exceptions.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <R, T : R> Result<T>.recoverCatching(transform: (exception: Throwable) -> R): Result<R> {\n    return when (val exception = exceptionOrNull()) {\n        null -> this\n        else -> runCatching { transform(exception) }\n    }\n}\n\n// \"peek\" onto value/exception and pipe\n\n/**\n * Performs the given [action] on the encapsulated [Throwable] exception if this instance represents [failure][Result.isFailure].\n * Returns the original `Result` unchanged.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.onFailure(action: (exception: Throwable) -> Unit): Result<T> {\n    contract {\n        callsInPlace(action, InvocationKind.AT_MOST_ONCE)\n    }\n    exceptionOrNull()?.let { action(it) }\n    return this\n}\n\n/**\n * Performs the given [action] on the encapsulated value if this instance represents [success][Result.isSuccess].\n * Returns the original `Result` unchanged.\n */\n@InlineOnly\n@SinceKotlin(\"1.3\")\npublic inline fun <T> Result<T>.onSuccess(action: (value: T) -> Unit): Result<T> {\n    contract {\n        callsInPlace(action, InvocationKind.AT_MOST_ONCE)\n    }\n    if (isSuccess) action(value as T)\n    return this\n}\n\n// -------------------\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.contracts.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Interface representing a continuation after a suspension point that returns a value of type `T`.\n */\n@SinceKotlin(\"1.3\")\npublic interface Continuation<in T> {\n    /**\n     * The context of the coroutine that corresponds to this continuation.\n     */\n    public val context: CoroutineContext\n\n    /**\n     * Resumes the execution of the corresponding coroutine passing a successful or failed [result] as the\n     * return value of the last suspension point.\n     */\n    public fun resumeWith(result: Result<T>)\n}\n\n/**\n * Classes and interfaces marked with this annotation are restricted when used as receivers for extension\n * `suspend` functions. These `suspend` extensions can only invoke other member or extension `suspend` functions on this particular\n * receiver and are restricted from calling arbitrary suspension functions.\n */\n@SinceKotlin(\"1.3\")\n@Target(AnnotationTarget.CLASS)\n@Retention(AnnotationRetention.BINARY)\npublic annotation class RestrictsSuspension\n\n/**\n * Resumes the execution of the corresponding coroutine passing [value] as the return value of the last suspension point.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation<T>.resume(value: T): Unit =\n    resumeWith(Result.success(value))\n\n/**\n * Resumes the execution of the corresponding coroutine so that the [exception] is re-thrown right after the\n * last suspension point.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation<T>.resumeWithException(exception: Throwable): Unit =\n    resumeWith(Result.failure(exception))\n\n\n/**\n * Creates a [Continuation] instance with the given [context] and implementation of [resumeWith] method.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun <T> Continuation(\n    context: CoroutineContext,\n    crossinline resumeWith: (Result<T>) -> Unit\n): Continuation<T> =\n    object : Continuation<T> {\n        override val context: CoroutineContext\n            get() = context\n\n        override fun resumeWith(result: Result<T>) =\n            resumeWith(result)\n    }\n\n/**\n * Creates a coroutine without a receiver and with result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n * Subsequent invocation of any resume function on the resulting continuation will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <T> (suspend () -> T).createCoroutine(\n    completion: Continuation<T>\n): Continuation<Unit> =\n    SafeContinuation(createCoroutineUnintercepted(completion).intercepted(), COROUTINE_SUSPENDED)\n\n/**\n * Creates a coroutine with receiver type [R] and result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n * Subsequent invocation of any resume function on the resulting continuation will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <R, T> (suspend R.() -> T).createCoroutine(\n    receiver: R,\n    completion: Continuation<T>\n): Continuation<Unit> =\n    SafeContinuation(createCoroutineUnintercepted(receiver, completion).intercepted(), COROUTINE_SUSPENDED)\n\n/**\n * Starts a coroutine without a receiver and with result type [T].\n * This function creates and starts a new, fresh instance of suspendable computation every time it is invoked.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <T> (suspend () -> T).startCoroutine(\n    completion: Continuation<T>\n) {\n    createCoroutineUnintercepted(completion).intercepted().resume(Unit)\n}\n\n/**\n * Starts a coroutine with receiver type [R] and result type [T].\n * This function creates and starts a new, fresh instance of suspendable computation every time it is invoked.\n * The [completion] continuation is invoked when the coroutine completes with a result or an exception.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"UNCHECKED_CAST\")\npublic fun <R, T> (suspend R.() -> T).startCoroutine(\n    receiver: R,\n    completion: Continuation<T>\n) {\n    createCoroutineUnintercepted(receiver, completion).intercepted().resume(Unit)\n}\n\n/**\n * Obtains the current continuation instance inside suspend functions and suspends\n * the currently running coroutine.\n *\n * In this function both [Continuation.resume] and [Continuation.resumeWithException] can be used either synchronously in\n * the same stack-frame where the suspension function is run or asynchronously later in the same thread or\n * from a different thread of execution. Subsequent invocation of any resume function will produce an [IllegalStateException].\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic suspend inline fun <T> suspendCoroutine(crossinline block: (Continuation<T>) -> Unit): T {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    return suspendCoroutineUninterceptedOrReturn { c: Continuation<T> ->\n        val safe = SafeContinuation(c.intercepted())\n        block(safe)\n        safe.getOrThrow()\n    }\n}\n\n/**\n * Returns the context of the current coroutine.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"WRONG_MODIFIER_TARGET\")\n@InlineOnly\npublic suspend inline val coroutineContext: CoroutineContext\n    get() {\n        throw NotImplementedError(\"Implemented as intrinsic\")\n    }\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines.intrinsics\n\nimport kotlin.coroutines.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Starts an unintercepted coroutine without a receiver and with result type [T] and executes it until its first suspension.\n * Returns the result of the coroutine or throws its exception if it does not suspend or [COROUTINE_SUSPENDED] if it suspends.\n * In the latter case, the [completion] continuation is invoked when the coroutine completes with a result or an exception.\n *\n * The coroutine is started directly in the invoker's thread without going through the [ContinuationInterceptor] that might\n * be present in the completion's [CoroutineContext]. It is the invoker's responsibility to ensure that a proper invocation\n * context is established.\n *\n * This function is designed to be used from inside of [suspendCoroutineUninterceptedOrReturn] to resume the execution of the suspended\n * coroutine using a reference to the suspending function.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic actual inline fun <T> (suspend () -> T).startCoroutineUninterceptedOrReturn(\n    completion: Continuation<T>\n): Any? = this.asDynamic()(completion, false)\n\n/**\n * Starts an unintercepted coroutine with receiver type [R] and result type [T] and executes it until its first suspension.\n * Returns the result of the coroutine or throws its exception if it does not suspend or [COROUTINE_SUSPENDED] if it suspends.\n * In the latter case, the [completion] continuation is invoked when the coroutine completes with a result or an exception.\n *\n * The coroutine is started directly in the invoker's thread without going through the [ContinuationInterceptor] that might\n * be present in the completion's [CoroutineContext]. It is the invoker's responsibility to ensure that a proper invocation\n * context is established.\n *\n * This function is designed to be used from inside of [suspendCoroutineUninterceptedOrReturn] to resume the execution of the suspended\n * coroutine using a reference to the suspending function.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic actual inline fun <R, T> (suspend R.() -> T).startCoroutineUninterceptedOrReturn(\n    receiver: R,\n    completion: Continuation<T>\n): Any? = this.asDynamic()(receiver, completion, false)\n\n@InlineOnly\ninternal actual inline fun <R, P, T> (suspend R.(P) -> T).startCoroutineUninterceptedOrReturn(\n    receiver: R,\n    param: P,\n    completion: Continuation<T>\n): Any? = this.asDynamic()(receiver, param, completion, false)\n\n/**\n * Creates unintercepted coroutine without receiver and with result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when coroutine completes with result or exception.\n *\n * This function returns unintercepted continuation.\n * Invocation of `resume(Unit)` starts coroutine immediately in the invoker's call stack without going through the\n * [ContinuationInterceptor] that might be present in the completion's [CoroutineContext].\n * It is the invoker's responsibility to ensure that a proper invocation context is established.\n * Note that [completion] of this function may get invoked in an arbitrary context.\n *\n * [Continuation.intercepted] can be used to acquire the intercepted continuation.\n * Invocation of `resume(Unit)` on intercepted continuation guarantees that execution of\n * both the coroutine and [completion] happens in the invocation context established by\n * [ContinuationInterceptor].\n *\n * Repeated invocation of any resume function on the resulting continuation corrupts the\n * state machine of the coroutine and may result in arbitrary behaviour or exception.\n */\n@SinceKotlin(\"1.3\")\npublic actual fun <T> (suspend () -> T).createCoroutineUnintercepted(\n    completion: Continuation<T>\n): Continuation<Unit> =\n    // Kotlin/JS suspend lambdas have an extra parameter `suspended`\n    if (this.asDynamic().length == 2) {\n        // When `suspended` is true the continuation is created, but not executed\n        this.asDynamic()(completion, true)\n    } else {\n        createCoroutineFromSuspendFunction(completion) {\n            this.asDynamic()(completion)\n        }\n    }\n\n/**\n * Creates unintercepted coroutine with receiver type [R] and result type [T].\n * This function creates a new, fresh instance of suspendable computation every time it is invoked.\n *\n * To start executing the created coroutine, invoke `resume(Unit)` on the returned [Continuation] instance.\n * The [completion] continuation is invoked when coroutine completes with result or exception.\n *\n * This function returns unintercepted continuation.\n * Invocation of `resume(Unit)` starts coroutine immediately in the invoker's call stack without going through the\n * [ContinuationInterceptor] that might be present in the completion's [CoroutineContext].\n * It is the invoker's responsibility to ensure that a proper invocation context is established.\n * Note that [completion] of this function may get invoked in an arbitrary context.\n *\n * [Continuation.intercepted] can be used to acquire the intercepted continuation.\n * Invocation of `resume(Unit)` on intercepted continuation guarantees that execution of\n * both the coroutine and [completion] happens in the invocation context established by\n * [ContinuationInterceptor].\n *\n * Repeated invocation of any resume function on the resulting continuation corrupts the\n * state machine of the coroutine and may result in arbitrary behaviour or exception.\n */\n@SinceKotlin(\"1.3\")\npublic actual fun <R, T> (suspend R.() -> T).createCoroutineUnintercepted(\n    receiver: R,\n    completion: Continuation<T>\n): Continuation<Unit> =\n    // Kotlin/JS suspend lambdas have an extra parameter `suspended`\n    if (this.asDynamic().length == 3) {\n        // When `suspended` is true the continuation is created, but not executed\n        this.asDynamic()(receiver, completion, true)\n    } else {\n        createCoroutineFromSuspendFunction(completion) {\n            this.asDynamic()(receiver, completion)\n        }\n    }\n\n/**\n * Intercepts this continuation with [ContinuationInterceptor].\n *\n * This function shall be used on the immediate result of [createCoroutineUnintercepted] or [suspendCoroutineUninterceptedOrReturn],\n * in which case it checks for [ContinuationInterceptor] in the continuation's [context][Continuation.context],\n * invokes [ContinuationInterceptor.interceptContinuation], caches and returns the result.\n *\n * If this function is invoked on other [Continuation] instances it returns `this` continuation unchanged.\n */\n@SinceKotlin(\"1.3\")\npublic actual fun <T> Continuation<T>.intercepted(): Continuation<T> =\n    (this as? CoroutineImpl)?.intercepted() ?: this\n\n\nprivate inline fun <T> createCoroutineFromSuspendFunction(\n    completion: Continuation<T>,\n    crossinline block: () -> Any?\n): Continuation<Unit> {\n    @Suppress(\"UNCHECKED_CAST\")\n    return object : CoroutineImpl(completion as Continuation<Any?>) {\n        override fun doResume(): Any? {\n            exception?.let { throw it }\n            return block()\n        }\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n// NOTE: Do not author your exceptions as they are written in this file, instead use this template:\n/*\npublic open class MyException : Exception {\n    constructor() : super()\n    constructor(message: String?) : super(message)\n    constructor(message: String?, cause: Throwable?) : super(message, cause)\n    constructor(cause: Throwable?) : super(cause)\n}\n*/\n\n\n// TODO: remove primary constructors, make all secondary KT-22055\n\n@Suppress(\"USELESS_ELVIS_RIGHT_IS_NULL\")\npublic actual open class Error actual constructor(message: String?, cause: Throwable?) : Throwable(message, cause ?: null) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\n@Suppress(\"USELESS_ELVIS_RIGHT_IS_NULL\")\npublic actual open class Exception actual constructor(message: String?, cause: Throwable?) : Throwable(message, cause ?: null) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class RuntimeException actual constructor(message: String?, cause: Throwable?) : Exception(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class IllegalArgumentException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class IllegalStateException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class IndexOutOfBoundsException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class ConcurrentModificationException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class UnsupportedOperationException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\n\npublic actual open class NumberFormatException actual constructor(message: String?) : IllegalArgumentException(message) {\n    actual constructor() : this(null)\n}\n\n\npublic actual open class NullPointerException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class ClassCastException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class AssertionError\n@SinceKotlin(\"1.4\")\nconstructor(message: String?, cause: Throwable?) : Error(message, cause) {\n    actual constructor() : this(null)\n    constructor(message: String?) : this(message, null)\n    actual constructor(message: Any?) : this(message.toString(), message as? Throwable)\n}\n\npublic actual open class NoSuchElementException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\n@SinceKotlin(\"1.3\")\npublic actual open class ArithmeticException actual constructor(message: String?) : RuntimeException(message) {\n    actual constructor() : this(null)\n}\n\npublic actual open class NoWhenBranchMatchedException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n\npublic actual open class UninitializedPropertyAccessException actual constructor(message: String?, cause: Throwable?) : RuntimeException(message, cause) {\n    actual constructor() : this(null, null)\n    actual constructor(message: String?) : this(message, null)\n    actual constructor(cause: Throwable?) : this(undefined, cause)\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/**\n * Returns a string representation of this [Long] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Long.toString(radix: Int): String = asDynamic().toString(checkRadix(radix))","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\nimport primitiveArrayConcat\nimport withType\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun <T> Array<out T>.elementAt(index: Int): T {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun ByteArray.elementAt(index: Int): Byte {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun ShortArray.elementAt(index: Int): Short {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun IntArray.elementAt(index: Int): Int {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun LongArray.elementAt(index: Int): Long {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun FloatArray.elementAt(index: Int): Float {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun DoubleArray.elementAt(index: Int): Double {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun BooleanArray.elementAt(index: Int): Boolean {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic actual fun CharArray.elementAt(index: Int): Char {\n    return elementAtOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, size: $size}\") }\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic actual fun <T> Array<out T>.asList(): List<T> {\n    return ArrayList<T>(this.unsafeCast<Array<Any?>>())\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun ByteArray.asList(): List<Byte> {\n    return this.unsafeCast<Array<Byte>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun ShortArray.asList(): List<Short> {\n    return this.unsafeCast<Array<Short>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun IntArray.asList(): List<Int> {\n    return this.unsafeCast<Array<Int>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun LongArray.asList(): List<Long> {\n    return this.unsafeCast<Array<Long>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun FloatArray.asList(): List<Float> {\n    return this.unsafeCast<Array<Float>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun DoubleArray.asList(): List<Double> {\n    return this.unsafeCast<Array<Double>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun BooleanArray.asList(): List<Boolean> {\n    return this.unsafeCast<Array<Boolean>>().asList()\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\npublic actual fun CharArray.asList(): List<Char> {\n    return object : AbstractList<Char>(), RandomAccess {\n        override val size: Int get() = this@asList.size\n        override fun isEmpty(): Boolean = this@asList.isEmpty()\n        override fun contains(element: Char): Boolean = this@asList.contains(element)\n        override fun get(index: Int): Char {\n            AbstractList.checkElementIndex(index, size)\n            return this@asList[index]\n        }\n        override fun indexOf(element: Char): Int {\n            @Suppress(\"USELESS_CAST\")\n            if ((element as Any?) !is Char) return -1\n            return this@asList.indexOf(element)\n        }\n        override fun lastIndexOf(element: Char): Int {\n            @Suppress(\"USELESS_CAST\")\n            if ((element as Any?) !is Char) return -1\n            return this@asList.lastIndexOf(element)\n        }\n    }\n}\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic actual infix fun <T> Array<out T>.contentDeepEquals(other: Array<out T>): Boolean {\n    return this.contentDeepEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *deeply* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The specified arrays are also considered deeply equal if both are `null`.\n * \n * If two corresponding elements are nested arrays, they are also compared deeply.\n * If any of arrays contains itself on any nesting level the behavior is undefined.\n * \n * The elements of other types are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayDeepEquals\")\npublic actual infix fun <T> Array<out T>?.contentDeepEquals(other: Array<out T>?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic actual fun <T> Array<out T>.contentDeepHashCode(): Int {\n    return this.contentDeepHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level the behavior is undefined.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayDeepHashCode\")\npublic actual fun <T> Array<out T>?.contentDeepHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.LowPriorityInOverloadResolution\npublic actual fun <T> Array<out T>.contentDeepToString(): String {\n    return this.contentDeepToString()\n}\n\n/**\n * Returns a string representation of the contents of this array as if it is a [List].\n * Nested arrays are treated as lists too.\n * \n * If any of arrays contains itself on any nesting level that reference\n * is rendered as `\"[...]\"` to prevent recursion.\n * \n * @sample samples.collections.Arrays.ContentOperations.contentDeepToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayDeepToString\")\npublic actual fun <T> Array<out T>?.contentDeepToString(): String {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun <T> Array<out T>.contentEquals(other: Array<out T>): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun ByteArray.contentEquals(other: ByteArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun ShortArray.contentEquals(other: ShortArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun IntArray.contentEquals(other: IntArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun LongArray.contentEquals(other: LongArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun FloatArray.contentEquals(other: FloatArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun DoubleArray.contentEquals(other: DoubleArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun BooleanArray.contentEquals(other: BooleanArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual infix fun CharArray.contentEquals(other: CharArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun <T> Array<out T>?.contentEquals(other: Array<out T>?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun ByteArray?.contentEquals(other: ByteArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun ShortArray?.contentEquals(other: ShortArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun IntArray?.contentEquals(other: IntArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun LongArray?.contentEquals(other: LongArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun FloatArray?.contentEquals(other: FloatArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun DoubleArray?.contentEquals(other: DoubleArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun BooleanArray?.contentEquals(other: BooleanArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n * \n * The elements are compared for equality with the [equals][Any.equals] function.\n * For floating point numbers it means that `NaN` is equal to itself and `-0.0` is not equal to `0.0`.\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayEquals\")\npublic actual infix fun CharArray?.contentEquals(other: CharArray?): Boolean {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun <T> Array<out T>.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ByteArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ShortArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun IntArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun LongArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun FloatArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun DoubleArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun BooleanArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun CharArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun <T> Array<out T>?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun ByteArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun ShortArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun IntArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun LongArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun FloatArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun DoubleArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun BooleanArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayHashCode\")\npublic actual fun CharArray?.contentHashCode(): Int {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun <T> Array<out T>.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ByteArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun ShortArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun IntArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun LongArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun FloatArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun DoubleArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun BooleanArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.1\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\npublic actual fun CharArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun <T> Array<out T>?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun ByteArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun ShortArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun IntArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun LongArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun FloatArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun DoubleArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun BooleanArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@library(\"arrayToString\")\npublic actual fun CharArray?.contentToString(): String {\n    definedExternally\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun <T> Array<out T>.copyInto(destination: Array<T>, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): Array<T> {\n    arrayCopy(this, destination, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun ByteArray.copyInto(destination: ByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ByteArray {\n    arrayCopy(this.unsafeCast<Array<Byte>>(), destination.unsafeCast<Array<Byte>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun ShortArray.copyInto(destination: ShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ShortArray {\n    arrayCopy(this.unsafeCast<Array<Short>>(), destination.unsafeCast<Array<Short>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun IntArray.copyInto(destination: IntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): IntArray {\n    arrayCopy(this.unsafeCast<Array<Int>>(), destination.unsafeCast<Array<Int>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun LongArray.copyInto(destination: LongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): LongArray {\n    arrayCopy(this.unsafeCast<Array<Long>>(), destination.unsafeCast<Array<Long>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun FloatArray.copyInto(destination: FloatArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): FloatArray {\n    arrayCopy(this.unsafeCast<Array<Float>>(), destination.unsafeCast<Array<Float>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun DoubleArray.copyInto(destination: DoubleArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): DoubleArray {\n    arrayCopy(this.unsafeCast<Array<Double>>(), destination.unsafeCast<Array<Double>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun BooleanArray.copyInto(destination: BooleanArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): BooleanArray {\n    arrayCopy(this.unsafeCast<Array<Boolean>>(), destination.unsafeCast<Array<Boolean>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun CharArray.copyInto(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): CharArray {\n    arrayCopy(this.unsafeCast<Array<Char>>(), destination.unsafeCast<Array<Char>>(), destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline fun <T> Array<out T>.copyOf(): Array<T> {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun ByteArray.copyOf(): ByteArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun ShortArray.copyOf(): ShortArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun IntArray.copyOf(): IntArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun LongArray.copyOf(): LongArray {\n    return withType(\"LongArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun FloatArray.copyOf(): FloatArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun DoubleArray.copyOf(): DoubleArray {\n    return this.asDynamic().slice()\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun BooleanArray.copyOf(): BooleanArray {\n    return withType(\"BooleanArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\npublic actual fun CharArray.copyOf(): CharArray {\n    return withType(\"CharArray\", this.asDynamic().slice())\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun ByteArray.copyOf(newSize: Int): ByteArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, ByteArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun ShortArray.copyOf(newSize: Int): ShortArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, ShortArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun IntArray.copyOf(newSize: Int): IntArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, IntArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun LongArray.copyOf(newSize: Int): LongArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"LongArray\", arrayCopyResize(this, newSize, 0L))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun FloatArray.copyOf(newSize: Int): FloatArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, FloatArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun DoubleArray.copyOf(newSize: Int): DoubleArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return fillFrom(this, DoubleArray(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `false` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `false` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun BooleanArray.copyOf(newSize: Int): BooleanArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"BooleanArray\", arrayCopyResize(this, newSize, false))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with null char (`\\u0000`) values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with null char (`\\u0000`) values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizedPrimitiveCopyOf\n */\npublic actual fun CharArray.copyOf(newSize: Int): CharArray {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return withType(\"CharArray\", fillFrom(this, CharArray(newSize)))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with `null` values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with `null` values.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.resizingCopyOf\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual fun <T> Array<out T>.copyOf(newSize: Int): Array<T?> {\n    require(newSize >= 0) { \"Invalid new array size: $newSize.\" }\n    return arrayCopyResize(this, newSize, null)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual fun <T> Array<out T>.copyOfRange(fromIndex: Int, toIndex: Int): Array<T> {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun ByteArray.copyOfRange(fromIndex: Int, toIndex: Int): ByteArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun ShortArray.copyOfRange(fromIndex: Int, toIndex: Int): ShortArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun IntArray.copyOfRange(fromIndex: Int, toIndex: Int): IntArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun LongArray.copyOfRange(fromIndex: Int, toIndex: Int): LongArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"LongArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun FloatArray.copyOfRange(fromIndex: Int, toIndex: Int): FloatArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun DoubleArray.copyOfRange(fromIndex: Int, toIndex: Int): DoubleArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return this.asDynamic().slice(fromIndex, toIndex)\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun BooleanArray.copyOfRange(fromIndex: Int, toIndex: Int): BooleanArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"BooleanArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\npublic actual fun CharArray.copyOfRange(fromIndex: Int, toIndex: Int): CharArray {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    return withType(\"CharArray\", this.asDynamic().slice(fromIndex, toIndex))\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun <T> Array<T>.fill(element: T, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.fill(element: Byte, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ShortArray.fill(element: Short, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun IntArray.fill(element: Int, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun LongArray.fill(element: Long, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun FloatArray.fill(element: Float, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun DoubleArray.fill(element: Double, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun BooleanArray.fill(element: Boolean, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.fill(element: Char, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    this.asDynamic().fill(element, fromIndex, toIndex);\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun <T> Array<out T>.plus(element: T): Array<T> {\n    return this.asDynamic().concat(arrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ByteArray.plus(element: Byte): ByteArray {\n    return plus(byteArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ShortArray.plus(element: Short): ShortArray {\n    return plus(shortArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun IntArray.plus(element: Int): IntArray {\n    return plus(intArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun LongArray.plus(element: Long): LongArray {\n    return plus(longArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun FloatArray.plus(element: Float): FloatArray {\n    return plus(floatArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun DoubleArray.plus(element: Double): DoubleArray {\n    return plus(doubleArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun BooleanArray.plus(element: Boolean): BooleanArray {\n    return plus(booleanArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun CharArray.plus(element: Char): CharArray {\n    return plus(charArrayOf(element))\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\")\npublic actual operator fun <T> Array<out T>.plus(elements: Collection<T>): Array<T> {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun ByteArray.plus(elements: Collection<Byte>): ByteArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun ShortArray.plus(elements: Collection<Short>): ShortArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun IntArray.plus(elements: Collection<Int>): IntArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun LongArray.plus(elements: Collection<Long>): LongArray {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun FloatArray.plus(elements: Collection<Float>): FloatArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun DoubleArray.plus(elements: Collection<Double>): DoubleArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun BooleanArray.plus(elements: Collection<Boolean>): BooleanArray {\n    return arrayPlusCollection(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\npublic actual operator fun CharArray.plus(elements: Collection<Char>): CharArray {\n    return fillFromCollection(this.copyOf(size + elements.size), this.size, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun <T> Array<out T>.plus(elements: Array<out T>): Array<T> {\n    return this.asDynamic().concat(elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ByteArray.plus(elements: ByteArray): ByteArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun ShortArray.plus(elements: ShortArray): ShortArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun IntArray.plus(elements: IntArray): IntArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun LongArray.plus(elements: LongArray): LongArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun FloatArray.plus(elements: FloatArray): FloatArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun DoubleArray.plus(elements: DoubleArray): DoubleArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun BooleanArray.plus(elements: BooleanArray): BooleanArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline operator fun CharArray.plus(elements: CharArray): CharArray {\n    return primitiveArrayConcat(this, elements)\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"NOTHING_TO_INLINE\")\npublic actual inline fun <T> Array<out T>.plusElement(element: T): Array<T> {\n    return this.asDynamic().concat(arrayOf(element))\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun IntArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\npublic actual fun LongArray.sort(): Unit {\n    @Suppress(\"DEPRECATION\")\n    if (size > 1) sort { a: Long, b: Long -> a.compareTo(b) }\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun ByteArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun ShortArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun DoubleArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun FloatArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@library(\"primitiveArraySort\")\npublic actual fun CharArray.sort(): Unit {\n    definedExternally\n}\n\n/**\n * Sorts the array in-place according to the natural order of its elements.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @sample samples.collections.Arrays.Sorting.sortArrayOfComparable\n */\npublic actual fun <T : Comparable<T>> Array<out T>.sort(): Unit {\n    if (size > 1) sortArray(this)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\n@Deprecated(\"Use sortWith instead\", ReplaceWith(\"this.sortWith(Comparator(comparison))\"))\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\npublic fun <T> Array<out T>.sort(comparison: (a: T, b: T) -> Int): Unit {\n    if (size > 1) sortArrayWith(this, comparison)\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArrayOfComparable\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun <T : Comparable<T>> Array<out T>.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArrayWith(this, fromIndex, toIndex, naturalOrder())\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<ByteArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ShortArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<ShortArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun IntArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<IntArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun LongArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArrayWith(this.unsafeCast<Array<Long>>(), fromIndex, toIndex, naturalOrder())\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun FloatArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<FloatArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun DoubleArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<DoubleArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    val subarray = this.asDynamic().subarray(fromIndex, toIndex).unsafeCast<CharArray>()\n    subarray.sort()\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@Deprecated(\"Use other sorting functions from the Standard Library\")\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.sort(noinline comparison: (a: Byte, b: Byte) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@Deprecated(\"Use other sorting functions from the Standard Library\")\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.sort(noinline comparison: (a: Short, b: Short) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@Deprecated(\"Use other sorting functions from the Standard Library\")\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.sort(noinline comparison: (a: Int, b: Int) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@Deprecated(\"Use other sorting functions from the Standard Library\")\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.sort(noinline comparison: (a: Long, b: Long) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@Deprecated(\"Use other sorting functions from the Standard Library\")\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun FloatArray.sort(noinline comparison: (a: Float, b: Float) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@Deprecated(\"Use other sorting functions from the Standard Library\")\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun DoubleArray.sort(noinline comparison: (a: Double, b: Double) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparison] function.\n */\n@Deprecated(\"Use other sorting functions from the Standard Library\")\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun CharArray.sort(noinline comparison: (a: Char, b: Char) -> Int): Unit {\n    asDynamic().sort(comparison)\n}\n\n/**\n * Sorts the array in-place according to the order specified by the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\npublic actual fun <T> Array<out T>.sortWith(comparator: Comparator<in T>): Unit {\n    if (size > 1) sortArrayWith(this, comparator)\n}\n\n/**\n * Sorts a range in the array in-place with the given [comparator].\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun <T> Array<out T>.sortWith(comparator: Comparator<in T>, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArrayWith(this, fromIndex, toIndex, comparator)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun ByteArray.toTypedArray(): Array<Byte> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun ShortArray.toTypedArray(): Array<Short> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun IntArray.toTypedArray(): Array<Int> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun LongArray.toTypedArray(): Array<Long> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun FloatArray.toTypedArray(): Array<Float> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun DoubleArray.toTypedArray(): Array<Double> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun BooleanArray.toTypedArray(): Array<Boolean> {\n    return js(\"[]\").slice.call(this)\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\npublic actual fun CharArray.toTypedArray(): Array<Char> {\n    return Array(size) { index -> this[index] }\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Reverses elements in the list in-place.\n */\npublic actual fun <T> MutableList<T>.reverse(): Unit {\n    val midPoint = (size / 2) - 1\n    if (midPoint < 0) return\n    var reverseIndex = lastIndex\n    for (index in 0..midPoint) {\n        val tmp = this[index]\n        this[index] = this[reverseIndex]\n        this[reverseIndex] = tmp\n        reverseIndex--\n    }\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateUnicodeData.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\n// 37 ranges totally\nprivate object Digit {\n    internal val rangeStart = intArrayOf(\n        0x0030, 0x0660, 0x06f0, 0x07c0, 0x0966, 0x09e6, 0x0a66, 0x0ae6, 0x0b66, 0x0be6, 0x0c66, 0x0ce6, 0x0d66, 0x0de6, 0x0e50, 0x0ed0, 0x0f20, 0x1040, 0x1090, 0x17e0, \n        0x1810, 0x1946, 0x19d0, 0x1a80, 0x1a90, 0x1b50, 0x1bb0, 0x1c40, 0x1c50, 0xa620, 0xa8d0, 0xa900, 0xa9d0, 0xa9f0, 0xaa50, 0xabf0, 0xff10, \n    )\n}\n\n/**\n * Returns the index of the largest element in [array] smaller or equal to the specified [needle],\n * or -1 if [needle] is smaller than the smallest element in [array].\n */\ninternal fun binarySearchRange(array: IntArray, needle: Int): Int {\n    var bottom = 0\n    var top = array.size - 1\n    var middle = -1\n    var value = 0\n    while (bottom <= top) {\n        middle = (bottom + top) / 2\n        value = array[middle]\n        if (needle > value)\n            bottom = middle + 1\n        else if (needle == value)\n            return middle\n        else\n            top = middle - 1\n    }\n    return middle - (if (needle < value) 1 else 0)\n}\n\n/**\n * Returns an integer from 0..9 indicating the digit this character represents,\n * or -1 if this character is not a digit.\n */\ninternal fun Char.digitToIntImpl(): Int {\n    val ch = this.code\n    val index = binarySearchRange(Digit.rangeStart, ch)\n    val diff = ch - Digit.rangeStart[index]\n    return if (diff < 10) diff else -1\n}\n\n/**\n * Returns `true` if this character is a digit.\n */\ninternal fun Char.isDigitImpl(): Boolean {\n    return digitToIntImpl() >= 0\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateUnicodeData.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\n// 9 ranges totally\n/**\n * Returns `true` if this character is a whitespace.\n */\ninternal fun Char.isWhitespaceImpl(): Boolean {\n    val ch = this.code\n    return ch in 0x0009..0x000d\n            || ch in 0x001c..0x0020\n            || ch == 0x00a0\n            || ch > 0x1000 && (\n                ch == 0x1680\n                || ch in 0x2000..0x200a\n                || ch == 0x2028\n                || ch == 0x2029\n                || ch == 0x202f\n                || ch == 0x205f\n                || ch == 0x3000\n            )\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\nimport kotlin.comparisons.naturalOrder\nimport kotlin.random.Random\n\n/**\n * Returns the array if it's not `null`, or an empty array otherwise.\n * @sample samples.collections.Arrays.Usage.arrayOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Array<out T>?.orEmpty(): Array<out T> = this ?: emptyArray<T>()\n\n/**\n * Returns a *typed* array containing all of the elements of this collection.\n *\n * Allocates an array of runtime type `T` having its size equal to the size of this collection\n * and populates the array with the elements of this collection.\n * @sample samples.collections.Collections.Collections.collectionToTypedArray\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun <T> Collection<T>.toTypedArray(): Array<T> = copyToArray(this)\n\n@JsName(\"copyToArray\")\n@PublishedApi\ninternal fun <T> copyToArray(collection: Collection<T>): Array<T> {\n    return if (collection.asDynamic().toArray !== undefined)\n        collection.asDynamic().toArray().unsafeCast<Array<T>>()\n    else\n        copyToArrayImpl(collection).unsafeCast<Array<T>>()\n}\n\n@JsName(\"copyToArrayImpl\")\ninternal actual fun copyToArrayImpl(collection: Collection<*>): Array<Any?> {\n    val array = emptyArray<Any?>()\n    val iterator = collection.iterator()\n    while (iterator.hasNext())\n        array.asDynamic().push(iterator.next())\n    return array\n}\n\n@JsName(\"copyToExistingArrayImpl\")\ninternal actual fun <T> copyToArrayImpl(collection: Collection<*>, array: Array<T>): Array<T> {\n    if (array.size < collection.size)\n        return copyToArrayImpl(collection).unsafeCast<Array<T>>()\n\n    val iterator = collection.iterator()\n    var index = 0\n    while (iterator.hasNext()) {\n        array[index++] = iterator.next().unsafeCast<T>()\n    }\n    if (index < array.size) {\n        array[index] = null.unsafeCast<T>()\n    }\n    return array\n}\n\n\n/**\n * Returns an immutable list containing only the specified object [element].\n */\npublic fun <T> listOf(element: T): List<T> = arrayListOf(element)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildListInternal(builderAction: MutableList<E>.() -> Unit): List<E> {\n    return ArrayList<E>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildListInternal(capacity: Int, builderAction: MutableList<E>.() -> Unit): List<E> {\n    checkBuilderCapacity(capacity)\n    return ArrayList<E>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Returns an immutable set containing only the specified object [element].\n */\npublic fun <T> setOf(element: T): Set<T> = hashSetOf(element)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildSetInternal(builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    return LinkedHashSet<E>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal actual inline fun <E> buildSetInternal(capacity: Int, builderAction: MutableSet<E>.() -> Unit): Set<E> {\n    return LinkedHashSet<E>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Returns an immutable map, mapping only the specified key to the\n * specified value.\n */\npublic fun <K, V> mapOf(pair: Pair<K, V>): Map<K, V> = hashMapOf(pair)\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal actual inline fun <K, V> buildMapInternal(builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    return LinkedHashMap<K, V>().apply(builderAction).build()\n}\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\ninternal actual inline fun <K, V> buildMapInternal(capacity: Int, builderAction: MutableMap<K, V>.() -> Unit): Map<K, V> {\n    return LinkedHashMap<K, V>(capacity).apply(builderAction).build()\n}\n\n\n/**\n * Fills the list with the provided [value].\n *\n * Each element in the list gets replaced with the [value].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.fill(value: T): Unit {\n    for (index in 0..lastIndex) {\n        this[index] = value\n    }\n}\n\n/**\n * Randomly shuffles elements in this list.\n *\n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> MutableList<T>.shuffle(): Unit = shuffle(Random)\n\n/**\n * Returns a new list with the elements of this list randomly shuffled.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun <T> Iterable<T>.shuffled(): List<T> = toMutableList().apply { shuffle() }\n\n/**\n * Sorts elements in the list in-place according to their natural sort order.\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * @sample samples.collections.Collections.Sorting.sortMutableList\n */\npublic actual fun <T : Comparable<T>> MutableList<T>.sort(): Unit {\n    collectionsSort(this, naturalOrder())\n}\n\n/**\n * Sorts elements in the list in-place according to the order specified with [comparator].\n *\n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n *\n * @sample samples.collections.Collections.Sorting.sortMutableListWith\n */\npublic actual fun <T> MutableList<T>.sortWith(comparator: Comparator<in T>): Unit {\n    collectionsSort(this, comparator)\n}\n\nprivate fun <T> collectionsSort(list: MutableList<T>, comparator: Comparator<in T>) {\n    if (list.size <= 1) return\n\n    val array = copyToArray(list)\n    sortArrayWith(array, comparator)\n\n    for (i in 0 until array.size) {\n        list[i] = array[i]\n    }\n}\n\ninternal actual fun <T> arrayOfNulls(reference: Array<T>, size: Int): Array<T> {\n    return arrayOfNulls<Any>(size).unsafeCast<Array<T>>()\n}\n\n@SinceKotlin(\"1.3\")\n@PublishedApi\n@JsName(\"arrayCopy\")\ninternal fun <T> arrayCopy(source: Array<out T>, destination: Array<in T>, destinationOffset: Int, startIndex: Int, endIndex: Int) {\n    AbstractList.checkRangeIndexes(startIndex, endIndex, source.size)\n    val rangeSize = endIndex - startIndex\n    AbstractList.checkRangeIndexes(destinationOffset, destinationOffset + rangeSize, destination.size)\n\n    if (js(\"ArrayBuffer\").isView(destination) && js(\"ArrayBuffer\").isView(source)) {\n        val subrange = source.asDynamic().subarray(startIndex, endIndex)\n        destination.asDynamic().set(subrange, destinationOffset)\n    } else {\n        if (source !== destination || destinationOffset <= startIndex) {\n            for (index in 0 until rangeSize) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        } else {\n            for (index in rangeSize - 1 downTo 0) {\n                destination[destinationOffset + index] = source[startIndex + index]\n            }\n        }\n    }\n}\n\n// no singleton map implementation in js, return map as is\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<K, V>.toSingletonMapOrSelf(): Map<K, V> = this\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <K, V> Map<out K, V>.toSingletonMap(): Map<K, V> = this.toMutableMap()\n\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <T> Array<out T>.copyToArrayOfAny(isVarargs: Boolean): Array<out Any?> =\n    if (isVarargs)\n    // no need to copy vararg array in JS\n        this\n    else\n        this.copyOf()\n\n\n\n@PublishedApi\ninternal actual fun checkIndexOverflow(index: Int): Int {\n    if (index < 0) {\n        throwIndexOverflow()\n    }\n    return index\n}\n\n@PublishedApi\ninternal actual fun checkCountOverflow(count: Int): Int {\n    if (count < 0) {\n        throwCountOverflow()\n    }\n    return count\n}\n\n\n/**\n * JS map and set implementations do not make use of capacities or load factors.\n */\n@PublishedApi\ninternal actual fun mapCapacity(expectedSize: Int) = expectedSize\n\n/**\n * Checks a collection builder function capacity argument.\n * In JS no validation is made in Map/Set constructor yet.\n */\n@SinceKotlin(\"1.3\")\n@PublishedApi\ninternal fun checkBuilderCapacity(capacity: Int) {\n    require(capacity >= 0) { \"capacity must be non-negative.\" }\n}\n\ninternal actual fun brittleContainsOptimizationEnabled(): Boolean = false","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:Suppress(\"UNUSED_PARAMETER\", \"NOTHING_TO_INLINE\")\n\npackage kotlin\n\n/**\n * Returns an empty array of the specified type [T].\n */\npublic inline fun <T> emptyArray(): Array<T> = js(\"[]\")\n\n@library\npublic fun <T> arrayOf(vararg elements: T): Array<T> = definedExternally\n\n@library\npublic fun doubleArrayOf(vararg elements: Double): DoubleArray = definedExternally\n\n@library\npublic fun floatArrayOf(vararg elements: Float): FloatArray = definedExternally\n\n@library\npublic fun longArrayOf(vararg elements: Long): LongArray = definedExternally\n\n@library\npublic fun intArrayOf(vararg elements: Int): IntArray = definedExternally\n\n@library\npublic fun charArrayOf(vararg elements: Char): CharArray = definedExternally\n\n@library\npublic fun shortArrayOf(vararg elements: Short): ShortArray = definedExternally\n\n@library\npublic fun byteArrayOf(vararg elements: Byte): ByteArray = definedExternally\n\n@library\npublic fun booleanArrayOf(vararg elements: Boolean): BooleanArray = definedExternally\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n */\npublic actual fun <T> lazy(initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n *\n * The [mode] parameter is ignored. */\npublic actual fun <T> lazy(mode: LazyThreadSafetyMode, initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n/**\n * Creates a new instance of the [Lazy] that uses the specified initialization function [initializer].\n *\n * The [lock] parameter is ignored.\n */\npublic actual fun <T> lazy(lock: Any?, initializer: () -> T): Lazy<T> = UnsafeLazyImpl(initializer)\n\n\ninternal fun fillFrom(src: dynamic, dst: dynamic): dynamic {\n    val srcLen: Int = src.length\n    val dstLen: Int = dst.length\n    var index: Int = 0\n    while (index < srcLen && index < dstLen) dst[index] = src[index++]\n    return dst\n}\n\n\ninternal fun arrayCopyResize(source: dynamic, newSize: Int, defaultValue: Any?): dynamic {\n    val result = source.slice(0, newSize)\n    copyArrayType(source, result)\n    var index: Int = source.length\n    if (newSize > index) {\n        result.length = newSize\n        while (index < newSize) result[index++] = defaultValue\n    }\n    return result\n}\n\ninternal fun <T> arrayPlusCollection(array: dynamic, collection: Collection<T>): dynamic {\n    val result = array.slice()\n    result.length += collection.size\n    copyArrayType(array, result)\n    var index: Int = array.length\n    for (element in collection) result[index++] = element\n    return result\n}\n\ninternal fun <T> fillFromCollection(dst: dynamic, startIndex: Int, collection: Collection<T>): dynamic {\n    var index = startIndex\n    for (element in collection) dst[index++] = element\n    return dst\n}\n\ninternal inline fun copyArrayType(from: dynamic, to: dynamic) {\n    if (from.`$type$` !== undefined) {\n        to.`$type$` = from.`$type$`\n    }\n}\n\ninternal inline fun jsIsType(obj: dynamic, jsClass: dynamic) = js(\"Kotlin\").isType(obj, jsClass)","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableCollection] interface.\n *\n * @param E the type of elements contained in the collection. The collection is invariant in its element type.\n */\npublic actual abstract class AbstractMutableCollection<E> protected actual constructor() : AbstractCollection<E>(), MutableCollection<E> {\n\n    actual abstract override fun add(element: E): Boolean\n\n    actual override fun remove(element: E): Boolean {\n        checkIsMutable()\n        val iterator = iterator()\n        while (iterator.hasNext()) {\n            if (iterator.next() == element) {\n                iterator.remove()\n                return true\n            }\n        }\n        return false\n    }\n\n    actual override fun addAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        var modified = false\n        for (element in elements) {\n            if (add(element)) modified = true\n        }\n        return modified\n    }\n\n    actual override fun removeAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        return (this as MutableIterable<E>).removeAll { it in elements }\n    }\n\n    actual override fun retainAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        return (this as MutableIterable<E>).removeAll { it !in elements }\n    }\n\n    actual override fun clear(): Unit {\n        checkIsMutable()\n        val iterator = this.iterator()\n        while (iterator.hasNext()) {\n            iterator.next()\n            iterator.remove()\n        }\n    }\n\n    @Deprecated(\"Provided so that subclasses inherit this function\", level = DeprecationLevel.HIDDEN)\n    @JsName(\"toJSON\")\n    protected fun toJSON(): Any = this.toArray()\n\n\n    /**\n     * This method is called every time when a mutating method is called on this mutable collection.\n     * Mutable collections that are built (frozen) must throw `UnsupportedOperationException`.\n     */\n    internal open fun checkIsMutable(): Unit { }\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractList\n * Copyright 2007 Google Inc.\n*/\n\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableList] interface.\n *\n * @param E the type of elements contained in the list. The list is invariant in its element type.\n */\npublic actual abstract class AbstractMutableList<E> protected actual constructor() : AbstractMutableCollection<E>(), MutableList<E> {\n    protected var modCount: Int = 0\n\n    abstract override fun add(index: Int, element: E): Unit\n    abstract override fun removeAt(index: Int): E\n    abstract override fun set(index: Int, element: E): E\n\n    /**\n     * Adds the specified element to the end of this list.\n     *\n     * @return `true` because the list is always modified as the result of this operation.\n     */\n    actual override fun add(element: E): Boolean {\n        checkIsMutable()\n        add(size, element)\n        return true\n    }\n\n    actual override fun addAll(index: Int, elements: Collection<E>): Boolean {\n        AbstractList.checkPositionIndex(index, size)\n\n        checkIsMutable()\n        var _index = index\n        var changed = false\n        for (e in elements) {\n            add(_index++, e)\n            changed = true\n        }\n        return changed\n    }\n\n    actual override fun clear() {\n        checkIsMutable()\n        removeRange(0, size)\n    }\n\n    actual override fun removeAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        return removeAll { it in elements }\n    }\n\n    actual override fun retainAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        return removeAll { it !in elements }\n    }\n\n\n    actual override fun iterator(): MutableIterator<E> = IteratorImpl()\n\n    actual override fun contains(element: E): Boolean = indexOf(element) >= 0\n\n    actual override fun indexOf(element: E): Int {\n        for (index in 0..lastIndex) {\n            if (get(index) == element) {\n                return index\n            }\n        }\n        return -1\n    }\n\n    actual override fun lastIndexOf(element: E): Int {\n        for (index in lastIndex downTo 0) {\n            if (get(index) == element) {\n                return index\n            }\n        }\n        return -1\n    }\n\n    actual override fun listIterator(): MutableListIterator<E> = listIterator(0)\n    actual override fun listIterator(index: Int): MutableListIterator<E> = ListIteratorImpl(index)\n\n\n    actual override fun subList(fromIndex: Int, toIndex: Int): MutableList<E> = SubList(this, fromIndex, toIndex)\n\n    /**\n     * Removes the range of elements from this list starting from [fromIndex] and ending with but not including [toIndex].\n     */\n    protected open fun removeRange(fromIndex: Int, toIndex: Int) {\n        val iterator = listIterator(fromIndex)\n        repeat(toIndex - fromIndex) {\n            iterator.next()\n            iterator.remove()\n        }\n    }\n\n    /**\n     * Compares this list with another list instance with the ordered structural equality.\n     *\n     * @return true, if [other] instance is a [List] of the same size, which contains the same elements in the same order.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is List<*>) return false\n\n        return AbstractList.orderedEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this list.\n     */\n    override fun hashCode(): Int = AbstractList.orderedHashCode(this)\n\n\n    private open inner class IteratorImpl : MutableIterator<E> {\n        /** the index of the item that will be returned on the next call to [next]`()` */\n        protected var index = 0\n        /** the index of the item that was returned on the previous call to [next]`()`\n         * or [ListIterator.previous]`()` (for `ListIterator`),\n         * -1 if no such item exists\n         */\n        protected var last = -1\n\n        override fun hasNext(): Boolean = index < size\n\n        override fun next(): E {\n            if (!hasNext()) throw NoSuchElementException()\n            last = index++\n            return get(last)\n        }\n\n        override fun remove() {\n            check(last != -1) { \"Call next() or previous() before removing element from the iterator.\" }\n\n            removeAt(last)\n            index = last\n            last = -1\n        }\n    }\n\n    /**\n     * Implementation of `MutableListIterator` for abstract lists.\n     */\n    private inner class ListIteratorImpl(index: Int) : IteratorImpl(), MutableListIterator<E> {\n\n        init {\n            AbstractList.checkPositionIndex(index, this@AbstractMutableList.size)\n            this.index = index\n        }\n\n        override fun hasPrevious(): Boolean = index > 0\n\n        override fun nextIndex(): Int = index\n\n        override fun previous(): E {\n            if (!hasPrevious()) throw NoSuchElementException()\n\n            last = --index\n            return get(last)\n        }\n\n        override fun previousIndex(): Int = index - 1\n\n        override fun add(element: E) {\n            add(index, element)\n            index++\n            last = -1\n        }\n\n        override fun set(element: E) {\n            check(last != -1) { \"Call next() or previous() before updating element value with the iterator.\" }\n            set(last, element)\n        }\n    }\n\n    private class SubList<E>(private val list: AbstractMutableList<E>, private val fromIndex: Int, toIndex: Int) : AbstractMutableList<E>(), RandomAccess {\n        private var _size: Int = 0\n\n        init {\n            AbstractList.checkRangeIndexes(fromIndex, toIndex, list.size)\n            this._size = toIndex - fromIndex\n        }\n\n        override fun add(index: Int, element: E) {\n            AbstractList.checkPositionIndex(index, _size)\n\n            list.add(fromIndex + index, element)\n            _size++\n        }\n\n        override fun get(index: Int): E {\n            AbstractList.checkElementIndex(index, _size)\n\n            return list[fromIndex + index]\n        }\n\n        override fun removeAt(index: Int): E {\n            AbstractList.checkElementIndex(index, _size)\n\n            val result = list.removeAt(fromIndex + index)\n            _size--\n            return result\n        }\n\n        override fun set(index: Int, element: E): E {\n            AbstractList.checkElementIndex(index, _size)\n\n            return list.set(fromIndex + index, element)\n        }\n\n        override val size: Int get() = _size\n\n        internal override fun checkIsMutable(): Unit = list.checkIsMutable()\n    }\n\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractMap\n * Copyright 2007 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableMap] interface.\n *\n * The implementor is required to implement [entries] property, which should return mutable set of map entries, and [put] function.\n *\n * @param K the type of map keys. The map is invariant in its key type.\n * @param V the type of map values. The map is invariant in its value type.\n */\npublic actual abstract class AbstractMutableMap<K, V> protected actual constructor() : AbstractMap<K, V>(), MutableMap<K, V> {\n\n    /**\n     * A mutable [Map.Entry] shared by several [Map] implementations.\n     */\n    internal open class SimpleEntry<K, V>(override val key: K, value: V) : MutableMap.MutableEntry<K, V> {\n        constructor(entry: Map.Entry<K, V>) : this(entry.key, entry.value)\n\n        private var _value = value\n\n        override val value: V get() = _value\n\n        override fun setValue(newValue: V): V {\n            // Should check if the map containing this entry is mutable.\n            // However, to not increase entry memory footprint it might be worthwhile not to check it here and\n            // force subclasses that implement `build()` (freezing) operation to implement their own `MutableEntry`.\n//            this@AbstractMutableMap.checkIsMutable()\n            val oldValue = this._value\n            this._value = newValue\n            return oldValue\n        }\n\n        override fun hashCode(): Int = entryHashCode(this)\n        override fun toString(): String = entryToString(this)\n        override fun equals(other: Any?): Boolean = entryEquals(this, other)\n\n    }\n\n    // intermediate abstract class to workaround KT-43321\n    internal abstract class AbstractEntrySet<E : Map.Entry<K, V>, K, V> : AbstractMutableSet<E>() {\n        final override fun contains(element: E): Boolean = containsEntry(element)\n        abstract fun containsEntry(element: Map.Entry<K, V>): Boolean\n        final override fun remove(element: E): Boolean = removeEntry(element)\n        abstract fun removeEntry(element: Map.Entry<K, V>): Boolean\n    }\n\n    actual override fun clear() {\n        entries.clear()\n    }\n\n    private var _keys: MutableSet<K>? = null\n    actual override val keys: MutableSet<K>\n        get() {\n            if (_keys == null) {\n                _keys = object : AbstractMutableSet<K>() {\n                    override fun add(element: K): Boolean = throw UnsupportedOperationException(\"Add is not supported on keys\")\n                    override fun clear() {\n                        this@AbstractMutableMap.clear()\n                    }\n\n                    override operator fun contains(element: K): Boolean = containsKey(element)\n\n                    override operator fun iterator(): MutableIterator<K> {\n                        val entryIterator = entries.iterator()\n                        return object : MutableIterator<K> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): K = entryIterator.next().key\n                            override fun remove() = entryIterator.remove()\n                        }\n                    }\n\n                    override fun remove(element: K): Boolean {\n                        checkIsMutable()\n                        if (containsKey(element)) {\n                            this@AbstractMutableMap.remove(element)\n                            return true\n                        }\n                        return false\n                    }\n\n                    override val size: Int get() = this@AbstractMutableMap.size\n\n                    override fun checkIsMutable(): Unit = this@AbstractMutableMap.checkIsMutable()\n                }\n            }\n            return _keys!!\n        }\n\n    actual abstract override fun put(key: K, value: V): V?\n\n    actual override fun putAll(from: Map<out K, V>) {\n        checkIsMutable()\n        for ((key, value) in from) {\n            put(key, value)\n        }\n    }\n\n    private var _values: MutableCollection<V>? = null\n    actual override val values: MutableCollection<V>\n        get() {\n            if (_values == null) {\n                _values = object : AbstractMutableCollection<V>() {\n                    override fun add(element: V): Boolean = throw UnsupportedOperationException(\"Add is not supported on values\")\n                    override fun clear() = this@AbstractMutableMap.clear()\n\n                    override operator fun contains(element: V): Boolean = containsValue(element)\n\n                    override operator fun iterator(): MutableIterator<V> {\n                        val entryIterator = entries.iterator()\n                        return object : MutableIterator<V> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): V = entryIterator.next().value\n                            override fun remove() = entryIterator.remove()\n                        }\n                    }\n\n                    override val size: Int get() = this@AbstractMutableMap.size\n\n                    override fun checkIsMutable(): Unit = this@AbstractMutableMap.checkIsMutable()\n                }\n            }\n            return _values!!\n        }\n\n    actual override fun remove(key: K): V? {\n        checkIsMutable()\n        val iter = entries.iterator()\n        while (iter.hasNext()) {\n            val entry = iter.next()\n            val k = entry.key\n            if (key == k) {\n                val value = entry.value\n                iter.remove()\n                return value\n            }\n        }\n        return null\n    }\n\n\n    /**\n     * This method is called every time when a mutating method is called on this mutable map.\n     * Mutable maps that are built (frozen) must throw `UnsupportedOperationException`.\n     */\n    internal open fun checkIsMutable(): Unit {}\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the [MutableSet] interface.\n *\n * @param E the type of elements contained in the set. The set is invariant in its element type.\n */\npublic actual abstract class AbstractMutableSet<E> protected actual constructor() : AbstractMutableCollection<E>(), MutableSet<E> {\n\n    /**\n     * Compares this set with another set instance with the unordered structural equality.\n     *\n     * @return `true`, if [other] instance is a [Set] of the same size, all elements of which are contained in this set.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is Set<*>) return false\n        return AbstractSet.setEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this set.\n     */\n    override fun hashCode(): Int = AbstractSet.unorderedHashCode(this)\n\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a [MutableList] implementation, which uses a resizable array as its backing storage.\n *\n * This implementation doesn't provide a way to manage capacity, as backing JS array is resizeable itself.\n * There is no speed advantage to pre-allocating array sizes in JavaScript, so this implementation does not include any of the\n * capacity and \"growth increment\" concepts.\n */\npublic actual open class ArrayList<E> internal constructor(private var array: Array<Any?>) : AbstractMutableList<E>(), MutableList<E>, RandomAccess {\n    private var isReadOnly: Boolean = false\n\n    /**\n     * Creates an empty [ArrayList].\n     */\n    public actual constructor() : this(emptyArray()) {}\n\n    /**\n     * Creates an empty [ArrayList].\n     * @param initialCapacity initial capacity (ignored)\n     */\n    public actual constructor(initialCapacity: Int) : this(emptyArray()) {}\n\n    /**\n     * Creates an [ArrayList] filled from the [elements] collection.\n     */\n    public actual constructor(elements: Collection<E>) : this(elements.toTypedArray<Any?>()) {}\n\n    @PublishedApi\n    internal fun build(): List<E> {\n        checkIsMutable()\n        isReadOnly = true\n        return this\n    }\n\n    /** Does nothing in this ArrayList implementation. */\n    public actual fun trimToSize() {}\n\n    /** Does nothing in this ArrayList implementation. */\n    public actual fun ensureCapacity(minCapacity: Int) {}\n\n    actual override val size: Int get() = array.size\n    @Suppress(\"UNCHECKED_CAST\")\n    actual override fun get(index: Int): E = array[rangeCheck(index)] as E\n    actual override fun set(index: Int, element: E): E {\n        checkIsMutable()\n        rangeCheck(index)\n        @Suppress(\"UNCHECKED_CAST\")\n        return array[index].apply { array[index] = element } as E\n    }\n\n    actual override fun add(element: E): Boolean {\n        checkIsMutable()\n        array.asDynamic().push(element)\n        modCount++\n        return true\n    }\n\n    actual override fun add(index: Int, element: E): Unit {\n        checkIsMutable()\n        array.asDynamic().splice(insertionRangeCheck(index), 0, element)\n        modCount++\n    }\n\n    actual override fun addAll(elements: Collection<E>): Boolean {\n        checkIsMutable()\n        if (elements.isEmpty()) return false\n\n        array += elements.toTypedArray<Any?>()\n        modCount++\n        return true\n    }\n\n    actual override fun addAll(index: Int, elements: Collection<E>): Boolean {\n        checkIsMutable()\n        insertionRangeCheck(index)\n\n        if (index == size) return addAll(elements)\n        if (elements.isEmpty()) return false\n        when (index) {\n            size -> return addAll(elements)\n            0 -> array = elements.toTypedArray<Any?>() + array\n            else -> array = array.copyOfRange(0, index).asDynamic().concat(elements.toTypedArray<Any?>(), array.copyOfRange(index, size))\n        }\n\n        modCount++\n        return true\n    }\n\n    actual override fun removeAt(index: Int): E {\n        checkIsMutable()\n        rangeCheck(index)\n        modCount++\n        return if (index == lastIndex)\n            array.asDynamic().pop()\n        else\n            array.asDynamic().splice(index, 1)[0]\n    }\n\n    actual override fun remove(element: E): Boolean {\n        checkIsMutable()\n        for (index in array.indices) {\n            if (array[index] == element) {\n                array.asDynamic().splice(index, 1)\n                modCount++\n                return true\n            }\n        }\n        return false\n    }\n\n    override fun removeRange(fromIndex: Int, toIndex: Int) {\n        checkIsMutable()\n        modCount++\n        array.asDynamic().splice(fromIndex, toIndex - fromIndex)\n    }\n\n    actual override fun clear() {\n        checkIsMutable()\n        array = emptyArray()\n        modCount++\n    }\n\n\n    actual override fun indexOf(element: E): Int = array.indexOf(element)\n\n    actual override fun lastIndexOf(element: E): Int = array.lastIndexOf(element)\n\n    override fun toString() = arrayToString(array)\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun <T> toArray(array: Array<T>): Array<T> {\n        if (array.size < size) {\n            return toArray() as Array<T>\n        }\n\n        (this.array as Array<T>).copyInto(array)\n\n        if (array.size > size) {\n            array[size] = null as T // null-terminate\n        }\n\n        return array\n    }\n\n    override fun toArray(): Array<Any?> {\n        return js(\"[]\").slice.call(array)\n    }\n\n\n    internal override fun checkIsMutable() {\n        if (isReadOnly) throw UnsupportedOperationException()\n    }\n\n    private fun rangeCheck(index: Int) = index.apply {\n        AbstractList.checkElementIndex(index, size)\n    }\n\n    private fun insertionRangeCheck(index: Int) = index.apply {\n        AbstractList.checkPositionIndex(index, size)\n    }\n}","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\ninternal fun <T> sortArrayWith(array: Array<out T>, comparison: (T, T) -> Int) {\n    if (getStableSortingIsSupported()) {\n        array.asDynamic().sort(comparison)\n    } else {\n        mergeSort(array.unsafeCast<Array<T>>(), 0, array.lastIndex, Comparator(comparison))\n    }\n}\n\ninternal fun <T> sortArrayWith(array: Array<out T>, comparator: Comparator<in T>) {\n    if (getStableSortingIsSupported()) {\n        val comparison = { a: T, b: T -> comparator.compare(a, b) }\n        array.asDynamic().sort(comparison)\n    } else {\n        mergeSort(array.unsafeCast<Array<T>>(), 0, array.lastIndex, comparator)\n    }\n}\n\ninternal fun <T> sortArrayWith(array: Array<out T>, fromIndex: Int, toIndex: Int, comparator: Comparator<in T>) {\n    if (fromIndex < toIndex - 1) {\n        mergeSort(array.unsafeCast<Array<T>>(), fromIndex, toIndex - 1, comparator)\n    }\n}\n\ninternal fun <T : Comparable<T>> sortArray(array: Array<out T>) {\n    if (getStableSortingIsSupported()) {\n        val comparison = { a: T, b: T -> a.compareTo(b) }\n        array.asDynamic().sort(comparison)\n    } else {\n        mergeSort(array.unsafeCast<Array<T>>(), 0, array.lastIndex, naturalOrder())\n    }\n}\n\nprivate var _stableSortingIsSupported: Boolean? = null\nprivate fun getStableSortingIsSupported(): Boolean {\n    _stableSortingIsSupported?.let { return it }\n    _stableSortingIsSupported = false\n\n    val array = js(\"[]\").unsafeCast<Array<Int>>()\n    // known implementations may use stable sort for arrays of up to 512 elements\n    // so we create slightly more elements to test stability\n    for (index in 0 until 600) array.asDynamic().push(index)\n    val comparison = { a: Int, b: Int -> (a and 3) - (b and 3) }\n    array.asDynamic().sort(comparison)\n    for (index in 1 until array.size) {\n        val a = array[index - 1]\n        val b = array[index]\n        if ((a and 3) == (b and 3) && a >= b) return false\n    }\n    _stableSortingIsSupported = true\n    return true\n}\n\n\nprivate fun <T> mergeSort(array: Array<T>, start: Int, endInclusive: Int, comparator: Comparator<in T>) {\n    val buffer = arrayOfNulls<Any?>(array.size).unsafeCast<Array<T>>()\n    val result = mergeSort(array, buffer, start, endInclusive, comparator)\n    if (result !== array) {\n        for (i in start..endInclusive) array[i] = result[i]\n    }\n}\n\n// Both start and end are inclusive indices.\nprivate fun <T> mergeSort(array: Array<T>, buffer: Array<T>, start: Int, end: Int, comparator: Comparator<in T>): Array<T> {\n    if (start == end) {\n        return array\n    }\n\n    val median = (start + end) / 2\n    val left = mergeSort(array, buffer, start, median, comparator)\n    val right = mergeSort(array, buffer, median + 1, end, comparator)\n\n    val target = if (left === buffer) array else buffer\n\n    // Merge.\n    var leftIndex = start\n    var rightIndex = median + 1\n    for (i in start..end) {\n        when {\n            leftIndex <= median && rightIndex <= end -> {\n                val leftValue = left[leftIndex]\n                val rightValue = right[rightIndex]\n\n                if (comparator.compare(leftValue, rightValue) <= 0) {\n                    target[i] = leftValue\n                    leftIndex++\n                } else {\n                    target[i] = rightValue\n                    rightIndex++\n                }\n            }\n            leftIndex <= median -> {\n                target[i] = left[leftIndex]\n                leftIndex++\n            }\n            else /* rightIndex <= end */ -> {\n                target[i] = right[rightIndex]\n                rightIndex++\n                Unit  // TODO: Fix KT-31506\n            }\n        }\n    }\n\n    return target\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\ninternal interface EqualityComparator {\n    /**\n     * Subclasses must override to return a value indicating\n     * whether or not two keys or values are equal.\n     */\n    abstract fun equals(value1: Any?, value2: Any?): Boolean\n\n    /**\n     * Subclasses must override to return the hash code of a given key.\n     */\n    abstract fun getHashCode(value: Any?): Int\n\n\n    object HashCode : EqualityComparator {\n        override fun equals(value1: Any?, value2: Any?): Boolean = value1 == value2\n\n        override fun getHashCode(value: Any?): Int = value?.hashCode() ?: 0\n    }\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n\npublic actual fun interface Comparator<T> {\n    @JsName(\"compare\")\n    public actual fun compare(a: T, b: T): Int\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractHashMap\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\n\n/**\n * Hash table based implementation of the [MutableMap] interface.\n *\n * This implementation makes no guarantees regarding the order of enumeration of [keys], [values] and [entries] collections.\n */\n// Classes that extend HashMap and implement `build()` (freezing) operation\n// have to make sure mutating methods check `checkIsMutable`.\npublic actual open class HashMap<K, V> : AbstractMutableMap<K, V>, MutableMap<K, V> {\n\n    private inner class EntrySet : AbstractEntrySet<MutableEntry<K, V>, K, V>() {\n\n        override fun add(element: MutableEntry<K, V>): Boolean = throw UnsupportedOperationException(\"Add is not supported on entries\")\n        override fun clear() {\n            this@HashMap.clear()\n        }\n\n        override fun containsEntry(element: Map.Entry<K, V>): Boolean = this@HashMap.containsEntry(element)\n\n        override operator fun iterator(): MutableIterator<MutableEntry<K, V>> = internalMap.iterator()\n\n        override fun removeEntry(element: Map.Entry<K, V>): Boolean {\n            if (contains(element)) {\n                this@HashMap.remove(element.key)\n                return true\n            }\n            return false\n        }\n\n        override val size: Int get() = this@HashMap.size\n    }\n\n\n    /**\n     * Internal implementation of the map: either string-based or hashcode-based.\n     */\n    private val internalMap: InternalMap<K, V>\n\n    private val equality: EqualityComparator\n\n    internal constructor(internalMap: InternalMap<K, V>) : super() {\n        this.internalMap = internalMap\n        this.equality = internalMap.equality\n    }\n\n    /**\n     * Constructs an empty [HashMap] instance.\n     */\n    actual constructor() : this(InternalHashCodeMap(EqualityComparator.HashCode))\n\n    /**\n     * Constructs an empty [HashMap] instance.\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    actual constructor(initialCapacity: Int, loadFactor: Float) : this() {\n        // This implementation of HashMap has no need of load factors or capacities.\n        require(initialCapacity >= 0) { \"Negative initial capacity: $initialCapacity\" }\n        require(loadFactor >= 0) { \"Non-positive load factor: $loadFactor\" }\n    }\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n\n    /**\n     * Constructs an instance of [HashMap] filled with the contents of the specified [original] map.\n     */\n    actual constructor(original: Map<out K, V>) : this() {\n        this.putAll(original)\n    }\n\n    actual override fun clear() {\n        internalMap.clear()\n//        structureChanged(this)\n    }\n\n    actual override fun containsKey(key: K): Boolean = internalMap.contains(key)\n\n    actual override fun containsValue(value: V): Boolean = internalMap.any { equality.equals(it.value, value) }\n\n    private var _entries: MutableSet<MutableMap.MutableEntry<K, V>>? = null\n    actual override val entries: MutableSet<MutableMap.MutableEntry<K, V>>\n        get() {\n            if (_entries == null) {\n                _entries = createEntrySet()\n            }\n            return _entries!!\n        }\n\n    internal open fun createEntrySet(): MutableSet<MutableMap.MutableEntry<K, V>> = EntrySet()\n\n    actual override operator fun get(key: K): V? = internalMap.get(key)\n\n    actual override fun put(key: K, value: V): V? = internalMap.put(key, value)\n\n    actual override fun remove(key: K): V? = internalMap.remove(key)\n\n    actual override val size: Int get() = internalMap.size\n\n}\n\n/**\n * Constructs the specialized implementation of [HashMap] with [String] keys, which stores the keys as properties of\n * JS object without hashing them.\n */\npublic fun <V> stringMapOf(vararg pairs: Pair<String, V>): HashMap<String, V> {\n    return HashMap<String, V>(InternalStringMap(EqualityComparator.HashCode)).apply { putAll(pairs) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT HashSet\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * The implementation of the [MutableSet] interface, backed by a [HashMap] instance.\n */\n// Classes that extend HashSet and implement `build()` (freezing) operation\n// have to make sure mutating methods check `checkIsMutable`.\npublic actual open class HashSet<E> : AbstractMutableSet<E>, MutableSet<E> {\n\n    internal val map: HashMap<E, Any>\n\n    /**\n     * Constructs a new empty [HashSet].\n     */\n    actual constructor() {\n        map = HashMap<E, Any>()\n    }\n\n    /**\n     * Constructs a new [HashSet] filled with the elements of the specified collection.\n     */\n    actual constructor(elements: Collection<E>) {\n        map = HashMap<E, Any>(elements.size)\n        addAll(elements)\n    }\n\n    /**\n     * Constructs a new empty [HashSet].\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    actual constructor(initialCapacity: Int, loadFactor: Float) {\n        map = HashMap<E, Any>(initialCapacity, loadFactor)\n    }\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n    /**\n     * Protected constructor to specify the underlying map. This is used by\n     * LinkedHashSet.\n\n     * @param map underlying map to use.\n     */\n    internal constructor(map: HashMap<E, Any>) {\n        this.map = map\n    }\n\n    actual override fun add(element: E): Boolean {\n        val old = map.put(element, this)\n        return old == null\n    }\n\n    actual override fun clear() {\n        map.clear()\n    }\n\n//    public override fun clone(): Any {\n//        return HashSet<E>(this)\n//    }\n\n    actual override operator fun contains(element: E): Boolean = map.containsKey(element)\n\n    actual override fun isEmpty(): Boolean = map.isEmpty()\n\n    actual override fun iterator(): MutableIterator<E> = map.keys.iterator()\n\n    actual override fun remove(element: E): Boolean = map.remove(element) != null\n\n    actual override val size: Int get() = map.size\n\n}\n\n/**\n * Creates a new instance of the specialized implementation of [HashSet] with the specified [String] elements,\n * which elements the keys as properties of JS object without hashing them.\n */\npublic fun stringSetOf(vararg elements: String): HashSet<String> {\n    return HashSet(stringMapOf<Any>()).apply { addAll(elements) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT InternalHashCodeMap\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\nimport kotlin.collections.AbstractMutableMap.SimpleEntry\n\n/**\n * A simple wrapper around JavaScriptObject to provide [java.util.Map]-like semantics for any\n * key type.\n *\n *\n * Implementation notes:\n *\n *\n * A key's hashCode is the index in backingMap which should contain that key. Since several keys may\n * have the same hash, each value in hashCodeMap is actually an array containing all entries whose\n * keys share the same hash.\n */\ninternal class InternalHashCodeMap<K, V>(override val equality: EqualityComparator) : InternalMap<K, V> {\n\n    private var backingMap: dynamic = createJsMap()\n    override var size: Int = 0\n        private set\n\n    override fun put(key: K, value: V): V? {\n        val hashCode = equality.getHashCode(key)\n        val chainOrEntry = getChainOrEntryOrNull(hashCode)\n        if (chainOrEntry == null) {\n            // This is a new chain, put it to the map.\n            backingMap[hashCode] = SimpleEntry(key, value)\n        } else {\n            if (chainOrEntry !is Array<*>) {\n                // It is an entry\n                val entry: SimpleEntry<K, V> = chainOrEntry\n                if (equality.equals(entry.key, key)) {\n                    return entry.setValue(value)\n                } else {\n                    backingMap[hashCode] = arrayOf(entry, SimpleEntry(key, value))\n                    size++\n                    return null\n                }\n            } else {\n                // Chain already exists, perhaps key also exists.\n                val chain: Array<MutableEntry<K, V>> = chainOrEntry\n                val entry = chain.findEntryInChain(key)\n                if (entry != null) {\n                    return entry.setValue(value)\n                }\n                chain.asDynamic().push(SimpleEntry(key, value))\n            }\n        }\n        size++\n//        structureChanged(host)\n        return null\n    }\n\n    override fun remove(key: K): V? {\n        val hashCode = equality.getHashCode(key)\n        val chainOrEntry = getChainOrEntryOrNull(hashCode) ?: return null\n        if (chainOrEntry !is Array<*>) {\n            val entry: MutableEntry<K, V> = chainOrEntry\n            if (equality.equals(entry.key, key)) {\n                jsDeleteProperty(backingMap, hashCode)\n                size--\n                return entry.value\n            } else {\n                return null\n            }\n        } else {\n            val chain: Array<MutableEntry<K, V>> = chainOrEntry\n            for (index in chain.indices) {\n                val entry = chain[index]\n                if (equality.equals(key, entry.key)) {\n                    if (chain.size == 1) {\n                        chain.asDynamic().length = 0\n                        // remove the whole array\n                        jsDeleteProperty(backingMap, hashCode)\n                    } else {\n                        // splice out the entry we're removing\n                        chain.asDynamic().splice(index, 1)\n                    }\n                    size--\n//                structureChanged(host)\n                    return entry.value\n                }\n            }\n        }\n        return null\n    }\n\n    override fun clear() {\n        backingMap = createJsMap()\n        size = 0\n    }\n\n    override fun contains(key: K): Boolean = getEntry(key) != null\n\n    override fun get(key: K): V? = getEntry(key)?.value\n\n    private fun getEntry(key: K): MutableEntry<K, V>? {\n        val chainOrEntry = getChainOrEntryOrNull(equality.getHashCode(key)) ?: return null\n        if (chainOrEntry !is Array<*>) {\n            val entry: MutableEntry<K, V> = chainOrEntry\n            if (equality.equals(entry.key, key)) {\n                return entry\n            } else {\n                return null\n            }\n        } else {\n            val chain: Array<MutableEntry<K, V>> = chainOrEntry\n            return chain.findEntryInChain(key)\n        }\n    }\n\n    private fun Array<MutableEntry<K, V>>.findEntryInChain(key: K): MutableEntry<K, V>? =\n        firstOrNull { entry -> equality.equals(entry.key, key) }\n\n    override fun iterator(): MutableIterator<MutableEntry<K, V>> {\n\n        return object : MutableIterator<MutableEntry<K, V>> {\n            var state = -1 // -1 not ready, 0 - ready, 1 - done\n\n            val keys: Array<String> = js(\"Object\").keys(backingMap)\n            var keyIndex = -1\n\n            var chainOrEntry: dynamic = null\n            var isChain = false\n            var itemIndex = -1\n            var lastEntry: MutableEntry<K, V>? = null\n\n            private fun computeNext(): Int {\n                if (chainOrEntry != null && isChain) {\n                    val chainSize: Int = chainOrEntry.unsafeCast<Array<MutableEntry<K, V>>>().size\n                    if (++itemIndex < chainSize)\n                        return 0\n                }\n\n                if (++keyIndex < keys.size) {\n                    chainOrEntry = backingMap[keys[keyIndex]]\n                    isChain = chainOrEntry is Array<*>\n                    itemIndex = 0\n                    return 0\n                } else {\n                    chainOrEntry = null\n                    return 1\n                }\n            }\n\n            override fun hasNext(): Boolean {\n                if (state == -1)\n                    state = computeNext()\n                return state == 0\n            }\n\n            override fun next(): MutableEntry<K, V> {\n                if (!hasNext()) throw NoSuchElementException()\n                val lastEntry = if (isChain) {\n                    chainOrEntry.unsafeCast<Array<MutableEntry<K, V>>>()[itemIndex]\n                } else {\n                    chainOrEntry.unsafeCast<MutableEntry<K, V>>()\n                }\n                this.lastEntry = lastEntry\n                state = -1\n                return lastEntry\n            }\n\n            override fun remove() {\n                checkNotNull(lastEntry)\n                this@InternalHashCodeMap.remove(lastEntry!!.key)\n                lastEntry = null\n                // the chain being iterated just got modified by InternalHashCodeMap.remove\n                itemIndex--\n            }\n        }\n    }\n\n    private fun getChainOrEntryOrNull(hashCode: Int): dynamic {\n        val chainOrEntry = backingMap[hashCode]\n        return if (chainOrEntry === undefined) null else chainOrEntry\n    }\n\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT InternalStringMap\n * Copyright 2008 Google Inc.\n */\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\n\n/**\n * A simple wrapper around JavaScript Map for key type is string.\n *\n * Though this map is instantiated only with K=String, the K type is not fixed to String statically,\n * because we want to have it erased to Any? in order not to generate type-safe override bridges for\n * [get], [contains], [remove] etc, if they ever are generated.\n */\ninternal class InternalStringMap<K, V>(override val equality: EqualityComparator) : InternalMap<K, V> {\n\n    private var backingMap: dynamic = createJsMap()\n    override var size: Int = 0\n        private set\n\n//    /**\n//     * A mod count to track 'value' replacements in map to ensure that the 'value' that we have in the\n//     * iterator entry is guaranteed to be still correct.\n//     * This is to optimize for the common scenario where the values are not modified during\n//     * iterations where the entries are never stale.\n//     */\n//    private var valueMod: Int = 0\n\n    override operator fun contains(key: K): Boolean {\n        if (key !is String) return false\n        return backingMap[key] !== undefined\n    }\n\n    override operator fun get(key: K): V? {\n        if (key !is String) return null\n        val value = backingMap[key]\n        return if (value !== undefined) value.unsafeCast<V>() else null\n    }\n\n\n    override fun put(key: K, value: V): V? {\n        require(key is String)\n        val oldValue = backingMap[key]\n        backingMap[key] = value\n\n        if (oldValue === undefined) {\n            size++\n//            structureChanged(host)\n            return null\n        } else {\n//            valueMod++\n            return oldValue.unsafeCast<V>()\n        }\n    }\n\n    override fun remove(key: K): V? {\n        if (key !is String) return null\n        val value = backingMap[key]\n        if (value !== undefined) {\n            jsDeleteProperty(backingMap, key)\n            size--\n//            structureChanged(host)\n            return value.unsafeCast<V>()\n        } else {\n//            valueMod++\n            return null\n        }\n    }\n\n\n    override fun clear() {\n        backingMap = createJsMap()\n        size = 0\n    }\n\n\n    override fun iterator(): MutableIterator<MutableEntry<K, V>> {\n        return object : MutableIterator<MutableEntry<K, V>> {\n            private val keys: Array<String> = js(\"Object\").keys(backingMap)\n            private val iterator = keys.iterator()\n            private var lastKey: String? = null\n\n            override fun hasNext(): Boolean = iterator.hasNext()\n\n            override fun next(): MutableEntry<K, V> {\n                val key = iterator.next()\n                lastKey = key\n                @Suppress(\"UNCHECKED_CAST\")\n                return newMapEntry(key as K)\n            }\n\n            override fun remove() {\n                @Suppress(\"UNCHECKED_CAST\")\n                this@InternalStringMap.remove(checkNotNull(lastKey) as K)\n            }\n        }\n    }\n\n    private fun newMapEntry(key: K): MutableEntry<K, V> = object : MutableEntry<K, V> {\n        override val key: K get() = key\n        override val value: V get() = this@InternalStringMap[key].unsafeCast<V>()\n\n        override fun setValue(newValue: V): V = this@InternalStringMap.put(key, newValue).unsafeCast<V>()\n\n        override fun hashCode(): Int = AbstractMap.entryHashCode(this)\n        override fun toString(): String = AbstractMap.entryToString(this)\n        override fun equals(other: Any?): Boolean = AbstractMap.entryEquals(this, other)\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT LinkedHashMap\n * Copyright 2008 Google Inc.\n */\npackage kotlin.collections\n\nimport kotlin.collections.MutableMap.MutableEntry\n\n/**\n * Hash table based implementation of the [MutableMap] interface, which additionally preserves the insertion order\n * of entries during the iteration.\n *\n * The insertion order is preserved by maintaining a doubly-linked list of all of its entries.\n */\npublic actual open class LinkedHashMap<K, V> : HashMap<K, V>, MutableMap<K, V> {\n\n    /**\n     * The entry we use includes next/prev pointers for a doubly-linked circular\n     * list with a head node. This reduces the special cases we have to deal with\n     * in the list operations.\n\n     * Note that we duplicate the key from the underlying hash map so we can find\n     * the eldest entry. The alternative would have been to modify HashMap so more\n     * of the code was directly usable here, but this would have added some\n     * overhead to HashMap, or to reimplement most of the HashMap code here with\n     * small modifications. Paying a small storage cost only if you use\n     * LinkedHashMap and minimizing code size seemed like a better tradeoff\n     */\n    private inner class ChainEntry<K, V>(key: K, value: V) : AbstractMutableMap.SimpleEntry<K, V>(key, value) {\n        internal var next: ChainEntry<K, V>? = null\n        internal var prev: ChainEntry<K, V>? = null\n\n        override fun setValue(newValue: V): V {\n            this@LinkedHashMap.checkIsMutable()\n            return super.setValue(newValue)\n        }\n    }\n\n    private inner class EntrySet : AbstractEntrySet<MutableEntry<K, V>, K, V>() {\n\n        private inner class EntryIterator : MutableIterator<MutableEntry<K, V>> {\n            // The last entry that was returned from this iterator.\n            private var last: ChainEntry<K, V>? = null\n\n            // The next entry to return from this iterator.\n            private var next: ChainEntry<K, V>? = null\n\n            init {\n                next = head\n//                recordLastKnownStructure(map, this)\n            }\n\n            override fun hasNext(): Boolean {\n                return next !== null\n            }\n\n            override fun next(): MutableEntry<K, V> {\n//                checkStructuralChange(map, this)\n                if (!hasNext()) throw NoSuchElementException()\n\n                val current = next!!\n                last = current\n                next = current.next.takeIf { it !== head }\n                return current\n            }\n\n            override fun remove() {\n                check(last != null)\n                this@EntrySet.checkIsMutable()\n//                checkStructuralChange(map, this)\n\n                last!!.remove()\n                map.remove(last!!.key)\n//                recordLastKnownStructure(map, this)\n                last = null\n            }\n        }\n\n        override fun add(element: MutableEntry<K, V>): Boolean = throw UnsupportedOperationException(\"Add is not supported on entries\")\n        override fun clear() {\n            this@LinkedHashMap.clear()\n        }\n\n        override fun containsEntry(element: Map.Entry<K, V>): Boolean = this@LinkedHashMap.containsEntry(element)\n\n        override operator fun iterator(): MutableIterator<MutableEntry<K, V>> = EntryIterator()\n\n        override fun removeEntry(element: Map.Entry<K, V>): Boolean {\n            checkIsMutable()\n            if (contains(element)) {\n                this@LinkedHashMap.remove(element.key)\n                return true\n            }\n            return false\n        }\n\n        override val size: Int get() = this@LinkedHashMap.size\n\n        override fun checkIsMutable(): Unit = this@LinkedHashMap.checkIsMutable()\n    }\n\n\n    /*\n   * The head of the insert order chain, which is a doubly-linked circular\n   * list.\n   *\n   * The most recently inserted node is at the end of the chain, ie.\n   * chain.prev.\n   */\n    private var head: ChainEntry<K, V>? = null\n\n    /**\n     * Add this node to the end of the chain.\n     */\n    private fun ChainEntry<K, V>.addToEnd() {\n        // This entry is not in the list.\n        check(next == null && prev == null)\n\n        val _head = head\n        if (_head == null) {\n            head = this\n            next = this\n            prev = this\n        } else {\n            // Chain is valid.\n            val _tail = checkNotNull(_head.prev)\n            // Update me.\n            prev = _tail\n            next = _head\n            // Update my new siblings: current head and old tail\n            _head.prev = this\n            _tail.next = this\n        }\n    }\n\n    /**\n     * Remove this node from the chain it is a part of.\n     */\n    private fun ChainEntry<K, V>.remove() {\n        if (this.next === this) {\n            // if this is single element, remove head\n            head = null\n        } else {\n            if (head === this) {\n                // if this is first element, move head to next\n                head = next\n            }\n            next!!.prev = prev\n            prev!!.next = next\n        }\n        next = null\n        prev = null\n    }\n\n    /*\n   * The hashmap that keeps track of our entries and the chain. Note that we\n   * duplicate the key here to eliminate changes to HashMap and minimize the\n   * code here, at the expense of additional space.\n   */\n    private val map: HashMap<K, ChainEntry<K, V>>\n\n    private var isReadOnly: Boolean = false\n\n    /**\n     * Constructs an empty [LinkedHashMap] instance.\n     */\n    actual constructor() : super() {\n        map = HashMap<K, ChainEntry<K, V>>()\n    }\n\n    internal constructor(backingMap: HashMap<K, Any>) : super() {\n        @Suppress(\"UNCHECKED_CAST\") // expected to work due to erasure\n        map = backingMap as HashMap<K, ChainEntry<K, V>>\n    }\n\n    /**\n     * Constructs an empty [LinkedHashMap] instance.\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    actual constructor(initialCapacity: Int, loadFactor: Float) : super(initialCapacity, loadFactor) {\n        map = HashMap<K, ChainEntry<K, V>>()\n    }\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n    /**\n     * Constructs an instance of [LinkedHashMap] filled with the contents of the specified [original] map.\n     */\n    actual constructor(original: Map<out K, V>) {\n        map = HashMap<K, ChainEntry<K, V>>()\n        this.putAll(original)\n    }\n\n    @PublishedApi\n    internal fun build(): Map<K, V> {\n        checkIsMutable()\n        isReadOnly = true\n        return this\n    }\n\n    actual override fun clear() {\n        checkIsMutable()\n        map.clear()\n        head = null\n    }\n\n\n//    override fun clone(): Any {\n//        return LinkedHashMap(this)\n//    }\n\n\n    actual override fun containsKey(key: K): Boolean = map.containsKey(key)\n\n    actual override fun containsValue(value: V): Boolean {\n        var node: ChainEntry<K, V> = head ?: return false\n        do {\n            if (node.value == value) {\n                return true\n            }\n            node = node.next!!\n        } while (node !== head)\n        return false\n    }\n\n\n    internal override fun createEntrySet(): MutableSet<MutableMap.MutableEntry<K, V>> = EntrySet()\n\n    actual override operator fun get(key: K): V? = map.get(key)?.value\n\n    actual override fun put(key: K, value: V): V? {\n        checkIsMutable()\n\n        val old = map.get(key)\n        if (old == null) {\n            val newEntry = ChainEntry(key, value)\n            map.put(key, newEntry)\n            newEntry.addToEnd()\n            return null\n        } else {\n            return old.setValue(value)\n        }\n    }\n\n    actual override fun remove(key: K): V? {\n        checkIsMutable()\n\n        val entry = map.remove(key)\n        if (entry != null) {\n            entry.remove()\n            return entry.value\n        }\n        return null\n    }\n\n    actual override val size: Int get() = map.size\n\n    internal override fun checkIsMutable() {\n        if (isReadOnly) throw UnsupportedOperationException()\n    }\n}\n\n/**\n * Constructs the specialized implementation of [LinkedHashMap] with [String] keys, which stores the keys as properties of\n * JS object without hashing them.\n */\npublic fun <V> linkedStringMapOf(vararg pairs: Pair<String, V>): LinkedHashMap<String, V> {\n    return LinkedHashMap<String, V>(stringMapOf<Any>()).apply { putAll(pairs) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n/*\n * Based on GWT LinkedHashSet\n * Copyright 2008 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * The implementation of the [MutableSet] interface, backed by a [LinkedHashMap] instance.\n *\n * This implementation preserves the insertion order of elements during the iteration.\n */\npublic actual open class LinkedHashSet<E> : HashSet<E>, MutableSet<E> {\n\n    internal constructor(map: LinkedHashMap<E, Any>) : super(map)\n\n    /**\n     * Constructs a new empty [LinkedHashSet].\n     */\n    actual constructor() : super(LinkedHashMap<E, Any>())\n\n    /**\n     * Constructs a new [LinkedHashSet] filled with the elements of the specified collection.\n     */\n    actual constructor(elements: Collection<E>) : super(LinkedHashMap<E, Any>()) {\n        addAll(elements)\n    }\n\n    /**\n     * Constructs a new empty [LinkedHashSet].\n     *\n     * @param  initialCapacity the initial capacity (ignored)\n     * @param  loadFactor      the load factor (ignored)\n     *\n     * @throws IllegalArgumentException if the initial capacity or load factor are negative\n     */\n    actual constructor(initialCapacity: Int, loadFactor: Float) : super(LinkedHashMap<E, Any>(initialCapacity, loadFactor))\n\n    actual constructor(initialCapacity: Int) : this(initialCapacity, 0.0f)\n\n    @PublishedApi\n    internal fun build(): Set<E> {\n        (map as LinkedHashMap<E, Any>).build()\n        return this\n    }\n\n    internal override fun checkIsMutable(): Unit = map.checkIsMutable()\n\n//    public override fun clone(): Any {\n//        return LinkedHashSet(this)\n//    }\n\n}\n\n/**\n * Creates a new instance of the specialized implementation of [LinkedHashSet] with the specified [String] elements,\n * which elements the keys as properties of JS object without hashing them.\n */\npublic fun linkedStringSetOf(vararg elements: String): LinkedHashSet<String> {\n    return LinkedHashSet(linkedStringMapOf<Any>()).apply { addAll(elements) }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.io\n\ninternal abstract class BaseOutput {\n    open fun println() {\n        print(\"\\n\")\n    }\n\n    open fun println(message: Any?) {\n        print(message)\n        println()\n    }\n\n    abstract fun print(message: Any?)\n\n    open fun flush() {}\n}\n\n/** JsName used to make the declaration available outside of module to test it */\n@JsName(\"NodeJsOutput\")\ninternal class NodeJsOutput(val outputStream: dynamic) : BaseOutput() {\n    override fun print(message: Any?) {\n        // TODO: Using local variable because of bug in block decomposition lowering in IR backend\n        val messageString = String(message)\n        outputStream.write(messageString)\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it */\n@JsName(\"OutputToConsoleLog\")\ninternal class OutputToConsoleLog : BaseOutput() {\n    override fun print(message: Any?) {\n        console.log(message)\n    }\n\n    override fun println(message: Any?) {\n        console.log(message)\n    }\n\n    override fun println() {\n        console.log(\"\")\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it and use at try.kotl.in */\n@JsName(\"BufferedOutput\")\ninternal open class BufferedOutput : BaseOutput() {\n    var buffer = \"\"\n\n    override fun print(message: Any?) {\n        buffer += String(message)\n    }\n\n    override fun flush() {\n        buffer = \"\"\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it */\n@JsName(\"BufferedOutputToConsoleLog\")\ninternal class BufferedOutputToConsoleLog : BufferedOutput() {\n    override fun print(message: Any?) {\n        var s = String(message)\n        val i = s.nativeLastIndexOf(\"\\n\", 0)\n        if (i >= 0) {\n            buffer += s.substring(0, i)\n            flush()\n            s = s.substring(i + 1)\n        }\n        buffer += s\n    }\n\n    override fun flush() {\n        console.log(buffer)\n        buffer = \"\"\n    }\n}\n\n/** JsName used to make the declaration available outside of module to test it and use at try.kotl.in */\n@JsName(\"output\")\ninternal var output = run {\n    val isNode: Boolean = js(\"typeof process !== 'undefined' && process.versions && !!process.versions.node\")\n    if (isNode) NodeJsOutput(js(\"process.stdout\")) else BufferedOutputToConsoleLog()\n}\n\n@kotlin.internal.InlineOnly\nprivate inline fun String(value: Any?): String = js(\"String\")(value)\n\n/** Prints the line separator to the standard output stream. */\npublic actual fun println() {\n    output.println()\n}\n\n/** Prints the given [message] and the line separator to the standard output stream. */\npublic actual fun println(message: Any?) {\n    output.println(message)\n}\n\n/** Prints the given [message] to the standard output stream. */\npublic actual fun print(message: Any?) {\n    output.print(message)\n}\n\n@SinceKotlin(\"1.6\")\npublic actual fun readln(): String = throw UnsupportedOperationException(\"readln is not supported in Kotlin/JS\")\n\n@SinceKotlin(\"1.6\")\npublic actual fun readlnOrNull(): String? = throw UnsupportedOperationException(\"readlnOrNull is not supported in Kotlin/JS\")","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.coroutines.intrinsics.CoroutineSingletons.*\nimport kotlin.coroutines.intrinsics.COROUTINE_SUSPENDED\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal actual class SafeContinuation<in T>\ninternal actual constructor(\n    private val delegate: Continuation<T>,\n    initialResult: Any?\n) : Continuation<T> {\n    @PublishedApi\n    internal actual constructor(delegate: Continuation<T>) : this(delegate, UNDECIDED)\n\n    public actual override val context: CoroutineContext\n        get() = delegate.context\n\n    private var result: Any? = initialResult\n\n    public actual override fun resumeWith(result: Result<T>) {\n        val cur = this.result\n        when {\n            cur === UNDECIDED -> {\n                this.result = result.value\n            }\n            cur === COROUTINE_SUSPENDED -> {\n                this.result = RESUMED\n                delegate.resumeWith(result)\n            }\n            else -> throw IllegalStateException(\"Already resumed\")\n        }\n    }\n\n    @PublishedApi\n    internal actual fun getOrThrow(): Any? {\n        if (result === UNDECIDED) {\n            result = COROUTINE_SUSPENDED\n            return COROUTINE_SUSPENDED\n        }\n        val result = this.result\n        return when {\n            result === RESUMED -> COROUTINE_SUSPENDED // already called continuation, indicate COROUTINE_SUSPENDED upstream\n            result is Result.Failure -> throw result.exception\n            else -> result // either COROUTINE_SUSPENDED or data\n        }\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\n@JsName(\"throwNPE\")\ninternal fun throwNPE(message: String) {\n    throw NullPointerException(message)\n}\n\n@JsName(\"throwCCE\")\ninternal fun throwCCE() {\n    throw ClassCastException(\"Illegal cast\")\n}\n\n@JsName(\"throwISE\")\ninternal fun throwISE(message: String) {\n    throw IllegalStateException(message)\n}\n\n@JsName(\"throwUPAE\")\ninternal fun throwUPAE(propertyName: String) {\n    throw UninitializedPropertyAccessException(\"lateinit property ${propertyName} has not been initialized\")\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.math\n\n\nimport kotlin.internal.InlineOnly\nimport kotlin.js.JsMath as nativeMath\n\n\n// region ================ Double Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Double): Double = nativeMath.sin(x)\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Double): Double = nativeMath.cos(x)\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Double): Double = nativeMath.tan(x)\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Double): Double = nativeMath.asin(x)\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Double): Double = nativeMath.acos(x)\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Double): Double = nativeMath.atan(x)\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Double, x: Double): Double = nativeMath.atan2(y, x)\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Double): Double = nativeMath.sinh(x)\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Double): Double = nativeMath.cosh(x)\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Double): Double = nativeMath.tanh(x)\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Double): Double = nativeMath.asinh(x)\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Double): Double = nativeMath.acosh(x)\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Double): Double = nativeMath.atanh(x)\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Double, y: Double): Double = nativeMath.hypot(x, y)\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Double): Double = nativeMath.sqrt(x)\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Double): Double = nativeMath.exp(x)\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Double): Double = nativeMath.expm1(x)\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\npublic actual fun log(x: Double, base: Double): Double {\n    if (base <= 0.0 || base == 1.0) return Double.NaN\n    return nativeMath.log(x) / nativeMath.log(base)\n}\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Double): Double = nativeMath.log(x)\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Double): Double = nativeMath.log10(x)\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Double): Double = nativeMath.log2(x)\n\n/**\n * Computes `ln(x + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Double): Double = nativeMath.log1p(x)\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest double value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Double): Double = nativeMath.ceil(x)\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest double value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Double): Double = nativeMath.floor(x)\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Double): Double = nativeMath.trunc(x)\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun round(x: Double): Double {\n    if (x % 0.5 != 0.0) {\n        return nativeMath.round(x)\n    }\n    val floor = floor(x)\n    return if (floor % 2 == 0.0) floor else ceil(x)\n}\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Double]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Double): Double = nativeMath.abs(x)\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Double): Double = nativeMath.sign(x)\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Double, b: Double): Double = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Double, b: Double): Double = nativeMath.max(a, b)\n\n// extensions\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(x: Double): Double = nativeMath.pow(this, x)\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.pow(n: Int): Double = nativeMath.pow(this, n.toDouble())\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.absoluteValue: Double get() = nativeMath.abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Double.sign: Double get() = nativeMath.sign(this)\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Double.withSign(sign: Int): Double = this.withSign(sign.toDouble())\n\n/**\n * Returns the ulp (unit in the last place) of this value.\n *\n * An ulp is a positive distance between this value and the next nearest [Double] value larger in magnitude.\n *\n * Special Cases:\n *   - `NaN.ulp` is `NaN`\n *   - `x.ulp` is `+Inf` when `x` is `+Inf` or `-Inf`\n *   - `0.0.ulp` is `Double.MIN_VALUE`\n */\n@SinceKotlin(\"1.2\")\npublic actual val Double.ulp: Double get() = when {\n    this < 0 -> (-this).ulp\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == Double.MAX_VALUE -> this - this.nextDown()\n    else -> this.nextUp() - this\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of positive infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextUp(): Double = when {\n    this.isNaN() || this == Double.POSITIVE_INFINITY -> this\n    this == 0.0 -> Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) 1 else -1)\n}\n\n/**\n * Returns the [Double] value nearest to this value in direction of negative infinity.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextDown(): Double = when {\n    this.isNaN() || this == Double.NEGATIVE_INFINITY -> this\n    this == 0.0 -> -Double.MIN_VALUE\n    else -> Double.fromBits(this.toRawBits() + if (this > 0) -1 else 1)\n}\n\n\n/**\n * Returns the [Double] value nearest to this value in direction from this value towards the value [to].\n *\n * Special cases:\n *   - `x.nextTowards(y)` is `NaN` if either `x` or `y` are `NaN`\n *   - `x.nextTowards(x) == x`\n *\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.nextTowards(to: Double): Double = when {\n    this.isNaN() || to.isNaN() -> Double.NaN\n    to == this -> to\n    to > this -> this.nextUp()\n    else /* to < this */ -> this.nextDown()\n}\n\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToInt(): Int = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Int.MAX_VALUE -> Int.MAX_VALUE\n    this < Int.MIN_VALUE -> Int.MIN_VALUE\n    else -> nativeMath.round(this).toInt()\n}\n\n/**\n * Rounds this [Double] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Double.roundToLong(): Long = when {\n    isNaN() -> throw IllegalArgumentException(\"Cannot round NaN value.\")\n    this > Long.MAX_VALUE -> Long.MAX_VALUE\n    this < Long.MIN_VALUE -> Long.MIN_VALUE\n    else -> nativeMath.round(this).toLong()\n}\n\n// endregion\n\n\n\n// region ================ Float Math ========================================\n\n/** Computes the sine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `sin(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sin(x: Float): Float = nativeMath.sin(x.toDouble()).toFloat()\n\n/** Computes the cosine of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `cos(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cos(x: Float): Float = nativeMath.cos(x.toDouble()).toFloat()\n\n/** Computes the tangent of the angle [x] given in radians.\n *\n *  Special cases:\n *   - `tan(NaN|+Inf|-Inf)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tan(x: Float): Float = nativeMath.tan(x.toDouble()).toFloat()\n\n/**\n * Computes the arc sine of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *    - `asin(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asin(x: Float): Float = nativeMath.asin(x.toDouble()).toFloat()\n\n/**\n * Computes the arc cosine of the value [x];\n * the returned value is an angle in the range from `0.0` to `PI` radians.\n *\n * Special cases:\n *    - `acos(x)` is `NaN`, when `abs(x) > 1` or x is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acos(x: Float): Float = nativeMath.acos(x.toDouble()).toFloat()\n\n/**\n * Computes the arc tangent of the value [x];\n * the returned value is an angle in the range from `-PI/2` to `PI/2` radians.\n *\n * Special cases:\n *   - `atan(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan(x: Float): Float = nativeMath.atan(x.toDouble()).toFloat()\n\n/**\n * Returns the angle `theta` of the polar coordinates `(r, theta)` that correspond\n * to the rectangular coordinates `(x, y)` by computing the arc tangent of the value [y] / [x];\n * the returned value is an angle in the range from `-PI` to `PI` radians.\n *\n * Special cases:\n *   - `atan2(0.0, 0.0)` is `0.0`\n *   - `atan2(0.0, x)` is  `0.0` for `x > 0` and `PI` for `x < 0`\n *   - `atan2(-0.0, x)` is `-0.0` for 'x > 0` and `-PI` for `x < 0`\n *   - `atan2(y, +Inf)` is `0.0` for `0 < y < +Inf` and `-0.0` for '-Inf < y < 0`\n *   - `atan2(y, -Inf)` is `PI` for `0 < y < +Inf` and `-PI` for `-Inf < y < 0`\n *   - `atan2(y, 0.0)` is `PI/2` for `y > 0` and `-PI/2` for `y < 0`\n *   - `atan2(+Inf, x)` is `PI/2` for finite `x`y\n *   - `atan2(-Inf, x)` is `-PI/2` for finite `x`\n *   - `atan2(NaN, x)` and `atan2(y, NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atan2(y: Float, x: Float): Float = nativeMath.atan2(y.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic sine of the value [x].\n *\n * Special cases:\n *   - `sinh(NaN)` is `NaN`\n *   - `sinh(+Inf)` is `+Inf`\n *   - `sinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sinh(x: Float): Float = nativeMath.sinh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic cosine of the value [x].\n *\n * Special cases:\n *   - `cosh(NaN)` is `NaN`\n *   - `cosh(+Inf|-Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun cosh(x: Float): Float = nativeMath.cosh(x.toDouble()).toFloat()\n\n/**\n * Computes the hyperbolic tangent of the value [x].\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(+Inf)` is `1.0`\n *   - `tanh(-Inf)` is `-1.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun tanh(x: Float): Float = nativeMath.tanh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic sine of the value [x].\n *\n * The returned value is `y` such that `sinh(y) == x`.\n *\n * Special cases:\n *   - `asinh(NaN)` is `NaN`\n *   - `asinh(+Inf)` is `+Inf`\n *   - `asinh(-Inf)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun asinh(x: Float): Float = nativeMath.asinh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic cosine of the value [x].\n *\n * The returned value is positive `y` such that `cosh(y) == x`.\n *\n * Special cases:\n *   - `acosh(NaN)` is `NaN`\n *   - `acosh(x)` is `NaN` when `x < 1`\n *   - `acosh(+Inf)` is `+Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun acosh(x: Float): Float = nativeMath.acosh(x.toDouble()).toFloat()\n\n/**\n * Computes the inverse hyperbolic tangent of the value [x].\n *\n * The returned value is `y` such that `tanh(y) == x`.\n *\n * Special cases:\n *   - `tanh(NaN)` is `NaN`\n *   - `tanh(x)` is `NaN` when `x > 1` or `x < -1`\n *   - `tanh(1.0)` is `+Inf`\n *   - `tanh(-1.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun atanh(x: Float): Float = nativeMath.atanh(x.toDouble()).toFloat()\n\n/**\n * Computes `sqrt(x^2 + y^2)` without intermediate overflow or underflow.\n *\n * Special cases:\n *   - returns `+Inf` if any of arguments is infinite\n *   - returns `NaN` if any of arguments is `NaN` and the other is not infinite\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun hypot(x: Float, y: Float): Float = nativeMath.hypot(x.toDouble(), y.toDouble()).toFloat()\n\n/**\n * Computes the positive square root of the value [x].\n *\n * Special cases:\n *   - `sqrt(x)` is `NaN` when `x < 0` or `x` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sqrt(x: Float): Float = nativeMath.sqrt(x.toDouble()).toFloat()\n\n/**\n * Computes Euler's number `e` raised to the power of the value [x].\n *\n * Special cases:\n *   - `exp(NaN)` is `NaN`\n *   - `exp(+Inf)` is `+Inf`\n *   - `exp(-Inf)` is `0.0`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun exp(x: Float): Float = nativeMath.exp(x.toDouble()).toFloat()\n\n/**\n * Computes `exp(x) - 1`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `expm1(NaN)` is `NaN`\n *   - `expm1(+Inf)` is `+Inf`\n *   - `expm1(-Inf)` is `-1.0`\n *\n * @see [exp] function.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun expm1(x: Float): Float = nativeMath.expm1(x.toDouble()).toFloat()\n\n/**\n * Computes the logarithm of the value [x] to the given [base].\n *\n * Special cases:\n *   - `log(x, b)` is `NaN` if either `x` or `b` are `NaN`\n *   - `log(x, b)` is `NaN` when `x < 0` or `b <= 0` or `b == 1.0`\n *   - `log(+Inf, +Inf)` is `NaN`\n *   - `log(+Inf, b)` is `+Inf` for `b > 1` and `-Inf` for `b < 1`\n *   - `log(0.0, b)` is `-Inf` for `b > 1` and `+Inf` for `b > 1`\n *\n * See also logarithm functions for common fixed bases: [ln], [log10] and [log2].\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log(x: Float, base: Float): Float = log(x.toDouble(), base.toDouble()).toFloat()\n\n/**\n * Computes the natural logarithm (base `E`) of the value [x].\n *\n * Special cases:\n *   - `ln(NaN)` is `NaN`\n *   - `ln(x)` is `NaN` when `x < 0.0`\n *   - `ln(+Inf)` is `+Inf`\n *   - `ln(0.0)` is `-Inf`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln(x: Float): Float = nativeMath.log(x.toDouble()).toFloat()\n\n/**\n * Computes the common logarithm (base 10) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log10(x: Float): Float = nativeMath.log10(x.toDouble()).toFloat()\n\n/**\n * Computes the binary logarithm (base 2) of the value [x].\n *\n * @see [ln] function for special cases.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun log2(x: Float): Float = nativeMath.log2(x.toDouble()).toFloat()\n\n/**\n * Computes `ln(a + 1)`.\n *\n * This function can be implemented to produce more precise result for [x] near zero.\n *\n * Special cases:\n *   - `ln1p(NaN)` is `NaN`\n *   - `ln1p(x)` is `NaN` where `x < -1.0`\n *   - `ln1p(-1.0)` is `-Inf`\n *   - `ln1p(+Inf)` is `+Inf`\n *\n * @see [ln] function\n * @see [expm1] function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ln1p(x: Float): Float = nativeMath.log1p(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards positive infinity.\n\n * @return the smallest Float value that is greater than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `ceil(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun ceil(x: Float): Float = nativeMath.ceil(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards negative infinity.\n\n * @return the largest Float value that is smaller than or equal to the given value [x] and is a mathematical integer.\n *\n * Special cases:\n *   - `floor(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun floor(x: Float): Float = nativeMath.floor(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] to an integer towards zero.\n *\n * @return the value [x] having its fractional part truncated.\n *\n * Special cases:\n *   - `truncate(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun truncate(x: Float): Float = truncate(x.toDouble()).toFloat()\n\n/**\n * Rounds the given value [x] towards the closest integer with ties rounded towards even integer.\n *\n * Special cases:\n *   - `round(x)` is `x` where `x` is `NaN` or `+Inf` or `-Inf` or already a mathematical integer.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun round(x: Float): Float = round(x.toDouble()).toFloat()\n\n\n/**\n * Returns the absolute value of the given value [x].\n *\n * Special cases:\n *   - `abs(NaN)` is `NaN`\n *\n * @see absoluteValue extension property for [Float]\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun abs(x: Float): Float = nativeMath.abs(x.toDouble()).toFloat()\n\n/**\n * Returns the sign of the given value [x]:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `sign(NaN)` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun sign(x: Float): Float = nativeMath.sign(x.toDouble()).toFloat()\n\n\n\n/**\n * Returns the smaller of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Float, b: Float): Float = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n *\n * If either value is `NaN`, then the result is `NaN`.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Float, b: Float): Float = nativeMath.max(a, b)\n\n// extensions\n\n\n/**\n * Raises this value to the power [x].\n *\n * Special cases:\n *   - `b.pow(0.0)` is `1.0`\n *   - `b.pow(1.0) == b`\n *   - `b.pow(NaN)` is `NaN`\n *   - `NaN.pow(x)` is `NaN` for `x != 0.0`\n *   - `b.pow(Inf)` is `NaN` for `abs(b) == 1.0`\n *   - `b.pow(x)` is `NaN` for `b < 0` and `x` is finite and not an integer\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(x: Float): Float = nativeMath.pow(this.toDouble(), x.toDouble()).toFloat()\n\n/**\n * Raises this value to the integer power [n].\n *\n * See the other overload of [pow] for details.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.pow(n: Int): Float = nativeMath.pow(this.toDouble(), n.toDouble()).toFloat()\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `NaN.absoluteValue` is `NaN`\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.absoluteValue: Float get() = nativeMath.abs(this.toDouble()).toFloat()\n\n/**\n * Returns the sign of this value:\n *   - `-1.0` if the value is negative,\n *   - zero if the value is zero,\n *   - `1.0` if the value is positive\n *\n * Special case:\n *   - `NaN.sign` is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Float.sign: Float get() = nativeMath.sign(this.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n *\n * If [sign] is `NaN` the sign of the result is undefined.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Float): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n/**\n * Returns this value with the sign bit same as of the [sign] value.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.withSign(sign: Int): Float = this.toDouble().withSign(sign.toDouble()).toFloat()\n\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Int].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToInt() == Int.MAX_VALUE` when `x > Int.MAX_VALUE`\n *   - `x.roundToInt() == Int.MIN_VALUE` when `x < Int.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToInt(): Int = toDouble().roundToInt()\n\n/**\n * Rounds this [Float] value to the nearest integer and converts the result to [Long].\n * Ties are rounded towards positive infinity.\n *\n * Special cases:\n *   - `x.roundToLong() == Long.MAX_VALUE` when `x > Long.MAX_VALUE`\n *   - `x.roundToLong() == Long.MIN_VALUE` when `x < Long.MIN_VALUE`\n *\n * @throws IllegalArgumentException when this value is `NaN`\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun Float.roundToLong(): Long = toDouble().roundToLong()\n\n\n// endregion\n\n// region ================ Integer Math ========================================\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Int.MIN_VALUE)` is `Int.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Int]\n */\n// TODO: remove manual 'or' when KT-19290 is fixed\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Int): Int = if (n < 0) (-n or 0) else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun min(a: Int, b: Int): Int = nativeMath.min(a, b)\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline fun max(a: Int, b: Int): Int = nativeMath.max(a, b)\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Int.MIN_VALUE.absoluteValue` is `Int.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Int.absoluteValue: Int get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Int.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n\n/**\n * Returns the absolute value of the given value [n].\n *\n * Special cases:\n *   - `abs(Long.MIN_VALUE)` is `Long.MIN_VALUE` due to an overflow\n *\n * @see absoluteValue extension property for [Long]\n */\n@SinceKotlin(\"1.2\")\npublic actual fun abs(n: Long): Long = if (n < 0) -n else n\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun min(a: Long, b: Long): Long = if (a <= b) a else b\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun max(a: Long, b: Long): Long = if (a >= b) a else b\n\n/**\n * Returns the absolute value of this value.\n *\n * Special cases:\n *   - `Long.MIN_VALUE.absoluteValue` is `Long.MIN_VALUE` due to an overflow\n *\n * @see abs function\n */\n@SinceKotlin(\"1.2\")\n@InlineOnly\npublic actual inline val Long.absoluteValue: Long get() = abs(this)\n\n/**\n * Returns the sign of this value:\n *   - `-1` if the value is negative,\n *   - `0` if the value is zero,\n *   - `1` if the value is positive\n */\n@SinceKotlin(\"1.2\")\npublic actual val Long.sign: Int get() = when {\n    this < 0 -> -1\n    this > 0 -> 1\n    else -> 0\n}\n\n\n// endregion\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n\n/**\n * Returns a bit representation of the specified floating-point value as [Long]\n * according to the IEEE 754 floating-point \"double format\" bit layout.\n */\n@SinceKotlin(\"1.2\")\n@library(\"doubleToBits\")\npublic actual fun Double.toBits(): Long = definedExternally\n\n/**\n * Returns a bit representation of the specified floating-point value as [Long]\n * according to the IEEE 754 floating-point \"double format\" bit layout,\n * preserving `NaN` values exact layout.\n */\n@SinceKotlin(\"1.2\")\n@library(\"doubleToRawBits\")\npublic actual fun Double.toRawBits(): Long = definedExternally\n\n/**\n * Returns the [Double] value corresponding to a given bit representation.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Double.Companion.fromBits(bits: Long): Double = js(\"Kotlin\").doubleFromBits(bits).unsafeCast<Double>()\n\n/**\n * Returns a bit representation of the specified floating-point value as [Int]\n * according to the IEEE 754 floating-point \"single format\" bit layout.\n *\n * Note that in Kotlin/JS [Float] range is wider than \"single format\" bit layout can represent,\n * so some [Float] values may overflow, underflow or loose their accuracy after conversion to bits and back.\n */\n@SinceKotlin(\"1.2\")\n@library(\"floatToBits\")\npublic actual fun Float.toBits(): Int = definedExternally\n\n/**\n * Returns a bit representation of the specified floating-point value as [Int]\n * according to the IEEE 754 floating-point \"single format\" bit layout,\n * preserving `NaN` values exact layout.\n *\n * Note that in Kotlin/JS [Float] range is wider than \"single format\" bit layout can represent,\n * so some [Float] values may overflow, underflow or loose their accuracy after conversion to bits and back.\n */\n@SinceKotlin(\"1.2\")\n@library(\"floatToRawBits\")\npublic actual fun Float.toRawBits(): Int = definedExternally\n\n/**\n * Returns the [Float] value corresponding to a given bit representation.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Float.Companion.fromBits(bits: Int): Float = js(\"Kotlin\").floatFromBits(bits).unsafeCast<Float>()\n\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun Long(low: Int, high: Int) = js(\"Kotlin\").Long.fromBits(low, high).unsafeCast<Long>()\ninternal inline val Long.low: Int get() = this.asDynamic().getLowBits().unsafeCast<Int>()\ninternal inline val Long.high: Int get() = this.asDynamic().getHighBits().unsafeCast<Int>()\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n/**\n * Returns `true` if the specified number is a\n * Not-a-Number (NaN) value, `false` otherwise.\n */\npublic actual fun Double.isNaN(): Boolean = this != this\n\n/**\n * Returns `true` if the specified number is a\n * Not-a-Number (NaN) value, `false` otherwise.\n */\npublic actual fun Float.isNaN(): Boolean = this != this\n\n/**\n * Returns `true` if this value is infinitely large in magnitude.\n */\npublic actual fun Double.isInfinite(): Boolean = this == Double.POSITIVE_INFINITY || this == Double.NEGATIVE_INFINITY\n\n/**\n * Returns `true` if this value is infinitely large in magnitude.\n */\npublic actual fun Float.isInfinite(): Boolean = this == Float.POSITIVE_INFINITY || this == Float.NEGATIVE_INFINITY\n\n/**\n * Returns `true` if the argument is a finite floating-point value; returns `false` otherwise (for `NaN` and infinity arguments).\n */\npublic actual fun Double.isFinite(): Boolean = !isInfinite() && !isNaN()\n\n/**\n * Returns `true` if the argument is a finite floating-point value; returns `false` otherwise (for `NaN` and infinity arguments).\n */\npublic actual fun Float.isFinite(): Boolean = !isInfinite() && !isNaN()\n\n\n/**\n * Counts the number of set bits in the binary representation of this [Int] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.countOneBits(): Int {\n    // Hacker's Delight 5-1 algorithm\n    var v = this\n    v = (v and 0x55555555) + (v.ushr(1) and 0x55555555)\n    v = (v and 0x33333333) + (v.ushr(2) and 0x33333333)\n    v = (v and 0x0F0F0F0F) + (v.ushr(4) and 0x0F0F0F0F)\n    v = (v and 0x00FF00FF) + (v.ushr(8) and 0x00FF00FF)\n    v = (v and 0x0000FFFF) + (v.ushr(16))\n    return v\n}\n\n/**\n * Counts the number of consecutive most significant bits that are zero in the binary representation of this [Int] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Int.countLeadingZeroBits(): Int = JsMath.clz32(this)\n\n/**\n * Counts the number of consecutive least significant bits that are zero in the binary representation of this [Int] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.countTrailingZeroBits(): Int =\n    // Hacker's Delight 5-4 algorithm for expressing countTrailingZeroBits with countLeadingZeroBits\n    Int.SIZE_BITS - (this or -this).inv().countLeadingZeroBits()\n\n/**\n * Returns a number having a single bit set in the position of the most significant set bit of this [Int] number,\n * or zero, if this number is zero.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.takeHighestOneBit(): Int =\n    if (this == 0) 0 else 1.shl(Int.SIZE_BITS - 1 - countLeadingZeroBits())\n\n/**\n * Returns a number having a single bit set in the position of the least significant set bit of this [Int] number,\n * or zero, if this number is zero.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.takeLowestOneBit(): Int =\n    // Hacker's Delight 2-1 algorithm for isolating rightmost 1-bit\n    this and -this\n\n/**\n * Rotates the binary representation of this [Int] number left by the specified [bitCount] number of bits.\n * The most significant bits pushed out from the left side reenter the number as the least significant bits on the right side.\n *\n * Rotating the number left by a negative bit count is the same as rotating it right by the negated bit count:\n * `number.rotateLeft(-n) == number.rotateRight(n)`\n *\n * Rotating by a multiple of [Int.SIZE_BITS] (32) returns the same number, or more generally\n * `number.rotateLeft(n) == number.rotateLeft(n % 32)`\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.rotateLeft(bitCount: Int): Int =\n    shl(bitCount) or ushr(Int.SIZE_BITS - bitCount)\n\n\n/**\n * Rotates the binary representation of this [Int] number right by the specified [bitCount] number of bits.\n * The least significant bits pushed out from the right side reenter the number as the most significant bits on the left side.\n *\n * Rotating the number right by a negative bit count is the same as rotating it left by the negated bit count:\n * `number.rotateRight(-n) == number.rotateLeft(n)`\n *\n * Rotating by a multiple of [Int.SIZE_BITS] (32) returns the same number, or more generally\n * `number.rotateRight(n) == number.rotateRight(n % 32)`\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Int.rotateRight(bitCount: Int): Int =\n    shl(Int.SIZE_BITS - bitCount) or ushr(bitCount)\n\n\n/**\n * Counts the number of set bits in the binary representation of this [Long] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.countOneBits(): Int =\n    high.countOneBits() + low.countOneBits()\n\n/**\n * Counts the number of consecutive most significant bits that are zero in the binary representation of this [Long] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.countLeadingZeroBits(): Int =\n    when (val high = this.high) {\n        0 -> Int.SIZE_BITS + low.countLeadingZeroBits()\n        else -> high.countLeadingZeroBits()\n    }\n\n/**\n * Counts the number of consecutive least significant bits that are zero in the binary representation of this [Long] number.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.countTrailingZeroBits(): Int =\n    when (val low = this.low) {\n        0 -> Int.SIZE_BITS + high.countTrailingZeroBits()\n        else -> low.countTrailingZeroBits()\n    }\n\n/**\n * Returns a number having a single bit set in the position of the most significant set bit of this [Long] number,\n * or zero, if this number is zero.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.takeHighestOneBit(): Long =\n    when (val high = this.high) {\n        0 -> Long(low.takeHighestOneBit(), 0)\n        else -> Long(0, high.takeHighestOneBit())\n    }\n\n/**\n * Returns a number having a single bit set in the position of the least significant set bit of this [Long] number,\n * or zero, if this number is zero.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.takeLowestOneBit(): Long =\n    when (val low = this.low) {\n        0 -> Long(0, high.takeLowestOneBit())\n        else -> Long(low.takeLowestOneBit(), 0)\n    }\n\n/**\n * Rotates the binary representation of this [Long] number left by the specified [bitCount] number of bits.\n * The most significant bits pushed out from the left side reenter the number as the least significant bits on the right side.\n *\n * Rotating the number left by a negative bit count is the same as rotating it right by the negated bit count:\n * `number.rotateLeft(-n) == number.rotateRight(n)`\n *\n * Rotating by a multiple of [Long.SIZE_BITS] (64) returns the same number, or more generally\n * `number.rotateLeft(n) == number.rotateLeft(n % 64)`\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Long.rotateLeft(bitCount: Int): Long {\n    if ((bitCount and 31) != 0) {\n        val low = this.low\n        val high = this.high\n        val newLow = low.shl(bitCount) or high.ushr(-bitCount)\n        val newHigh = high.shl(bitCount) or low.ushr(-bitCount)\n        return if ((bitCount and 32) == 0) Long(newLow, newHigh) else Long(newHigh, newLow)\n    } else {\n        return if ((bitCount and 32) == 0) this else Long(high, low)\n    }\n}\n\n\n/**\n * Rotates the binary representation of this [Long] number right by the specified [bitCount] number of bits.\n * The least significant bits pushed out from the right side reenter the number as the most significant bits on the left side.\n *\n * Rotating the number right by a negative bit count is the same as rotating it left by the negated bit count:\n * `number.rotateRight(-n) == number.rotateLeft(n)`\n *\n * Rotating by a multiple of [Long.SIZE_BITS] (64) returns the same number, or more generally\n * `number.rotateRight(n) == number.rotateRight(n % 64)`\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Long.rotateRight(bitCount: Int): Long = rotateLeft(-bitCount)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.random\n\nimport kotlin.math.pow\n\ninternal actual fun defaultPlatformRandom(): Random =\n    Random(js(\"(Math.random() * Math.pow(2, 32)) | 0\").unsafeCast<Int>())\n\n\nprivate val INV_2_26: Double = 2.0.pow(-26)\nprivate val INV_2_53: Double = 2.0.pow(-53)\ninternal actual fun doubleFromParts(hi26: Int, low27: Int): Double =\n    hi26 * INV_2_26 + low27 * INV_2_53","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect.js.internal\n\nimport kotlin.reflect.*\n\ninternal abstract class KClassImpl<T : Any>(\n    internal open val jClass: JsClass<T>\n) : KClass<T> {\n\n    override val qualifiedName: String?\n        get() = TODO()\n\n    override fun equals(other: Any?): Boolean {\n        return other is KClassImpl<*> && jClass == other.jClass\n    }\n\n    // TODO: use FQN\n    override fun hashCode(): Int = simpleName?.hashCode() ?: 0\n\n    override fun toString(): String {\n        // TODO: use FQN\n        return \"class $simpleName\"\n    }\n}\n\ninternal class SimpleKClassImpl<T : Any>(jClass: JsClass<T>) : KClassImpl<T>(jClass) {\n    override val simpleName: String? = jClass.asDynamic().`$metadata$`?.simpleName.unsafeCast<String?>()\n\n    override fun isInstance(value: Any?): Boolean {\n        return jsIsType(value, jClass)\n    }\n}\n\ninternal class PrimitiveKClassImpl<T : Any>(\n    jClass: JsClass<T>,\n    private val givenSimpleName: String,\n    private val isInstanceFunction: (Any?) -> Boolean\n) : KClassImpl<T>(jClass) {\n    override fun equals(other: Any?): Boolean {\n        if (other !is PrimitiveKClassImpl<*>) return false\n        return super.equals(other) && givenSimpleName == other.givenSimpleName\n    }\n\n    override val simpleName: String? get() = givenSimpleName\n\n    override fun isInstance(value: Any?): Boolean {\n        return isInstanceFunction(value)\n    }\n}\n\ninternal object NothingKClassImpl : KClassImpl<Nothing>(js(\"Object\")) {\n    override val simpleName: String = \"Nothing\"\n\n    override fun isInstance(value: Any?): Boolean = false\n\n    override val jClass: JsClass<Nothing>\n        get() = throw UnsupportedOperationException(\"There's no native JS class for Nothing type\")\n\n    override fun equals(other: Any?): Boolean = other === this\n\n    override fun hashCode(): Int = 0\n}\n\ninternal class ErrorKClass : KClass<Nothing> {\n    override val simpleName: String? get() = error(\"Unknown simpleName for ErrorKClass\")\n    override val qualifiedName: String? get() = error(\"Unknown qualifiedName for ErrorKClass\")\n\n    override fun isInstance(value: Any?): Boolean = error(\"Can's check isInstance on ErrorKClass\")\n\n    override fun equals(other: Any?): Boolean = other === this\n\n    override fun hashCode(): Int = 0\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.collections\n\n/**\n * The common interface of [InternalStringMap] and [InternalHashCodeMap].\n */\ninternal interface InternalMap<K, V> : MutableIterable<MutableMap.MutableEntry<K, V>> {\n    val equality: EqualityComparator\n    val size: Int\n    operator fun contains(key: K): Boolean\n    operator fun get(key: K): V?\n\n    fun put(key: K, value: V): V?\n    fun remove(key: K): V?\n    fun clear(): Unit\n\n    fun createJsMap(): dynamic {\n        val result = js(\"Object.create(null)\")\n        // force to switch object representation to dictionary mode\n        result[\"foo\"] = 1\n        jsDeleteProperty(result, \"foo\")\n        return result\n    }\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. Use of this source code is governed by the Apache 2.0 license\n * that can be found in the license/LICENSE.txt file.\n */\n\n\n@file:Suppress(\"UNUSED_PARAMETER\")\n\npackage kotlin.js\n\n@kotlin.internal.InlineOnly\ninternal inline fun jsDeleteProperty(obj: Any, property: Any) {\n    js(\"delete obj[property]\")\n}\n\n@kotlin.internal.InlineOnly\ninternal inline fun jsBitwiseOr(lhs: Any?, rhs: Any?): Int =\n    js(\"lhs | rhs\").unsafeCast<Int>()","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Converts the characters in the specified array to a string.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString() instead\", ReplaceWith(\"chars.concatToString()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic actual fun String(chars: CharArray): String {\n    var result = \"\"\n    for (char in chars) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Converts the characters from a portion of the specified array to a string.\n *\n * @throws IndexOutOfBoundsException if either [offset] or [length] are less than zero\n * or `offset + length` is out of [chars] array bounds.\n */\n@SinceKotlin(\"1.2\")\n@Deprecated(\"Use CharArray.concatToString(startIndex, endIndex) instead\", ReplaceWith(\"chars.concatToString(offset, offset + length)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\")\npublic actual fun String(chars: CharArray, offset: Int, length: Int): String {\n    if (offset < 0 || length < 0 || chars.size - offset < length)\n        throw IndexOutOfBoundsException(\"size: ${chars.size}; offset: $offset; length: $length\")\n    var result = \"\"\n    for (index in offset until offset + length) {\n        result += chars[index]\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] into a String.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun CharArray.concatToString(): String {\n    var result = \"\"\n    for (char in this) {\n        result += char\n    }\n    return result\n}\n\n/**\n * Concatenates characters in this [CharArray] or its subrange into a String.\n *\n * @param startIndex the beginning (inclusive) of the subrange of characters, 0 by default.\n * @param endIndex the end (exclusive) of the subrange of characters, size of this array by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharArray.concatToString(startIndex: Int = 0, endIndex: Int = this.size): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    var result = \"\"\n    for (index in startIndex until endIndex) {\n        result += this[index]\n    }\n    return result\n}\n\n/**\n * Returns a [CharArray] containing characters of this string.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.toCharArray(): CharArray {\n    return CharArray(length) { get(it) }\n}\n\n/**\n * Returns a [CharArray] containing characters of this string or its substring.\n *\n * @param startIndex the beginning (inclusive) of the substring, 0 by default.\n * @param endIndex the end (exclusive) of the substring, length of this string by default.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.toCharArray(startIndex: Int = 0, endIndex: Int = this.length): CharArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return CharArray(endIndex - startIndex) { get(startIndex + it) }\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array.\n *\n * Malformed byte sequences are replaced by the replacement char `\\uFFFD`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun ByteArray.decodeToString(): String {\n    return decodeUtf8(this, 0, size, false)\n}\n\n/**\n * Decodes a string from the bytes in UTF-8 encoding in this array or its subrange.\n *\n * @param startIndex the beginning (inclusive) of the subrange to decode, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to decode, size of this array by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed byte sequence or replace it by the replacement char `\\uFFFD`.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if the byte array contains malformed UTF-8 byte sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun ByteArray.decodeToString(\n    startIndex: Int = 0,\n    endIndex: Int = this.size,\n    throwOnInvalidSequence: Boolean = false\n): String {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, this.size)\n    return decodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Encodes this string to an array of bytes in UTF-8 encoding.\n *\n * Any malformed char sequence is replaced by the replacement byte sequence.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun String.encodeToByteArray(): ByteArray {\n    return encodeUtf8(this, 0, length, false)\n}\n\n/**\n * Encodes this string or its substring to an array of bytes in UTF-8 encoding.\n *\n * @param startIndex the beginning (inclusive) of the substring to encode, 0 by default.\n * @param endIndex the end (exclusive) of the substring to encode, length of this string by default.\n * @param throwOnInvalidSequence specifies whether to throw an exception on malformed char sequence or replace.\n *\n * @throws IndexOutOfBoundsException if [startIndex] is less than zero or [endIndex] is greater than the length of this string.\n * @throws IllegalArgumentException if [startIndex] is greater than [endIndex].\n * @throws CharacterCodingException if this string contains malformed char sequence and [throwOnInvalidSequence] is true.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.encodeToByteArray(\n    startIndex: Int = 0,\n    endIndex: Int = this.length,\n    throwOnInvalidSequence: Boolean = false\n): ByteArray {\n    AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n    return encodeUtf8(this, startIndex, endIndex, throwOnInvalidSequence)\n}\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n */\n@Deprecated(\"Use uppercase() instead.\", ReplaceWith(\"uppercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toUpperCase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun String.uppercase(): String = asDynamic().toUpperCase()\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n */\n@Deprecated(\"Use lowercase() instead.\", ReplaceWith(\"lowercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toLowerCase(): String = asDynamic().toLowerCase()\n\n/**\n * Returns a copy of this string converted to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun String.lowercase(): String = asDynamic().toLowerCase()\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(str: String, fromIndex: Int): Int = asDynamic().indexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(str: String, fromIndex: Int): Int = asDynamic().lastIndexOf(str, fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeStartsWith(s: String, position: Int): Boolean = asDynamic().startsWith(s, position)\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeEndsWith(s: String): Boolean = asDynamic().endsWith(s)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int): String = asDynamic().substring(startIndex)\n\n@kotlin.internal.InlineOnly\npublic actual inline fun String.substring(startIndex: Int, endIndex: Int): String = asDynamic().substring(startIndex, endIndex)\n\n@Deprecated(\"Use String.plus() instead\", ReplaceWith(\"this + str\"))\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun String.concat(str: String): String = asDynamic().concat(str)\n\n@Deprecated(\"Use Regex.findAll() instead or invoke matches() on String dynamically: this.asDynamic().match(regex)\")\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun String.match(regex: String): Array<String>? = asDynamic().match(regex)\n\n//native public fun String.trim(): String\n//TODO: String.replace to implement effective trimLeading and trimTrailing\n\n@kotlin.internal.InlineOnly\ninternal inline fun String.nativeReplace(pattern: RegExp, replacement: String): String = asDynamic().replace(pattern, replacement)\n\n/**\n * Compares two strings lexicographically, optionally ignoring case differences.\n *\n * If [ignoreCase] is true, the result of `Char.uppercaseChar().lowercaseChar()` on each character is compared.\n */\n@SinceKotlin(\"1.2\")\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.compareTo(other: String, ignoreCase: Boolean = false): Int {\n    if (ignoreCase) {\n        val n1 = this.length\n        val n2 = other.length\n        val min = minOf(n1, n2)\n        if (min == 0) return n1 - n2\n        for (index in 0 until min) {\n            var thisChar = this[index]\n            var otherChar = other[index]\n\n            if (thisChar != otherChar) {\n                thisChar = thisChar.uppercaseChar()\n                otherChar = otherChar.uppercaseChar()\n\n                if (thisChar != otherChar) {\n                    thisChar = thisChar.lowercaseChar()\n                    otherChar = otherChar.lowercaseChar()\n\n                    if (thisChar != otherChar) {\n                        return thisChar.compareTo(otherChar)\n                    }\n                }\n            }\n        }\n        return n1 - n2\n    } else {\n        return compareTo(other)\n    }\n}\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other],\n * i.e. both char sequences contain the same number of the same characters in the same order.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic actual infix fun CharSequence?.contentEquals(other: CharSequence?): Boolean = contentEqualsImpl(other)\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other], optionally ignoring case difference.\n *\n * @param ignoreCase `true` to ignore character case when comparing contents.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic actual fun CharSequence?.contentEquals(other: CharSequence?, ignoreCase: Boolean): Boolean {\n    return if (ignoreCase)\n        this.contentEqualsIgnoreCaseImpl(other)\n    else\n        this.contentEqualsImpl(other)\n}\n\n\nprivate val STRING_CASE_INSENSITIVE_ORDER = Comparator<String> { a, b -> a.compareTo(b, ignoreCase = true) }\n\n@SinceKotlin(\"1.2\")\npublic actual val String.Companion.CASE_INSENSITIVE_ORDER: Comparator<String>\n    get() = STRING_CASE_INSENSITIVE_ORDER\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect.js.internal\n\nimport kotlin.reflect.*\n\ninternal class KTypeImpl(\n    override val classifier: KClassifier,\n    override val arguments: List<KTypeProjection>,\n    override val isMarkedNullable: Boolean\n) : KType {\n    override fun equals(other: Any?): Boolean =\n        other is KTypeImpl &&\n                classifier == other.classifier && arguments == other.arguments && isMarkedNullable == other.isMarkedNullable\n\n    override fun hashCode(): Int =\n        (classifier.hashCode() * 31 + arguments.hashCode()) * 31 + isMarkedNullable.hashCode()\n\n    override fun toString(): String {\n        val kClass = (classifier as? KClass<*>)\n        val classifierName = when {\n            kClass == null -> classifier.toString()\n            kClass.simpleName != null -> kClass.simpleName\n            else -> \"(non-denotable type)\"\n        }\n\n        val args =\n            if (arguments.isEmpty()) \"\"\n            else arguments.joinToString(\", \", \"<\", \">\") { it.asString() }\n        val nullable = if (isMarkedNullable) \"?\" else \"\"\n\n        return classifierName + args + nullable\n    }\n\n    // TODO: this should be the implementation of KTypeProjection.toString, see KT-30071\n    private fun KTypeProjection.asString(): String {\n        if (variance == null) return \"*\"\n        return variance.prefixString() + type.toString()\n    }\n}\n\ninternal object DynamicKType : KType {\n    override val classifier: KClassifier? = null\n    override val arguments: List<KTypeProjection> = emptyList()\n    override val isMarkedNullable: Boolean = false\n    override fun toString(): String = \"dynamic\"\n}\n\ninternal fun KVariance.prefixString() =\n    when (this) {\n        KVariance.INVARIANT -> \"\"\n        KVariance.IN -> \"in \"\n        KVariance.OUT -> \"out \"\n    }\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.reflect.js.internal\n\nimport kotlin.js.JsClass\n\n@JsName(\"PrimitiveClasses\")\ninternal object PrimitiveClasses {\n    @JsName(\"anyClass\")\n    val anyClass = PrimitiveKClassImpl(js(\"Object\").unsafeCast<JsClass<Any>>(), \"Any\", { it is Any })\n\n    @JsName(\"numberClass\")\n    val numberClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Number>>(), \"Number\", { it is Number })\n\n    @JsName(\"nothingClass\")\n    val nothingClass = NothingKClassImpl\n\n    @JsName(\"booleanClass\")\n    val booleanClass = PrimitiveKClassImpl(js(\"Boolean\").unsafeCast<JsClass<Boolean>>(), \"Boolean\", { it is Boolean })\n\n    @JsName(\"byteClass\")\n    val byteClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Byte>>(), \"Byte\", { it is Byte })\n\n    @JsName(\"shortClass\")\n    val shortClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Short>>(), \"Short\", { it is Short })\n\n    @JsName(\"intClass\")\n    val intClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Int>>(), \"Int\", { it is Int })\n\n    @JsName(\"floatClass\")\n    val floatClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Float>>(), \"Float\", { it is Float })\n\n    @JsName(\"doubleClass\")\n    val doubleClass = PrimitiveKClassImpl(js(\"Number\").unsafeCast<JsClass<Double>>(), \"Double\", { it is Double })\n\n    @JsName(\"arrayClass\")\n    val arrayClass = PrimitiveKClassImpl(js(\"Array\").unsafeCast<JsClass<Array<*>>>(), \"Array\", { it is Array<*> })\n\n    @JsName(\"stringClass\")\n    val stringClass = PrimitiveKClassImpl(js(\"String\").unsafeCast<JsClass<String>>(), \"String\", { it is String })\n\n    @JsName(\"throwableClass\")\n    val throwableClass = PrimitiveKClassImpl(js(\"Error\").unsafeCast<JsClass<Throwable>>(), \"Throwable\", { it is Throwable })\n\n    @JsName(\"booleanArrayClass\")\n    val booleanArrayClass = PrimitiveKClassImpl(js(\"Array\").unsafeCast<JsClass<BooleanArray>>(), \"BooleanArray\", { it is BooleanArray })\n\n    @JsName(\"charArrayClass\")\n    val charArrayClass = PrimitiveKClassImpl(js(\"Uint16Array\").unsafeCast<JsClass<CharArray>>(), \"CharArray\", { it is CharArray })\n\n    @JsName(\"byteArrayClass\")\n    val byteArrayClass = PrimitiveKClassImpl(js(\"Int8Array\").unsafeCast<JsClass<ByteArray>>(), \"ByteArray\", { it is ByteArray })\n\n    @JsName(\"shortArrayClass\")\n    val shortArrayClass = PrimitiveKClassImpl(js(\"Int16Array\").unsafeCast<JsClass<ShortArray>>(), \"ShortArray\", { it is ShortArray })\n\n    @JsName(\"intArrayClass\")\n    val intArrayClass = PrimitiveKClassImpl(js(\"Int32Array\").unsafeCast<JsClass<IntArray>>(), \"IntArray\", { it is IntArray })\n\n    @JsName(\"longArrayClass\")\n    val longArrayClass = PrimitiveKClassImpl(js(\"Array\").unsafeCast<JsClass<LongArray>>(), \"LongArray\", { it is LongArray })\n\n    @JsName(\"floatArrayClass\")\n    val floatArrayClass = PrimitiveKClassImpl(js(\"Float32Array\").unsafeCast<JsClass<FloatArray>>(), \"FloatArray\", { it is FloatArray })\n\n    @JsName(\"doubleArrayClass\")\n    val doubleArrayClass = PrimitiveKClassImpl(js(\"Float64Array\").unsafeCast<JsClass<DoubleArray>>(), \"DoubleArray\", { it is DoubleArray })\n\n    @JsName(\"functionClass\")\n    fun functionClass(arity: Int): KClassImpl<Any> {\n        return functionClasses.get(arity) ?: run {\n            val result = PrimitiveKClassImpl(js(\"Function\").unsafeCast<JsClass<Any>>(), \"Function$arity\",\n                                             { jsTypeOf(it) === \"function\" && it.asDynamic().length === arity })\n            functionClasses.asDynamic()[arity] = result\n            result\n        }\n    }\n}\n\nprivate val functionClasses = arrayOfNulls<KClassImpl<Any>>(0)","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\nimport kotlin.reflect.*\nimport kotlin.reflect.js.internal.*\n\n@JsName(\"getKClass\")\ninternal fun <T : Any> getKClass(jClass: Any /* JsClass<T> | Array<JsClass<T>> */): KClass<T> {\n    return if (js(\"Array\").isArray(jClass)) {\n        getKClassM(jClass.unsafeCast<Array<JsClass<T>>>())\n    } else {\n        getKClass1(jClass.unsafeCast<JsClass<T>>())\n    }\n}\n\n@JsName(\"getKClassM\")\ninternal fun <T : Any> getKClassM(jClasses: Array<JsClass<T>>): KClass<T> = when (jClasses.size) {\n    1 -> getKClass1(jClasses[0])\n    0 -> NothingKClassImpl.unsafeCast<KClass<T>>()\n    else -> ErrorKClass().unsafeCast<KClass<T>>()\n}\n\n@JsName(\"getKClassFromExpression\")\ninternal fun <T : Any> getKClassFromExpression(e: T): KClass<T> =\n    when (jsTypeOf(e)) {\n        \"string\" -> PrimitiveClasses.stringClass\n        \"number\" -> if (jsBitwiseOr(e, 0).asDynamic() === e) PrimitiveClasses.intClass else PrimitiveClasses.doubleClass\n        \"boolean\" -> PrimitiveClasses.booleanClass\n        \"function\" -> PrimitiveClasses.functionClass(e.asDynamic().length)\n        else -> {\n            when {\n                e is BooleanArray -> PrimitiveClasses.booleanArrayClass\n                e is CharArray -> PrimitiveClasses.charArrayClass\n                e is ByteArray -> PrimitiveClasses.byteArrayClass\n                e is ShortArray -> PrimitiveClasses.shortArrayClass\n                e is IntArray -> PrimitiveClasses.intArrayClass\n                e is LongArray -> PrimitiveClasses.longArrayClass\n                e is FloatArray -> PrimitiveClasses.floatArrayClass\n                e is DoubleArray -> PrimitiveClasses.doubleArrayClass\n                e is KClass<*> -> KClass::class\n                e is Array<*> -> PrimitiveClasses.arrayClass\n                else -> {\n                    val constructor = js(\"Object\").getPrototypeOf(e).constructor\n                    when {\n                        constructor === js(\"Object\") -> PrimitiveClasses.anyClass\n                        constructor === js(\"Error\") -> PrimitiveClasses.throwableClass\n                        else -> {\n                            val jsClass: JsClass<T> = constructor\n                            getKClass1(jsClass)\n                        }\n                    }\n                }\n            }\n        }\n    }.unsafeCast<KClass<T>>()\n\n@JsName(\"getKClass1\")\ninternal fun <T : Any> getKClass1(jClass: JsClass<T>): KClass<T> {\n    if (jClass === js(\"String\")) return PrimitiveClasses.stringClass.unsafeCast<KClass<T>>()\n\n    val metadata = jClass.asDynamic().`$metadata$`\n\n    return if (metadata != null) {\n        if (metadata.`$kClass$` == null) {\n            val kClass = SimpleKClassImpl(jClass)\n            metadata.`$kClass$` = kClass\n            kClass\n        } else {\n            metadata.`$kClass$`\n        }\n    } else {\n        SimpleKClassImpl(jClass)\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.js\n\n/**\n * Exposes the JavaScript [RegExp object](https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/RegExp) to Kotlin.\n */\n@Suppress(\"NOT_DOCUMENTED\")\npublic external class RegExp(pattern: String, flags: String? = definedExternally) {\n\n    public fun test(str: String): Boolean\n\n    public fun exec(str: String): RegExpMatch?\n\n    public override fun toString(): String\n\n    /**\n     * The lastIndex is a read/write integer property of regular expressions that specifies the index at which to start the next match.\n     */\n    public var lastIndex: Int\n\n    public val global: Boolean\n    public val ignoreCase: Boolean\n    public val multiline: Boolean\n}\n\n/**\n * Resets the regular expression so that subsequent [RegExp.test] and [RegExp.exec] calls will match starting with the beginning of the input string.\n */\npublic fun RegExp.reset() {\n    lastIndex = 0\n}\n\n// TODO: Inherit from array or introduce asArray() extension\n/**\n * Represents the return value of [RegExp.exec].\n */\n@Suppress(\"NOT_DOCUMENTED\")\npublic external interface RegExpMatch {\n    public val index: Int\n    public val input: String\n    public val length: Int\n}\n\n/**\n * Returns the entire text matched by [RegExp.exec] if the [index] parameter is 0, or the text matched by the capturing parenthesis\n * at the given index.\n */\npublic inline operator fun RegExpMatch.get(index: Int): String? = asDynamic()[index]\n\n/**\n * Converts the result of [RegExp.exec] to an array where the first element contains the entire matched text and each subsequent\n * element is the text matched by each capturing parenthesis.\n */\npublic inline fun RegExpMatch.asArray(): Array<out String?> = unsafeCast<Array<out String?>>()\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/**\n *  The exception thrown when a character encoding or decoding error occurs.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual open class CharacterCodingException(message: String?) : Exception(message) {\n    actual constructor() : this(null)\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/**\n * A mutable sequence of characters.\n *\n * String builder can be used to efficiently perform multiple string manipulation operations.\n */\npublic actual class StringBuilder actual constructor(content: String) : Appendable, CharSequence {\n    /**\n     * Constructs an empty string builder with the specified initial [capacity].\n     *\n     * In Kotlin/JS implementation of StringBuilder the initial capacity has no effect on the further performance of operations.\n     */\n    actual constructor(capacity: Int) : this() {\n    }\n\n    /** Constructs a string builder that contains the same characters as the specified [content] char sequence. */\n    actual constructor(content: CharSequence) : this(content.toString()) {}\n\n    /** Constructs an empty string builder. */\n    actual constructor() : this(\"\")\n\n    private var string: String = if (content !== undefined) content else \"\"\n\n    actual override val length: Int\n        get() = string.asDynamic().length\n\n    actual override fun get(index: Int): Char =\n        string.getOrElse(index) { throw IndexOutOfBoundsException(\"index: $index, length: $length}\") }\n\n    actual override fun subSequence(startIndex: Int, endIndex: Int): CharSequence = string.substring(startIndex, endIndex)\n\n    actual override fun append(value: Char): StringBuilder {\n        string += value\n        return this\n    }\n\n    actual override fun append(value: CharSequence?): StringBuilder {\n        string += value.toString()\n        return this\n    }\n\n    actual override fun append(value: CharSequence?, startIndex: Int, endIndex: Int): StringBuilder =\n        this.appendRange(value ?: \"null\", startIndex, endIndex)\n\n    /**\n     * Reverses the contents of this string builder and returns this instance.\n     *\n     * Surrogate pairs included in this string builder are treated as single characters.\n     * Therefore, the order of the high-low surrogates is never reversed.\n     *\n     * Note that the reverse operation may produce new surrogate pairs that were unpaired low-surrogates and high-surrogates before the operation.\n     * For example, reversing `\"\\uDC00\\uD800\"` produces `\"\\uD800\\uDC00\"` which is a valid surrogate pair.\n     */\n    actual fun reverse(): StringBuilder {\n        var reversed = \"\"\n        var index = string.length - 1\n        while (index >= 0) {\n            val low = string[index--]\n            if (low.isLowSurrogate() && index >= 0) {\n                val high = string[index--]\n                if (high.isHighSurrogate()) {\n                    reversed = reversed + high + low\n                } else {\n                    reversed = reversed + low + high\n                }\n            } else {\n                reversed += low\n            }\n        }\n        string = reversed\n        return this\n    }\n\n    /**\n     * Appends the string representation of the specified object [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    actual fun append(value: Any?): StringBuilder {\n        string += value.toString()\n        return this\n    }\n\n    /**\n     * Appends the string representation of the specified boolean [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    actual fun append(value: Boolean): StringBuilder {\n        string += value\n        return this\n    }\n\n    /**\n     * Appends characters in the specified character array [value] to this string builder and returns this instance.\n     *\n     * Characters are appended in order, starting at the index 0.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun append(value: CharArray): StringBuilder {\n        string += value.concatToString()\n        return this\n    }\n\n    @Deprecated(\"Provided for binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun append(value: String): StringBuilder = append(value)\n\n    /**\n     * Appends the specified string [value] to this string builder and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are appended.\n     */\n    @SinceKotlin(\"1.3\")\n    actual fun append(value: String?): StringBuilder {\n        this.string += value ?: \"null\"\n        return this\n    }\n\n    /**\n     * Returns the current capacity of this string builder.\n     *\n     * The capacity is the maximum length this string builder can have before an allocation occurs.\n     *\n     * In Kotlin/JS implementation of StringBuilder the value returned from this method may not indicate the actual size of the backing storage.\n     */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    @Deprecated(\"Obtaining StringBuilder capacity is not supported in JS and common code.\", level = DeprecationLevel.ERROR)\n    actual fun capacity(): Int = length\n\n    /**\n     * Ensures that the capacity of this string builder is at least equal to the specified [minimumCapacity].\n     *\n     * If the current capacity is less than the [minimumCapacity], a new backing storage is allocated with greater capacity.\n     * Otherwise, this method takes no action and simply returns.\n     *\n     * In Kotlin/JS implementation of StringBuilder the size of the backing storage is not extended to comply the given [minimumCapacity],\n     * thus calling this method has no effect on the further performance of operations.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun ensureCapacity(minimumCapacity: Int) {\n    }\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun indexOf(string: String): Int = this.string.asDynamic().indexOf(string)\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string],\n     * starting at the specified [startIndex].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun indexOf(string: String, startIndex: Int): Int = this.string.asDynamic().indexOf(string, startIndex)\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string].\n     * The last occurrence of empty string `\"\"` is considered to be at the index equal to `this.length`.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun lastIndexOf(string: String): Int = this.string.asDynamic().lastIndexOf(string)\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string],\n     * starting from the specified [startIndex] toward the beginning.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun lastIndexOf(string: String, startIndex: Int): Int {\n        if (string.isEmpty() && startIndex < 0) return -1\n        return this.string.asDynamic().lastIndexOf(string, startIndex)\n    }\n\n    /**\n     * Inserts the string representation of the specified boolean [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: Boolean): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts the specified character [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: Char): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts characters in the specified character array [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in same order as in the [value] character array, starting at [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: CharArray): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value.concatToString() + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts characters in the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the character sequence from which characters are inserted. If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: CharSequence?): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value.toString() + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts the string representation of the specified object [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: Any?): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        string = string.substring(0, index) + value.toString() + string.substring(index)\n        return this\n    }\n\n    @Deprecated(\"Provided for binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    fun insert(index: Int, value: String): StringBuilder = insert(index, value)\n\n    /**\n     * Inserts the string [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun insert(index: Int, value: String?): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        val toInsert = value ?: \"null\"\n        this.string = this.string.substring(0, index) + toInsert + this.string.substring(index)\n        return this\n    }\n\n    /**\n     *  Sets the length of this string builder to the specified [newLength].\n     *\n     *  If the [newLength] is less than the current length, it is changed to the specified [newLength].\n     *  Otherwise, null characters '\\u0000' are appended to this string builder until its length is less than the [newLength].\n     *\n     *  Note that in Kotlin/JS [set] operator function has non-constant execution time complexity.\n     *  Therefore, increasing length of this string builder and then updating each character by index may slow down your program.\n     *\n     *  @throws IndexOutOfBoundsException or [IllegalArgumentException] if [newLength] is less than zero.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun setLength(newLength: Int) {\n        if (newLength < 0) {\n            throw IllegalArgumentException(\"Negative new length: $newLength.\")\n        }\n\n        if (newLength <= length) {\n            string = string.substring(0, newLength)\n        } else {\n            for (i in length until newLength) {\n                string += '\\u0000'\n            }\n        }\n    }\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [length] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun substring(startIndex: Int): String {\n        AbstractList.checkPositionIndex(startIndex, length)\n\n        return string.substring(startIndex)\n    }\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [endIndex] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun substring(startIndex: Int, endIndex: Int): String {\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n\n        return string.substring(startIndex, endIndex)\n    }\n\n    /**\n     * Attempts to reduce storage used for this string builder.\n     *\n     * If the backing storage of this string builder is larger than necessary to hold its current contents,\n     * then it may be resized to become more space efficient.\n     * Calling this method may, but is not required to, affect the value of the [capacity] property.\n     *\n     * In Kotlin/JS implementation of StringBuilder the size of the backing storage is always equal to the length of the string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    actual fun trimToSize() {\n    }\n\n    override fun toString(): String = string\n\n    /**\n     * Clears the content of this string builder making it empty and returns this instance.\n     *\n     * @sample samples.text.Strings.clearStringBuilder\n     */\n    @SinceKotlin(\"1.3\")\n    public fun clear(): StringBuilder {\n        string = \"\"\n        return this\n    }\n\n    /**\n     * Sets the character at the specified [index] to the specified [value].\n     *\n     * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public operator fun set(index: Int, value: Char) {\n        AbstractList.checkElementIndex(index, length)\n\n        string = string.substring(0, index) + value + string.substring(index + 1)\n    }\n\n    /**\n     * Replaces characters in the specified range of this string builder with characters in the specified string [value] and returns this instance.\n     *\n     * @param startIndex the beginning (inclusive) of the range to replace.\n     * @param endIndex the end (exclusive) of the range to replace.\n     * @param value the string to replace with.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] if [startIndex] is less than zero, greater than the length of this string builder, or `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder {\n        checkReplaceRange(startIndex, endIndex, length)\n\n        this.string = this.string.substring(0, startIndex) + value + this.string.substring(endIndex)\n        return this\n    }\n\n    private fun checkReplaceRange(startIndex: Int, endIndex: Int, length: Int) {\n        if (startIndex < 0 || startIndex > length) {\n            throw IndexOutOfBoundsException(\"startIndex: $startIndex, length: $length\")\n        }\n        if (startIndex > endIndex) {\n            throw IllegalArgumentException(\"startIndex($startIndex) > endIndex($endIndex)\")\n        }\n    }\n\n    /**\n     * Removes the character at the specified [index] from this string builder and returns this instance.\n     *\n     * If the `Char` at the specified [index] is part of a supplementary code point, this method does not remove the entire supplementary character.\n     *\n     * @param index the index of `Char` to remove.\n     *\n     * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun deleteAt(index: Int): StringBuilder {\n        AbstractList.checkElementIndex(index, length)\n\n        string = string.substring(0, index) + string.substring(index + 1)\n        return this\n    }\n\n    /**\n     * Removes characters in the specified range from this string builder and returns this instance.\n     *\n     * @param startIndex the beginning (inclusive) of the range to remove.\n     * @param endIndex the end (exclusive) of the range to remove.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun deleteRange(startIndex: Int, endIndex: Int): StringBuilder {\n        checkReplaceRange(startIndex, endIndex, length)\n\n        string = string.substring(0, startIndex) + string.substring(endIndex)\n        return this\n    }\n\n    /**\n     * Copies characters from this string builder into the [destination] character array.\n     *\n     * @param destination the array to copy to.\n     * @param destinationOffset the position in the array to copy to, 0 by default.\n     * @param startIndex the beginning (inclusive) of the range to copy, 0 by default.\n     * @param endIndex the end (exclusive) of the range to copy, length of this string builder by default.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n     *  or when that index is out of the [destination] array indices range.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun toCharArray(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = this.length) {\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, length)\n        AbstractList.checkBoundsIndexes(destinationOffset, destinationOffset + endIndex - startIndex, destination.size)\n\n        var dstIndex = destinationOffset\n        for (index in startIndex until endIndex) {\n            destination[dstIndex++] = string[index]\n        }\n    }\n\n    /**\n     * Appends characters in a subarray of the specified character array [value] to this string builder and returns this instance.\n     *\n     * Characters are appended in order, starting at specified [startIndex].\n     *\n     * @param value the array from which characters are appended.\n     * @param startIndex the beginning (inclusive) of the subarray to append.\n     * @param endIndex the end (exclusive) of the subarray to append.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder {\n        string += value.concatToString(startIndex, endIndex)\n        return this\n    }\n\n    /**\n     * Appends a subsequence of the specified character sequence [value] to this string builder and returns this instance.\n     *\n     * @param value the character sequence from which a subsequence is appended.\n     * @param startIndex the beginning (inclusive) of the subsequence to append.\n     * @param endIndex the end (exclusive) of the subsequence to append.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun appendRange(value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder {\n        val stringCsq = value.toString()\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, stringCsq.length)\n\n        string += stringCsq.substring(startIndex, endIndex)\n        return this\n    }\n\n    /**\n     * Inserts characters in a subarray of the specified character array [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in same order as in the [value] array, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the array from which characters are inserted.\n     * @param startIndex the beginning (inclusive) of the subarray to insert.\n     * @param endIndex the end (exclusive) of the subarray to insert.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder {\n        AbstractList.checkPositionIndex(index, this.length)\n\n        string = string.substring(0, index) + value.concatToString(startIndex, endIndex) + string.substring(index)\n        return this\n    }\n\n    /**\n     * Inserts characters in a subsequence of the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the character sequence from which a subsequence is inserted.\n     * @param startIndex the beginning (inclusive) of the subsequence to insert.\n     * @param endIndex the end (exclusive) of the subsequence to insert.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    public fun insertRange(index: Int, value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder {\n        AbstractList.checkPositionIndex(index, length)\n\n        val stringCsq = value.toString()\n        AbstractList.checkBoundsIndexes(startIndex, endIndex, stringCsq.length)\n\n        string = string.substring(0, index) + stringCsq.substring(startIndex, endIndex) + string.substring(index)\n        return this\n    }\n}\n\n\n/**\n * Clears the content of this string builder making it empty and returns this instance.\n *\n * @sample samples.text.Strings.clearStringBuilder\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.clear(): StringBuilder = this.clear()\n\n/**\n * Sets the character at the specified [index] to the specified [value].\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline operator fun StringBuilder.set(index: Int, value: Char) = this.set(index, value)\n\n/**\n * Replaces characters in the specified range of this string builder with characters in the specified string [value] and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to replace.\n * @param endIndex the end (exclusive) of the range to replace.\n * @param value the string to replace with.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] if [startIndex] is less than zero, greater than the length of this string builder, or `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder =\n    this.setRange(startIndex, endIndex, value)\n\n/**\n * Removes the character at the specified [index] from this string builder and returns this instance.\n *\n * If the `Char` at the specified [index] is part of a supplementary code point, this method does not remove the entire supplementary character.\n *\n * @param index the index of `Char` to remove.\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.deleteAt(index: Int): StringBuilder = this.deleteAt(index)\n\n/**\n * Removes characters in the specified range from this string builder and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to remove.\n * @param endIndex the end (exclusive) of the range to remove.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.deleteRange(startIndex: Int, endIndex: Int): StringBuilder = this.deleteRange(startIndex, endIndex)\n\n/**\n * Copies characters from this string builder into the [destination] character array.\n *\n * @param destination the array to copy to.\n * @param destinationOffset the position in the array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the range to copy, 0 by default.\n * @param endIndex the end (exclusive) of the range to copy, length of this string builder by default.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n *  or when that index is out of the [destination] array indices range.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\", \"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual inline fun StringBuilder.toCharArray(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = this.length) =\n    this.toCharArray(destination, destinationOffset, startIndex, endIndex)\n\n/**\n * Appends characters in a subarray of the specified character array [value] to this string builder and returns this instance.\n *\n * Characters are appended in order, starting at specified [startIndex].\n *\n * @param value the array from which characters are appended.\n * @param startIndex the beginning (inclusive) of the subarray to append.\n * @param endIndex the end (exclusive) of the subarray to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder =\n    this.appendRange(value, startIndex, endIndex)\n\n/**\n * Appends a subsequence of the specified character sequence [value] to this string builder and returns this instance.\n *\n * @param value the character sequence from which a subsequence is appended.\n * @param startIndex the beginning (inclusive) of the subsequence to append.\n * @param endIndex the end (exclusive) of the subsequence to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.appendRange(value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder =\n    this.appendRange(value, startIndex, endIndex)\n\n/**\n * Inserts characters in a subarray of the specified character array [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in same order as in the [value] array, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the array from which characters are inserted.\n * @param startIndex the beginning (inclusive) of the subarray to insert.\n * @param endIndex the end (exclusive) of the subarray to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder =\n    this.insertRange(index, value, startIndex, endIndex)\n\n/**\n * Inserts characters in a subsequence of the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the character sequence from which a subsequence is inserted.\n * @param startIndex the beginning (inclusive) of the subsequence to insert.\n * @param endIndex the end (exclusive) of the subsequence to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"NOTHING_TO_INLINE\")\npublic actual inline fun StringBuilder.insertRange(index: Int, value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder =\n    this.insertRange(index, value, startIndex, endIndex)\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n */\n@Deprecated(\"Use lowercaseChar() instead.\", ReplaceWith(\"lowercaseChar()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.toLowerCase(): Char = lowercaseChar()\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [lowercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.lowercaseChar(): Char = lowercase()[0]\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\u0130'.lowercase()` returns `\"\\u0069\\u0307\"`,\n * where `'\\u0130'` is the LATIN CAPITAL LETTER I WITH DOT ABOVE character (``).\n * If this character has no lower case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.lowercase(): String = toString().asDynamic().toLowerCase().unsafeCast<String>()\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n */\n@Deprecated(\"Use uppercaseChar() instead.\", ReplaceWith(\"uppercaseChar()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.toUpperCase(): Char = uppercaseChar()\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [uppercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic actual fun Char.uppercaseChar(): Char {\n    val uppercase = uppercase()\n    return if (uppercase.length > 1) this else uppercase[0]\n}\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\uFB00'.uppercase()` returns `\"\\u0046\\u0046\"`,\n * where `'\\uFB00'` is the LATIN SMALL LIGATURE FF character (``).\n * If this character has no upper case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic actual inline fun Char.uppercase(): String = toString().asDynamic().toUpperCase().unsafeCast<String>()\n\n/**\n * Converts this character to title case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [titlecase] function.\n * If this character has no mapping equivalent, the result of calling [uppercaseChar] is returned.\n *\n * @sample samples.text.Chars.titlecase\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.titlecaseChar(): Char = titlecaseCharImpl()\n\n/**\n * Returns `true` if this character is a Unicode high-surrogate code unit (also known as leading-surrogate code unit).\n */\npublic actual fun Char.isHighSurrogate(): Boolean = this in Char.MIN_HIGH_SURROGATE..Char.MAX_HIGH_SURROGATE\n\n/**\n * Returns `true` if this character is a Unicode low-surrogate code unit (also known as trailing-surrogate code unit).\n */\npublic actual fun Char.isLowSurrogate(): Boolean = this in Char.MIN_LOW_SURROGATE..Char.MAX_LOW_SURROGATE\n\n/**\n * Returns the Unicode general category of this character.\n */\n@SinceKotlin(\"1.5\")\npublic actual val Char.category: CharCategory\n    get() = CharCategory.valueOf(getCategoryValue())\n\n/**\n * Returns `true` if this character (Unicode code point) is defined in Unicode.\n *\n * A character is considered to be defined in Unicode if its [category] is not [CharCategory.UNASSIGNED].\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isDefined(): Boolean {\n    if (this < '\\u0080') {\n        return true\n    }\n    return getCategoryValue() != CharCategory.UNASSIGNED.value\n}\n\n/**\n * Returns `true` if this character is a letter.\n *\n * A character is considered to be a letter if its [category] is [CharCategory.UPPERCASE_LETTER],\n * [CharCategory.LOWERCASE_LETTER], [CharCategory.TITLECASE_LETTER], [CharCategory.MODIFIER_LETTER], or [CharCategory.OTHER_LETTER].\n *\n * @sample samples.text.Chars.isLetter\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isLetter(): Boolean {\n    if (this in 'a'..'z' || this in 'A'..'Z') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n    return isLetterImpl()\n}\n\n/**\n * Returns `true` if this character is a letter or digit.\n *\n * @see isLetter\n * @see isDigit\n *\n * @sample samples.text.Chars.isLetterOrDigit\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isLetterOrDigit(): Boolean {\n    if (this in 'a'..'z' || this in 'A'..'Z' || this in '0'..'9') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n\n    return isDigitImpl() || isLetterImpl()\n}\n\n/**\n * Returns `true` if this character is a digit.\n *\n * A character is considered to be a digit if its [category] is [CharCategory.DECIMAL_DIGIT_NUMBER].\n *\n * @sample samples.text.Chars.isDigit\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isDigit(): Boolean {\n    if (this in '0'..'9') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n    return isDigitImpl()\n}\n\n/**\n * Returns `true` if this character is upper case.\n *\n * A character is considered to be an upper case character if its [category] is [CharCategory.UPPERCASE_LETTER],\n * or it has contributory property Other_Uppercase as defined by the Unicode Standard.\n *\n * @sample samples.text.Chars.isUpperCase\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isUpperCase(): Boolean {\n    if (this in 'A'..'Z') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n    return isUpperCaseImpl()\n}\n\n/**\n * Returns `true` if this character is lower case.\n *\n * A character is considered to be a lower case character if its [category] is [CharCategory.LOWERCASE_LETTER],\n * or it has contributory property Other_Lowercase as defined by the Unicode Standard.\n *\n * @sample samples.text.Chars.isLowerCase\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isLowerCase(): Boolean {\n    if (this in 'a'..'z') {\n        return true\n    }\n    if (this < '\\u0080') {\n        return false\n    }\n    return isLowerCaseImpl()\n}\n\n/**\n * Returns `true` if this character is a title case letter.\n *\n * A character is considered to be a title case letter if its [category] is [CharCategory.TITLECASE_LETTER].\n *\n * @sample samples.text.Chars.isTitleCase\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isTitleCase(): Boolean {\n    if (this < '\\u0080') {\n        return false\n    }\n    return getCategoryValue() == CharCategory.TITLECASE_LETTER.value\n}\n\n/**\n * Returns `true` if this character is an ISO control character.\n *\n * A character is considered to be an ISO control character if its [category] is [CharCategory.CONTROL],\n * meaning the Char is in the range `'\\u0000'..'\\u001F'` or in the range `'\\u007F'..'\\u009F'`.\n *\n * @sample samples.text.Chars.isISOControl\n */\n@SinceKotlin(\"1.5\")\npublic actual fun Char.isISOControl(): Boolean {\n    return this <= '\\u001F' || this in '\\u007F'..'\\u009F'\n}\n\n/**\n * Determines whether a character is whitespace according to the Unicode standard.\n * Returns `true` if the character is whitespace.\n *\n * @sample samples.text.Chars.isWhitespace\n */\npublic actual fun Char.isWhitespace(): Boolean = isWhitespaceImpl()","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n\n/**\n * Returns `true` if the content of this string is equal to the word \"true\", ignoring case, and `false` otherwise.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toBoolean(): Boolean = this.toBoolean()\n\n/**\n * Returns `true` if this string is not `null` and its content is equal to the word \"true\", ignoring case, and `false` otherwise.\n *\n * There are also strict versions of the function available on non-nullable String, [toBooleanStrict] and [toBooleanStrictOrNull].\n */\n@SinceKotlin(\"1.4\")\npublic actual fun String?.toBoolean(): Boolean = this != null && this.lowercase() == \"true\"\n\n/**\n * Parses the string as a signed [Byte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toByte(): Byte = toByteOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a signed [Byte] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toByte(radix: Int): Byte = toByteOrNull(radix) ?: numberFormatError(this)\n\n\n/**\n * Parses the string as a [Short] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toShort(): Short = toShortOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Short] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toShort(radix: Int): Short = toShortOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as an [Int] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toInt(): Int = toIntOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as an [Int] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toInt(radix: Int): Int = toIntOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Long] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toLong(): Long = toLongOrNull() ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Long] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n * @throws IllegalArgumentException when [radix] is not a valid radix for string to number conversion.\n */\npublic actual fun String.toLong(radix: Int): Long = toLongOrNull(radix) ?: numberFormatError(this)\n\n/**\n * Parses the string as a [Double] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\npublic actual fun String.toDouble(): Double = (+(this.asDynamic())).unsafeCast<Double>().also {\n    if (it.isNaN() && !this.isNaN() || it == 0.0 && this.isBlank())\n        numberFormatError(this)\n}\n\n/**\n * Parses the string as a [Float] number and returns the result.\n * @throws NumberFormatException if the string is not a valid representation of a number.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toFloat(): Float = toDouble().unsafeCast<Float>()\n\n/**\n * Parses the string as a [Double] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\npublic actual fun String.toDoubleOrNull(): Double? = (+(this.asDynamic())).unsafeCast<Double>().takeIf {\n    !(it.isNaN() && !this.isNaN() || it == 0.0 && this.isBlank())\n}\n\n/**\n * Parses the string as a [Float] number and returns the result\n * or `null` if the string is not a valid representation of a number.\n */\n@kotlin.internal.InlineOnly\npublic actual inline fun String.toFloatOrNull(): Float? = toDoubleOrNull().unsafeCast<Float?>()\n\n/**\n * Returns a string representation of this [Byte] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Byte.toString(radix: Int): String = this.toInt().toString(radix)\n\n/**\n * Returns a string representation of this [Short] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\n@kotlin.internal.InlineOnly\npublic actual inline fun Short.toString(radix: Int): String = this.toInt().toString(radix)\n\n/**\n * Returns a string representation of this [Int] value in the specified [radix].\n *\n * @throws IllegalArgumentException when [radix] is not a valid radix for number to string conversion.\n */\n@SinceKotlin(\"1.2\")\npublic actual fun Int.toString(radix: Int): String = asDynamic().toString(checkRadix(radix))\n\nprivate fun String.isNaN(): Boolean = when (this.lowercase()) {\n    \"nan\", \"+nan\", \"-nan\" -> true\n    else -> false\n}\n\n/**\n * Checks whether the given [radix] is valid radix for string to number and number to string conversion.\n */\n@PublishedApi\ninternal actual fun checkRadix(radix: Int): Int {\n    if (radix !in 2..36) {\n        throw IllegalArgumentException(\"radix $radix was not in valid range 2..36\")\n    }\n    return radix\n}\n\ninternal actual fun digitOf(char: Char, radix: Int): Int = when {\n    char >= '0' && char <= '9' -> char - '0'\n    char >= 'A' && char <= 'Z' -> char - 'A' + 10\n    char >= 'a' && char <= 'z' -> char - 'a' + 10\n    char < '\\u0080' -> -1\n    char >= '\\uFF21' && char <= '\\uFF3A' -> char - '\\uFF21' + 10 // full-width latin capital letter\n    char >= '\\uFF41' && char <= '\\uFF5A' -> char - '\\uFF41' + 10 // full-width latin small letter\n    else -> char.digitToIntImpl()\n}.let { if (it >= radix) -1 else it }\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n/**\n * Provides enumeration values to use to set regular expression options.\n */\npublic actual enum class RegexOption(val value: String) {\n    /** Enables case-insensitive matching. */\n    IGNORE_CASE(\"i\"),\n    /** Enables multiline mode.\n     *\n     * In multiline mode the expressions `^` and `$` match just after or just before,\n     * respectively, a line terminator or the end of the input sequence. */\n    MULTILINE(\"m\")\n}\n\nprivate fun Iterable<RegexOption>.toFlags(prepend: String): String = joinToString(\"\", prefix = prepend) { it.value }\n\n\n/**\n * Represents the results from a single capturing group within a [MatchResult] of [Regex].\n *\n * @param value The value of captured group.\n */\npublic actual data class MatchGroup(actual val value: String)\n\n\n/**\n * Represents a compiled regular expression.\n * Provides functions to match strings in text with a pattern, replace the found occurrences and split text around matches.\n *\n * For pattern syntax reference see [MDN RegExp](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp#Special_characters_meaning_in_regular_expressions)\n * and [http://www.w3schools.com/jsref/jsref_obj_regexp.asp](https://www.w3schools.com/jsref/jsref_obj_regexp.asp).\n *\n * Note that `RegExp` objects under the hood are constructed with [the \"u\" flag](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/RegExp/unicode)\n * that enables Unicode-related features in regular expressions. This also makes the pattern syntax more strict,\n * for example, prohibiting unnecessary escape sequences.\n *\n * @constructor Creates a regular expression from the specified [pattern] string and the specified set of [options].\n */\npublic actual class Regex actual constructor(pattern: String, options: Set<RegexOption>) {\n\n    /** Creates a regular expression from the specified [pattern] string and the specified single [option].  */\n    public actual constructor(pattern: String, option: RegexOption) : this(pattern, setOf(option))\n\n    /** Creates a regular expression from the specified [pattern] string and the default options.  */\n    public actual constructor(pattern: String) : this(pattern, emptySet())\n\n\n    /** The pattern string of this regular expression. */\n    public actual val pattern: String = pattern\n    /** The set of options that were used to create this regular expression. */\n    public actual val options: Set<RegexOption> = options.toSet()\n    private val nativePattern: RegExp = RegExp(pattern, options.toFlags(\"gu\"))\n    private var nativeStickyPattern: RegExp? = null\n    private fun initStickyPattern(): RegExp =\n        nativeStickyPattern ?: RegExp(pattern, options.toFlags(\"yu\")).also { nativeStickyPattern = it }\n\n    private var nativeMatchesEntirePattern: RegExp? = null\n    private fun initMatchesEntirePattern(): RegExp =\n        nativeMatchesEntirePattern ?: run {\n            if (pattern.startsWith('^') && pattern.endsWith('$'))\n                nativePattern\n            else\n                return RegExp(\"^${pattern.trimStart('^').trimEnd('$')}$\", options.toFlags(\"gu\"))\n        }.also { nativeMatchesEntirePattern = it }\n\n\n    /** Indicates whether the regular expression matches the entire [input]. */\n    public actual infix fun matches(input: CharSequence): Boolean {\n        nativePattern.reset()\n        val match = nativePattern.exec(input.toString())\n        return match != null && match.index == 0 && nativePattern.lastIndex == input.length\n    }\n\n    /** Indicates whether the regular expression can find at least one match in the specified [input]. */\n    public actual fun containsMatchIn(input: CharSequence): Boolean {\n        nativePattern.reset()\n        return nativePattern.test(input.toString())\n    }\n\n    @SinceKotlin(\"1.5\")\n    @ExperimentalStdlibApi\n    public actual fun matchesAt(input: CharSequence, index: Int): Boolean {\n        if (index < 0 || index > input.length) {\n            throw IndexOutOfBoundsException(\"index out of bounds: $index, input length: ${input.length}\")\n        }\n        val pattern = initStickyPattern()\n        pattern.lastIndex = index\n        return pattern.test(input.toString())\n    }\n\n    /**\n     * Returns the first match of a regular expression in the [input], beginning at the specified [startIndex].\n     *\n     * @param startIndex An index to start search with, by default 0. Must be not less than zero and not greater than `input.length()`\n     * @return An instance of [MatchResult] if match was found or `null` otherwise.\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of the [input] char sequence.\n     * @sample samples.text.Regexps.find\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    public actual fun find(input: CharSequence, startIndex: Int = 0): MatchResult? {\n        if (startIndex < 0 || startIndex > input.length) {\n            throw IndexOutOfBoundsException(\"Start index out of bounds: $startIndex, input length: ${input.length}\")\n        }\n        return nativePattern.findNext(input.toString(), startIndex, nativePattern)\n    }\n\n    /**\n     * Returns a sequence of all occurrences of a regular expression within the [input] string, beginning at the specified [startIndex].\n     *\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of the [input] char sequence.\n     *\n     * @sample samples.text.Regexps.findAll\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    public actual fun findAll(input: CharSequence, startIndex: Int = 0): Sequence<MatchResult> {\n        if (startIndex < 0 || startIndex > input.length) {\n            throw IndexOutOfBoundsException(\"Start index out of bounds: $startIndex, input length: ${input.length}\")\n        }\n        return generateSequence({ find(input, startIndex) }, { match -> match.next() })\n    }\n\n    /**\n     * Attempts to match the entire [input] CharSequence against the pattern.\n     *\n     * @return An instance of [MatchResult] if the entire input matches or `null` otherwise.\n     */\n    public actual fun matchEntire(input: CharSequence): MatchResult? =\n        initMatchesEntirePattern().findNext(input.toString(), 0, nativePattern)\n\n    @SinceKotlin(\"1.5\")\n    @ExperimentalStdlibApi\n    public actual fun matchAt(input: CharSequence, index: Int): MatchResult? {\n        if (index < 0 || index > input.length) {\n            throw IndexOutOfBoundsException(\"index out of bounds: $index, input length: ${input.length}\")\n        }\n        return initStickyPattern().findNext(input.toString(), index, nativePattern)\n    }\n\n\n    /**\n     * Replaces all occurrences of this regular expression in the specified [input] string with specified [replacement] expression.\n     *\n     * The replacement string may contain references to the captured groups during a match. Occurrences of `$index`\n     * in the replacement string will be substituted with the subsequences corresponding to the captured groups with the specified index.\n     * The first digit after '$' is always treated as part of group reference. Subsequent digits are incorporated\n     * into `index` only if they would form a valid group reference. Only the digits '0'..'9' are considered as potential components\n     * of the group reference. Note that indexes of captured groups start from 1, and the group with index 0 is the whole match.\n     *\n     * Backslash character '\\' can be used to include the succeeding character as a literal in the replacement string, e.g, `\\$` or `\\\\`.\n     * [Regex.escapeReplacement] can be used if [replacement] have to be treated as a literal string.\n     *\n     * Note that referring named capturing groups by name is currently not supported in Kotlin/JS.\n     * However, you can still refer them by index.\n     *\n     * @param input the char sequence to find matches of this regular expression in\n     * @param replacement the expression to replace found matches with\n     * @return the result of replacing each occurrence of this regular expression in [input] with the result of evaluating the [replacement] expression\n     * @throws RuntimeException if [replacement] expression is malformed, or capturing group with specified `name` or `index` does not exist\n     */\n    public actual fun replace(input: CharSequence, replacement: String): String {\n        if (!replacement.contains('\\\\') && !replacement.contains('$')) {\n            return input.toString().nativeReplace(nativePattern, replacement)\n        }\n        return replace(input) { substituteGroupRefs(it, replacement) }\n    }\n\n    /**\n     * Replaces all occurrences of this regular expression in the specified [input] string with the result of\n     * the given function [transform] that takes [MatchResult] and returns a string to be used as a\n     * replacement for that match.\n     */\n    public actual fun replace(input: CharSequence, transform: (MatchResult) -> CharSequence): String {\n        var match = find(input)\n        if (match == null) return input.toString()\n\n        var lastStart = 0\n        val length = input.length\n        val sb = StringBuilder(length)\n        do {\n            val foundMatch = match!!\n            sb.append(input, lastStart, foundMatch.range.start)\n            sb.append(transform(foundMatch))\n            lastStart = foundMatch.range.endInclusive + 1\n            match = foundMatch.next()\n        } while (lastStart < length && match != null)\n\n        if (lastStart < length) {\n            sb.append(input, lastStart, length)\n        }\n\n        return sb.toString()\n    }\n\n    /**\n     * Replaces the first occurrence of this regular expression in the specified [input] string with specified [replacement] expression.\n     *\n     * The replacement string may contain references to the captured groups during a match. Occurrences of `$index`\n     * in the replacement string will be substituted with the subsequences corresponding to the captured groups with the specified index.\n     * The first digit after '$' is always treated as part of group reference. Subsequent digits are incorporated\n     * into `index` only if they would form a valid group reference. Only the digits '0'..'9' are considered as potential components\n     * of the group reference. Note that indexes of captured groups start from 1, and the group with index 0 is the whole match.\n     *\n     * Backslash character '\\' can be used to include the succeeding character as a literal in the replacement string, e.g, `\\$` or `\\\\`.\n     * [Regex.escapeReplacement] can be used if [replacement] have to be treated as a literal string.\n     *\n     * Note that referring named capturing groups by name is not supported currently in Kotlin/JS.\n     * However, you can still refer them by index.\n     *\n     * @param input the char sequence to find a match of this regular expression in\n     * @param replacement the expression to replace the found match with\n     * @return the result of replacing the first occurrence of this regular expression in [input] with the result of evaluating the [replacement] expression\n     * @throws RuntimeException if [replacement] expression is malformed, or capturing group with specified `name` or `index` does not exist\n     */\n    public actual fun replaceFirst(input: CharSequence, replacement: String): String {\n        if (!replacement.contains('\\\\') && !replacement.contains('$')) {\n            val nonGlobalOptions = options.toFlags(\"u\")\n            return input.toString().nativeReplace(RegExp(pattern, nonGlobalOptions), replacement)\n        }\n\n        val match = find(input) ?: return input.toString()\n\n        return buildString {\n            append(input.substring(0, match.range.first))\n            append(substituteGroupRefs(match, replacement))\n            append(input.substring(match.range.last + 1, input.length))\n        }\n    }\n\n    /**\n     * Splits the [input] CharSequence to a list of strings around matches of this regular expression.\n     *\n     * @param limit Non-negative value specifying the maximum number of substrings the string can be split to.\n     * Zero by default means no limit is set.\n     */\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    public actual fun split(input: CharSequence, limit: Int = 0): List<String> {\n        requireNonNegativeLimit(limit)\n        val matches = findAll(input).let { if (limit == 0) it else it.take(limit - 1) }\n        val result = mutableListOf<String>()\n        var lastStart = 0\n\n        for (match in matches) {\n            result.add(input.subSequence(lastStart, match.range.start).toString())\n            lastStart = match.range.endInclusive + 1\n        }\n        result.add(input.subSequence(lastStart, input.length).toString())\n        return result\n    }\n\n    /**\n     * Splits the [input] CharSequence to a sequence of strings around matches of this regular expression.\n     *\n     * @param limit Non-negative value specifying the maximum number of substrings the string can be split to.\n     * Zero by default means no limit is set.\n     * @sample samples.text.Regexps.splitToSequence\n     */\n    @SinceKotlin(\"1.6\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    @Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\n    public actual fun splitToSequence(input: CharSequence, limit: Int = 0): Sequence<String> {\n        requireNonNegativeLimit(limit)\n\n        return sequence {\n            var match = find(input)\n            if (match == null || limit == 1) {\n                yield(input.toString())\n                return@sequence\n            }\n\n            var nextStart = 0\n            var splitCount = 0\n\n            do {\n                val foundMatch = match!!\n                yield(input.substring(nextStart, foundMatch.range.first))\n                nextStart = foundMatch.range.endInclusive + 1\n                match = foundMatch.next()\n            } while (++splitCount != limit - 1 && match != null)\n\n            yield(input.substring(nextStart, input.length))\n        }\n    }\n\n\n    /**\n     * Returns the string representation of this regular expression, namely the [pattern] of this regular expression.\n     *\n     * Note that another regular expression constructed from the same pattern string may have different [options]\n     * and may match strings differently.\n     */\n    public override fun toString(): String = nativePattern.toString()\n\n    actual companion object {\n        /**\n         * Returns a regular expression that matches the specified [literal] string literally.\n         * No characters of that string will have special meaning when searching for an occurrence of the regular expression.\n         */\n        public actual fun fromLiteral(literal: String): Regex = Regex(escape(literal))\n\n        /**\n         * Returns a regular expression pattern string that matches the specified [literal] string literally.\n         * No characters of that string will have special meaning when searching for an occurrence of the regular expression.\n         */\n        public actual fun escape(literal: String): String = literal.nativeReplace(patternEscape, \"\\\\$&\")\n\n        /**\n         * Returns a literal replacement expression for the specified [literal] string.\n         * No characters of that string will have special meaning when it is used as a replacement string in [Regex.replace] function.\n         */\n        public actual fun escapeReplacement(literal: String): String = literal.nativeReplace(replacementEscape, \"\\\\$&\")\n\n        private val patternEscape = RegExp(\"\"\"[\\\\^$*+?.()|[\\]{}]\"\"\", \"g\")\n        private val replacementEscape = RegExp(\"\"\"[\\\\$]\"\"\", \"g\")\n\n        internal fun nativeEscapeReplacement(literal: String): String = literal.nativeReplace(nativeReplacementEscape, \"$$$$\")\n        private val nativeReplacementEscape = RegExp(\"\"\"\\$\"\"\", \"g\")\n    }\n}\n\n\n\nprivate fun RegExp.findNext(input: String, from: Int, nextPattern: RegExp): MatchResult? {\n    this.lastIndex = from\n    val match = exec(input)\n    if (match == null) return null\n    val range = match.index..lastIndex - 1\n\n    return object : MatchResult {\n        override val range: IntRange = range\n        override val value: String\n            get() = match[0]!!\n\n        override val groups: MatchGroupCollection = object : MatchGroupCollection, AbstractCollection<MatchGroup?>() {\n            override val size: Int get() = match.length\n            override fun iterator(): Iterator<MatchGroup?> = indices.asSequence().map { this[it] }.iterator()\n            override fun get(index: Int): MatchGroup? = match[index]?.let { MatchGroup(it) }\n        }\n\n\n        private var groupValues_: List<String>? = null\n\n        override val groupValues: List<String>\n            get() {\n                if (groupValues_ == null) {\n                    groupValues_ = object : AbstractList<String>() {\n                        override val size: Int get() = match.length\n                        override fun get(index: Int): String = match[index] ?: \"\"\n                    }\n                }\n                return groupValues_!!\n            }\n\n        override fun next(): MatchResult? =\n            nextPattern.findNext(input, if (range.isEmpty()) range.start + 1 else range.endInclusive + 1, nextPattern)\n    }\n}\n\n// The same code from K/N Regex.kt\nprivate fun substituteGroupRefs(match: MatchResult, replacement: String): String {\n    var index = 0\n    val result = StringBuilder(replacement.length)\n\n    while (index < replacement.length) {\n        val char = replacement[index++]\n        if (char == '\\\\') {\n            if (index == replacement.length)\n                throw IllegalArgumentException(\"The Char to be escaped is missing\")\n\n            result.append(replacement[index++])\n        } else if (char == '$') {\n            if (index == replacement.length)\n                throw IllegalArgumentException(\"Capturing group index is missing\")\n\n            if (replacement[index] == '{')\n                throw IllegalArgumentException(\"Named capturing group reference currently is not supported\")\n\n            if (replacement[index] !in '0'..'9')\n                throw IllegalArgumentException(\"Invalid capturing group reference\")\n\n            val endIndex = replacement.readGroupIndex(index, match.groupValues.size)\n            val groupIndex = replacement.substring(index, endIndex).toInt()\n\n            if (groupIndex >= match.groupValues.size)\n                throw IndexOutOfBoundsException(\"Group with index $groupIndex does not exist\")\n\n            result.append(match.groupValues[groupIndex])\n            index = endIndex\n        } else {\n            result.append(char)\n        }\n    }\n    return result.toString()\n}\n\nprivate fun String.readGroupIndex(startIndex: Int, groupCount: Int): Int {\n    // at least one digit after '$' is always captured\n    var index = startIndex + 1\n    var groupIndex = this[startIndex] - '0'\n\n    // capture the largest valid group index\n    while (index < length && this[index] in '0'..'9') {\n        val newGroupIndex = (groupIndex * 10) + (this[index] - '0')\n        if (newGroupIndex in 0 until groupCount) {\n            groupIndex = newGroupIndex\n            index++\n        } else {\n            break\n        }\n    }\n    return index\n}","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\n\n/**\n * Returns a character at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\npublic expect fun CharSequence.elementAt(index: Int): Char\n\n/**\n * Returns a character at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAtOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns a character at the given [index] or `null` if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.elementAtOrNull(index: Int): Char? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first character matching the given [predicate], or `null` if no such character was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.find(predicate: (Char) -> Boolean): Char? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last character matching the given [predicate], or `null` if no such character was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.findLast(predicate: (Char) -> Boolean): Char? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first character.\n * @throws [NoSuchElementException] if the char sequence is empty.\n */\npublic fun CharSequence.first(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return this[0]\n}\n\n/**\n * Returns the first character matching the given [predicate].\n * @throws [NoSuchElementException] if no such character is found.\n */\npublic inline fun CharSequence.first(predicate: (Char) -> Boolean): Char {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to characters of this char sequence in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <R : Any> CharSequence.firstNotNullOf(transform: (Char) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the char sequence was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to characters of this char sequence in iteration order,\n * or `null` if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <R : Any> CharSequence.firstNotNullOfOrNull(transform: (Char) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns the first character, or `null` if the char sequence is empty.\n */\npublic fun CharSequence.firstOrNull(): Char? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first character matching the given [predicate], or `null` if character was not found.\n */\npublic inline fun CharSequence.firstOrNull(predicate: (Char) -> Boolean): Char? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns a character at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.getOrElse(index: Int, defaultValue: (Int) -> Char): Char {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns a character at the given [index] or `null` if the [index] is out of bounds of this char sequence.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\npublic fun CharSequence.getOrNull(index: Int): Char? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns index of the first character matching the given [predicate], or -1 if the char sequence does not contain such character.\n */\npublic inline fun CharSequence.indexOfFirst(predicate: (Char) -> Boolean): Int {\n    for (index in indices) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns index of the last character matching the given [predicate], or -1 if the char sequence does not contain such character.\n */\npublic inline fun CharSequence.indexOfLast(predicate: (Char) -> Boolean): Int {\n    for (index in indices.reversed()) {\n        if (predicate(this[index])) {\n            return index\n        }\n    }\n    return -1\n}\n\n/**\n * Returns the last character.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n * \n * @sample samples.text.Strings.last\n */\npublic fun CharSequence.last(): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return this[lastIndex]\n}\n\n/**\n * Returns the last character matching the given [predicate].\n * \n * @throws NoSuchElementException if no such character is found.\n * \n * @sample samples.text.Strings.last\n */\npublic inline fun CharSequence.last(predicate: (Char) -> Boolean): Char {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n}\n\n/**\n * Returns the last character, or `null` if the char sequence is empty.\n * \n * @sample samples.text.Strings.last\n */\npublic fun CharSequence.lastOrNull(): Char? {\n    return if (isEmpty()) null else this[length - 1]\n}\n\n/**\n * Returns the last character matching the given [predicate], or `null` if no such character was found.\n * \n * @sample samples.text.Strings.last\n */\npublic inline fun CharSequence.lastOrNull(predicate: (Char) -> Boolean): Char? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random character from this char sequence.\n * \n * @throws NoSuchElementException if this char sequence is empty.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.random(): Char {\n    return random(Random)\n}\n\n/**\n * Returns a random character from this char sequence using the specified source of randomness.\n * \n * @throws NoSuchElementException if this char sequence is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun CharSequence.random(random: Random): Char {\n    if (isEmpty())\n        throw NoSuchElementException(\"Char sequence is empty.\")\n    return get(random.nextInt(length))\n}\n\n/**\n * Returns a random character from this char sequence, or `null` if this char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.randomOrNull(): Char? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random character from this char sequence using the specified source of randomness, or `null` if this char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun CharSequence.randomOrNull(random: Random): Char? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(length))\n}\n\n/**\n * Returns the single character, or throws an exception if the char sequence is empty or has more than one character.\n */\npublic fun CharSequence.single(): Char {\n    return when (length) {\n        0 -> throw NoSuchElementException(\"Char sequence is empty.\")\n        1 -> this[0]\n        else -> throw IllegalArgumentException(\"Char sequence has more than one element.\")\n    }\n}\n\n/**\n * Returns the single character matching the given [predicate], or throws exception if there is no or more than one matching character.\n */\npublic inline fun CharSequence.single(predicate: (Char) -> Boolean): Char {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Char sequence contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Char sequence contains no character matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as Char\n}\n\n/**\n * Returns single character, or `null` if the char sequence is empty or has more than one character.\n */\npublic fun CharSequence.singleOrNull(): Char? {\n    return if (length == 1) this[0] else null\n}\n\n/**\n * Returns the single character matching the given [predicate], or `null` if character was not found or more than one character was found.\n */\npublic inline fun CharSequence.singleOrNull(predicate: (Char) -> Boolean): Char? {\n    var single: Char? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a subsequence of this char sequence with the first [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun CharSequence.drop(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return subSequence(n.coerceAtMost(length), length)\n}\n\n/**\n * Returns a string with the first [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun String.drop(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return substring(n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence with the last [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun CharSequence.dropLast(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return take((length - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a string with the last [n] characters removed.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.drop\n */\npublic fun String.dropLast(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return take((length - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a subsequence of this char sequence containing all characters except last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun CharSequence.dropLastWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in lastIndex downTo 0)\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n    return \"\"\n}\n\n/**\n * Returns a string containing all characters except last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun String.dropLastWhile(predicate: (Char) -> Boolean): String {\n    for (index in lastIndex downTo 0)\n        if (!predicate(this[index]))\n            return substring(0, index + 1)\n    return \"\"\n}\n\n/**\n * Returns a subsequence of this char sequence containing all characters except first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun CharSequence.dropWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n    return \"\"\n}\n\n/**\n * Returns a string containing all characters except first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.drop\n */\npublic inline fun String.dropWhile(predicate: (Char) -> Boolean): String {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return substring(index)\n    return \"\"\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that match the given [predicate].\n * \n * @sample samples.text.Strings.filter\n */\npublic inline fun CharSequence.filter(predicate: (Char) -> Boolean): CharSequence {\n    return filterTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that match the given [predicate].\n * \n * @sample samples.text.Strings.filter\n */\npublic inline fun String.filter(predicate: (Char) -> Boolean): String {\n    return filterTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that match the given [predicate].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun CharSequence.filterIndexed(predicate: (index: Int, Char) -> Boolean): CharSequence {\n    return filterIndexedTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that match the given [predicate].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\npublic inline fun String.filterIndexed(predicate: (index: Int, Char) -> Boolean): String {\n    return filterIndexedTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Appends all characters matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of a character and the character itself\n * and returns the result of predicate evaluation on the character.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\npublic inline fun <C : Appendable> CharSequence.filterIndexedTo(destination: C, predicate: (index: Int, Char) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.append(element)\n    }\n    return destination\n}\n\n/**\n * Returns a char sequence containing only those characters from the original char sequence that do not match the given [predicate].\n * \n * @sample samples.text.Strings.filterNot\n */\npublic inline fun CharSequence.filterNot(predicate: (Char) -> Boolean): CharSequence {\n    return filterNotTo(StringBuilder(), predicate)\n}\n\n/**\n * Returns a string containing only those characters from the original string that do not match the given [predicate].\n * \n * @sample samples.text.Strings.filterNot\n */\npublic inline fun String.filterNot(predicate: (Char) -> Boolean): String {\n    return filterNotTo(StringBuilder(), predicate).toString()\n}\n\n/**\n * Appends all characters not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : Appendable> CharSequence.filterNotTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.append(element)\n    return destination\n}\n\n/**\n * Appends all characters matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\npublic inline fun <C : Appendable> CharSequence.filterTo(destination: C, predicate: (Char) -> Boolean): C {\n    for (index in 0 until length) {\n        val element = get(index)\n        if (predicate(element)) destination.append(element)\n    }\n    return destination\n}\n\n/**\n * Returns a char sequence containing characters of the original char sequence at the specified range of [indices].\n */\npublic fun CharSequence.slice(indices: IntRange): CharSequence {\n    if (indices.isEmpty()) return \"\"\n    return subSequence(indices)\n}\n\n/**\n * Returns a string containing characters of the original string at the specified range of [indices].\n */\npublic fun String.slice(indices: IntRange): String {\n    if (indices.isEmpty()) return \"\"\n    return substring(indices)\n}\n\n/**\n * Returns a char sequence containing characters of the original char sequence at specified [indices].\n */\npublic fun CharSequence.slice(indices: Iterable<Int>): CharSequence {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return \"\"\n    val result = StringBuilder(size)\n    for (i in indices) {\n        result.append(get(i))\n    }\n    return result\n}\n\n/**\n * Returns a string containing characters of the original string at specified [indices].\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.slice(indices: Iterable<Int>): String {\n    return (this as CharSequence).slice(indices).toString()\n}\n\n/**\n * Returns a subsequence of this char sequence containing the first [n] characters from this char sequence, or the entire char sequence if this char sequence is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun CharSequence.take(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return subSequence(0, n.coerceAtMost(length))\n}\n\n/**\n * Returns a string containing the first [n] characters from this string, or the entire string if this string is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun String.take(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    return substring(0, n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence containing the last [n] characters from this char sequence, or the entire char sequence if this char sequence is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun CharSequence.takeLast(n: Int): CharSequence {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    val length = length\n    return subSequence(length - n.coerceAtMost(length), length)\n}\n\n/**\n * Returns a string containing the last [n] characters from this string, or the entire string if this string is shorter.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.text.Strings.take\n */\npublic fun String.takeLast(n: Int): String {\n    require(n >= 0) { \"Requested character count $n is less than zero.\" }\n    val length = length\n    return substring(length - n.coerceAtMost(length))\n}\n\n/**\n * Returns a subsequence of this char sequence containing last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun CharSequence.takeLastWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return subSequence(index + 1, length)\n        }\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Returns a string containing last characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun String.takeLastWhile(predicate: (Char) -> Boolean): String {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return substring(index + 1)\n        }\n    }\n    return this\n}\n\n/**\n * Returns a subsequence of this char sequence containing the first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun CharSequence.takeWhile(predicate: (Char) -> Boolean): CharSequence {\n    for (index in 0 until length)\n        if (!predicate(get(index))) {\n            return subSequence(0, index)\n        }\n    return subSequence(0, length)\n}\n\n/**\n * Returns a string containing the first characters that satisfy the given [predicate].\n * \n * @sample samples.text.Strings.take\n */\npublic inline fun String.takeWhile(predicate: (Char) -> Boolean): String {\n    for (index in 0 until length)\n        if (!predicate(get(index))) {\n            return substring(0, index)\n        }\n    return this\n}\n\n/**\n * Returns a char sequence with characters in reversed order.\n */\npublic fun CharSequence.reversed(): CharSequence {\n    return StringBuilder(this).reverse()\n}\n\n/**\n * Returns a string with characters in reversed order.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.reversed(): String {\n    return (this as CharSequence).reversed().toString()\n}\n\n/**\n * Returns a [Map] containing key-value pairs provided by [transform] function\n * applied to characters of the given char sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associate\n */\npublic inline fun <K, V> CharSequence.associate(transform: (Char) -> Pair<K, V>): Map<K, V> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateTo(LinkedHashMap<K, V>(capacity), transform)\n}\n\n/**\n * Returns a [Map] containing the characters from the given char sequence indexed by the key\n * returned from [keySelector] function applied to each character.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateBy\n */\npublic inline fun <K> CharSequence.associateBy(keySelector: (Char) -> K): Map<K, Char> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, Char>(capacity), keySelector)\n}\n\n/**\n * Returns a [Map] containing the values provided by [valueTransform] and indexed by [keySelector] functions applied to characters of the given char sequence.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateByWithValueTransform\n */\npublic inline fun <K, V> CharSequence.associateBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, V> {\n    val capacity = mapCapacity(length).coerceAtLeast(16)\n    return associateByTo(LinkedHashMap<K, V>(capacity), keySelector, valueTransform)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function applied to each character of the given char sequence\n * and value is the character itself.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateByTo\n */\npublic inline fun <K, M : MutableMap<in K, in Char>> CharSequence.associateByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        destination.put(keySelector(element), element)\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs,\n * where key is provided by the [keySelector] function and\n * and value is provided by the [valueTransform] function applied to characters of the given char sequence.\n * \n * If any two characters would have the same key returned by [keySelector] the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateByToWithValueTransform\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        destination.put(keySelector(element), valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs\n * provided by [transform] function applied to each character of the given char sequence.\n * \n * If any of two pairs would have the same key the last one gets added to the map.\n * \n * @sample samples.text.Strings.associateTo\n */\npublic inline fun <K, V, M : MutableMap<in K, in V>> CharSequence.associateTo(destination: M, transform: (Char) -> Pair<K, V>): M {\n    for (element in this) {\n        destination += transform(element)\n    }\n    return destination\n}\n\n/**\n * Returns a [Map] where keys are characters from the given char sequence and values are\n * produced by the [valueSelector] function applied to each character.\n * \n * If any two characters are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original char sequence.\n * \n * @sample samples.text.Strings.associateWith\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <V> CharSequence.associateWith(valueSelector: (Char) -> V): Map<Char, V> {\n    val result = LinkedHashMap<Char, V>(mapCapacity(length.coerceAtMost(128)).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each character of the given char sequence,\n * where key is the character itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two characters are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.text.Strings.associateWithTo\n */\n@SinceKotlin(\"1.3\")\npublic inline fun <V, M : MutableMap<in Char, in V>> CharSequence.associateWithTo(destination: M, valueSelector: (Char) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Appends all characters to the given [destination] collection.\n */\npublic fun <C : MutableCollection<in Char>> CharSequence.toCollection(destination: C): C {\n    for (item in this) {\n        destination.add(item)\n    }\n    return destination\n}\n\n/**\n * Returns a new [HashSet] of all characters.\n */\npublic fun CharSequence.toHashSet(): HashSet<Char> {\n    return toCollection(HashSet<Char>(mapCapacity(length.coerceAtMost(128))))\n}\n\n/**\n * Returns a [List] containing all characters.\n */\npublic fun CharSequence.toList(): List<Char> {\n    return when (length) {\n        0 -> emptyList()\n        1 -> listOf(this[0])\n        else -> this.toMutableList()\n    }\n}\n\n/**\n * Returns a new [MutableList] filled with all characters of this char sequence.\n */\npublic fun CharSequence.toMutableList(): MutableList<Char> {\n    return toCollection(ArrayList<Char>(length))\n}\n\n/**\n * Returns a [Set] of all characters.\n * \n * The returned set preserves the element iteration order of the original char sequence.\n */\npublic fun CharSequence.toSet(): Set<Char> {\n    return when (length) {\n        0 -> emptySet()\n        1 -> setOf(this[0])\n        else -> toCollection(LinkedHashSet<Char>(mapCapacity(length.coerceAtMost(128))))\n    }\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each character of original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\npublic inline fun <R> CharSequence.flatMap(transform: (Char) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each character\n * and its index in the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterable\")\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.flatMapIndexed(transform: (index: Int, Char) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each character\n * and its index in the original char sequence, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapIndexedIterableTo\")\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.flatMapIndexedTo(destination: C, transform: (index: Int, Char) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each character of original char sequence, to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.flatMapTo(destination: C, transform: (Char) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups characters of the original char sequence by the key returned by the given [keySelector] function\n * applied to each character and returns a map where each group key is associated with a list of corresponding characters.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K> CharSequence.groupBy(keySelector: (Char) -> K): Map<K, List<Char>> {\n    return groupByTo(LinkedHashMap<K, MutableList<Char>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each character of the original char sequence\n * by the key returned by the given [keySelector] function applied to the character\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V> CharSequence.groupBy(keySelector: (Char) -> K, valueTransform: (Char) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups characters of the original char sequence by the key returned by the given [keySelector] function\n * applied to each character and puts to the [destination] map each group key associated with a list of corresponding characters.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\npublic inline fun <K, M : MutableMap<in K, MutableList<Char>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<Char>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each character of the original char sequence\n * by the key returned by the given [keySelector] function applied to the character\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> CharSequence.groupByTo(destination: M, keySelector: (Char) -> K, valueTransform: (Char) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Creates a [Grouping] source from a char sequence to be used later with one of group-and-fold operations\n * using the specified [keySelector] function to extract a key from each character.\n * \n * @sample samples.collections.Grouping.groupingByEachCount\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <K> CharSequence.groupingBy(crossinline keySelector: (Char) -> K): Grouping<Char, K> {\n    return object : Grouping<Char, K> {\n        override fun sourceIterator(): Iterator<Char> = this@groupingBy.iterator()\n        override fun keyOf(element: Char): K = keySelector(element)\n    }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each character in the original char sequence.\n * \n * @sample samples.text.Strings.map\n */\npublic inline fun <R> CharSequence.map(transform: (Char) -> R): List<R> {\n    return mapTo(ArrayList<R>(length), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each character and its index in the original char sequence.\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R> CharSequence.mapIndexed(transform: (index: Int, Char) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(length), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each character and its index in the original char sequence.\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R : Any> CharSequence.mapIndexedNotNull(transform: (index: Int, Char) -> R?): List<R> {\n    return mapIndexedNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each character and its index in the original char sequence\n * and appends only the non-null results to the given [destination].\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R : Any, C : MutableCollection<in R>> CharSequence.mapIndexedNotNullTo(destination: C, transform: (index: Int, Char) -> R?): C {\n    forEachIndexed { index, element -> transform(index, element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each character and its index in the original char sequence\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of a character and the character itself\n * and returns the result of the transform applied to the character.\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.mapIndexedTo(destination: C, transform: (index: Int, Char) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each character in the original char sequence.\n * \n * @sample samples.collections.Collections.Transformations.mapNotNull\n */\npublic inline fun <R : Any> CharSequence.mapNotNull(transform: (Char) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each character in the original char sequence\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <R : Any, C : MutableCollection<in R>> CharSequence.mapNotNullTo(destination: C, transform: (Char) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each character of the original char sequence\n * and appends the results to the given [destination].\n */\npublic inline fun <R, C : MutableCollection<in R>> CharSequence.mapTo(destination: C, transform: (Char) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each character of the original char sequence\n * into an [IndexedValue] containing the index of that character and the character itself.\n */\npublic fun CharSequence.withIndex(): Iterable<IndexedValue<Char>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns `true` if all characters match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun CharSequence.all(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if char sequence has at least one character.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun CharSequence.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one character matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun CharSequence.any(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the length of this char sequence.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.count(): Int {\n    return length\n}\n\n/**\n * Returns the number of characters matching the given [predicate].\n */\npublic inline fun CharSequence.count(predicate: (Char) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.fold(initial: R, operation: (acc: R, Char) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes a character and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldRight(initial: R, operation: (Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Returns the specified [initial] value if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself\n * and current accumulator value, and calculates the next accumulator value.\n */\npublic inline fun <R> CharSequence.foldRightIndexed(initial: R, operation: (index: Int, Char, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each character.\n */\npublic inline fun CharSequence.forEach(action: (Char) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each character, providing sequential index with the character.\n * @param [action] function that takes the index of a character and the character itself\n * and performs the action on the character.\n */\npublic inline fun CharSequence.forEachIndexed(action: (index: Int, Char) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun CharSequence.max(): Char? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic inline fun <R : Comparable<R>> CharSequence.maxBy(selector: (Char) -> R): Char? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first character yielding the largest value of the given function or `null` if there are no characters.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharSequence.maxByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.maxOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.maxOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.maxOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.maxOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest character or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.maxOrNull(): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun CharSequence.maxWith(comparator: Comparator<in Char>): Char? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first character having the largest value according to the provided [comparator] or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.maxWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun CharSequence.min(): Char? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic inline fun <R : Comparable<R>> CharSequence.minBy(selector: (Char) -> R): Char? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first character yielding the smallest value of the given function or `null` if there are no characters.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R : Comparable<R>> CharSequence.minByOrNull(selector: (Char) -> R): Char? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOf(selector: (Char) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOf(selector: (Char) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.minOf(selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOfOrNull(selector: (Char) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.minOfOrNull(selector: (Char) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> CharSequence.minOfOrNull(selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence.\n * \n * @throws NoSuchElementException if the char sequence is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.minOfWith(comparator: Comparator<in R>, selector: (Char) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each character in the char sequence or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <R> CharSequence.minOfWithOrNull(comparator: Comparator<in R>, selector: (Char) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest character or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.minOrNull(): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun CharSequence.minWith(comparator: Comparator<in Char>): Char? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first character having the smallest value according to the provided [comparator] or `null` if there are no characters.\n */\n@SinceKotlin(\"1.4\")\npublic fun CharSequence.minWithOrNull(comparator: Comparator<in Char>): Char? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the char sequence has no characters.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun CharSequence.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no characters match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun CharSequence.none(predicate: (Char) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each character and returns the char sequence itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <S : CharSequence> S.onEach(action: (Char) -> Unit): S {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each character, providing sequential index with the character,\n * and returns the char sequence itself afterwards.\n * @param [action] function that takes the index of a character and the character itself\n * and performs the action on the character.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <S : CharSequence> S.onEachIndexed(action: (index: Int, Char) -> Unit): S {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and a character,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharSequence.reduce(operation: (acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value and the character itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\npublic inline fun CharSequence.reduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): Char {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character with its index in the original char sequence.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, current accumulator value and the character itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.reduceIndexedOrNull(operation: (index: Int, acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first character and applying [operation] from left to right\n * to current accumulator value and each character.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes current accumulator value and a character,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharSequence.reduceOrNull(operation: (acc: Char, Char) -> Char): Char? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes a character and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharSequence.reduceRight(operation: (Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Throws an exception if this char sequence is empty. If the char sequence can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\npublic inline fun CharSequence.reduceRightIndexed(operation: (index: Int, Char, acc: Char) -> Char): Char {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty char sequence can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character with its index in the original char sequence and current accumulator value.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes the index of a character, the character itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.reduceRightIndexedOrNull(operation: (index: Int, Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last character and applying [operation] from right to left\n * to each character and current accumulator value.\n * \n * Returns `null` if the char sequence is empty.\n * \n * @param [operation] function that takes a character and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun CharSequence.reduceRightOrNull(operation: (Char, acc: Char) -> Char): Char? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R> CharSequence.runningFold(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(length + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <R> CharSequence.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(length + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with the first character of this char sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.runningReduce(operation: (acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(length).apply { add(accumulator) }\n    for (index in 1 until length) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with the first character of this char sequence.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\npublic inline fun CharSequence.runningReduceIndexed(operation: (index: Int, acc: Char, Char) -> Char): List<Char> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<Char>(length).apply { add(accumulator) }\n    for (index in 1 until length) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and a character, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <R> CharSequence.scan(initial: R, operation: (acc: R, Char) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each character, its index in the original char sequence and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of a character, current accumulator value\n * and the character itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic inline fun <R> CharSequence.scanIndexed(initial: R, operation: (index: Int, acc: R, Char) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun CharSequence.sumBy(selector: (Char) -> Int): Int {\n    var sum: Int = 0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic inline fun CharSequence.sumByDouble(selector: (Char) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each character in the char sequence.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.sumOf(selector: (Char) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Splits this char sequence into a list of strings each not exceeding the given [size].\n * \n * The last string in the resulting list may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.chunked(size: Int): List<String> {\n    return windowed(size, size, partialWindows = true)\n}\n\n/**\n * Splits this char sequence into several char sequences each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return list of results of the [transform] applied to an each char sequence.\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last char sequence may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunkedTransform\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.chunked(size: Int, transform: (CharSequence) -> R): List<R> {\n    return windowed(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Splits this char sequence into a sequence of strings each not exceeding the given [size].\n * \n * The last string in the resulting sequence may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each string, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.collections.Collections.Transformations.chunked\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.chunkedSequence(size: Int): Sequence<String> {\n    return chunkedSequence(size) { it.toString() }\n}\n\n/**\n * Splits this char sequence into several char sequences each not exceeding the given [size]\n * and applies the given [transform] function to an each.\n * \n * @return sequence of results of the [transform] applied to an each char sequence.\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * The last char sequence may have fewer characters than the given [size].\n * \n * @param size the number of elements to take in each char sequence, must be positive and can be greater than the number of elements in this char sequence.\n * \n * @sample samples.text.Strings.chunkedTransformToSequence\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.chunkedSequence(size: Int, transform: (CharSequence) -> R): Sequence<R> {\n    return windowedSequence(size, size, partialWindows = true, transform = transform)\n}\n\n/**\n * Splits the original char sequence into pair of char sequences,\n * where *first* char sequence contains characters for which [predicate] yielded `true`,\n * while *second* char sequence contains characters for which [predicate] yielded `false`.\n * \n * @sample samples.text.Strings.partition\n */\npublic inline fun CharSequence.partition(predicate: (Char) -> Boolean): Pair<CharSequence, CharSequence> {\n    val first = StringBuilder()\n    val second = StringBuilder()\n    for (element in this) {\n        if (predicate(element)) {\n            first.append(element)\n        } else {\n            second.append(element)\n        }\n    }\n    return Pair(first, second)\n}\n\n/**\n * Splits the original string into pair of strings,\n * where *first* string contains characters for which [predicate] yielded `true`,\n * while *second* string contains characters for which [predicate] yielded `false`.\n * \n * @sample samples.text.Strings.partition\n */\npublic inline fun String.partition(predicate: (Char) -> Boolean): Pair<String, String> {\n    val first = StringBuilder()\n    val second = StringBuilder()\n    for (element in this) {\n        if (predicate(element)) {\n            first.append(element)\n        } else {\n            second.append(element)\n        }\n    }\n    return Pair(first.toString(), second.toString())\n}\n\n/**\n * Returns a list of snapshots of the window of the given [size]\n * sliding along this char sequence with the given [step], where each\n * snapshot is a string.\n * \n * Several last strings may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false): List<String> {\n    return windowed(size, step, partialWindows) { it.toString() }\n}\n\n/**\n * Returns a list of results of applying the given [transform] function to\n * an each char sequence representing a view over the window of the given [size]\n * sliding along this char sequence with the given [step].\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last char sequences may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.windowed(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (CharSequence) -> R): List<R> {\n    checkWindowSizeStep(size, step)\n    val thisSize = this.length\n    val resultCapacity = thisSize / step + if (thisSize % step == 0) 0 else 1\n    val result = ArrayList<R>(resultCapacity)\n    var index = 0\n    while (index in 0 until thisSize) {\n        val end = index + size\n        val coercedEnd = if (end < 0 || end > thisSize) { if (partialWindows) thisSize else break } else end\n        result.add(transform(subSequence(index, coercedEnd)))\n        index += step\n    }\n    return result\n}\n\n/**\n * Returns a sequence of snapshots of the window of the given [size]\n * sliding along this char sequence with the given [step], where each\n * snapshot is a string.\n * \n * Several last strings may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.takeWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.windowedSequence(size: Int, step: Int = 1, partialWindows: Boolean = false): Sequence<String> {\n    return windowedSequence(size, step, partialWindows) { it.toString() }\n}\n\n/**\n * Returns a sequence of results of applying the given [transform] function to\n * an each char sequence representing a view over the window of the given [size]\n * sliding along this char sequence with the given [step].\n * \n * Note that the char sequence passed to the [transform] function is ephemeral and is valid only inside that function.\n * You should not store it or allow it to escape in some way, unless you made a snapshot of it.\n * Several last char sequences may have fewer characters than the given [size].\n * \n * Both [size] and [step] must be positive and can be greater than the number of elements in this char sequence.\n * @param size the number of elements to take in each window\n * @param step the number of elements to move the window forward by on an each step, by default 1\n * @param partialWindows controls whether or not to keep partial windows in the end if any,\n * by default `false` which means partial windows won't be preserved\n * \n * @sample samples.collections.Sequences.Transformations.averageWindows\n */\n@SinceKotlin(\"1.2\")\npublic fun <R> CharSequence.windowedSequence(size: Int, step: Int = 1, partialWindows: Boolean = false, transform: (CharSequence) -> R): Sequence<R> {\n    checkWindowSizeStep(size, step)\n    val windows = (if (partialWindows) indices else 0 until length - size + 1) step step\n    return windows.asSequence().map { index ->\n        val end = index + size\n        val coercedEnd = if (end < 0 || end > length) length else end\n        transform(subSequence(index, coercedEnd))\n    }\n}\n\n/**\n * Returns a list of pairs built from the characters of `this` and the [other] char sequences with the same index\n * The returned list has length of the shortest char sequence.\n * \n * @sample samples.text.Strings.zip\n */\npublic infix fun CharSequence.zip(other: CharSequence): List<Pair<Char, Char>> {\n    return zip(other) { c1, c2 -> c1 to c2 }\n}\n\n/**\n * Returns a list of values built from the characters of `this` and the [other] char sequences with the same index\n * using the provided [transform] function applied to each pair of characters.\n * The returned list has length of the shortest char sequence.\n * \n * @sample samples.text.Strings.zipWithTransform\n */\npublic inline fun <V> CharSequence.zip(other: CharSequence, transform: (a: Char, b: Char) -> V): List<V> {\n    val length = minOf(this.length, other.length)\n    val list = ArrayList<V>(length)\n    for (i in 0 until length) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs of each two adjacent characters in this char sequence.\n * \n * The returned list is empty if this char sequence contains less than two characters.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNext\n */\n@SinceKotlin(\"1.2\")\npublic fun CharSequence.zipWithNext(): List<Pair<Char, Char>> {\n    return zipWithNext { a, b -> a to b }\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to an each pair of two adjacent characters in this char sequence.\n * \n * The returned list is empty if this char sequence contains less than two characters.\n * \n * @sample samples.collections.Collections.Transformations.zipWithNextToFindDeltas\n */\n@SinceKotlin(\"1.2\")\npublic inline fun <R> CharSequence.zipWithNext(transform: (a: Char, b: Char) -> R): List<R> {\n    val size = length - 1\n    if (size < 1) return emptyList()\n    val result = ArrayList<R>(size)\n    for (index in 0 until size) {\n        result.add(transform(this[index], this[index + 1]))\n    }\n    return result\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original char sequence returning its characters when being iterated.\n */\npublic fun CharSequence.asIterable(): Iterable<Char> {\n    if (this is String && isEmpty()) return emptyList()\n    return Iterable { this.iterator() }\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original char sequence returning its characters when being iterated.\n */\npublic fun CharSequence.asSequence(): Sequence<Char> {\n    if (this is String && isEmpty()) return emptySequence()\n    return Sequence { this.iterator() }\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\nimport kotlin.contracts.contract\nimport kotlin.jvm.JvmName\n\n/**\n * Returns a copy of this string converted to upper case using the rules of the default locale.\n */\n@Deprecated(\"Use uppercase() instead.\", ReplaceWith(\"uppercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.toUpperCase(): String\n\n/**\n * Returns a copy of this string converted to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun String.uppercase(): String\n\n/**\n * Returns a copy of this string converted to lower case using the rules of the default locale.\n */\n@Deprecated(\"Use lowercase() instead.\", ReplaceWith(\"lowercase()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.toLowerCase(): String\n\n/**\n * Returns a copy of this string converted to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many and many-to-one character mapping,\n * thus the length of the returned string can be different from the length of the original string.\n *\n * @sample samples.text.Strings.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun String.lowercase(): String\n\n/**\n * Returns a copy of this string having its first letter titlecased using the rules of the default locale,\n * or the original string if it's empty or already starts with a title case letter.\n *\n * The title case of a character is usually the same as its upper case with several exceptions.\n * The particular list of characters with the special title case form depends on the underlying platform.\n *\n * @sample samples.text.Strings.capitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.capitalize(): String\n\n/**\n * Returns a copy of this string having its first letter lowercased using the rules of the default locale,\n * or the original string if it's empty or already starts with a lower case letter.\n *\n * @sample samples.text.Strings.decapitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { it.lowercase() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun String.decapitalize(): String\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trim(predicate: (Char) -> Boolean): CharSequence {\n    var startIndex = 0\n    var endIndex = length - 1\n    var startFound = false\n\n    while (startIndex <= endIndex) {\n        val index = if (!startFound) startIndex else endIndex\n        val match = predicate(this[index])\n\n        if (!startFound) {\n            if (!match)\n                startFound = true\n            else\n                startIndex += 1\n        } else {\n            if (!match)\n                break\n            else\n                endIndex -= 1\n        }\n    }\n\n    return subSequence(startIndex, endIndex + 1)\n}\n\n/**\n * Returns a string having leading and trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trim(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trim(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimStart(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices)\n        if (!predicate(this[index]))\n            return subSequence(index, length)\n\n    return \"\"\n}\n\n/**\n * Returns a string having leading characters matching the [predicate] removed.\n */\npublic inline fun String.trimStart(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimStart(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters matching the [predicate] removed.\n */\npublic inline fun CharSequence.trimEnd(predicate: (Char) -> Boolean): CharSequence {\n    for (index in this.indices.reversed())\n        if (!predicate(this[index]))\n            return subSequence(0, index + 1)\n\n    return \"\"\n}\n\n/**\n * Returns a string having trailing characters matching the [predicate] removed.\n */\npublic inline fun String.trimEnd(predicate: (Char) -> Boolean): String =\n    (this as CharSequence).trimEnd(predicate).toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trim(vararg chars: Char): CharSequence = trim { it in chars }\n\n/**\n * Returns a string having leading and trailing characters from the [chars] array removed.\n */\npublic fun String.trim(vararg chars: Char): String = trim { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading characters from the [chars] array removed.\n */\npublic fun CharSequence.trimStart(vararg chars: Char): CharSequence = trimStart { it in chars }\n\n/**\n * Returns a string having leading characters from the [chars] array removed.\n */\npublic fun String.trimStart(vararg chars: Char): String = trimStart { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having trailing characters from the [chars] array removed.\n */\npublic fun CharSequence.trimEnd(vararg chars: Char): CharSequence = trimEnd { it in chars }\n\n/**\n * Returns a string having trailing characters from the [chars] array removed.\n */\npublic fun String.trimEnd(vararg chars: Char): String = trimEnd { it in chars }\n\n/**\n * Returns a sub sequence of this char sequence having leading and trailing whitespace removed.\n */\npublic fun CharSequence.trim(): CharSequence = trim(Char::isWhitespace)\n\n/**\n * Returns a string having leading and trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trim(): String = (this as CharSequence).trim().toString()\n\n/**\n * Returns a sub sequence of this char sequence having leading whitespace removed.\n */\npublic fun CharSequence.trimStart(): CharSequence = trimStart(Char::isWhitespace)\n\n/**\n * Returns a string having leading whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimStart(): String = (this as CharSequence).trimStart().toString()\n\n/**\n * Returns a sub sequence of this char sequence having trailing whitespace removed.\n */\npublic fun CharSequence.trimEnd(): CharSequence = trimEnd(Char::isWhitespace)\n\n/**\n * Returns a string having trailing whitespace removed.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.trimEnd(): String = (this as CharSequence).trimEnd().toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the beginning\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun CharSequence.padStart(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    sb.append(this)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the beginning with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string prepended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padStart\n */\npublic fun String.padStart(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padStart(length, padChar).toString()\n\n/**\n * Returns a char sequence with content of this char sequence padded at the end\n * to the specified [length] with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a char sequence of length at least [length] consisting of `this` char sequence appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun CharSequence.padEnd(length: Int, padChar: Char = ' '): CharSequence {\n    if (length < 0)\n        throw IllegalArgumentException(\"Desired length $length is less than zero.\")\n    if (length <= this.length)\n        return this.subSequence(0, this.length)\n\n    val sb = StringBuilder(length)\n    sb.append(this)\n    for (i in 1..(length - this.length))\n        sb.append(padChar)\n    return sb\n}\n\n/**\n * Pads the string to the specified [length] at the end with the specified character or space.\n *\n * @param length the desired string length.\n * @param padChar the character to pad string with, if it has length less than the [length] specified. Space is used by default.\n * @return Returns a string of length at least [length] consisting of `this` string appended with [padChar] as many times\n * as are necessary to reach that length.\n * @sample samples.text.Strings.padEnd\n */\npublic fun String.padEnd(length: Int, padChar: Char = ' '): String =\n    (this as CharSequence).padEnd(length, padChar).toString()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty.\n *\n * @sample samples.text.Strings.stringIsNullOrEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrEmpty(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrEmpty != null)\n    }\n\n    return this == null || this.length == 0\n}\n\n/**\n * Returns `true` if this char sequence is empty (contains no characters).\n *\n * @sample samples.text.Strings.stringIsEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isEmpty(): Boolean = length == 0\n\n/**\n * Returns `true` if this char sequence is not empty.\n *\n * @sample samples.text.Strings.stringIsNotEmpty\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotEmpty(): Boolean = length > 0\n\n// implemented differently in JVM and JS\n//public fun String.isBlank(): Boolean = length() == 0 || all { it.isWhitespace() }\n\n\n/**\n * Returns `true` if this char sequence is not empty and contains some characters except of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNotBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.isNotBlank(): Boolean = !isBlank()\n\n/**\n * Returns `true` if this nullable char sequence is either `null` or empty or consists solely of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsNullOrBlank\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence?.isNullOrBlank(): Boolean {\n    contract {\n        returns(false) implies (this@isNullOrBlank != null)\n    }\n\n    return this == null || this.isBlank()\n}\n\n/**\n * Iterator for characters of the given char sequence.\n */\npublic operator fun CharSequence.iterator(): CharIterator = object : CharIterator() {\n    private var index = 0\n\n    public override fun nextChar(): Char = get(index++)\n\n    public override fun hasNext(): Boolean = index < length\n}\n\n/** Returns the string if it is not `null`, or the empty string otherwise. */\n@kotlin.internal.InlineOnly\npublic inline fun String?.orEmpty(): String = this ?: \"\"\n\n/**\n * Returns this char sequence if it's not empty\n * or the result of calling [defaultValue] function if the char sequence is empty.\n *\n * @sample samples.text.Strings.stringIfEmpty\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifEmpty(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isEmpty()) defaultValue() else this\n\n/**\n * Returns this char sequence if it is not empty and doesn't consist solely of whitespace characters,\n * or the result of calling [defaultValue] function otherwise.\n *\n * @sample samples.text.Strings.stringIfBlank\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline fun <C, R> C.ifBlank(defaultValue: () -> R): R where C : CharSequence, C : R =\n    if (isBlank()) defaultValue() else this\n\n/**\n * Returns the range of valid character indices for this char sequence.\n */\npublic val CharSequence.indices: IntRange\n    get() = 0..length - 1\n\n/**\n * Returns the index of the last character in the char sequence or -1 if it is empty.\n */\npublic val CharSequence.lastIndex: Int\n    get() = this.length - 1\n\n/**\n * Returns `true` if this CharSequence has Unicode surrogate pair at the specified [index].\n */\npublic fun CharSequence.hasSurrogatePairAt(index: Int): Boolean {\n    return index in 0..length - 2\n            && this[index].isHighSurrogate()\n            && this[index + 1].isLowSurrogate()\n}\n\n/**\n * Returns a substring specified by the given [range] of indices.\n */\npublic fun String.substring(range: IntRange): String = substring(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence specified by the given [range] of indices.\n */\npublic fun CharSequence.subSequence(range: IntRange): CharSequence = subSequence(range.start, range.endInclusive + 1)\n\n/**\n * Returns a subsequence of this char sequence.\n *\n * This extension is chosen only for invocation with old-named parameters.\n * Replace parameter names with the same as those of [CharSequence.subSequence].\n */\n@kotlin.internal.InlineOnly\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\") // false warning\n@Deprecated(\"Use parameters named startIndex and endIndex.\", ReplaceWith(\"subSequence(startIndex = start, endIndex = end)\"))\npublic inline fun String.subSequence(start: Int, end: Int): CharSequence = subSequence(start, end)\n\n/**\n * Returns a substring of chars from a range of this char sequence starting at the [startIndex] and ending right before the [endIndex].\n *\n * @param startIndex the start index (inclusive).\n * @param endIndex the end index (exclusive). If not specified, the length of the char sequence is used.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.substring(startIndex: Int, endIndex: Int = length): String = subSequence(startIndex, endIndex).toString()\n\n/**\n * Returns a substring of chars at indices from the specified [range] of this char sequence.\n */\npublic fun CharSequence.substring(range: IntRange): String = subSequence(range.start, range.endInclusive + 1).toString()\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBefore(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the first occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfter(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring before the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringBeforeLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(0, index)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: Char, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + 1, length)\n}\n\n/**\n * Returns a substring after the last occurrence of [delimiter].\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.substringAfterLast(delimiter: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else substring(index + delimiter.length, length)\n}\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range\n * is replaced with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\npublic fun CharSequence.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n    val sb = StringBuilder()\n    sb.appendRange(this, 0, startIndex)\n    sb.append(replacement)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Replaces the part of the string at the given range with the [replacement] char sequence.\n * @param startIndex the index of the first character to be replaced.\n * @param endIndex the index of the first character after the replacement to keep in the string.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(startIndex: Int, endIndex: Int, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(startIndex, endIndex, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range]\n * is replaced with the [replacement] char sequence.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\npublic fun CharSequence.replaceRange(range: IntRange, replacement: CharSequence): CharSequence =\n    replaceRange(range.start, range.endInclusive + 1, replacement)\n\n/**\n * Replace the part of string at the given [range] with the [replacement] string.\n *\n * The end index of the [range] is included in the part to be replaced.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceRange(range: IntRange, replacement: CharSequence): String =\n    (this as CharSequence).replaceRange(range, replacement).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given range is removed.\n *\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n * [endIndex] is not included in the removed part.\n */\npublic fun CharSequence.removeRange(startIndex: Int, endIndex: Int): CharSequence {\n    if (endIndex < startIndex)\n        throw IndexOutOfBoundsException(\"End index ($endIndex) is less than start index ($startIndex).\")\n\n    if (endIndex == startIndex)\n        return this.subSequence(0, length)\n\n    val sb = StringBuilder(length - (endIndex - startIndex))\n    sb.appendRange(this, 0, startIndex)\n    sb.appendRange(this, endIndex, length)\n    return sb\n}\n\n/**\n * Removes the part of a string at a given range.\n * @param startIndex the index of the first character to be removed.\n * @param endIndex the index of the first character after the removed part to keep in the string.\n *\n *  [endIndex] is not included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(startIndex: Int, endIndex: Int): String =\n    (this as CharSequence).removeRange(startIndex, endIndex).toString()\n\n/**\n * Returns a char sequence with content of this char sequence where its part at the given [range] is removed.\n *\n * The end index of the [range] is included in the removed part.\n */\npublic fun CharSequence.removeRange(range: IntRange): CharSequence = removeRange(range.start, range.endInclusive + 1)\n\n/**\n * Removes the part of a string at the given [range].\n *\n * The end index of the [range] is included in the removed part.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.removeRange(range: IntRange): String =\n    (this as CharSequence).removeRange(range).toString()\n\n/**\n * If this char sequence starts with the given [prefix], returns a new char sequence\n * with the prefix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removePrefix(prefix: CharSequence): CharSequence {\n    if (startsWith(prefix)) {\n        return subSequence(prefix.length, length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string starts with the given [prefix], returns a copy of this string\n * with the prefix removed. Otherwise, returns this string.\n */\npublic fun String.removePrefix(prefix: CharSequence): String {\n    if (startsWith(prefix)) {\n        return substring(prefix.length)\n    }\n    return this\n}\n\n/**\n * If this char sequence ends with the given [suffix], returns a new char sequence\n * with the suffix removed. Otherwise, returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSuffix(suffix: CharSequence): CharSequence {\n    if (endsWith(suffix)) {\n        return subSequence(0, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * If this string ends with the given [suffix], returns a copy of this string\n * with the suffix removed. Otherwise, returns this string.\n */\npublic fun String.removeSuffix(suffix: CharSequence): String {\n    if (endsWith(suffix)) {\n        return substring(0, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with the given [prefix] and ends with the given [suffix],\n * returns a new char sequence having both the given [prefix] and [suffix] removed.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(prefix: CharSequence, suffix: CharSequence): CharSequence {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return subSequence(prefix.length, length - suffix.length)\n    }\n    return subSequence(0, length)\n}\n\n/**\n * Removes from a string both the given [prefix] and [suffix] if and only if\n * it starts with the [prefix] and ends with the [suffix].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(prefix: CharSequence, suffix: CharSequence): String {\n    if ((length >= prefix.length + suffix.length) && startsWith(prefix) && endsWith(suffix)) {\n        return substring(prefix.length, length - suffix.length)\n    }\n    return this\n}\n\n/**\n * When this char sequence starts with and ends with the given [delimiter],\n * returns a new char sequence having this [delimiter] removed both from the start and end.\n * Otherwise returns a new char sequence with the same characters.\n */\npublic fun CharSequence.removeSurrounding(delimiter: CharSequence): CharSequence = removeSurrounding(delimiter, delimiter)\n\n/**\n * Removes the given [delimiter] string from both the start and the end of this string\n * if and only if it starts with and ends with the [delimiter].\n * Otherwise returns this string unchanged.\n */\npublic fun String.removeSurrounding(delimiter: CharSequence): String = removeSurrounding(delimiter, delimiter)\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBefore(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string after the first occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfter(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = indexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + delimiter.length, length, replacement)\n}\n\n/**\n * Replace part of string after the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceAfterLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(index + 1, length, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: Char, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n/**\n * Replace part of string before the last occurrence of given delimiter with the [replacement] string.\n * If the string does not contain the delimiter, returns [missingDelimiterValue] which defaults to the original string.\n */\npublic fun String.replaceBeforeLast(delimiter: String, replacement: String, missingDelimiterValue: String = this): String {\n    val index = lastIndexOf(delimiter)\n    return if (index == -1) missingDelimiterValue else replaceRange(0, index, replacement)\n}\n\n\n// public fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean): String // JVM- and JS-specific\n// public fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean): String // JVM- and JS-specific\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the given [replacement].\n *\n * The [replacement] can consist of any combination of literal text and $-substitutions. To treat the replacement string\n * literally escape it with the [kotlin.text.Regex.Companion.escapeReplacement] method.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, replacement: String): String = regex.replace(this, replacement)\n\n/**\n * Returns a new string obtained by replacing each substring of this char sequence that matches the given regular expression\n * with the result of the given function [transform] that takes [MatchResult] and returns a string to be used as a\n * replacement for that match.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replace(regex: Regex, noinline transform: (MatchResult) -> CharSequence): String =\n    regex.replace(this, transform)\n\n/**\n * Replaces the first occurrence of the given regular expression [regex] in this char sequence with specified [replacement] expression.\n *\n * @param replacement A replacement expression that can include substitutions. See [Regex.replaceFirst] for details.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.replaceFirst(regex: Regex, replacement: String): String = regex.replaceFirst(this, replacement)\n\n/**\n * Returns a copy of this string having its first character replaced with the result of the specified [transform],\n * or the original string if it's empty.\n *\n * @param transform function that takes the first character and returns the result of the transform applied to the character.\n *\n * @sample samples.text.Strings.replaceFirstChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@JvmName(\"replaceFirstCharWithChar\")\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceFirstChar(transform: (Char) -> Char): String {\n    return if (isNotEmpty()) transform(this[0]) + substring(1) else this\n}\n\n/**\n * Returns a copy of this string having its first character replaced with the result of the specified [transform],\n * or the original string if it's empty.\n *\n * @param transform function that takes the first character and returns the result of the transform applied to the character.\n *\n * @sample samples.text.Strings.replaceFirstChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@JvmName(\"replaceFirstCharWithCharSequence\")\n@kotlin.internal.InlineOnly\npublic inline fun String.replaceFirstChar(transform: (Char) -> CharSequence): String {\n    return if (isNotEmpty()) transform(this[0]).toString() + substring(1) else this\n}\n\n\n/**\n * Returns `true` if this char sequence matches the given regular expression.\n */\n@kotlin.internal.InlineOnly\npublic inline infix fun CharSequence.matches(regex: Regex): Boolean = regex.matches(this)\n\n/**\n * Implementation of [regionMatches] for CharSequences.\n * Invoked when it's already known that arguments are not Strings, so that no additional type checks are performed.\n */\ninternal fun CharSequence.regionMatchesImpl(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean): Boolean {\n    if ((otherOffset < 0) || (thisOffset < 0) || (thisOffset > this.length - length) || (otherOffset > other.length - length)) {\n        return false\n    }\n\n    for (index in 0 until length) {\n        if (!this[thisOffset + index].equals(other[otherOffset + index], ignoreCase))\n            return false\n    }\n    return true\n}\n\n/**\n * Returns `true` if this char sequence starts with the specified character.\n */\npublic fun CharSequence.startsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[0].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence ends with the specified character.\n */\npublic fun CharSequence.endsWith(char: Char, ignoreCase: Boolean = false): Boolean =\n    this.length > 0 && this[lastIndex].equals(char, ignoreCase)\n\n/**\n * Returns `true` if this char sequence starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix)\n    else\n        return regionMatchesImpl(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this char sequence starting at the specified offset [startIndex] starts with the specified prefix.\n */\npublic fun CharSequence.startsWith(prefix: CharSequence, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && prefix is String)\n        return this.startsWith(prefix, startIndex)\n    else\n        return regionMatchesImpl(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this char sequence ends with the specified suffix.\n */\npublic fun CharSequence.endsWith(suffix: CharSequence, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase && this is String && suffix is String)\n        return this.endsWith(suffix)\n    else\n        return regionMatchesImpl(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n\n// common prefix and suffix\n\n/**\n * Returns the longest string `prefix` such that this char sequence and [other] char sequence both start with this prefix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common prefix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonPrefixWith\n */\npublic fun CharSequence.commonPrefixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val shortestLength = minOf(this.length, other.length)\n\n    var i = 0\n    while (i < shortestLength && this[i].equals(other[i], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(i - 1) || other.hasSurrogatePairAt(i - 1)) {\n        i--\n    }\n    return subSequence(0, i).toString()\n}\n\n/**\n * Returns the longest string `suffix` such that this char sequence and [other] char sequence both end with this suffix,\n * taking care not to split surrogate pairs.\n * If this and [other] have no common suffix, returns the empty string.\n\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @sample samples.text.Strings.commonSuffixWith\n */\npublic fun CharSequence.commonSuffixWith(other: CharSequence, ignoreCase: Boolean = false): String {\n    val thisLength = this.length\n    val otherLength = other.length\n    val shortestLength = minOf(thisLength, otherLength)\n\n    var i = 0\n    while (i < shortestLength && this[thisLength - i - 1].equals(other[otherLength - i - 1], ignoreCase = ignoreCase)) {\n        i++\n    }\n    if (this.hasSurrogatePairAt(thisLength - i - 1) || other.hasSurrogatePairAt(otherLength - i - 1)) {\n        i--\n    }\n    return subSequence(thisLength - i, thisLength).toString()\n}\n\n\n// indexOfAny()\n\n/**\n * Finds the index of the first occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.indexOfAny(chars: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeIndexOf(char, startIndex)\n    }\n\n    for (index in startIndex.coerceAtLeast(0)..lastIndex) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n    return -1\n}\n\n/**\n * Finds the index of the last occurrence of any of the specified [chars] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of matched character from [chars] or -1 if none of [chars] are found.\n *\n */\npublic fun CharSequence.lastIndexOfAny(chars: CharArray, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    if (!ignoreCase && chars.size == 1 && this is String) {\n        val char = chars.single()\n        return nativeLastIndexOf(char, startIndex)\n    }\n\n\n    for (index in startIndex.coerceAtMost(lastIndex) downTo 0) {\n        val charAtIndex = get(index)\n        if (chars.any { it.equals(charAtIndex, ignoreCase) })\n            return index\n    }\n\n    return -1\n}\n\n\nprivate fun CharSequence.indexOf(other: CharSequence, startIndex: Int, endIndex: Int, ignoreCase: Boolean, last: Boolean = false): Int {\n    val indices = if (!last)\n        startIndex.coerceAtLeast(0)..endIndex.coerceAtMost(length)\n    else\n        startIndex.coerceAtMost(lastIndex) downTo endIndex.coerceAtLeast(0)\n\n    if (this is String && other is String) { // smart cast\n        for (index in indices) {\n            if (other.regionMatches(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    } else {\n        for (index in indices) {\n            if (other.regionMatchesImpl(0, this, index, other.length, ignoreCase))\n                return index\n        }\n    }\n    return -1\n}\n\nprivate fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int, ignoreCase: Boolean, last: Boolean): Pair<Int, String>? {\n    if (!ignoreCase && strings.size == 1) {\n        val string = strings.single()\n        val index = if (!last) indexOf(string, startIndex) else lastIndexOf(string, startIndex)\n        return if (index < 0) null else index to string\n    }\n\n    val indices = if (!last) startIndex.coerceAtLeast(0)..length else startIndex.coerceAtMost(lastIndex) downTo 0\n\n    if (this is String) {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatches(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    } else {\n        for (index in indices) {\n            val matchingString = strings.firstOrNull { it.regionMatchesImpl(0, this, index, it.length, ignoreCase) }\n            if (matchingString != null)\n                return index to matchingString\n        }\n    }\n\n    return null\n}\n\n/**\n * Finds the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the first occurrence of matched string from [strings] and the string matched\n * or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findAnyOf(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)\n\n/**\n * Finds the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return A pair of an index of the last occurrence of matched string from [strings] and the string matched or `null` if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.findLastAnyOf(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Pair<Int, String>? =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)\n\n/**\n * Finds the index of the first occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.indexOfAny(strings: Collection<String>, startIndex: Int = 0, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = false)?.first ?: -1\n\n/**\n * Finds the index of the last occurrence of any of the specified [strings] in this char sequence,\n * starting from the specified [startIndex] and optionally ignoring the case.\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of matched string from [strings] or -1 if none of [strings] are found.\n *\n * To avoid ambiguous results when strings in [strings] have characters in common, this method proceeds from\n * the end toward the beginning of this string, and finds at each position the first element in [strings]\n * that matches this string at that position.\n */\npublic fun CharSequence.lastIndexOfAny(strings: Collection<String>, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int =\n    findAnyOf(strings, startIndex, ignoreCase, last = true)?.first ?: -1\n\n\n// indexOf\n\n/**\n * Returns the index within this string of the first occurrence of the specified character, starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the first occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.indexOf(char: Char, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the first occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the first occurrence of [string] or `-1` if none is found.\n * @sample samples.text.Strings.indexOf\n */\npublic fun CharSequence.indexOf(string: String, startIndex: Int = 0, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, length, ignoreCase)\n    else\n        nativeIndexOf(string, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified character,\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a character. By default `false`.\n * @return An index of the last occurrence of [char] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(char: Char, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        lastIndexOfAny(charArrayOf(char), startIndex, ignoreCase)\n    else\n        nativeLastIndexOf(char, startIndex)\n}\n\n/**\n * Returns the index within this char sequence of the last occurrence of the specified [string],\n * starting from the specified [startIndex].\n *\n * @param startIndex The index of character to start searching at. The search proceeds backward toward the beginning of the string.\n * @param ignoreCase `true` to ignore character case when matching a string. By default `false`.\n * @return An index of the last occurrence of [string] or -1 if none is found.\n */\npublic fun CharSequence.lastIndexOf(string: String, startIndex: Int = lastIndex, ignoreCase: Boolean = false): Int {\n    return if (ignoreCase || this !is String)\n        indexOf(string, startIndex, 0, ignoreCase, last = true)\n    else\n        nativeLastIndexOf(string, startIndex)\n}\n\n/**\n * Returns `true` if this char sequence contains the specified [other] sequence of characters as a substring.\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(other: CharSequence, ignoreCase: Boolean = false): Boolean =\n    if (other is String)\n        indexOf(other, ignoreCase = ignoreCase) >= 0\n    else\n        indexOf(other, 0, length, ignoreCase) >= 0\n\n\n\n/**\n * Returns `true` if this char sequence contains the specified character [char].\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n */\n@Suppress(\"INAPPLICABLE_OPERATOR_MODIFIER\")\npublic operator fun CharSequence.contains(char: Char, ignoreCase: Boolean = false): Boolean =\n    indexOf(char, ignoreCase = ignoreCase) >= 0\n\n/**\n * Returns `true` if this char sequence contains at least one match of the specified regular expression [regex].\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun CharSequence.contains(regex: Regex): Boolean = regex.containsMatchIn(this)\n\n\n// rangesDelimitedBy\n\n\nprivate class DelimitedRangesSequence(\n    private val input: CharSequence,\n    private val startIndex: Int,\n    private val limit: Int,\n    private val getNextMatch: CharSequence.(currentIndex: Int) -> Pair<Int, Int>?\n) : Sequence<IntRange> {\n\n    override fun iterator(): Iterator<IntRange> = object : Iterator<IntRange> {\n        var nextState: Int = -1 // -1 for unknown, 0 for done, 1 for continue\n        var currentStartIndex: Int = startIndex.coerceIn(0, input.length)\n        var nextSearchIndex: Int = currentStartIndex\n        var nextItem: IntRange? = null\n        var counter: Int = 0\n\n        private fun calcNext() {\n            if (nextSearchIndex < 0) {\n                nextState = 0\n                nextItem = null\n            } else {\n                if (limit > 0 && ++counter >= limit || nextSearchIndex > input.length) {\n                    nextItem = currentStartIndex..input.lastIndex\n                    nextSearchIndex = -1\n                } else {\n                    val match = input.getNextMatch(nextSearchIndex)\n                    if (match == null) {\n                        nextItem = currentStartIndex..input.lastIndex\n                        nextSearchIndex = -1\n                    } else {\n                        val (index, length) = match\n                        nextItem = currentStartIndex until index\n                        currentStartIndex = index + length\n                        nextSearchIndex = currentStartIndex + if (length == 0) 1 else 0\n                    }\n                }\n                nextState = 1\n            }\n        }\n\n        override fun next(): IntRange {\n            if (nextState == -1)\n                calcNext()\n            if (nextState == 0)\n                throw NoSuchElementException()\n            val result = nextItem as IntRange\n            // Clean next to avoid keeping reference on yielded instance\n            nextItem = null\n            nextState = -1\n            return result\n        }\n\n        override fun hasNext(): Boolean {\n            if (nextState == -1)\n                calcNext()\n            return nextState == 1\n        }\n    }\n}\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: CharArray, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    requireNonNegativeLimit(limit)\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex ->\n        indexOfAny(delimiters, currentIndex, ignoreCase = ignoreCase).let { if (it < 0) null else it to 1 }\n    })\n}\n\n\n/**\n * Returns a sequence of index ranges of substrings in this char sequence around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param startIndex The index to start searching delimiters from.\n *  No range having its start value less than [startIndex] is returned.\n *  [startIndex] is coerced to be non-negative and not greater than length of this string.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\nprivate fun CharSequence.rangesDelimitedBy(delimiters: Array<out String>, startIndex: Int = 0, ignoreCase: Boolean = false, limit: Int = 0): Sequence<IntRange> {\n    requireNonNegativeLimit(limit)\n    val delimitersList = delimiters.asList()\n\n    return DelimitedRangesSequence(this, startIndex, limit, { currentIndex -> findAnyOf(delimitersList, currentIndex, ignoreCase = ignoreCase, last = false)?.let { it.first to it.second.length } })\n\n}\n\ninternal fun requireNonNegativeLimit(limit: Int) =\n    require(limit >= 0) { \"Limit must be non-negative, but was $limit\" }\n\n\n// split\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and finds at each position the first element in [delimiters]\n * that matches this string at that position.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more strings to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return. Zero by default means no limit is set.\n *\n * To avoid ambiguous results when strings in [delimiters] have characters in common, this method proceeds from\n * the beginning to the end of this string, and matches at each position the first element in [delimiters]\n * that is equal to a delimiter in this instance at that position.\n */\npublic fun CharSequence.split(vararg delimiters: String, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        val delimiter = delimiters[0]\n        if (!delimiter.isEmpty()) {\n            return split(delimiter, ignoreCase, limit)\n        }\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a sequence of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.splitToSequence(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): Sequence<String> =\n    rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).map { substring(it) }\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiters].\n *\n * @param delimiters One or more characters to be used as delimiters.\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\npublic fun CharSequence.split(vararg delimiters: Char, ignoreCase: Boolean = false, limit: Int = 0): List<String> {\n    if (delimiters.size == 1) {\n        return split(delimiters[0].toString(), ignoreCase, limit)\n    }\n\n    return rangesDelimitedBy(delimiters, ignoreCase = ignoreCase, limit = limit).asIterable().map { substring(it) }\n}\n\n/**\n * Splits this char sequence to a list of strings around occurrences of the specified [delimiter].\n * This is specialized version of split which receives single non-empty delimiter and offers better performance\n *\n * @param delimiter String used as delimiter\n * @param ignoreCase `true` to ignore character case when matching a delimiter. By default `false`.\n * @param limit The maximum number of substrings to return.\n */\nprivate fun CharSequence.split(delimiter: String, ignoreCase: Boolean, limit: Int): List<String> {\n    requireNonNegativeLimit(limit)\n\n    var currentOffset = 0\n    var nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    if (nextIndex == -1 || limit == 1) {\n        return listOf(this.toString())\n    }\n\n    val isLimited = limit > 0\n    val result = ArrayList<String>(if (isLimited) limit.coerceAtMost(10) else 10)\n    do {\n        result.add(substring(currentOffset, nextIndex))\n        currentOffset = nextIndex + delimiter.length\n        // Do not search for next occurrence if we're reaching limit\n        if (isLimited && result.size == limit - 1) break\n        nextIndex = indexOf(delimiter, currentOffset, ignoreCase)\n    } while (nextIndex != -1)\n\n    result.add(substring(currentOffset, length))\n    return result\n}\n\n/**\n * Splits this char sequence to a list of strings around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.split(regex: Regex, limit: Int = 0): List<String> = regex.split(this, limit)\n\n/**\n * Splits this char sequence to a sequence of strings around matches of the given regular expression.\n *\n * @param limit Non-negative value specifying the maximum number of substrings to return.\n * Zero by default means no limit is set.\n * @sample samples.text.Strings.splitToSequence\n */\n@SinceKotlin(\"1.6\")\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun CharSequence.splitToSequence(regex: Regex, limit: Int = 0): Sequence<String> = regex.splitToSequence(this, limit)\n\n/**\n * Splits this char sequence to a sequence of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lineSequence(): Sequence<String> = splitToSequence(\"\\r\\n\", \"\\n\", \"\\r\")\n\n/**\n * Splits this char sequence to a list of lines delimited by any of the following character sequences: CRLF, LF or CR.\n *\n * The lines returned do not include terminating line separators.\n */\npublic fun CharSequence.lines(): List<String> = lineSequence().toList()\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other],\n * i.e. both char sequences contain the same number of the same characters in the same order.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic expect infix fun CharSequence?.contentEquals(other: CharSequence?): Boolean\n\n/**\n * Returns `true` if the contents of this char sequence are equal to the contents of the specified [other], optionally ignoring case difference.\n *\n * @param ignoreCase `true` to ignore character case when comparing contents.\n *\n * @sample samples.text.Strings.contentEquals\n */\n@SinceKotlin(\"1.5\")\npublic expect fun CharSequence?.contentEquals(other: CharSequence?, ignoreCase: Boolean): Boolean\n\ninternal fun CharSequence?.contentEqualsIgnoreCaseImpl(other: CharSequence?): Boolean {\n    if (this is String && other is String) {\n        return this.equals(other, ignoreCase = true)\n    }\n\n    if (this === other) return true\n    if (this == null || other == null || this.length != other.length) return false\n\n    for (i in 0 until length) {\n        if (!this[i].equals(other[i], ignoreCase = true)) {\n            return false\n        }\n    }\n\n    return true\n}\n\ninternal fun CharSequence?.contentEqualsImpl(other: CharSequence?): Boolean {\n    if (this is String && other is String) {\n        return this == other\n    }\n\n    if (this === other) return true\n    if (this == null || other == null || this.length != other.length) return false\n\n    for (i in 0 until length) {\n        if (this[i] != other[i]) {\n            return false\n        }\n    }\n\n    return true\n}\n\n/**\n * Returns `true` if the content of this string is equal to the word \"true\", `false` if it is equal to \"false\",\n * and throws an exception otherwise.\n *\n * There is also a lenient version of the function available on nullable String, [String?.toBoolean].\n * Note that this function is case-sensitive.\n *\n * @sample samples.text.Strings.toBooleanStrict\n */\n@SinceKotlin(\"1.5\")\npublic fun String.toBooleanStrict(): Boolean = when (this) {\n    \"true\" -> true\n    \"false\" -> false\n    else -> throw IllegalArgumentException(\"The string doesn't represent a boolean value: $this\")\n}\n\n/**\n * Returns `true` if the content of this string is equal to the word \"true\", `false` if it is equal to \"false\",\n * and `null` otherwise.\n *\n * There is also a lenient version of the function available on nullable String, [String?.toBoolean].\n * Note that this function is case-sensitive.\n *\n * @sample samples.text.Strings.toBooleanStrictOrNull\n */\n@SinceKotlin(\"1.5\")\npublic fun String.toBooleanStrictOrNull(): Boolean? = when (this) {\n    \"true\" -> true\n    \"false\" -> false\n    else -> null\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n@file:Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n\npackage kotlin.text\n\nimport kotlin.contracts.*\n\n/**\n * A mutable sequence of characters.\n *\n * String builder can be used to efficiently perform multiple string manipulation operations.\n */\nexpect class StringBuilder : Appendable, CharSequence {\n    /** Constructs an empty string builder. */\n    constructor()\n\n    /** Constructs an empty string builder with the specified initial [capacity]. */\n    constructor(capacity: Int)\n\n    /** Constructs a string builder that contains the same characters as the specified [content] char sequence. */\n    constructor(content: CharSequence)\n\n    /** Constructs a string builder that contains the same characters as the specified [content] string. */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    constructor(content: String)\n\n    override val length: Int\n\n    override operator fun get(index: Int): Char\n\n    override fun subSequence(startIndex: Int, endIndex: Int): CharSequence\n\n    override fun append(value: Char): StringBuilder\n    override fun append(value: CharSequence?): StringBuilder\n    override fun append(value: CharSequence?, startIndex: Int, endIndex: Int): StringBuilder\n\n    /**\n     * Reverses the contents of this string builder and returns this instance.\n     *\n     * Surrogate pairs included in this string builder are treated as single characters.\n     * Therefore, the order of the high-low surrogates is never reversed.\n     *\n     * Note that the reverse operation may produce new surrogate pairs that were unpaired low-surrogates and high-surrogates before the operation.\n     * For example, reversing `\"\\uDC00\\uD800\"` produces `\"\\uD800\\uDC00\"` which is a valid surrogate pair.\n     */\n    fun reverse(): StringBuilder\n\n    /**\n     * Appends the string representation of the specified object [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    fun append(value: Any?): StringBuilder\n\n    /**\n     * Appends the string representation of the specified boolean [value] to this string builder and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was appended to this string builder.\n     */\n    @SinceKotlin(\"1.3\")\n    fun append(value: Boolean): StringBuilder\n\n    /**\n     * Appends characters in the specified character array [value] to this string builder and returns this instance.\n     *\n     * Characters are appended in order, starting at the index 0.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun append(value: CharArray): StringBuilder\n\n    /**\n     * Appends the specified string [value] to this string builder and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are appended.\n     */\n    @SinceKotlin(\"1.3\")\n    fun append(value: String?): StringBuilder\n\n    /**\n     * Returns the current capacity of this string builder.\n     *\n     * The capacity is the maximum length this string builder can have before an allocation occurs.\n     */\n    @SinceKotlin(\"1.3\")\n//    @ExperimentalStdlibApi\n    @Deprecated(\"Obtaining StringBuilder capacity is not supported in JS and common code.\", level = DeprecationLevel.ERROR)\n    fun capacity(): Int\n\n    /**\n     * Ensures that the capacity of this string builder is at least equal to the specified [minimumCapacity].\n     *\n     * If the current capacity is less than the [minimumCapacity], a new backing storage is allocated with greater capacity.\n     * Otherwise, this method takes no action and simply returns.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun ensureCapacity(minimumCapacity: Int)\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun indexOf(string: String): Int\n\n    /**\n     * Returns the index within this string builder of the first occurrence of the specified [string],\n     * starting at the specified [startIndex].\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun indexOf(string: String, startIndex: Int): Int\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string].\n     * The last occurrence of empty string `\"\"` is considered to be at the index equal to `this.length`.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun lastIndexOf(string: String): Int\n\n    /**\n     * Returns the index within this string builder of the last occurrence of the specified [string],\n     * starting from the specified [startIndex] toward the beginning.\n     *\n     * Returns `-1` if the specified [string] does not occur in this string builder starting at the specified [startIndex].\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun lastIndexOf(string: String, startIndex: Int): Int\n\n    /**\n     * Inserts the string representation of the specified boolean [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Boolean): StringBuilder\n\n    /**\n     * Inserts the specified character [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Char): StringBuilder\n\n    /**\n     * Inserts characters in the specified character array [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in same order as in the [value] character array, starting at [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: CharArray): StringBuilder\n\n    /**\n     * Inserts characters in the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n     *\n     * @param index the position in this string builder to insert at.\n     * @param value the character sequence from which characters are inserted. If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: CharSequence?): StringBuilder\n\n    /**\n     * Inserts the string representation of the specified object [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * The overall effect is exactly as if the [value] were converted to a string by the `value.toString()` method,\n     * and then that string was inserted into this string builder at the specified [index].\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: Any?): StringBuilder\n\n    /**\n     * Inserts the string [value] into this string builder at the specified [index] and returns this instance.\n     *\n     * If [value] is `null`, then the four characters `\"null\"` are inserted.\n     *\n     * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun insert(index: Int, value: String?): StringBuilder\n\n    /**\n     *  Sets the length of this string builder to the specified [newLength].\n     *\n     *  If the [newLength] is less than the current length, it is changed to the specified [newLength].\n     *  Otherwise, null characters '\\u0000' are appended to this string builder until its length is less than the [newLength].\n     *\n     *  Note that in Kotlin/JS [set] operator function has non-constant execution time complexity.\n     *  Therefore, increasing length of this string builder and then updating each character by index may slow down your program.\n     *\n     *  @throws IndexOutOfBoundsException or [IllegalArgumentException] if [newLength] is less than zero.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun setLength(newLength: Int)\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [length] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException if [startIndex] is less than zero or greater than the length of this string builder.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun substring(startIndex: Int): String\n\n    /**\n     * Returns a new [String] that contains characters in this string builder at [startIndex] (inclusive) and up to the [endIndex] (exclusive).\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun substring(startIndex: Int, endIndex: Int): String\n\n    /**\n     * Attempts to reduce storage used for this string builder.\n     *\n     * If the backing storage of this string builder is larger than necessary to hold its current contents,\n     * then it may be resized to become more space efficient.\n     * Calling this method may, but is not required to, affect the value of the [capacity] property.\n     */\n    @SinceKotlin(\"1.4\")\n    @WasExperimental(ExperimentalStdlibApi::class)\n    fun trimToSize()\n}\n\n\n/**\n * Clears the content of this string builder making it empty and returns this instance.\n *\n * @sample samples.text.Strings.clearStringBuilder\n */\n@SinceKotlin(\"1.3\")\npublic expect fun StringBuilder.clear(): StringBuilder\n\n/**\n * Sets the character at the specified [index] to the specified [value].\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect operator fun StringBuilder.set(index: Int, value: Char)\n\n/**\n * Replaces characters in the specified range of this string builder with characters in the specified string [value] and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to replace.\n * @param endIndex the end (exclusive) of the range to replace.\n * @param value the string to replace with.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] if [startIndex] is less than zero, greater than the length of this string builder, or `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.setRange(startIndex: Int, endIndex: Int, value: String): StringBuilder\n\n/**\n * Removes the character at the specified [index] from this string builder and returns this instance.\n *\n * If the `Char` at the specified [index] is part of a supplementary code point, this method does not remove the entire supplementary character.\n *\n * @param index the index of `Char` to remove.\n *\n * @throws IndexOutOfBoundsException if [index] is out of bounds of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.deleteAt(index: Int): StringBuilder\n\n/**\n * Removes characters in the specified range from this string builder and returns this instance.\n *\n * @param startIndex the beginning (inclusive) of the range to remove.\n * @param endIndex the end (exclusive) of the range to remove.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.deleteRange(startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Copies characters from this string builder into the [destination] character array.\n *\n * @param destination the array to copy to.\n * @param destinationOffset the position in the array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the range to copy, 0 by default.\n * @param endIndex the end (exclusive) of the range to copy, length of this string builder by default.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this string builder indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n *  or when that index is out of the [destination] array indices range.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.toCharArray(destination: CharArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = this.length)\n\n/**\n * Appends characters in a subarray of the specified character array [value] to this string builder and returns this instance.\n *\n * Characters are appended in order, starting at specified [startIndex].\n *\n * @param value the array from which characters are appended.\n * @param startIndex the beginning (inclusive) of the subarray to append.\n * @param endIndex the end (exclusive) of the subarray to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.appendRange(value: CharArray, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Appends a subsequence of the specified character sequence [value] to this string builder and returns this instance.\n *\n * @param value the character sequence from which a subsequence is appended.\n * @param startIndex the beginning (inclusive) of the subsequence to append.\n * @param endIndex the end (exclusive) of the subsequence to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.appendRange(value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Inserts characters in a subarray of the specified character array [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in same order as in the [value] array, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the array from which characters are inserted.\n * @param startIndex the beginning (inclusive) of the subarray to insert.\n * @param endIndex the end (exclusive) of the subarray to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.insertRange(index: Int, value: CharArray, startIndex: Int, endIndex: Int): StringBuilder\n\n/**\n * Inserts characters in a subsequence of the specified character sequence [value] into this string builder at the specified [index] and returns this instance.\n *\n * The inserted characters go in the same order as in the [value] character sequence, starting at [index].\n *\n * @param index the position in this string builder to insert at.\n * @param value the character sequence from which a subsequence is inserted.\n * @param startIndex the beginning (inclusive) of the subsequence to insert.\n * @param endIndex the end (exclusive) of the subsequence to insert.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException if [index] is less than zero or greater than the length of this string builder.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun StringBuilder.insertRange(index: Int, value: CharSequence, startIndex: Int, endIndex: Int): StringBuilder\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n@Deprecated(\"Use append(value: Any?) instead\", ReplaceWith(\"append(value = obj)\"), DeprecationLevel.WARNING)\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.append(obj: Any?): StringBuilder = this.append(obj)\n\n/**\n * Builds new string by populating newly created [StringBuilder] using provided [builderAction]\n * and then converting it to [String].\n */\n@kotlin.internal.InlineOnly\npublic inline fun buildString(builderAction: StringBuilder.() -> Unit): String {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return StringBuilder().apply(builderAction).toString()\n}\n\n/**\n * Builds new string by populating newly created [StringBuilder] initialized with the given [capacity]\n * using provided [builderAction] and then converting it to [String].\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun buildString(capacity: Int, builderAction: StringBuilder.() -> Unit): String {\n    contract { callsInPlace(builderAction, InvocationKind.EXACTLY_ONCE) }\n    return StringBuilder(capacity).apply(builderAction).toString()\n}\n\n/**\n * Appends all arguments to the given StringBuilder.\n */\npublic fun StringBuilder.append(vararg value: String?): StringBuilder {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/**\n * Appends all arguments to the given StringBuilder.\n */\npublic fun StringBuilder.append(vararg value: Any?): StringBuilder {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/** Appends a line feed character (`\\n`) to this StringBuilder. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(): StringBuilder = append('\\n')\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: CharSequence?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: String?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Any?): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: CharArray): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Char): StringBuilder = append(value).appendLine()\n\n/** Appends [value] to this [StringBuilder], followed by a line feed character (`\\n`). */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun StringBuilder.appendLine(value: Boolean): StringBuilder = append(value).appendLine()\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.comparisons\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.js.*\n\n/**\n * Returns the greater of two values.\n * \n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T): T {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Byte, b: Byte): Byte {\n    return maxOf(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Short, b: Short): Short {\n    return maxOf(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Int, b: Int): Int {\n    return JsMath.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun maxOf(a: Long, b: Long): Long {\n    return if (a >= b) a else b\n}\n\n/**\n * Returns the greater of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Float, b: Float): Float {\n    return JsMath.max(a, b)\n}\n\n/**\n * Returns the greater of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Double, b: Double): Double {\n    return JsMath.max(a, b)\n}\n\n/**\n * Returns the greater of three values.\n * \n * If there are multiple equal maximal values, returns the first of them.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, b: T, c: T): T {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Byte, b: Byte, c: Byte): Byte {\n    return JsMath.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Short, b: Short, c: Short): Short {\n    return JsMath.max(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Int, b: Int, c: Int): Int {\n    return JsMath.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Long, b: Long, c: Long): Long {\n    return maxOf(a, maxOf(b, c))\n}\n\n/**\n * Returns the greater of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Float, b: Float, c: Float): Float {\n    return JsMath.max(a, b, c)\n}\n\n/**\n * Returns the greater of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun maxOf(a: Double, b: Double, c: Double): Double {\n    return JsMath.max(a, b, c)\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If there are multiple equal maximal values, returns the first of them.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun <T : Comparable<T>> maxOf(a: T, vararg other: T): T {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Byte, vararg other: Byte): Byte {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Short, vararg other: Short): Short {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Int, vararg other: Int): Int {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Long, vararg other: Long): Long {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Float, vararg other: Float): Float {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the greater of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun maxOf(a: Double, vararg other: Double): Double {\n    var max = a\n    for (e in other) max = maxOf(max, e)\n    return max\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If values are equal, returns the first one.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T): T {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Byte, b: Byte): Byte {\n    return minOf(a.toInt(), b.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Short, b: Short): Short {\n    return minOf(a.toInt(), b.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Int, b: Int): Int {\n    return JsMath.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n */\n@SinceKotlin(\"1.1\")\n@Suppress(\"NOTHING_TO_INLINE\")\npublic actual inline fun minOf(a: Long, b: Long): Long {\n    return if (a <= b) a else b\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Float, b: Float): Float {\n    return JsMath.min(a, b)\n}\n\n/**\n * Returns the smaller of two values.\n * \n * If either value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Double, b: Double): Double {\n    return JsMath.min(a, b)\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If there are multiple equal minimal values, returns the first of them.\n */\n@SinceKotlin(\"1.1\")\npublic actual fun <T : Comparable<T>> minOf(a: T, b: T, c: T): T {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Byte, b: Byte, c: Byte): Byte {\n    return JsMath.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Byte>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Short, b: Short, c: Short): Short {\n    return JsMath.min(a.toInt(), b.toInt(), c.toInt()).unsafeCast<Short>()\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Int, b: Int, c: Int): Int {\n    return JsMath.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Long, b: Long, c: Long): Long {\n    return minOf(a, minOf(b, c))\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Float, b: Float, c: Float): Float {\n    return JsMath.min(a, b, c)\n}\n\n/**\n * Returns the smaller of three values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic actual inline fun minOf(a: Double, b: Double, c: Double): Double {\n    return JsMath.min(a, b, c)\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If there are multiple equal minimal values, returns the first of them.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun <T : Comparable<T>> minOf(a: T, vararg other: T): T {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Byte, vararg other: Byte): Byte {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Short, vararg other: Short): Short {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Int, vararg other: Int): Int {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Long, vararg other: Long): Long {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Float, vararg other: Float): Float {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n/**\n * Returns the smaller of the given values.\n * \n * If any value is `NaN`, returns `NaN`.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun minOf(a: Double, vararg other: Double): Double {\n    var min = a\n    for (e in other) min = minOf(min, e)\n    return min\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\nimport kotlin.js.RegExp\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeIndexOf(ch: Char, fromIndex: Int): Int = nativeIndexOf(ch.toString(), fromIndex)\n\n@kotlin.internal.InlineOnly\ninternal actual inline fun String.nativeLastIndexOf(ch: Char, fromIndex: Int): Int = nativeLastIndexOf(ch.toString(), fromIndex)\n\n/**\n * Returns `true` if this string starts with the specified prefix.\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.startsWith(prefix: String, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase)\n        return nativeStartsWith(prefix, 0)\n    else\n        return regionMatches(0, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if a substring of this string starting at the specified offset [startIndex] starts with the specified prefix.\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.startsWith(prefix: String, startIndex: Int, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase)\n        return nativeStartsWith(prefix, startIndex)\n    else\n        return regionMatches(startIndex, prefix, 0, prefix.length, ignoreCase)\n}\n\n/**\n * Returns `true` if this string ends with the specified suffix.\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.endsWith(suffix: String, ignoreCase: Boolean = false): Boolean {\n    if (!ignoreCase)\n        return nativeEndsWith(suffix)\n    else\n        return regionMatches(length - suffix.length, suffix, 0, suffix.length, ignoreCase)\n}\n\n@Deprecated(\"Use Regex.matches() instead\", ReplaceWith(\"regex.toRegex().matches(this)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.6\")\npublic fun String.matches(regex: String): Boolean {\n    @Suppress(\"DEPRECATION\")\n    val result = this.match(regex)\n    return result != null && result.size != 0\n}\n\n/**\n * Returns `true` if this string is empty or consists solely of whitespace characters.\n *\n * @sample samples.text.Strings.stringIsBlank\n */\npublic actual fun CharSequence.isBlank(): Boolean = length == 0 || indices.all { this[it].isWhitespace() }\n\n/**\n * Returns `true` if this string is equal to [other], optionally ignoring character case.\n *\n * Two strings are considered to be equal if they have the same length and the same character at the same index.\n * If [ignoreCase] is true, the result of `Char.uppercaseChar().lowercaseChar()` on each character is compared.\n *\n * @param ignoreCase `true` to ignore character case when comparing strings. By default `false`.\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String?.equals(other: String?, ignoreCase: Boolean = false): Boolean {\n    if (this == null) return other == null\n    if (other == null) return false\n    if (!ignoreCase) return this == other\n\n    if (this.length != other.length) return false\n\n    for (index in 0 until this.length) {\n        val thisChar = this[index]\n        val otherChar = other[index]\n        if (!thisChar.equals(otherChar, ignoreCase)) {\n            return false\n        }\n    }\n\n    return true\n}\n\n\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun CharSequence.regionMatches(thisOffset: Int, other: CharSequence, otherOffset: Int, length: Int, ignoreCase: Boolean = false): Boolean =\n    regionMatchesImpl(thisOffset, other, otherOffset, length, ignoreCase)\n\n\n/**\n * Returns a copy of this string having its first letter titlecased using the rules of the default locale,\n * or the original string if it's empty or already starts with a title case letter.\n *\n * The title case of a character is usually the same as its upper case with several exceptions.\n * The particular list of characters with the special title case form depends on the underlying platform.\n *\n * @sample samples.text.Strings.capitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { if (it.isLowerCase()) it.titlecase() else it.toString() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic actual fun String.capitalize(): String {\n    return if (isNotEmpty()) substring(0, 1).uppercase() + substring(1) else this\n}\n\n/**\n * Returns a copy of this string having its first letter lowercased using the rules of the default locale,\n * or the original string if it's empty or already starts with a lower case letter.\n *\n * @sample samples.text.Strings.decapitalize\n */\n@Deprecated(\"Use replaceFirstChar instead.\", ReplaceWith(\"replaceFirstChar { it.lowercase() }\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic actual fun String.decapitalize(): String {\n    return if (isNotEmpty()) substring(0, 1).lowercase() + substring(1) else this\n}\n\n/**\n * Returns a string containing this char sequence repeated [n] times.\n * @throws [IllegalArgumentException] when n < 0.\n * @sample samples.text.Strings.repeat\n */\npublic actual fun CharSequence.repeat(n: Int): String {\n    require(n >= 0) { \"Count 'n' must be non-negative, but was $n.\" }\n    return when (n) {\n        0 -> \"\"\n        1 -> this.toString()\n        else -> {\n            var result = \"\"\n            if (!isEmpty()) {\n                var s = this.toString()\n                var count = n\n                while (true) {\n                    if ((count and 1) == 1) {\n                        result += s\n                    }\n                    count = count ushr 1\n                    if (count == 0) {\n                        break\n                    }\n                    s += s\n                }\n            }\n            return result\n        }\n    }\n}\n\n/**\n * Returns a new string obtained by replacing all occurrences of the [oldValue] substring in this string\n * with the specified [newValue] string.\n *\n * @sample samples.text.Strings.replace\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.replace(oldValue: String, newValue: String, ignoreCase: Boolean = false): String =\n    nativeReplace(RegExp(Regex.escape(oldValue), if (ignoreCase) \"gui\" else \"gu\"), Regex.nativeEscapeReplacement(newValue))\n\n/**\n * Returns a new string with all occurrences of [oldChar] replaced with [newChar].\n *\n * @sample samples.text.Strings.replace\n */\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.replace(oldChar: Char, newChar: Char, ignoreCase: Boolean = false): String =\n    nativeReplace(RegExp(Regex.escape(oldChar.toString()), if (ignoreCase) \"gui\" else \"gu\"), newChar.toString())\n\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.replaceFirst(oldValue: String, newValue: String, ignoreCase: Boolean = false): String =\n    nativeReplace(RegExp(Regex.escape(oldValue), if (ignoreCase) \"ui\" else \"u\"), Regex.nativeEscapeReplacement(newValue))\n\n@Suppress(\"ACTUAL_FUNCTION_WITH_DEFAULT_ARGUMENTS\")\npublic actual fun String.replaceFirst(oldChar: Char, newChar: Char, ignoreCase: Boolean = false): String =\n    nativeReplace(RegExp(Regex.escape(oldChar.toString()), if (ignoreCase) \"ui\" else \"u\"), newChar.toString())\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/** Returns the negative [size] if [throwOnMalformed] is false, throws [CharacterCodingException] otherwise. */\nprivate fun malformed(size: Int, index: Int, throwOnMalformed: Boolean): Int {\n    if (throwOnMalformed) throw CharacterCodingException(\"Malformed sequence starting at ${index - 1}\")\n    return -size\n}\n\n/**\n * Returns code point corresponding to UTF-16 surrogate pair,\n * where the first of the pair is the [high] and the second is in the [string] at the [index].\n * Returns zero if the pair is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the pair is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFromSurrogate(string: String, high: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (high !in 0xD800..0xDBFF || index >= endIndex) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    val low = string[index].code\n    if (low !in 0xDC00..0xDFFF) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    return 0x10000 + ((high and 0x3FF) shl 10) or (low and 0x3FF)\n}\n\n/**\n * Returns code point corresponding to UTF-8 sequence of two bytes,\n * where the first byte of the sequence is the [byte1] and the second byte is in the [bytes] array at the [index].\n * Returns zero if the sequence is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the sequence of two bytes is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFrom2(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (byte1 and 0x1E == 0 || index >= endIndex) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    val byte2 = bytes[index].toInt()\n    if (byte2 and 0xC0 != 0x80) {\n        return malformed(0, index, throwOnMalformed)\n    }\n    return (byte1 shl 6) xor byte2 xor 0xF80\n}\n\n/**\n * Returns code point corresponding to UTF-8 sequence of three bytes,\n * where the first byte of the sequence is the [byte1] and the others are in the [bytes] array starting from the [index].\n * Returns a non-positive value indicating number of bytes from [bytes] included in malformed sequence\n * if the sequence is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the sequence of three bytes is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFrom3(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (index >= endIndex) {\n        return malformed(0, index, throwOnMalformed)\n    }\n\n    val byte2 = bytes[index].toInt()\n    if (byte1 and 0xF == 0) {\n        if (byte2 and 0xE0 != 0xA0) {\n            // Non-shortest form\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte1 and 0xF == 0xD) {\n        if (byte2 and 0xE0 != 0x80) {\n            // Surrogate code point\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte2 and 0xC0 != 0x80) {\n        return malformed(0, index, throwOnMalformed)\n    }\n\n    if (index + 1 == endIndex) {\n        return malformed(1, index, throwOnMalformed)\n    }\n    val byte3 = bytes[index + 1].toInt()\n    if (byte3 and 0xC0 != 0x80) {\n        return malformed(1, index, throwOnMalformed)\n    }\n\n    return (byte1 shl 12) xor (byte2 shl 6) xor byte3 xor -0x1E080\n}\n\n/**\n * Returns code point corresponding to UTF-8 sequence of four bytes,\n * where the first byte of the sequence is the [byte1] and the others are in the [bytes] array starting from the [index].\n * Returns a non-positive value indicating number of bytes from [bytes] included in malformed sequence\n * if the sequence is malformed and [throwOnMalformed] is false.\n *\n * @throws CharacterCodingException if the sequence of four bytes is malformed and [throwOnMalformed] is true.\n */\nprivate fun codePointFrom4(bytes: ByteArray, byte1: Int, index: Int, endIndex: Int, throwOnMalformed: Boolean): Int {\n    if (index >= endIndex) {\n        malformed(0, index, throwOnMalformed)\n    }\n\n    val byte2 = bytes[index].toInt()\n    if (byte1 and 0xF == 0x0) {\n        if (byte2 and 0xF0 <= 0x80) {\n            // Non-shortest form\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte1 and 0xF == 0x4) {\n        if (byte2 and 0xF0 != 0x80) {\n            // Out of Unicode code points domain (larger than U+10FFFF)\n            return malformed(0, index, throwOnMalformed)\n        }\n    } else if (byte1 and 0xF > 0x4) {\n        return malformed(0, index, throwOnMalformed)\n    } else if (byte2 and 0xC0 != 0x80) {\n        return malformed(0, index, throwOnMalformed)\n    }\n\n    if (index + 1 == endIndex) {\n        return malformed(1, index, throwOnMalformed)\n    }\n    val byte3 = bytes[index + 1].toInt()\n    if (byte3 and 0xC0 != 0x80) {\n        return malformed(1, index, throwOnMalformed)\n    }\n\n    if (index + 2 == endIndex) {\n        return malformed(2, index, throwOnMalformed)\n    }\n    val byte4 = bytes[index + 2].toInt()\n    if (byte4 and 0xC0 != 0x80) {\n        return malformed(2, index, throwOnMalformed)\n    }\n    return (byte1 shl 18) xor (byte2 shl 12) xor (byte3 shl 6) xor byte4 xor 0x381F80\n}\n\n/**\n * Maximum number of bytes needed to encode a single char.\n *\n * Code points in `0..0x7F` are encoded in a single byte.\n * Code points in `0x80..0x7FF` are encoded in two bytes.\n * Code points in `0x800..0xD7FF` or in `0xE000..0xFFFF` are encoded in three bytes.\n * Surrogate code points in `0xD800..0xDFFF` are not Unicode scalar values, therefore aren't encoded.\n * Code points in `0x10000..0x10FFFF` are represented by a pair of surrogate `Char`s and are encoded in four bytes.\n */\nprivate const val MAX_BYTES_PER_CHAR = 3\n\n/**\n * The byte sequence a malformed UTF-16 char sequence is replaced by.\n */\nprivate val REPLACEMENT_BYTE_SEQUENCE: ByteArray = byteArrayOf(0xEF.toByte(), 0xBF.toByte(), 0xBD.toByte())\n\n/**\n * Encodes the [string] using UTF-8 and returns the resulting [ByteArray].\n *\n * @param string the string to encode.\n * @param startIndex the start offset (inclusive) of the substring to encode.\n * @param endIndex the end offset (exclusive) of the substring to encode.\n * @param throwOnMalformed whether to throw on malformed char sequence or replace by the [REPLACEMENT_BYTE_SEQUENCE].\n *\n * @throws CharacterCodingException if the char sequence is malformed and [throwOnMalformed] is true.\n */\ninternal fun encodeUtf8(string: String, startIndex: Int, endIndex: Int, throwOnMalformed: Boolean): ByteArray {\n    require(startIndex >= 0 && endIndex <= string.length && startIndex <= endIndex)\n\n    val bytes = ByteArray((endIndex - startIndex) * MAX_BYTES_PER_CHAR)\n    var byteIndex = 0\n    var charIndex = startIndex\n\n    while (charIndex < endIndex) {\n        val code = string[charIndex++].code\n        when {\n            code < 0x80 ->\n                bytes[byteIndex++] = code.toByte()\n            code < 0x800 -> {\n                bytes[byteIndex++] = ((code shr 6) or 0xC0).toByte()\n                bytes[byteIndex++] = ((code and 0x3F) or 0x80).toByte()\n            }\n            code < 0xD800 || code >= 0xE000 -> {\n                bytes[byteIndex++] = ((code shr 12) or 0xE0).toByte()\n                bytes[byteIndex++] = (((code shr 6) and 0x3F) or 0x80).toByte()\n                bytes[byteIndex++] = ((code and 0x3F) or 0x80).toByte()\n            }\n            else -> { // Surrogate char value\n                val codePoint = codePointFromSurrogate(string, code, charIndex, endIndex, throwOnMalformed)\n                if (codePoint <= 0) {\n                    bytes[byteIndex++] = REPLACEMENT_BYTE_SEQUENCE[0]\n                    bytes[byteIndex++] = REPLACEMENT_BYTE_SEQUENCE[1]\n                    bytes[byteIndex++] = REPLACEMENT_BYTE_SEQUENCE[2]\n                } else {\n                    bytes[byteIndex++] = ((codePoint shr 18) or 0xF0).toByte()\n                    bytes[byteIndex++] = (((codePoint shr 12) and 0x3F) or 0x80).toByte()\n                    bytes[byteIndex++] = (((codePoint shr 6) and 0x3F) or 0x80).toByte()\n                    bytes[byteIndex++] = ((codePoint and 0x3F) or 0x80).toByte()\n                    charIndex++\n                }\n            }\n        }\n    }\n\n    return if (bytes.size == byteIndex) bytes else bytes.copyOf(byteIndex)\n}\n\n/**\n * The character a malformed UTF-8 byte sequence is replaced by.\n */\nprivate const val REPLACEMENT_CHAR = '\\uFFFD'\n\n/**\n * Decodes the UTF-8 [bytes] array and returns the resulting [String].\n *\n * @param bytes the byte array to decode.\n * @param startIndex the start offset (inclusive) of the array to be decoded.\n * @param endIndex the end offset (exclusive) of the array to be encoded.\n * @param throwOnMalformed whether to throw on malformed byte sequence or replace by the [REPLACEMENT_CHAR].\n *\n * @throws CharacterCodingException if the array is malformed UTF-8 byte sequence and [throwOnMalformed] is true.\n */\ninternal fun decodeUtf8(bytes: ByteArray, startIndex: Int, endIndex: Int, throwOnMalformed: Boolean): String {\n    require(startIndex >= 0 && endIndex <= bytes.size && startIndex <= endIndex)\n\n    var byteIndex = startIndex\n    val stringBuilder = StringBuilder()\n\n    while (byteIndex < endIndex) {\n        val byte = bytes[byteIndex++].toInt()\n        when {\n            byte >= 0 ->\n                stringBuilder.append(byte.toChar())\n            byte shr 5 == -2 -> {\n                val code = codePointFrom2(bytes, byte, byteIndex, endIndex, throwOnMalformed)\n                if (code <= 0) {\n                    stringBuilder.append(REPLACEMENT_CHAR)\n                    byteIndex += -code\n                } else {\n                    stringBuilder.append(code.toChar())\n                    byteIndex += 1\n                }\n            }\n            byte shr 4 == -2 -> {\n                val code = codePointFrom3(bytes, byte, byteIndex, endIndex, throwOnMalformed)\n                if (code <= 0) {\n                    stringBuilder.append(REPLACEMENT_CHAR)\n                    byteIndex += -code\n                } else {\n                    stringBuilder.append(code.toChar())\n                    byteIndex += 2\n                }\n            }\n            byte shr 3 == -2 -> {\n                val code = codePointFrom4(bytes, byte, byteIndex, endIndex, throwOnMalformed)\n                if (code <= 0) {\n                    stringBuilder.append(REPLACEMENT_CHAR)\n                    byteIndex += -code\n                } else {\n                    val high = (code - 0x10000) shr 10 or 0xD800\n                    val low = (code and 0x3FF) or 0xDC00\n                    stringBuilder.append(high.toChar())\n                    stringBuilder.append(low.toChar())\n                    byteIndex += 3\n                }\n            }\n            else -> {\n                malformed(0, byteIndex, throwOnMalformed)\n                stringBuilder.append(REPLACEMENT_CHAR)\n            }\n        }\n    }\n\n    return stringBuilder.toString()\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.collections\n\nimport kotlin.js.JsName\n\n/**\n * Provides a skeletal implementation of the read-only [Collection] interface.\n *\n * @param E the type of elements contained in the collection. The collection is covariant in its element type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractCollection<out E> protected constructor() : Collection<E> {\n    abstract override val size: Int\n    abstract override fun iterator(): Iterator<E>\n\n    override fun contains(element: @UnsafeVariance E): Boolean = any { it == element }\n\n    override fun containsAll(elements: Collection<@UnsafeVariance E>): Boolean =\n        elements.all { contains(it) } // use when js will support bound refs: elements.all(this::contains)\n\n    override fun isEmpty(): Boolean = size == 0\n\n    override fun toString(): String = joinToString(\", \", \"[\", \"]\") {\n        if (it === this) \"(this Collection)\" else it.toString()\n    }\n\n    /**\n     * Returns new array of type `Array<Any?>` with the elements of this collection.\n     */\n    @JsName(\"toArray\")\n    protected open fun toArray(): Array<Any?> = copyToArrayImpl(this)\n\n    /**\n     * Fills the provided [array] or creates new array of the same type\n     * and fills it with the elements of this collection.\n     */\n    protected open fun <T> toArray(array: Array<T>): Array<T> = copyToArrayImpl(this, array)\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractList\n * Copyright 2007 Google Inc.\n*/\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the read-only [List] interface.\n *\n * This class is intended to help implementing read-only lists so it doesn't support concurrent modification tracking.\n *\n * @param E the type of elements contained in the list. The list is covariant in its element type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractList<out E> protected constructor() : AbstractCollection<E>(), List<E> {\n    abstract override val size: Int\n    abstract override fun get(index: Int): E\n\n    override fun iterator(): Iterator<E> = IteratorImpl()\n\n    override fun indexOf(element: @UnsafeVariance E): Int = indexOfFirst { it == element }\n\n    override fun lastIndexOf(element: @UnsafeVariance E): Int = indexOfLast { it == element }\n\n    override fun listIterator(): ListIterator<E> = ListIteratorImpl(0)\n\n    override fun listIterator(index: Int): ListIterator<E> = ListIteratorImpl(index)\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<E> = SubList(this, fromIndex, toIndex)\n\n    private class SubList<out E>(private val list: AbstractList<E>, private val fromIndex: Int, toIndex: Int) : AbstractList<E>(), RandomAccess {\n        private var _size: Int = 0\n\n        init {\n            checkRangeIndexes(fromIndex, toIndex, list.size)\n            this._size = toIndex - fromIndex\n        }\n\n        override fun get(index: Int): E {\n            checkElementIndex(index, _size)\n\n            return list[fromIndex + index]\n        }\n\n        override val size: Int get() = _size\n    }\n\n    /**\n     * Compares this list with other list instance with the ordered structural equality.\n     *\n     * @return true, if [other] instance is a [List] of the same size, which contains the same elements in the same order.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is List<*>) return false\n\n        return orderedEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this list.\n     */\n    override fun hashCode(): Int = orderedHashCode(this)\n\n    private open inner class IteratorImpl : Iterator<E> {\n        /** the index of the item that will be returned on the next call to [next]`()` */\n        protected var index = 0\n\n        override fun hasNext(): Boolean = index < size\n\n        override fun next(): E {\n            if (!hasNext()) throw NoSuchElementException()\n            return get(index++)\n        }\n    }\n\n    /**\n     * Implementation of [ListIterator] for abstract lists.\n     */\n    private open inner class ListIteratorImpl(index: Int) : IteratorImpl(), ListIterator<E> {\n\n        init {\n            checkPositionIndex(index, this@AbstractList.size)\n            this.index = index\n        }\n\n        override fun hasPrevious(): Boolean = index > 0\n\n        override fun nextIndex(): Int = index\n\n        override fun previous(): E {\n            if (!hasPrevious()) throw NoSuchElementException()\n            return get(--index)\n        }\n\n        override fun previousIndex(): Int = index - 1\n    }\n\n    internal companion object {\n        internal fun checkElementIndex(index: Int, size: Int) {\n            if (index < 0 || index >= size) {\n                throw IndexOutOfBoundsException(\"index: $index, size: $size\")\n            }\n        }\n\n        internal fun checkPositionIndex(index: Int, size: Int) {\n            if (index < 0 || index > size) {\n                throw IndexOutOfBoundsException(\"index: $index, size: $size\")\n            }\n        }\n\n        internal fun checkRangeIndexes(fromIndex: Int, toIndex: Int, size: Int) {\n            if (fromIndex < 0 || toIndex > size) {\n                throw IndexOutOfBoundsException(\"fromIndex: $fromIndex, toIndex: $toIndex, size: $size\")\n            }\n            if (fromIndex > toIndex) {\n                throw IllegalArgumentException(\"fromIndex: $fromIndex > toIndex: $toIndex\")\n            }\n        }\n\n        internal fun checkBoundsIndexes(startIndex: Int, endIndex: Int, size: Int) {\n            if (startIndex < 0 || endIndex > size) {\n                throw IndexOutOfBoundsException(\"startIndex: $startIndex, endIndex: $endIndex, size: $size\")\n            }\n            if (startIndex > endIndex) {\n                throw IllegalArgumentException(\"startIndex: $startIndex > endIndex: $endIndex\")\n            }\n        }\n\n        internal fun orderedHashCode(c: Collection<*>): Int {\n            var hashCode = 1\n            for (e in c) {\n                hashCode = 31 * hashCode + (e?.hashCode() ?: 0)\n            }\n            return hashCode\n        }\n\n        internal fun orderedEquals(c: Collection<*>, other: Collection<*>): Boolean {\n            if (c.size != other.size) return false\n\n            val otherIterator = other.iterator()\n            for (elem in c) {\n                val elemOther = otherIterator.next()\n                if (elem != elemOther) {\n                    return false\n                }\n            }\n            return true\n        }\n    }\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n/*\n * Based on GWT AbstractMap\n * Copyright 2007 Google Inc.\n */\n\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the read-only [Map] interface.\n *\n * The implementor is required to implement [entries] property, which should return read-only set of map entries.\n *\n * @param K the type of map keys. The map is invariant in its key type.\n * @param V the type of map values. The map is covariant in its value type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractMap<K, out V> protected constructor() : Map<K, V> {\n\n    override fun containsKey(key: K): Boolean {\n        return implFindEntry(key) != null\n    }\n\n    override fun containsValue(value: @UnsafeVariance V): Boolean = entries.any { it.value == value }\n\n    internal fun containsEntry(entry: Map.Entry<*, *>?): Boolean {\n        // since entry comes from @UnsafeVariance parameters it can be virtually anything\n        if (entry !is Map.Entry<*, *>) return false\n        val key = entry.key\n        val value = entry.value\n        val ourValue = get(key)\n\n        if (value != ourValue) {\n            return false\n        }\n\n        // Perhaps it was null and we don't contain the key?\n        if (ourValue == null && !containsKey(key)) {\n            return false\n        }\n\n        return true\n    }\n\n\n    /**\n     * Compares this map with other instance with the ordered structural equality.\n     *\n     * @return true, if [other] instance is a [Map] of the same size, all entries of which are contained in the [entries] set of this map.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is Map<*, *>) return false\n        if (size != other.size) return false\n\n        return other.entries.all { containsEntry(it) }\n    }\n\n    override operator fun get(key: K): V? = implFindEntry(key)?.value\n\n\n    /**\n     * Returns the hash code value for this map.\n     *\n     * It is the same as the hashCode of [entries] set.\n     */\n    override fun hashCode(): Int = entries.hashCode()\n\n    override fun isEmpty(): Boolean = size == 0\n    override val size: Int get() = entries.size\n\n    /**\n     * Returns a read-only [Set] of all keys in this map.\n     *\n     * Accessing this property first time creates a keys view from [entries].\n     * All subsequent accesses just return the created instance.\n     */\n    override val keys: Set<K>\n        get() {\n            if (_keys == null) {\n                _keys = object : AbstractSet<K>() {\n                    override operator fun contains(element: K): Boolean = containsKey(element)\n\n                    override operator fun iterator(): Iterator<K> {\n                        val entryIterator = entries.iterator()\n                        return object : Iterator<K> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): K = entryIterator.next().key\n                        }\n                    }\n\n                    override val size: Int get() = this@AbstractMap.size\n                }\n            }\n            return _keys!!\n        }\n\n    @kotlin.jvm.Volatile\n    private var _keys: Set<K>? = null\n\n\n    override fun toString(): String = entries.joinToString(\", \", \"{\", \"}\") { toString(it) }\n\n    private fun toString(entry: Map.Entry<K, V>): String = toString(entry.key) + \"=\" + toString(entry.value)\n\n    private fun toString(o: Any?): String = if (o === this) \"(this Map)\" else o.toString()\n\n    /**\n     * Returns a read-only [Collection] of all values in this map.\n     *\n     * Accessing this property first time creates a values view from [entries].\n     * All subsequent accesses just return the created instance.\n     */\n    override val values: Collection<V>\n        get() {\n            if (_values == null) {\n                _values = object : AbstractCollection<V>() {\n                    override operator fun contains(element: @UnsafeVariance V): Boolean = containsValue(element)\n\n                    override operator fun iterator(): Iterator<V> {\n                        val entryIterator = entries.iterator()\n                        return object : Iterator<V> {\n                            override fun hasNext(): Boolean = entryIterator.hasNext()\n                            override fun next(): V = entryIterator.next().value\n                        }\n                    }\n\n                    override val size: Int get() = this@AbstractMap.size\n                }\n            }\n            return _values!!\n        }\n\n    @kotlin.jvm.Volatile\n    private var _values: Collection<V>? = null\n\n    private fun implFindEntry(key: K): Map.Entry<K, V>? = entries.firstOrNull { it.key == key }\n\n    internal companion object {\n\n        internal fun entryHashCode(e: Map.Entry<*, *>): Int = with(e) { (key?.hashCode() ?: 0) xor (value?.hashCode() ?: 0) }\n        internal fun entryToString(e: Map.Entry<*, *>): String = with(e) { \"$key=$value\" }\n        internal fun entryEquals(e: Map.Entry<*, *>, other: Any?): Boolean {\n            if (other !is Map.Entry<*, *>) return false\n            return e.key == other.key && e.value == other.value\n        }\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\npackage kotlin.collections\n\n/**\n * Provides a skeletal implementation of the read-only [Set] interface.\n *\n * This class is intended to help implementing read-only sets so it doesn't support concurrent modification tracking.\n *\n * @param E the type of elements contained in the set. The set is covariant in its element type.\n */\n@SinceKotlin(\"1.1\")\npublic abstract class AbstractSet<out E> protected constructor() : AbstractCollection<E>(), Set<E> {\n\n    /**\n     * Compares this set with other set instance with the unordered structural equality.\n     *\n     * @return true, if [other] instance is a [Set] of the same size, all elements of which are contained in this set.\n     */\n    override fun equals(other: Any?): Boolean {\n        if (other === this) return true\n        if (other !is Set<*>) return false\n        return setEquals(this, other)\n    }\n\n    /**\n     * Returns the hash code value for this set.\n     */\n    override fun hashCode(): Int = unorderedHashCode(this)\n\n    internal companion object {\n        internal fun unorderedHashCode(c: Collection<*>): Int {\n            var hashCode = 0\n            for (element in c) {\n                hashCode += (element?.hashCode() ?: 0)\n            }\n            return hashCode\n        }\n\n        internal fun setEquals(c: Set<*>, other: Set<*>): Boolean {\n            if (c.size != other.size) return false\n            return c.containsAll(other)\n        }\n    }\n\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n\npackage kotlin.collections\n\n/**\n * Returns the value for the given key, or the implicit default value for this map.\n * By default no implicit value is provided for maps and a [NoSuchElementException] is thrown.\n * To create a map with implicit default value use [withDefault] method.\n *\n * @throws NoSuchElementException when the map doesn't contain a value for the specified key and no implicit default was provided for that map.\n */\n@kotlin.jvm.JvmName(\"getOrImplicitDefaultNullable\")\n@PublishedApi\ninternal fun <K, V> Map<K, V>.getOrImplicitDefault(key: K): V {\n    if (this is MapWithDefault)\n        return this.getOrImplicitDefault(key)\n\n    return getOrElseNullable(key, { throw NoSuchElementException(\"Key $key is missing in the map.\") })\n}\n\n/**\n * Returns a wrapper of this read-only map, having the implicit default value provided with the specified function [defaultValue].\n *\n * This implicit default value is used when the original map doesn't contain a value for the key specified\n * and a value is obtained with [Map.getValue] function, for example when properties are delegated to the map.\n *\n * When this map already has an implicit default value provided with a former call to [withDefault], it is being replaced by this call.\n */\npublic fun <K, V> Map<K, V>.withDefault(defaultValue: (key: K) -> V): Map<K, V> =\n    when (this) {\n        is MapWithDefault -> this.map.withDefault(defaultValue)\n        else -> MapWithDefaultImpl(this, defaultValue)\n    }\n\n/**\n * Returns a wrapper of this mutable map, having the implicit default value provided with the specified function [defaultValue].\n *\n * This implicit default value is used when the original map doesn't contain a value for the key specified\n * and a value is obtained with [Map.getValue] function, for example when properties are delegated to the map.\n *\n * When this map already has an implicit default value provided with a former call to [withDefault], it is being replaced by this call.\n */\n@kotlin.jvm.JvmName(\"withDefaultMutable\")\npublic fun <K, V> MutableMap<K, V>.withDefault(defaultValue: (key: K) -> V): MutableMap<K, V> =\n    when (this) {\n        is MutableMapWithDefault -> this.map.withDefault(defaultValue)\n        else -> MutableMapWithDefaultImpl(this, defaultValue)\n    }\n\n\nprivate interface MapWithDefault<K, out V> : Map<K, V> {\n    public val map: Map<K, V>\n    public fun getOrImplicitDefault(key: K): V\n}\n\nprivate interface MutableMapWithDefault<K, V> : MutableMap<K, V>, MapWithDefault<K, V> {\n    public override val map: MutableMap<K, V>\n}\n\n\nprivate class MapWithDefaultImpl<K, out V>(public override val map: Map<K, V>, private val default: (key: K) -> V) : MapWithDefault<K, V> {\n    override fun equals(other: Any?): Boolean = map.equals(other)\n    override fun hashCode(): Int = map.hashCode()\n    override fun toString(): String = map.toString()\n    override val size: Int get() = map.size\n    override fun isEmpty(): Boolean = map.isEmpty()\n    override fun containsKey(key: K): Boolean = map.containsKey(key)\n    override fun containsValue(value: @UnsafeVariance V): Boolean = map.containsValue(value)\n    override fun get(key: K): V? = map.get(key)\n    override val keys: Set<K> get() = map.keys\n    override val values: Collection<V> get() = map.values\n    override val entries: Set<Map.Entry<K, V>> get() = map.entries\n\n    override fun getOrImplicitDefault(key: K): V = map.getOrElseNullable(key, { default(key) })\n}\n\nprivate class MutableMapWithDefaultImpl<K, V>(public override val map: MutableMap<K, V>, private val default: (key: K) -> V) : MutableMapWithDefault<K, V> {\n    override fun equals(other: Any?): Boolean = map.equals(other)\n    override fun hashCode(): Int = map.hashCode()\n    override fun toString(): String = map.toString()\n    override val size: Int get() = map.size\n    override fun isEmpty(): Boolean = map.isEmpty()\n    override fun containsKey(key: K): Boolean = map.containsKey(key)\n    override fun containsValue(value: @UnsafeVariance V): Boolean = map.containsValue(value)\n    override fun get(key: K): V? = map.get(key)\n    override val keys: MutableSet<K> get() = map.keys\n    override val values: MutableCollection<V> get() = map.values\n    override val entries: MutableSet<MutableMap.MutableEntry<K, V>> get() = map.entries\n\n    override fun put(key: K, value: V): V? = map.put(key, value)\n    override fun remove(key: K): V? = map.remove(key)\n    override fun putAll(from: Map<out K, V>) = map.putAll(from)\n    override fun clear() = map.clear()\n\n    override fun getOrImplicitDefault(key: K): V = map.getOrElseNullable(key, { default(key) })\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nimport kotlin.random.Random\n\n/**\n * Removes a single instance of the specified element from this\n * collection, if it is present.\n *\n * Allows to overcome type-safety restriction of `remove` that requires to pass an element of type `E`.\n *\n * @return `true` if the element has been successfully removed; `false` if it was not present in the collection.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.remove(element: T): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).remove(element)\n\n/**\n * Removes all of this collection's elements that are also contained in the specified collection.\n\n * Allows to overcome type-safety restriction of `removeAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any of the specified elements was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.removeAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).removeAll(elements)\n\n/**\n * Retains only the elements in this collection that are contained in the specified collection.\n *\n * Allows to overcome type-safety restriction of `retainAll` that requires to pass a collection of type `Collection<E>`.\n *\n * @return `true` if any element was removed from the collection, `false` if the collection was not modified.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <@kotlin.internal.OnlyInputTypes T> MutableCollection<out T>.retainAll(elements: Collection<T>): Boolean =\n    @Suppress(\"UNCHECKED_CAST\") (this as MutableCollection<T>).retainAll(elements)\n\n/**\n * Adds the specified [element] to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(element: T) {\n    this.add(element)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Iterable<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] array to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Array<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.plusAssign(elements: Sequence<T>) {\n    this.addAll(elements)\n}\n\n/**\n * Removes a single instance of the specified [element] from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(element: T) {\n    this.remove(element)\n}\n\n/**\n * Removes all elements contained in the given [elements] collection from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Iterable<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] array from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Array<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Removes all elements contained in the given [elements] sequence from this mutable collection.\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> MutableCollection<in T>.minusAssign(elements: Sequence<T>) {\n    this.removeAll(elements)\n}\n\n/**\n * Adds all elements of the given [elements] collection to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Iterable<T>): Boolean {\n    when (elements) {\n        is Collection -> return addAll(elements)\n        else -> {\n            var result: Boolean = false\n            for (item in elements)\n                if (add(item)) result = true\n            return result\n        }\n    }\n}\n\n/**\n * Adds all elements of the given [elements] sequence to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Sequence<T>): Boolean {\n    var result: Boolean = false\n    for (item in elements) {\n        if (add(item)) result = true\n    }\n    return result\n}\n\n/**\n * Adds all elements of the given [elements] array to this [MutableCollection].\n */\npublic fun <T> MutableCollection<in T>.addAll(elements: Array<out T>): Boolean {\n    return addAll(elements.asList())\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Iterable<T>): Boolean {\n    return removeAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Sequence<T>): Boolean {\n    val set = elements.convertToSetForSetOperation()\n    return set.isNotEmpty() && removeAll(set)\n}\n\n/**\n * Removes all elements from this [MutableCollection] that are also contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.removeAll(elements: Array<out T>): Boolean {\n    return elements.isNotEmpty() && removeAll(elements.convertToSetForSetOperation())\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] collection.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Iterable<T>): Boolean {\n    return retainAll(elements.convertToSetForSetOperationWith(this))\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] array.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Array<out T>): Boolean {\n    if (elements.isNotEmpty())\n        return retainAll(elements.convertToSetForSetOperation())\n    else\n        return retainNothing()\n}\n\n/**\n * Retains only elements of this [MutableCollection] that are contained in the given [elements] sequence.\n */\npublic fun <T> MutableCollection<in T>.retainAll(elements: Sequence<T>): Boolean {\n    val set = elements.convertToSetForSetOperation()\n    if (set.isNotEmpty())\n        return retainAll(set)\n    else\n        return retainNothing()\n}\n\nprivate fun MutableCollection<*>.retainNothing(): Boolean {\n    val result = isNotEmpty()\n    clear()\n    return result\n}\n\n\n/**\n * Removes all elements from this [MutableIterable] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when no elements were removed and collection was not modified.\n */\npublic fun <T> MutableIterable<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableIterable] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when all elements were retained and collection was not modified.\n */\npublic fun <T> MutableIterable<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableIterable<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    var result = false\n    with(iterator()) {\n        while (hasNext())\n            if (predicate(next()) == predicateResultToRemove) {\n                remove()\n                result = true\n            }\n    }\n    return result\n}\n\n\n/**\n * Removes the element at the specified [index] from this list.\n * In Kotlin one should use the [MutableList.removeAt] function instead.\n */\n@Deprecated(\"Use removeAt(index) instead.\", ReplaceWith(\"removeAt(index)\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline fun <T> MutableList<T>.remove(index: Int): T = removeAt(index)\n\n/**\n * Removes the first element from this mutable list and returns that removed element, or throws [NoSuchElementException] if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeFirst(): T = if (isEmpty()) throw NoSuchElementException(\"List is empty.\") else removeAt(0)\n\n/**\n * Removes the first element from this mutable list and returns that removed element, or returns `null` if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeFirstOrNull(): T? = if (isEmpty()) null else removeAt(0)\n\n/**\n * Removes the last element from this mutable list and returns that removed element, or throws [NoSuchElementException] if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeLast(): T = if (isEmpty()) throw NoSuchElementException(\"List is empty.\") else removeAt(lastIndex)\n\n/**\n * Removes the last element from this mutable list and returns that removed element, or returns `null` if this list is empty.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T> MutableList<T>.removeLastOrNull(): T? = if (isEmpty()) null else removeAt(lastIndex)\n\n/**\n * Removes all elements from this [MutableList] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when no elements were removed and collection was not modified.\n */\npublic fun <T> MutableList<T>.removeAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, true)\n\n/**\n * Retains only elements of this [MutableList] that match the given [predicate].\n *\n * @return `true` if any element was removed from this collection, or `false` when all elements were retained and collection was not modified.\n */\npublic fun <T> MutableList<T>.retainAll(predicate: (T) -> Boolean): Boolean = filterInPlace(predicate, false)\n\nprivate fun <T> MutableList<T>.filterInPlace(predicate: (T) -> Boolean, predicateResultToRemove: Boolean): Boolean {\n    if (this !is RandomAccess)\n        return (this as MutableIterable<T>).filterInPlace(predicate, predicateResultToRemove)\n\n    var writeIndex: Int = 0\n    for (readIndex in 0..lastIndex) {\n        val element = this[readIndex]\n        if (predicate(element) == predicateResultToRemove)\n            continue\n\n        if (writeIndex != readIndex)\n            this[writeIndex] = element\n\n        writeIndex++\n    }\n    if (writeIndex < size) {\n        for (removeIndex in lastIndex downTo writeIndex)\n            removeAt(removeIndex)\n\n        return true\n    } else {\n        return false\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CollectionsKt\")\n\npackage kotlin.collections\n\nprivate open class ReversedListReadOnly<out T>(private val delegate: List<T>) : AbstractList<T>() {\n    override val size: Int get() = delegate.size\n    override fun get(index: Int): T = delegate[reverseElementIndex(index)]\n}\n\nprivate class ReversedList<T>(private val delegate: MutableList<T>) : AbstractMutableList<T>() {\n    override val size: Int get() = delegate.size\n    override fun get(index: Int): T = delegate[reverseElementIndex(index)]\n\n    override fun clear() = delegate.clear()\n    override fun removeAt(index: Int): T = delegate.removeAt(reverseElementIndex(index))\n\n    override fun set(index: Int, element: T): T = delegate.set(reverseElementIndex(index), element)\n    override fun add(index: Int, element: T) {\n        delegate.add(reversePositionIndex(index), element)\n    }\n}\n\nprivate fun List<*>.reverseElementIndex(index: Int) =\n    if (index in 0..lastIndex) lastIndex - index else throw IndexOutOfBoundsException(\"Element index $index must be in range [${0..lastIndex}].\")\n\nprivate fun List<*>.reversePositionIndex(index: Int) =\n    if (index in 0..size) size - index else throw IndexOutOfBoundsException(\"Position index $index must be in range [${0..size}].\")\n\n\n/**\n * Returns a reversed read-only view of the original List.\n * All changes made in the original list will be reflected in the reversed one.\n * @sample samples.collections.ReversedViews.asReversedList\n */\npublic fun <T> List<T>.asReversed(): List<T> = ReversedListReadOnly(this)\n\n/**\n * Returns a reversed mutable view of the original mutable List.\n * All changes made in the original list will be reflected in the reversed one and vice versa.\n * @sample samples.collections.ReversedViews.asReversedMutableList\n */\n@kotlin.jvm.JvmName(\"asReversedMutable\")\npublic fun <T> MutableList<T>.asReversed(): MutableList<T> = ReversedList(this)\n\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SequencesKt\")\n@file:OptIn(ExperimentalTypeInference::class)\n\npackage kotlin.sequences\n\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.experimental.ExperimentalTypeInference\n\n/**\n * Builds a [Sequence] lazily yielding values one by one.\n *\n * @see kotlin.sequences.generateSequence\n *\n * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n * @sample samples.collections.Sequences.Building.buildFibonacciSequence\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> sequence(@BuilderInference block: suspend SequenceScope<T>.() -> Unit): Sequence<T> = Sequence { iterator(block) }\n\n@SinceKotlin(\"1.3\")\n@Deprecated(\"Use 'sequence { }' function instead.\", ReplaceWith(\"sequence(builderAction)\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline fun <T> buildSequence(@BuilderInference noinline builderAction: suspend SequenceScope<T>.() -> Unit): Sequence<T> = Sequence { iterator(builderAction) }\n\n/**\n * Builds an [Iterator] lazily yielding values one by one.\n *\n * @sample samples.collections.Sequences.Building.buildIterator\n * @sample samples.collections.Iterables.Building.iterable\n */\n@SinceKotlin(\"1.3\")\npublic fun <T> iterator(@BuilderInference block: suspend SequenceScope<T>.() -> Unit): Iterator<T> {\n    val iterator = SequenceBuilderIterator<T>()\n    iterator.nextStep = block.createCoroutineUnintercepted(receiver = iterator, completion = iterator)\n    return iterator\n}\n\n@SinceKotlin(\"1.3\")\n@Deprecated(\"Use 'iterator { }' function instead.\", ReplaceWith(\"iterator(builderAction)\"), level = DeprecationLevel.ERROR)\n@kotlin.internal.InlineOnly\npublic inline fun <T> buildIterator(@BuilderInference noinline builderAction: suspend SequenceScope<T>.() -> Unit): Iterator<T> = iterator(builderAction)\n\n/**\n * The scope for yielding values of a [Sequence] or an [Iterator], provides [yield] and [yieldAll] suspension functions.\n *\n * @see sequence\n * @see iterator\n *\n * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n * @sample samples.collections.Sequences.Building.buildFibonacciSequence\n */\n@RestrictsSuspension\n@SinceKotlin(\"1.3\")\npublic abstract class SequenceScope<in T> internal constructor() {\n    /**\n     * Yields a value to the [Iterator] being built and suspends\n     * until the next value is requested.\n     *\n     * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n     * @sample samples.collections.Sequences.Building.buildFibonacciSequence\n     */\n    public abstract suspend fun yield(value: T)\n\n    /**\n     * Yields all values from the `iterator` to the [Iterator] being built\n     * and suspends until all these values are iterated and the next one is requested.\n     *\n     * The sequence of values returned by the given iterator can be potentially infinite.\n     *\n     * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n     */\n    public abstract suspend fun yieldAll(iterator: Iterator<T>)\n\n    /**\n     * Yields a collections of values to the [Iterator] being built\n     * and suspends until all these values are iterated and the next one is requested.\n     *\n     * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n     */\n    public suspend fun yieldAll(elements: Iterable<T>) {\n        if (elements is Collection && elements.isEmpty()) return\n        return yieldAll(elements.iterator())\n    }\n\n    /**\n     * Yields potentially infinite sequence of values  to the [Iterator] being built\n     * and suspends until all these values are iterated and the next one is requested.\n     *\n     * The sequence can be potentially infinite.\n     *\n     * @sample samples.collections.Sequences.Building.buildSequenceYieldAll\n     */\n    public suspend fun yieldAll(sequence: Sequence<T>) = yieldAll(sequence.iterator())\n}\n\n@Deprecated(\"Use SequenceScope class instead.\", ReplaceWith(\"SequenceScope<T>\"), level = DeprecationLevel.ERROR)\npublic typealias SequenceBuilder<T> = SequenceScope<T>\n\nprivate typealias State = Int\n\nprivate const val State_NotReady: State = 0\nprivate const val State_ManyNotReady: State = 1\nprivate const val State_ManyReady: State = 2\nprivate const val State_Ready: State = 3\nprivate const val State_Done: State = 4\nprivate const val State_Failed: State = 5\n\nprivate class SequenceBuilderIterator<T> : SequenceScope<T>(), Iterator<T>, Continuation<Unit> {\n    private var state = State_NotReady\n    private var nextValue: T? = null\n    private var nextIterator: Iterator<T>? = null\n    var nextStep: Continuation<Unit>? = null\n\n    override fun hasNext(): Boolean {\n        while (true) {\n            when (state) {\n                State_NotReady -> {}\n                State_ManyNotReady ->\n                    if (nextIterator!!.hasNext()) {\n                        state = State_ManyReady\n                        return true\n                    } else {\n                        nextIterator = null\n                    }\n                State_Done -> return false\n                State_Ready, State_ManyReady -> return true\n                else -> throw exceptionalState()\n            }\n\n            state = State_Failed\n            val step = nextStep!!\n            nextStep = null\n            step.resume(Unit)\n        }\n    }\n\n    override fun next(): T {\n        when (state) {\n            State_NotReady, State_ManyNotReady -> return nextNotReady()\n            State_ManyReady -> {\n                state = State_ManyNotReady\n                return nextIterator!!.next()\n            }\n            State_Ready -> {\n                state = State_NotReady\n                @Suppress(\"UNCHECKED_CAST\")\n                val result = nextValue as T\n                nextValue = null\n                return result\n            }\n            else -> throw exceptionalState()\n        }\n    }\n\n    private fun nextNotReady(): T {\n        if (!hasNext()) throw NoSuchElementException() else return next()\n    }\n\n    private fun exceptionalState(): Throwable = when (state) {\n        State_Done -> NoSuchElementException()\n        State_Failed -> IllegalStateException(\"Iterator has failed.\")\n        else -> IllegalStateException(\"Unexpected state of the iterator: $state\")\n    }\n\n\n    override suspend fun yield(value: T) {\n        nextValue = value\n        state = State_Ready\n        return suspendCoroutineUninterceptedOrReturn { c ->\n            nextStep = c\n            COROUTINE_SUSPENDED\n        }\n    }\n\n    override suspend fun yieldAll(iterator: Iterator<T>) {\n        if (!iterator.hasNext()) return\n        nextIterator = iterator\n        state = State_ManyReady\n        return suspendCoroutineUninterceptedOrReturn { c ->\n            nextStep = c\n            COROUTINE_SUSPENDED\n        }\n    }\n\n    // Completion continuation implementation\n    override fun resumeWith(result: Result<Unit>) {\n        result.getOrThrow() // just rethrow exception if it is there\n        state = State_Done\n    }\n\n    override val context: CoroutineContext\n        get() = EmptyCoroutineContext\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\n/**\n * Marks coroutine context element that intercepts coroutine continuations.\n * The coroutines framework uses [ContinuationInterceptor.Key] to retrieve the interceptor and\n * intercepts all coroutine continuations with [interceptContinuation] invocations.\n *\n * [ContinuationInterceptor] behaves like a [polymorphic element][AbstractCoroutineContextKey], meaning that\n * its implementation delegates [get][CoroutineContext.Element.get] and [minusKey][CoroutineContext.Element.minusKey]\n * to [getPolymorphicElement] and [minusPolymorphicKey] respectively.\n * [ContinuationInterceptor] subtypes can be extracted from the coroutine context using either [ContinuationInterceptor.Key]\n * or subtype key if it extends [AbstractCoroutineContextKey].\n */\n@SinceKotlin(\"1.3\")\npublic interface ContinuationInterceptor : CoroutineContext.Element {\n    /**\n     * The key that defines *the* context interceptor.\n     */\n    companion object Key : CoroutineContext.Key<ContinuationInterceptor>\n\n    /**\n     * Returns continuation that wraps the original [continuation], thus intercepting all resumptions.\n     * This function is invoked by coroutines framework when needed and the resulting continuations are\n     * cached internally per each instance of the original [continuation].\n     *\n     * This function may simply return original [continuation] if it does not want to intercept this particular continuation.\n     *\n     * When the original [continuation] completes, coroutine framework invokes [releaseInterceptedContinuation]\n     * with the resulting continuation if it was intercepted, that is if `interceptContinuation` had previously\n     * returned a different continuation instance.\n     */\n    public fun <T> interceptContinuation(continuation: Continuation<T>): Continuation<T>\n\n    /**\n     * Invoked for the continuation instance returned by [interceptContinuation] when the original\n     * continuation completes and will not be used anymore. This function is invoked only if [interceptContinuation]\n     * had returned a different continuation instance from the one it was invoked with.\n     *\n     * Default implementation does nothing.\n     *\n     * @param continuation Continuation instance returned by this interceptor's [interceptContinuation] invocation.\n     */\n    public fun releaseInterceptedContinuation(continuation: Continuation<*>) {\n        /* do nothing by default */\n    }\n\n    public override operator fun <E : CoroutineContext.Element> get(key: CoroutineContext.Key<E>): E? {\n        // getPolymorphicKey specialized for ContinuationInterceptor key\n        @OptIn(ExperimentalStdlibApi::class)\n        if (key is AbstractCoroutineContextKey<*, *>) {\n            @Suppress(\"UNCHECKED_CAST\")\n            return if (key.isSubKey(this.key)) key.tryCast(this) as? E else null\n        }\n        @Suppress(\"UNCHECKED_CAST\")\n        return if (ContinuationInterceptor === key) this as E else null\n    }\n\n\n    public override fun minusKey(key: CoroutineContext.Key<*>): CoroutineContext {\n        // minusPolymorphicKey specialized for ContinuationInterceptor key\n        @OptIn(ExperimentalStdlibApi::class)\n        if (key is AbstractCoroutineContextKey<*, *>) {\n            return if (key.isSubKey(this.key) && key.tryCast(this) != null) EmptyCoroutineContext else this\n        }\n        return if (ContinuationInterceptor === key) EmptyCoroutineContext else this\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\n/**\n * Persistent context for the coroutine. It is an indexed set of [Element] instances.\n * An indexed set is a mix between a set and a map.\n * Every element in this set has a unique [Key].\n */\n@SinceKotlin(\"1.3\")\npublic interface CoroutineContext {\n    /**\n     * Returns the element with the given [key] from this context or `null`.\n     */\n    public operator fun <E : Element> get(key: Key<E>): E?\n\n    /**\n     * Accumulates entries of this context starting with [initial] value and applying [operation]\n     * from left to right to current accumulator value and each element of this context.\n     */\n    public fun <R> fold(initial: R, operation: (R, Element) -> R): R\n\n    /**\n     * Returns a context containing elements from this context and elements from  other [context].\n     * The elements from this context with the same key as in the other one are dropped.\n     */\n    public operator fun plus(context: CoroutineContext): CoroutineContext =\n        if (context === EmptyCoroutineContext) this else // fast path -- avoid lambda creation\n            context.fold(this) { acc, element ->\n                val removed = acc.minusKey(element.key)\n                if (removed === EmptyCoroutineContext) element else {\n                    // make sure interceptor is always last in the context (and thus is fast to get when present)\n                    val interceptor = removed[ContinuationInterceptor]\n                    if (interceptor == null) CombinedContext(removed, element) else {\n                        val left = removed.minusKey(ContinuationInterceptor)\n                        if (left === EmptyCoroutineContext) CombinedContext(element, interceptor) else\n                            CombinedContext(CombinedContext(left, element), interceptor)\n                    }\n                }\n            }\n\n    /**\n     * Returns a context containing elements from this context, but without an element with\n     * the specified [key].\n     */\n    public fun minusKey(key: Key<*>): CoroutineContext\n\n    /**\n     * Key for the elements of [CoroutineContext]. [E] is a type of element with this key.\n     */\n    public interface Key<E : Element>\n\n    /**\n     * An element of the [CoroutineContext]. An element of the coroutine context is a singleton context by itself.\n     */\n    public interface Element : CoroutineContext {\n        /**\n         * A key of this coroutine context element.\n         */\n        public val key: Key<*>\n\n        public override operator fun <E : Element> get(key: Key<E>): E? =\n            @Suppress(\"UNCHECKED_CAST\")\n            if (this.key == key) this as E else null\n\n        public override fun <R> fold(initial: R, operation: (R, Element) -> R): R =\n            operation(initial, this)\n\n        public override fun minusKey(key: Key<*>): CoroutineContext =\n            if (this.key == key) EmptyCoroutineContext else this\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines\n\nimport kotlin.coroutines.CoroutineContext.Element\nimport kotlin.coroutines.CoroutineContext.Key\n\n/**\n * Base class for [CoroutineContext.Element] implementations.\n */\n@SinceKotlin(\"1.3\")\npublic abstract class AbstractCoroutineContextElement(public override val key: Key<*>) : Element\n\n/**\n * Base class for [CoroutineContext.Key] associated with polymorphic [CoroutineContext.Element] implementation.\n * Polymorphic element implementation implies delegating its [get][Element.get] and [minusKey][Element.minusKey]\n * to [getPolymorphicElement] and [minusPolymorphicKey] respectively.\n *\n * Polymorphic elements can be extracted from the coroutine context using both element key and its supertype key.\n * Example of polymorphic elements:\n * ```\n * open class BaseElement : CoroutineContext.Element {\n *     companion object Key : CoroutineContext.Key<BaseElement>\n *     override val key: CoroutineContext.Key<*> get() = Key\n *     // It is important to use getPolymorphicKey and minusPolymorphicKey\n *     override fun <E : CoroutineContext.Element> get(key: CoroutineContext.Key<E>): E? = getPolymorphicElement(key)\n *     override fun minusKey(key: CoroutineContext.Key<*>): CoroutineContext = minusPolymorphicKey(key)\n * }\n *\n * class DerivedElement : BaseElement() {\n *     companion object Key : AbstractCoroutineContextKey<BaseElement, DerivedElement>(BaseElement, { it as? DerivedElement })\n * }\n * // Now it is possible to query both `BaseElement` and `DerivedElement`\n * someContext[BaseElement] // Returns BaseElement?, non-null both for BaseElement and DerivedElement instances\n * someContext[DerivedElement] // Returns DerivedElement?, non-null only for DerivedElement instance\n * ```\n * @param B base class of a polymorphic element\n * @param baseKey an instance of base key\n * @param E element type associated with the current key\n * @param safeCast a function that can safely cast abstract [CoroutineContext.Element] to the concrete [E] type\n *                 and return the element if it is a subtype of [E] or `null` otherwise.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic abstract class AbstractCoroutineContextKey<B : Element, E : B>(\n    baseKey: Key<B>,\n    private val safeCast: (element: Element) -> E?\n) : Key<E> {\n    private val topmostKey: Key<*> = if (baseKey is AbstractCoroutineContextKey<*, *>) baseKey.topmostKey else baseKey\n\n    internal fun tryCast(element: Element): E? = safeCast(element)\n    internal fun isSubKey(key: Key<*>): Boolean = key === this || topmostKey === key\n}\n\n/**\n * Returns the current element if it is associated with the given [key] in a polymorphic manner or `null` otherwise.\n * This method returns non-null value if either [Element.key] is equal to the given [key] or if the [key] is associated\n * with [Element.key] via [AbstractCoroutineContextKey].\n * See [AbstractCoroutineContextKey] for the example of usage.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun <E : Element> Element.getPolymorphicElement(key: Key<E>): E? {\n    if (key is AbstractCoroutineContextKey<*, *>) {\n        @Suppress(\"UNCHECKED_CAST\")\n        return if (key.isSubKey(this.key)) key.tryCast(this) as? E else null\n    }\n    @Suppress(\"UNCHECKED_CAST\")\n    return if (this.key === key) this as E else null\n}\n\n/**\n * Returns empty coroutine context if the element is associated with the given [key] in a polymorphic manner\n * or `null` otherwise.\n * This method returns empty context if either [Element.key] is equal to the given [key] or if the [key] is associated\n * with [Element.key] via [AbstractCoroutineContextKey].\n * See [AbstractCoroutineContextKey] for the example of usage.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalStdlibApi\npublic fun Element.minusPolymorphicKey(key: Key<*>): CoroutineContext {\n    if (key is AbstractCoroutineContextKey<*, *>) {\n        return if (key.isSubKey(this.key) && key.tryCast(this) != null) EmptyCoroutineContext else this\n    }\n    return if (this.key === key) EmptyCoroutineContext else this\n}\n\n/**\n * An empty coroutine context.\n */\n@SinceKotlin(\"1.3\")\npublic object EmptyCoroutineContext : CoroutineContext, Serializable {\n    private const val serialVersionUID: Long = 0\n    private fun readResolve(): Any = EmptyCoroutineContext\n\n    public override fun <E : Element> get(key: Key<E>): E? = null\n    public override fun <R> fold(initial: R, operation: (R, Element) -> R): R = initial\n    public override fun plus(context: CoroutineContext): CoroutineContext = context\n    public override fun minusKey(key: Key<*>): CoroutineContext = this\n    public override fun hashCode(): Int = 0\n    public override fun toString(): String = \"EmptyCoroutineContext\"\n}\n\n//--------------------- internal impl ---------------------\n\n// this class is not exposed, but is hidden inside implementations\n// this is a left-biased list, so that `plus` works naturally\n@SinceKotlin(\"1.3\")\ninternal class CombinedContext(\n    private val left: CoroutineContext,\n    private val element: Element\n) : CoroutineContext, Serializable {\n\n    override fun <E : Element> get(key: Key<E>): E? {\n        var cur = this\n        while (true) {\n            cur.element[key]?.let { return it }\n            val next = cur.left\n            if (next is CombinedContext) {\n                cur = next\n            } else {\n                return next[key]\n            }\n        }\n    }\n\n    public override fun <R> fold(initial: R, operation: (R, Element) -> R): R =\n        operation(left.fold(initial, operation), element)\n\n    public override fun minusKey(key: Key<*>): CoroutineContext {\n        element[key]?.let { return left }\n        val newLeft = left.minusKey(key)\n        return when {\n            newLeft === left -> this\n            newLeft === EmptyCoroutineContext -> element\n            else -> CombinedContext(newLeft, element)\n        }\n    }\n\n    private fun size(): Int {\n        var cur = this\n        var size = 2\n        while (true) {\n            cur = cur.left as? CombinedContext ?: return size\n            size++\n        }\n    }\n\n    private fun contains(element: Element): Boolean =\n        get(element.key) == element\n\n    private fun containsAll(context: CombinedContext): Boolean {\n        var cur = context\n        while (true) {\n            if (!contains(cur.element)) return false\n            val next = cur.left\n            if (next is CombinedContext) {\n                cur = next\n            } else {\n                return contains(next as Element)\n            }\n        }\n    }\n\n    override fun equals(other: Any?): Boolean =\n        this === other || other is CombinedContext && other.size() == size() && other.containsAll(this)\n\n    override fun hashCode(): Int = left.hashCode() + element.hashCode()\n\n    override fun toString(): String =\n        \"[\" + fold(\"\") { acc, element ->\n            if (acc.isEmpty()) element.toString() else \"$acc, $element\"\n        } + \"]\"\n\n    private fun writeReplace(): Any {\n        val n = size()\n        val elements = arrayOfNulls<CoroutineContext>(n)\n        var index = 0\n        fold(Unit) { _, element -> elements[index++] = element }\n        check(index == n)\n        @Suppress(\"UNCHECKED_CAST\")\n        return Serialized(elements as Array<CoroutineContext>)\n    }\n\n    private class Serialized(val elements: Array<CoroutineContext>) : Serializable {\n        companion object {\n            private const val serialVersionUID: Long = 0L\n        }\n\n        private fun readResolve(): Any = elements.fold(EmptyCoroutineContext, CoroutineContext::plus)\n    }\n}\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"IntrinsicsKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin.coroutines.intrinsics\n\nimport kotlin.contracts.*\nimport kotlin.coroutines.*\nimport kotlin.internal.InlineOnly\n\n/**\n * Obtains the current continuation instance inside suspend functions and either suspends\n * currently running coroutine or returns result immediately without suspension.\n *\n * If the [block] returns the special [COROUTINE_SUSPENDED] value, it means that suspend function did suspend the execution and will\n * not return any result immediately. In this case, the [Continuation] provided to the [block] shall be\n * resumed by invoking [Continuation.resumeWith] at some moment in the\n * future when the result becomes available to resume the computation.\n *\n * Otherwise, the return value of the [block] must have a type assignable to [T] and represents the result of this suspend function.\n * It means that the execution was not suspended and the [Continuation] provided to the [block] shall not be invoked.\n * As the result type of the [block] is declared as `Any?` and cannot be correctly type-checked,\n * its proper return type remains on the conscience of the suspend function's author.\n *\n * Invocation of [Continuation.resumeWith] resumes coroutine directly in the invoker's thread without going through the\n * [ContinuationInterceptor] that might be present in the coroutine's [CoroutineContext].\n * It is the invoker's responsibility to ensure that a proper invocation context is established.\n * [Continuation.intercepted] can be used to acquire the intercepted continuation.\n *\n * Note that it is not recommended to call either [Continuation.resume] nor [Continuation.resumeWithException] functions synchronously\n * in the same stackframe where suspension function is run. Use [suspendCoroutine] as a safer way to obtain current\n * continuation instance.\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\n@Suppress(\"UNUSED_PARAMETER\", \"RedundantSuspendModifier\")\npublic suspend inline fun <T> suspendCoroutineUninterceptedOrReturn(crossinline block: (Continuation<T>) -> Any?): T {\n    contract { callsInPlace(block, InvocationKind.EXACTLY_ONCE) }\n    throw NotImplementedError(\"Implementation of suspendCoroutineUninterceptedOrReturn is intrinsic\")\n}\n\n/**\n * This value is used as a return value of [suspendCoroutineUninterceptedOrReturn] `block` argument to state that\n * the execution was suspended and will not return any result immediately.\n *\n * **Note: this value should not be used in general code.** Using it outside of the context of\n * `suspendCoroutineUninterceptedOrReturn` function return value  (including, but not limited to,\n * storing this value in other properties, returning it from other functions, etc)\n * can lead to unspecified behavior of the code.\n */\n// It is implemented as property with getter to avoid ProGuard <clinit> problem with multifile IntrinsicsKt class\n@SinceKotlin(\"1.3\")\npublic val COROUTINE_SUSPENDED: Any get() = CoroutineSingletons.COROUTINE_SUSPENDED\n\n// Using enum here ensures two important properties:\n//  1. It makes SafeContinuation serializable with all kinds of serialization frameworks (since all of them natively support enums)\n//  2. It improves debugging experience, since you clearly see toString() value of those objects and what package they come from\n@SinceKotlin(\"1.3\")\n@PublishedApi // This class is Published API via serialized representation of SafeContinuation, don't rename/move\ninternal enum class CoroutineSingletons { COROUTINE_SUSPENDED, UNDECIDED, RESUMED }\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.random\n\nimport kotlin.math.nextDown\n\n/**\n * An abstract class that is implemented by random number generator algorithms.\n *\n * The companion object [Random.Default] is the default instance of [Random].\n *\n * To get a seeded instance of random generator use [Random] function.\n *\n * @sample samples.random.Randoms.defaultRandom\n */\n@SinceKotlin(\"1.3\")\npublic abstract class Random {\n\n    /**\n     * Gets the next random [bitCount] number of bits.\n     *\n     * Generates an `Int` whose lower [bitCount] bits are filled with random values and the remaining upper bits are zero.\n     *\n     * @param bitCount number of bits to generate, must be in range 0..32, otherwise the behavior is unspecified.\n     *\n     * @sample samples.random.Randoms.nextBits\n     */\n    public abstract fun nextBits(bitCount: Int): Int\n\n    /**\n     * Gets the next random `Int` from the random number generator.\n     *\n     * Generates an `Int` random value uniformly distributed between `Int.MIN_VALUE` and `Int.MAX_VALUE` (inclusive).\n     *\n     * @sample samples.random.Randoms.nextInt\n     */\n    public open fun nextInt(): Int = nextBits(32)\n\n    /**\n     * Gets the next random non-negative `Int` from the random number generator less than the specified [until] bound.\n     *\n     * Generates an `Int` random value uniformly distributed between `0` (inclusive) and the specified [until] bound (exclusive).\n     *\n     * @param until must be positive.\n     *\n     * @throws IllegalArgumentException if [until] is negative or zero.\n     *\n     * @sample samples.random.Randoms.nextIntFromUntil\n     */\n    public open fun nextInt(until: Int): Int = nextInt(0, until)\n\n    /**\n     * Gets the next random `Int` from the random number generator in the specified range.\n     *\n     * Generates an `Int` random value uniformly distributed between the specified [from] (inclusive) and [until] (exclusive) bounds.\n     *\n     * @throws IllegalArgumentException if [from] is greater than or equal to [until].\n     *\n     * @sample samples.random.Randoms.nextIntFromUntil\n     */\n    public open fun nextInt(from: Int, until: Int): Int {\n        checkRangeBounds(from, until)\n        val n = until - from\n        if (n > 0 || n == Int.MIN_VALUE) {\n            val rnd = if (n and -n == n) {\n                val bitCount = fastLog2(n)\n                nextBits(bitCount)\n            } else {\n                var v: Int\n                do {\n                    val bits = nextInt().ushr(1)\n                    v = bits % n\n                } while (bits - v + (n - 1) < 0)\n                v\n            }\n            return from + rnd\n        } else {\n            while (true) {\n                val rnd = nextInt()\n                if (rnd in from until until) return rnd\n            }\n        }\n    }\n\n    /**\n     * Gets the next random `Long` from the random number generator.\n     *\n     * Generates a `Long` random value uniformly distributed between `Long.MIN_VALUE` and `Long.MAX_VALUE` (inclusive).\n     *\n     * @sample samples.random.Randoms.nextLong\n     */\n    public open fun nextLong(): Long = nextInt().toLong().shl(32) + nextInt()\n\n    /**\n     * Gets the next random non-negative `Long` from the random number generator less than the specified [until] bound.\n     *\n     * Generates a `Long` random value uniformly distributed between `0` (inclusive) and the specified [until] bound (exclusive).\n     *\n     * @param until must be positive.\n     *\n     * @throws IllegalArgumentException if [until] is negative or zero.\n     *\n     * @sample samples.random.Randoms.nextLongFromUntil\n     */\n    public open fun nextLong(until: Long): Long = nextLong(0, until)\n\n    /**\n     * Gets the next random `Long` from the random number generator in the specified range.\n     *\n     * Generates a `Long` random value uniformly distributed between the specified [from] (inclusive) and [until] (exclusive) bounds.\n     *\n     * @throws IllegalArgumentException if [from] is greater than or equal to [until].\n     *\n     * @sample samples.random.Randoms.nextLongFromUntil\n     */\n    public open fun nextLong(from: Long, until: Long): Long {\n        checkRangeBounds(from, until)\n        val n = until - from\n        if (n > 0) {\n            val rnd: Long\n            if (n and -n == n) {\n                val nLow = n.toInt()\n                val nHigh = (n ushr 32).toInt()\n                rnd = when {\n                    nLow != 0 -> {\n                        val bitCount = fastLog2(nLow)\n                        // toUInt().toLong()\n                        nextBits(bitCount).toLong() and 0xFFFF_FFFF\n                    }\n                    nHigh == 1 ->\n                        // toUInt().toLong()\n                        nextInt().toLong() and 0xFFFF_FFFF\n                    else -> {\n                        val bitCount = fastLog2(nHigh)\n                        nextBits(bitCount).toLong().shl(32) + (nextInt().toLong() and 0xFFFF_FFFF)\n                    }\n                }\n            } else {\n                var v: Long\n                do {\n                    val bits = nextLong().ushr(1)\n                    v = bits % n\n                } while (bits - v + (n - 1) < 0)\n                rnd = v\n            }\n            return from + rnd\n        } else {\n            while (true) {\n                val rnd = nextLong()\n                if (rnd in from until until) return rnd\n            }\n        }\n    }\n\n    /**\n     * Gets the next random [Boolean] value.\n     *\n     * @sample samples.random.Randoms.nextBoolean\n     */\n    public open fun nextBoolean(): Boolean = nextBits(1) != 0\n\n    /**\n     * Gets the next random [Double] value uniformly distributed between 0 (inclusive) and 1 (exclusive).\n     *\n     * @sample samples.random.Randoms.nextDouble\n     */\n    public open fun nextDouble(): Double = doubleFromParts(nextBits(26), nextBits(27))\n\n    /**\n     * Gets the next random non-negative `Double` from the random number generator less than the specified [until] bound.\n     *\n     * Generates a `Double` random value uniformly distributed between 0 (inclusive) and [until] (exclusive).\n     *\n     * @throws IllegalArgumentException if [until] is negative or zero.\n     *\n     * @sample samples.random.Randoms.nextDoubleFromUntil\n     */\n    public open fun nextDouble(until: Double): Double = nextDouble(0.0, until)\n\n    /**\n     * Gets the next random `Double` from the random number generator in the specified range.\n     *\n     * Generates a `Double` random value uniformly distributed between the specified [from] (inclusive) and [until] (exclusive) bounds.\n     *\n     * [from] and [until] must be finite otherwise the behavior is unspecified.\n     *\n     * @throws IllegalArgumentException if [from] is greater than or equal to [until].\n     *\n     * @sample samples.random.Randoms.nextDoubleFromUntil\n     */\n    public open fun nextDouble(from: Double, until: Double): Double {\n        checkRangeBounds(from, until)\n        val size = until - from\n        val r = if (size.isInfinite() && from.isFinite() && until.isFinite()) {\n            val r1 = nextDouble() * (until / 2 - from / 2)\n            from + r1 + r1\n        } else {\n            from + nextDouble() * size\n        }\n        return if (r >= until) until.nextDown() else r\n    }\n\n    /**\n     * Gets the next random [Float] value uniformly distributed between 0 (inclusive) and 1 (exclusive).\n     *\n     * @sample samples.random.Randoms.nextFloat\n     */\n    public open fun nextFloat(): Float = nextBits(24) / (1 shl 24).toFloat()\n\n    /**\n     * Fills a subrange of the specified byte [array] starting from [fromIndex] inclusive and ending [toIndex] exclusive\n     * with random bytes.\n     *\n     * @return [array] with the subrange filled with random bytes.\n     *\n     * @sample samples.random.Randoms.nextBytes\n     */\n    public open fun nextBytes(array: ByteArray, fromIndex: Int = 0, toIndex: Int = array.size): ByteArray {\n        require(fromIndex in 0..array.size && toIndex in 0..array.size) { \"fromIndex ($fromIndex) or toIndex ($toIndex) are out of range: 0..${array.size}.\" }\n        require(fromIndex <= toIndex) { \"fromIndex ($fromIndex) must be not greater than toIndex ($toIndex).\" }\n\n        val steps = (toIndex - fromIndex) / 4\n\n        var position = fromIndex\n        repeat(steps) {\n            val v = nextInt()\n            array[position] = v.toByte()\n            array[position + 1] = v.ushr(8).toByte()\n            array[position + 2] = v.ushr(16).toByte()\n            array[position + 3] = v.ushr(24).toByte()\n            position += 4\n        }\n\n        val remainder = toIndex - position\n        val vr = nextBits(remainder * 8)\n        for (i in 0 until remainder) {\n            array[position + i] = vr.ushr(i * 8).toByte()\n        }\n\n        return array\n    }\n\n    /**\n     * Fills the specified byte [array] with random bytes and returns it.\n     *\n     * @return [array] filled with random bytes.\n     *\n     * @sample samples.random.Randoms.nextBytes\n     */\n    public open fun nextBytes(array: ByteArray): ByteArray = nextBytes(array, 0, array.size)\n\n    /**\n     * Creates a byte array of the specified [size], filled with random bytes.\n     *\n     * @sample samples.random.Randoms.nextBytes\n     */\n    public open fun nextBytes(size: Int): ByteArray = nextBytes(ByteArray(size))\n\n\n    /**\n     * The default random number generator.\n     *\n     * On JVM this generator is thread-safe, its methods can be invoked from multiple threads.\n     *\n     * @sample samples.random.Randoms.defaultRandom\n     */\n    companion object Default : Random(), Serializable {\n        private val defaultRandom: Random = defaultPlatformRandom()\n\n        private object Serialized : Serializable {\n            private const val serialVersionUID = 0L\n\n            private fun readResolve(): Any = Random\n        }\n\n        private fun writeReplace(): Any = Serialized\n\n        override fun nextBits(bitCount: Int): Int = defaultRandom.nextBits(bitCount)\n        override fun nextInt(): Int = defaultRandom.nextInt()\n        override fun nextInt(until: Int): Int = defaultRandom.nextInt(until)\n        override fun nextInt(from: Int, until: Int): Int = defaultRandom.nextInt(from, until)\n\n        override fun nextLong(): Long = defaultRandom.nextLong()\n        override fun nextLong(until: Long): Long = defaultRandom.nextLong(until)\n        override fun nextLong(from: Long, until: Long): Long = defaultRandom.nextLong(from, until)\n\n        override fun nextBoolean(): Boolean = defaultRandom.nextBoolean()\n\n        override fun nextDouble(): Double = defaultRandom.nextDouble()\n        override fun nextDouble(until: Double): Double = defaultRandom.nextDouble(until)\n        override fun nextDouble(from: Double, until: Double): Double = defaultRandom.nextDouble(from, until)\n\n        override fun nextFloat(): Float = defaultRandom.nextFloat()\n\n        override fun nextBytes(array: ByteArray): ByteArray = defaultRandom.nextBytes(array)\n        override fun nextBytes(size: Int): ByteArray = defaultRandom.nextBytes(size)\n        override fun nextBytes(array: ByteArray, fromIndex: Int, toIndex: Int): ByteArray =\n            defaultRandom.nextBytes(array, fromIndex, toIndex)\n    }\n}\n\n/**\n * Returns a repeatable random number generator seeded with the given [seed] `Int` value.\n *\n * Two generators with the same seed produce the same sequence of values within the same version of Kotlin runtime.\n *\n * *Note:* Future versions of Kotlin may change the algorithm of this seeded number generator so that it will return\n * a sequence of values different from the current one for a given seed.\n *\n * On JVM the returned generator is NOT thread-safe. Do not invoke it from multiple threads without proper synchronization.\n *\n * @sample samples.random.Randoms.seededRandom\n */\n@SinceKotlin(\"1.3\")\npublic fun Random(seed: Int): Random = XorWowRandom(seed, seed.shr(31))\n\n/**\n * Returns a repeatable random number generator seeded with the given [seed] `Long` value.\n *\n * Two generators with the same seed produce the same sequence of values within the same version of Kotlin runtime.\n *\n * *Note:* Future versions of Kotlin may change the algorithm of this seeded number generator so that it will return\n * a sequence of values different from the current one for a given seed.\n *\n * On JVM the returned generator is NOT thread-safe. Do not invoke it from multiple threads without proper synchronization.\n *\n * @sample samples.random.Randoms.seededRandom\n */\n@SinceKotlin(\"1.3\")\npublic fun Random(seed: Long): Random = XorWowRandom(seed.toInt(), seed.shr(32).toInt())\n\n\n/**\n * Gets the next random `Int` from the random number generator in the specified [range].\n *\n * Generates an `Int` random value uniformly distributed in the specified [range]:\n * from `range.start` inclusive to `range.endInclusive` inclusive.\n *\n * @throws IllegalArgumentException if [range] is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun Random.nextInt(range: IntRange): Int = when {\n    range.isEmpty() -> throw IllegalArgumentException(\"Cannot get random in empty range: $range\")\n    range.last < Int.MAX_VALUE -> nextInt(range.first, range.last + 1)\n    range.first > Int.MIN_VALUE -> nextInt(range.first - 1, range.last) + 1\n    else -> nextInt()\n}\n\n/**\n * Gets the next random `Long` from the random number generator in the specified [range].\n *\n * Generates a `Long` random value uniformly distributed in the specified [range]:\n * from `range.start` inclusive to `range.endInclusive` inclusive.\n *\n * @throws IllegalArgumentException if [range] is empty.\n */\n@SinceKotlin(\"1.3\")\npublic fun Random.nextLong(range: LongRange): Long = when {\n    range.isEmpty() -> throw IllegalArgumentException(\"Cannot get random in empty range: $range\")\n    range.last < Long.MAX_VALUE -> nextLong(range.first, range.last + 1)\n    range.first > Long.MIN_VALUE -> nextLong(range.first - 1, range.last) + 1\n    else -> nextLong()\n}\n\n\ninternal expect fun defaultPlatformRandom(): Random\ninternal expect fun doubleFromParts(hi26: Int, low27: Int): Double\n\ninternal fun fastLog2(value: Int): Int = 31 - value.countLeadingZeroBits()\n\n/** Takes upper [bitCount] bits (0..32) from this number. */\ninternal fun Int.takeUpperBits(bitCount: Int): Int =\n    this.ushr(32 - bitCount) and (-bitCount).shr(31)\n\ninternal fun checkRangeBounds(from: Int, until: Int) = require(until > from) { boundsErrorMessage(from, until) }\ninternal fun checkRangeBounds(from: Long, until: Long) = require(until > from) { boundsErrorMessage(from, until) }\ninternal fun checkRangeBounds(from: Double, until: Double) = require(until > from) { boundsErrorMessage(from, until) }\n\ninternal fun boundsErrorMessage(from: Any, until: Any) = \"Random range is empty: [$from, $until).\"\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.properties\n\nimport kotlin.reflect.KProperty\n\n/**\n * Base interface that can be used for implementing property delegates of read-only properties.\n *\n * This is provided only for convenience; you don't have to extend this interface\n * as long as your property delegate has methods with the same signatures.\n *\n * @param T the type of object which owns the delegated property.\n * @param V the type of the property value.\n */\npublic fun interface ReadOnlyProperty<in T, out V> {\n    /**\n     * Returns the value of the property for the given object.\n     * @param thisRef the object for which the value is requested.\n     * @param property the metadata for the property.\n     * @return the property value.\n     */\n    public operator fun getValue(thisRef: T, property: KProperty<*>): V\n}\n\n/**\n * Base interface that can be used for implementing property delegates of read-write properties.\n *\n * This is provided only for convenience; you don't have to extend this interface\n * as long as your property delegate has methods with the same signatures.\n *\n * @param T the type of object which owns the delegated property.\n * @param V the type of the property value.\n */\npublic interface ReadWriteProperty<in T, V> : ReadOnlyProperty<T, V> {\n    /**\n     * Returns the value of the property for the given object.\n     * @param thisRef the object for which the value is requested.\n     * @param property the metadata for the property.\n     * @return the property value.\n     */\n    public override operator fun getValue(thisRef: T, property: KProperty<*>): V\n\n    /**\n     * Sets the value of the property for the given object.\n     * @param thisRef the object for which the value is requested.\n     * @param property the metadata for the property.\n     * @param value the value to set.\n     */\n    public operator fun setValue(thisRef: T, property: KProperty<*>, value: V)\n}\n\n/**\n * Base interface that can be used for implementing property delegate providers.\n *\n * This is provided only for convenience; you don't have to extend this interface\n * as long as your delegate provider has a method with the same signature.\n *\n * @param T the type of object which owns the delegated property.\n * @param D the type of property delegates this provider provides.\n */\n@SinceKotlin(\"1.4\")\npublic fun interface PropertyDelegateProvider<in T, out D> {\n    /**\n     * Returns the delegate of the property for the given object.\n     *\n     * This function can be used to extend the logic of creating the object (e.g. perform validation checks)\n     * to which the property implementation is delegated.\n     *\n     * @param thisRef the object for which property delegate is requested.\n     * @param property the metadata for the property.\n     * @return the property delegate.\n     */\n    public operator fun provideDelegate(thisRef: T, property: KProperty<*>): D\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.random\n\n/**\n * Random number generator, using Marsaglia's \"xorwow\" algorithm\n *\n * Cycles after 2^192 - 2^32 repetitions.\n *\n * For more details, see Marsaglia, George (July 2003). \"Xorshift RNGs\". Journal of Statistical Software. 8 (14). doi:10.18637/jss.v008.i14\n *\n * Available at https://www.jstatsoft.org/v08/i14/paper\n *\n */\ninternal class XorWowRandom internal constructor(\n    private var x: Int,\n    private var y: Int,\n    private var z: Int,\n    private var w: Int,\n    private var v: Int,\n    private var addend: Int\n) : Random(), Serializable {\n\n    internal constructor(seed1: Int, seed2: Int) :\n            this(seed1, seed2, 0, 0, seed1.inv(), (seed1 shl 10) xor (seed2 ushr 4))\n\n    init {\n        require((x or y or z or w or v) != 0) { \"Initial state must have at least one non-zero element.\" }\n\n        // some trivial seeds can produce several values with zeroes in upper bits, so we discard first 64\n        repeat(64) { nextInt() }\n    }\n\n    override fun nextInt(): Int {\n        // Equivalent to the xorxow algorithm\n        // From Marsaglia, G. 2003. Xorshift RNGs. J. Statis. Soft. 8, 14, p. 5\n        var t = x\n        t = t xor (t ushr 2)\n        x = y\n        y = z\n        z = w\n        val v0 = v\n        w = v0\n        t = (t xor (t shl 1)) xor v0 xor (v0 shl 4)\n        v = t\n        addend += 362437\n        return t + addend\n    }\n\n    override fun nextBits(bitCount: Int): Int =\n        nextInt().takeUpperBits(bitCount)\n\n    private companion object {\n        private const val serialVersionUID: Long = 0L\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"RangesKt\")\n\npackage kotlin.ranges\n\n/**\n * Represents a range of [Comparable] values.\n */\nprivate open class ComparableRange<T : Comparable<T>>(\n    override val start: T,\n    override val endInclusive: T\n) : ClosedRange<T> {\n\n    override fun equals(other: Any?): Boolean {\n        return other is ComparableRange<*> && (isEmpty() && other.isEmpty() ||\n                start == other.start && endInclusive == other.endInclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * start.hashCode() + endInclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$start..$endInclusive\"\n}\n\n/**\n * Creates a range from this [Comparable] value to the specified [that] value.\n *\n * This value needs to be smaller than or equal to [that] value, otherwise the returned range will be empty.\n * @sample samples.ranges.Ranges.rangeFromComparable\n */\npublic operator fun <T : Comparable<T>> T.rangeTo(that: T): ClosedRange<T> = ComparableRange(this, that)\n\n\n/**\n * Represents a range of floating point numbers.\n * Extends [ClosedRange] interface providing custom operation [lessThanOrEquals] for comparing values of range domain type.\n *\n * This interface is implemented by floating point ranges returned by [Float.rangeTo] and [Double.rangeTo] operators to\n * achieve IEEE-754 comparison order instead of total order of floating point numbers.\n */\n@SinceKotlin(\"1.1\")\npublic interface ClosedFloatingPointRange<T : Comparable<T>> : ClosedRange<T> {\n    override fun contains(value: T): Boolean = lessThanOrEquals(start, value) && lessThanOrEquals(value, endInclusive)\n    override fun isEmpty(): Boolean = !lessThanOrEquals(start, endInclusive)\n\n    /**\n     * Compares two values of range domain type and returns true if first is less than or equal to second.\n     */\n    fun lessThanOrEquals(a: T, b: T): Boolean\n}\n\n\n/**\n * A closed range of values of type `Double`.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n */\nprivate class ClosedDoubleRange(\n    start: Double,\n    endInclusive: Double\n) : ClosedFloatingPointRange<Double> {\n    private val _start = start\n    private val _endInclusive = endInclusive\n    override val start: Double get() = _start\n    override val endInclusive: Double get() = _endInclusive\n\n    override fun lessThanOrEquals(a: Double, b: Double): Boolean = a <= b\n\n    override fun contains(value: Double): Boolean = value >= _start && value <= _endInclusive\n    override fun isEmpty(): Boolean = !(_start <= _endInclusive)\n\n    override fun equals(other: Any?): Boolean {\n        return other is ClosedDoubleRange && (isEmpty() && other.isEmpty() ||\n                _start == other._start && _endInclusive == other._endInclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * _start.hashCode() + _endInclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$_start..$_endInclusive\"\n}\n\n/**\n * Creates a range from this [Double] value to the specified [that] value.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n * @sample samples.ranges.Ranges.rangeFromDouble\n */\n@SinceKotlin(\"1.1\")\npublic operator fun Double.rangeTo(that: Double): ClosedFloatingPointRange<Double> = ClosedDoubleRange(this, that)\n\n\n/**\n * A closed range of values of type `Float`.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n */\nprivate class ClosedFloatRange(\n    start: Float,\n    endInclusive: Float\n) : ClosedFloatingPointRange<Float> {\n    private val _start = start\n    private val _endInclusive = endInclusive\n    override val start: Float get() = _start\n    override val endInclusive: Float get() = _endInclusive\n\n    override fun lessThanOrEquals(a: Float, b: Float): Boolean = a <= b\n\n    override fun contains(value: Float): Boolean = value >= _start && value <= _endInclusive\n    override fun isEmpty(): Boolean = !(_start <= _endInclusive)\n\n    override fun equals(other: Any?): Boolean {\n        return other is ClosedFloatRange && (isEmpty() && other.isEmpty() ||\n                _start == other._start && _endInclusive == other._endInclusive)\n    }\n\n    override fun hashCode(): Int {\n        return if (isEmpty()) -1 else 31 * _start.hashCode() + _endInclusive.hashCode()\n    }\n\n    override fun toString(): String = \"$_start..$_endInclusive\"\n}\n\n/**\n * Creates a range from this [Float] value to the specified [that] value.\n *\n * Numbers are compared with the ends of this range according to IEEE-754.\n * @sample samples.ranges.Ranges.rangeFromFloat\n */\n@SinceKotlin(\"1.1\")\npublic operator fun Float.rangeTo(that: Float): ClosedFloatingPointRange<Float> = ClosedFloatRange(this, that)\n\n\n/**\n * Returns `true` if this iterable range contains the specified [element].\n *\n * Always returns `false` if the [element] is `null`.\n */\n@SinceKotlin(\"1.3\")\n@kotlin.internal.InlineOnly\npublic inline operator fun <T, R> R.contains(element: T?): Boolean where T : Any, R : Iterable<T>, R : ClosedRange<T> =\n    element != null && contains(element)\n\n\ninternal fun checkStepIsPositive(isPositive: Boolean, step: Number) {\n    if (!isPositive) throw IllegalArgumentException(\"Step must be positive, was: $step.\")\n}\n","/*\n * Copyright 2010-2019 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n/**\n * An object to which char sequences and values can be appended.\n */\nexpect interface Appendable {\n    /**\n     * Appends the specified character [value] to this Appendable and returns this instance.\n     *\n     * @param value the character to append.\n     */\n    fun append(value: Char): Appendable\n\n    /**\n     * Appends the specified character sequence [value] to this Appendable and returns this instance.\n     *\n     * @param value the character sequence to append. If [value] is `null`, then the four characters `\"null\"` are appended to this Appendable.\n     */\n    fun append(value: CharSequence?): Appendable\n\n    /**\n     * Appends a subsequence of the specified character sequence [value] to this Appendable and returns this instance.\n     *\n     * @param value the character sequence from which a subsequence is appended. If [value] is `null`,\n     *  then characters are appended as if [value] contained the four characters `\"null\"`.\n     * @param startIndex the beginning (inclusive) of the subsequence to append.\n     * @param endIndex the end (exclusive) of the subsequence to append.\n     *\n     * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n     */\n    fun append(value: CharSequence?, startIndex: Int, endIndex: Int): Appendable\n}\n\n/**\n * Appends a subsequence of the specified character sequence [value] to this Appendable and returns this instance.\n *\n * @param value the character sequence from which a subsequence is appended.\n * @param startIndex the beginning (inclusive) of the subsequence to append.\n * @param endIndex the end (exclusive) of the subsequence to append.\n *\n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of the [value] character sequence indices or when `startIndex > endIndex`.\n */\n@SinceKotlin(\"1.4\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun <T : Appendable> T.appendRange(value: CharSequence, startIndex: Int, endIndex: Int): T {\n    @Suppress(\"UNCHECKED_CAST\")\n    return append(value, startIndex, endIndex) as T\n}\n\n/**\n * Appends all arguments to the given [Appendable].\n */\npublic fun <T : Appendable> T.append(vararg value: CharSequence?): T {\n    for (item in value)\n        append(item)\n    return this\n}\n\n/** Appends a line feed character (`\\n`) to this Appendable. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun Appendable.appendLine(): Appendable = append('\\n')\n\n/** Appends value to the given Appendable and a line feed character (`\\n`) after it. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun Appendable.appendLine(value: CharSequence?): Appendable = append(value).appendLine()\n\n/** Appends value to the given Appendable and a line feed character (`\\n`) after it. */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun Appendable.appendLine(value: Char): Appendable = append(value).appendLine()\n\n\ninternal fun <T> Appendable.appendElement(element: T, transform: ((T) -> CharSequence)?) {\n    when {\n        transform != null -> append(transform(element))\n        element is CharSequence? -> append(element)\n        element is Char -> append(element)\n        else -> append(element.toString())\n    }\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CharsKt\")\n\npackage kotlin.text\n\n/**\n * Returns the numeric value of the decimal digit that this Char represents.\n * Throws an exception if this Char is not a valid decimal digit.\n *\n * A Char is considered to represent a decimal digit if [isDigit] is true for the Char.\n * In this case, the Unicode decimal digit value of the character is returned.\n *\n * @sample samples.text.Chars.digitToInt\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Char.digitToInt(): Int {\n    return digitOf(this, 10).also {\n        if (it < 0) throw IllegalArgumentException(\"Char $this is not a decimal digit\")\n    }\n}\n\n/**\n * Returns the numeric value of the digit that this Char represents in the specified [radix].\n * Throws an exception if the [radix] is not in the range `2..36` or if this Char is not a valid digit in the specified [radix].\n *\n * A Char is considered to represent a digit in the specified [radix] if at least one of the following is true:\n *  - [isDigit] is `true` for the Char and the Unicode decimal digit value of the character is less than the specified [radix]. In this case the decimal digit value is returned.\n *  - The Char is one of the uppercase Latin letters 'A' through 'Z' and its [code] is less than `radix + 'A'.code - 10`. In this case, `this.code - 'A'.code + 10` is returned.\n *  - The Char is one of the lowercase Latin letters 'a' through 'z' and its [code] is less than `radix + 'a'.code - 10`. In this case, `this.code - 'a'.code + 10` is returned.\n *  - The Char is one of the fullwidth Latin capital letters '\\uFF21' through '\\uFF3A' and its [code] is less than `radix + 0xFF21 - 10`. In this case, `this.code - 0xFF21 + 10` is returned.\n *  - The Char is one of the fullwidth Latin small letters '\\uFF41' through '\\uFF5A' and its [code] is less than `radix + 0xFF41 - 10`. In this case, `this.code - 0xFF41 + 10` is returned.\n *\n * @sample samples.text.Chars.digitToInt\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Char.digitToInt(radix: Int): Int {\n    return digitToIntOrNull(radix) ?: throw IllegalArgumentException(\"Char $this is not a digit in the given radix=$radix\")\n}\n\n/**\n *\n * Returns the numeric value of the decimal digit that this Char represents, or `null` if this Char is not a valid decimal digit.\n *\n * A Char is considered to represent a decimal digit if [isDigit] is true for the Char.\n * In this case, the Unicode decimal digit value of the character is returned.\n *\n * @sample samples.text.Chars.digitToIntOrNull\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Char.digitToIntOrNull(): Int? {\n    return digitOf(this, 10).takeIf { it >= 0 }\n}\n\n/**\n * Returns the numeric value of the digit that this Char represents in the specified [radix], or `null` if this Char is not a valid digit in the specified [radix].\n * Throws an exception if the [radix] is not in the range `2..36`.\n *\n * A Char is considered to represent a digit in the specified [radix] if at least one of the following is true:\n *  - [isDigit] is `true` for the Char and the Unicode decimal digit value of the character is less than the specified [radix]. In this case the decimal digit value is returned.\n *  - The Char is one of the uppercase Latin letters 'A' through 'Z' and its [code] is less than `radix + 'A'.code - 10`. In this case, `this.code - 'A'.code + 10` is returned.\n *  - The Char is one of the lowercase Latin letters 'a' through 'z' and its [code] is less than `radix + 'a'.code - 10`. In this case, `this.code - 'a'.code + 10` is returned.\n *  - The Char is one of the fullwidth Latin capital letters '\\uFF21' through '\\uFF3A' and its [code] is less than `radix + 0xFF21 - 10`. In this case, `this.code - 0xFF21 + 10` is returned.\n *  - The Char is one of the fullwidth Latin small letters '\\uFF41' through '\\uFF5A' and its [code] is less than `radix + 0xFF41 - 10`. In this case, `this.code - 0xFF41 + 10` is returned.\n *\n * @sample samples.text.Chars.digitToIntOrNull\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Char.digitToIntOrNull(radix: Int): Int? {\n    checkRadix(radix)\n    return digitOf(this, radix).takeIf { it >= 0 }\n}\n\n/**\n * Returns the Char that represents this decimal digit.\n * Throws an exception if this value is not in the range `0..9`.\n *\n * If this value is in `0..9`, the decimal digit Char with code `'0'.code + this` is returned.\n *\n * @sample samples.text.Chars.digitToChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Int.digitToChar(): Char {\n    if (this in 0..9) {\n        return '0' + this\n    }\n    throw IllegalArgumentException(\"Int $this is not a decimal digit\")\n}\n\n/**\n * Returns the Char that represents this numeric digit value in the specified [radix].\n * Throws an exception if the [radix] is not in the range `2..36` or if this value is not in the range `0 until radix`.\n *\n * If this value is less than `10`, the decimal digit Char with code `'0'.code + this` is returned.\n * Otherwise, the uppercase Latin letter with code `'A'.code + this - 10` is returned.\n *\n * @sample samples.text.Chars.digitToChar\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun Int.digitToChar(radix: Int): Char {\n    if (radix !in 2..36) {\n        throw IllegalArgumentException(\"Invalid radix: $radix. Valid radix values are in range 2..36\")\n    }\n    if (this < 0 || this >= radix) {\n        throw IllegalArgumentException(\"Digit $this does not represent a valid digit in radix $radix\")\n    }\n    return if (this < 10) {\n        '0' + this\n    } else {\n        'A' + this - 10\n    }\n}\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n */\n@Deprecated(\"Use lowercaseChar() instead.\", ReplaceWith(\"lowercaseChar()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun Char.toLowerCase(): Char\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [lowercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun Char.lowercaseChar(): Char\n\n/**\n * Converts this character to lower case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\u0130'.lowercase()` returns `\"\\u0069\\u0307\"`,\n * where `'\\u0130'` is the LATIN CAPITAL LETTER I WITH DOT ABOVE character (``).\n * If this character has no lower case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.lowercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun Char.lowercase(): String\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n */\n@Deprecated(\"Use uppercaseChar() instead.\", ReplaceWith(\"uppercaseChar()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\npublic expect fun Char.toUpperCase(): Char\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [uppercase] function.\n * If this character has no mapping equivalent, the character itself is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun Char.uppercaseChar(): Char\n\n/**\n * Converts this character to upper case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\uFB00'.uppercase()` returns `\"\\u0046\\u0046\"`,\n * where `'\\uFB00'` is the LATIN SMALL LIGATURE FF character (``).\n * If this character has no upper case mapping, the result of `toString()` of this char is returned.\n *\n * @sample samples.text.Chars.uppercase\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalStdlibApi::class)\npublic expect fun Char.uppercase(): String\n\n/**\n * Converts this character to title case using Unicode mapping rules of the invariant locale.\n *\n * This function performs one-to-one character mapping.\n * To support one-to-many character mapping use the [titlecase] function.\n * If this character has no mapping equivalent, the result of calling [uppercaseChar] is returned.\n *\n * @sample samples.text.Chars.titlecase\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.titlecaseChar(): Char\n\n/**\n * Converts this character to title case using Unicode mapping rules of the invariant locale.\n *\n * This function supports one-to-many character mapping, thus the length of the returned string can be greater than one.\n * For example, `'\\uFB00'.titlecase()` returns `\"\\u0046\\u0066\"`,\n * where `'\\uFB00'` is the LATIN SMALL LIGATURE FF character (``).\n * If this character has no title case mapping, the result of [uppercase] is returned instead.\n *\n * @sample samples.text.Chars.titlecase\n */\n@SinceKotlin(\"1.5\")\npublic fun Char.titlecase(): String = titlecaseImpl()\n\n/**\n * Concatenates this Char and a String.\n *\n * @sample samples.text.Chars.plus\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun Char.plus(other: String): String = this.toString() + other\n\n/**\n * Returns `true` if this character is equal to the [other] character, optionally ignoring character case.\n *\n * Two characters are considered equal ignoring case if `Char.uppercaseChar().lowercaseChar()` on each character produces the same result.\n *\n * @param ignoreCase `true` to ignore character case when comparing characters. By default `false`.\n * @sample samples.text.Chars.equals\n */\npublic fun Char.equals(other: Char, ignoreCase: Boolean = false): Boolean {\n    if (this == other) return true\n    if (!ignoreCase) return false\n\n    val thisUpper = this.uppercaseChar()\n    val otherUpper = other.uppercaseChar()\n\n    return thisUpper == otherUpper || thisUpper.lowercaseChar() == otherUpper.lowercaseChar()\n}\n\n/**\n * Returns `true` if this character is a Unicode surrogate code unit.\n */\npublic fun Char.isSurrogate(): Boolean = this in Char.MIN_SURROGATE..Char.MAX_SURROGATE\n\n/**\n * Returns the Unicode general category of this character.\n */\n@SinceKotlin(\"1.5\")\npublic expect val Char.category: CharCategory\n\n/**\n * Returns `true` if this character (Unicode code point) is defined in Unicode.\n *\n * A character is considered to be defined in Unicode if its [category] is not [CharCategory.UNASSIGNED].\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isDefined(): Boolean\n\n/**\n * Returns `true` if this character is a letter.\n *\n * A character is considered to be a letter if its [category] is [CharCategory.UPPERCASE_LETTER],\n * [CharCategory.LOWERCASE_LETTER], [CharCategory.TITLECASE_LETTER], [CharCategory.MODIFIER_LETTER], or [CharCategory.OTHER_LETTER].\n *\n * @sample samples.text.Chars.isLetter\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isLetter(): Boolean\n\n/**\n * Returns `true` if this character is a letter or digit.\n *\n * @see isLetter\n * @see isDigit\n *\n * @sample samples.text.Chars.isLetterOrDigit\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isLetterOrDigit(): Boolean\n\n/**\n * Returns `true` if this character is a digit.\n *\n * A character is considered to be a digit if its [category] is [CharCategory.DECIMAL_DIGIT_NUMBER].\n *\n * @sample samples.text.Chars.isDigit\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isDigit(): Boolean\n\n/**\n * Returns `true` if this character is upper case.\n *\n * A character is considered to be an upper case character if its [category] is [CharCategory.UPPERCASE_LETTER],\n * or it has contributory property Other_Uppercase as defined by the Unicode Standard.\n *\n * @sample samples.text.Chars.isUpperCase\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isUpperCase(): Boolean\n\n/**\n * Returns `true` if this character is lower case.\n *\n * A character is considered to be a lower case character if its [category] is [CharCategory.LOWERCASE_LETTER],\n * or it has contributory property Other_Lowercase as defined by the Unicode Standard.\n *\n * @sample samples.text.Chars.isLowerCase\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isLowerCase(): Boolean\n\n/**\n * Returns `true` if this character is a title case letter.\n *\n * A character is considered to be a title case letter if its [category] is [CharCategory.TITLECASE_LETTER].\n *\n * @sample samples.text.Chars.isTitleCase\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isTitleCase(): Boolean\n\n/**\n * Returns `true` if this character is an ISO control character.\n *\n * A character is considered to be an ISO control character if its [category] is [CharCategory.CONTROL],\n * meaning the Char is in the range `'\\u0000'..'\\u001F'` or in the range `'\\u007F'..'\\u009F'`.\n *\n * @sample samples.text.Chars.isISOControl\n */\n@SinceKotlin(\"1.5\")\npublic expect fun Char.isISOControl(): Boolean\n\n/**\n * Determines whether a character is whitespace according to the Unicode standard.\n * Returns `true` if the character is whitespace.\n *\n * @sample samples.text.Chars.isWhitespace\n */\npublic expect fun Char.isWhitespace(): Boolean\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n/**\n * Trims leading whitespace characters followed by [marginPrefix] from every line of a source string and removes\n * the first and the last lines if they are blank (notice difference blank vs empty).\n *\n * Doesn't affect a line if it doesn't contain [marginPrefix] except the first and the last blank lines.\n *\n * Doesn't preserve the original line endings.\n *\n * @param marginPrefix non-blank string, which is used as a margin delimiter. Default is `|` (pipe character).\n *\n * @sample samples.text.Strings.trimMargin\n * @see trimIndent\n * @see kotlin.text.isWhitespace\n */\npublic fun String.trimMargin(marginPrefix: String = \"|\"): String =\n    replaceIndentByMargin(\"\", marginPrefix)\n\n/**\n * Detects indent by [marginPrefix] as it does [trimMargin] and replace it with [newIndent].\n *\n * @param marginPrefix non-blank string, which is used as a margin delimiter. Default is `|` (pipe character).\n */\npublic fun String.replaceIndentByMargin(newIndent: String = \"\", marginPrefix: String = \"|\"): String {\n    require(marginPrefix.isNotBlank()) { \"marginPrefix must be non-blank string.\" }\n    val lines = lines()\n\n    return lines.reindent(length + newIndent.length * lines.size, getIndentFunction(newIndent), { line ->\n        val firstNonWhitespaceIndex = line.indexOfFirst { !it.isWhitespace() }\n\n        when {\n            firstNonWhitespaceIndex == -1 -> null\n            line.startsWith(marginPrefix, firstNonWhitespaceIndex) -> line.substring(firstNonWhitespaceIndex + marginPrefix.length)\n            else -> null\n        }\n    })\n}\n\n/**\n * Detects a common minimal indent of all the input lines, removes it from every line and also removes the first and the last\n * lines if they are blank (notice difference blank vs empty).\n *\n * Note that blank lines do not affect the detected indent level.\n *\n * In case if there are non-blank lines with no leading whitespace characters (no indent at all) then the\n * common indent is 0, and therefore this function doesn't change the indentation.\n *\n * Doesn't preserve the original line endings.\n *\n * @sample samples.text.Strings.trimIndent\n * @see trimMargin\n * @see kotlin.text.isBlank\n */\npublic fun String.trimIndent(): String = replaceIndent(\"\")\n\n/**\n * Detects a common minimal indent like it does [trimIndent] and replaces it with the specified [newIndent].\n */\npublic fun String.replaceIndent(newIndent: String = \"\"): String {\n    val lines = lines()\n\n    val minCommonIndent = lines\n        .filter(String::isNotBlank)\n        .map(String::indentWidth)\n        .minOrNull() ?: 0\n\n    return lines.reindent(length + newIndent.length * lines.size, getIndentFunction(newIndent), { line -> line.drop(minCommonIndent) })\n}\n\n/**\n * Prepends [indent] to every line of the original string.\n *\n * Doesn't preserve the original line endings.\n */\npublic fun String.prependIndent(indent: String = \"    \"): String =\n    lineSequence()\n        .map {\n            when {\n                it.isBlank() -> {\n                    when {\n                        it.length < indent.length -> indent\n                        else -> it\n                    }\n                }\n                else -> indent + it\n            }\n        }\n        .joinToString(\"\\n\")\n\nprivate fun String.indentWidth(): Int = indexOfFirst { !it.isWhitespace() }.let { if (it == -1) length else it }\n\nprivate fun getIndentFunction(indent: String) = when {\n    indent.isEmpty() -> { line: String -> line }\n    else -> { line: String -> indent + line }\n}\n\nprivate inline fun List<String>.reindent(\n    resultSizeEstimate: Int,\n    indentAddFunction: (String) -> String,\n    indentCutFunction: (String) -> String?\n): String {\n    val lastIndex = lastIndex\n    return mapIndexedNotNull { index, value ->\n        if ((index == 0 || index == lastIndex) && value.isBlank())\n            null\n        else\n            indentCutFunction(value)?.let(indentAddFunction) ?: value\n    }\n        .joinTo(StringBuilder(resultSizeEstimate), \"\\n\")\n        .toString()\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.text\n\n/**\n * Represents a collection of captured groups in a single match of a regular expression.\n *\n * This collection has size of `groupCount + 1` where `groupCount` is the count of groups in the regular expression.\n * Groups are indexed from 1 to `groupCount` and group with the index 0 corresponds to the entire match.\n *\n * An element of the collection at the particular index can be `null`,\n * if the corresponding group in the regular expression is optional and\n * there was no match captured by that group.\n */\npublic interface MatchGroupCollection : Collection<MatchGroup?> {\n\n    /** Returns a group with the specified [index].\n     *\n     * @return An instance of [MatchGroup] if the group with the specified [index] was matched or `null` otherwise.\n     *\n     * Groups are indexed from 1 to the count of groups in the regular expression. A group with the index 0\n     * corresponds to the entire match.\n     */\n    public operator fun get(index: Int): MatchGroup?\n}\n\n/**\n * Extends [MatchGroupCollection] by introducing a way to get matched groups by name, when regex supports it.\n */\n@SinceKotlin(\"1.1\")\npublic interface MatchNamedGroupCollection : MatchGroupCollection {\n    /**\n     * Returns a named group with the specified [name].\n     * @return An instance of [MatchGroup] if the group with the specified [name] was matched or `null` otherwise.\n     * @throws IllegalArgumentException if there is no group with the specified [name] defined in the regex pattern.\n     * @throws UnsupportedOperationException if getting named groups isn't supported on the current platform.\n     */\n    public operator fun get(name: String): MatchGroup?\n}\n\n/**\n * Represents the results from a single regular expression match.\n */\npublic interface MatchResult {\n    /** The range of indices in the original string where match was captured. */\n    public val range: IntRange\n    /** The substring from the input string captured by this match. */\n    public val value: String\n    /**\n     * A collection of groups matched by the regular expression.\n     *\n     * This collection has size of `groupCount + 1` where `groupCount` is the count of groups in the regular expression.\n     * Groups are indexed from 1 to `groupCount` and group with the index 0 corresponds to the entire match.\n     */\n    public val groups: MatchGroupCollection\n    /**\n     * A list of matched indexed group values.\n     *\n     * This list has size of `groupCount + 1` where `groupCount` is the count of groups in the regular expression.\n     * Groups are indexed from 1 to `groupCount` and group with the index 0 corresponds to the entire match.\n     *\n     * If the group in the regular expression is optional and there were no match captured by that group,\n     * corresponding item in [groupValues] is an empty string.\n     *\n     * @sample samples.text.Regexps.matchDestructuringToGroupValues\n     */\n    public val groupValues: List<String>\n\n    /**\n     * An instance of [MatchResult.Destructured] wrapper providing components for destructuring assignment of group values.\n     *\n     * component1 corresponds to the value of the first group, component2  of the second, and so on.\n     *\n     * @sample samples.text.Regexps.matchDestructuringToGroupValues\n     */\n    public val destructured: Destructured get() = Destructured(this)\n\n    /** Returns a new [MatchResult] with the results for the next match, starting at the position\n     *  at which the last match ended (at the character after the last matched character).\n     */\n    public fun next(): MatchResult?\n\n    /**\n     * Provides components for destructuring assignment of group values.\n     *\n     * [component1] corresponds to the value of the first group, [component2]  of the second, and so on.\n     *\n     * If the group in the regular expression is optional and there were no match captured by that group,\n     * corresponding component value is an empty string.\n     *\n     * @sample samples.text.Regexps.matchDestructuringToGroupValues\n     */\n    public class Destructured internal constructor(public val match: MatchResult) {\n        @kotlin.internal.InlineOnly\n        public operator inline fun component1():  String = match.groupValues[1]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component2():  String = match.groupValues[2]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component3():  String = match.groupValues[3]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component4():  String = match.groupValues[4]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component5():  String = match.groupValues[5]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component6():  String = match.groupValues[6]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component7():  String = match.groupValues[7]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component8():  String = match.groupValues[8]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component9():  String = match.groupValues[9]\n        @kotlin.internal.InlineOnly\n        public operator inline fun component10(): String = match.groupValues[10]\n\n        /**\n         *  Returns destructured group values as a list of strings.\n         *  First value in the returned list corresponds to the value of the first group, and so on.\n         *\n         * @sample samples.text.Regexps.matchDestructuringToGroupValues\n         */\n        public fun toList(): List<String> = match.groupValues.subList(1, match.groupValues.size)\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"LazyKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin\n\nimport kotlin.reflect.KProperty\n\n/**\n * Represents a value with lazy initialization.\n *\n * To create an instance of [Lazy] use the [lazy] function.\n */\npublic interface Lazy<out T> {\n    /**\n     * Gets the lazily initialized value of the current Lazy instance.\n     * Once the value was initialized it must not change during the rest of lifetime of this Lazy instance.\n     */\n    public val value: T\n\n    /**\n     * Returns `true` if a value for this Lazy instance has been already initialized, and `false` otherwise.\n     * Once this function has returned `true` it stays `true` for the rest of lifetime of this Lazy instance.\n     */\n    public fun isInitialized(): Boolean\n}\n\n/**\n * Creates a new instance of the [Lazy] that is already initialized with the specified [value].\n */\npublic fun <T> lazyOf(value: T): Lazy<T> = InitializedLazyImpl(value)\n\n/**\n * An extension to delegate a read-only property of type [T] to an instance of [Lazy].\n *\n * This extension allows to use instances of Lazy for property delegation:\n * `val property: String by lazy { initializer }`\n */\n@kotlin.internal.InlineOnly\npublic inline operator fun <T> Lazy<T>.getValue(thisRef: Any?, property: KProperty<*>): T = value\n\n/**\n * Specifies how a [Lazy] instance synchronizes initialization among multiple threads.\n */\npublic enum class LazyThreadSafetyMode {\n\n    /**\n     * Locks are used to ensure that only a single thread can initialize the [Lazy] instance.\n     */\n    SYNCHRONIZED,\n\n    /**\n     * Initializer function can be called several times on concurrent access to uninitialized [Lazy] instance value,\n     * but only the first returned value will be used as the value of [Lazy] instance.\n     */\n    PUBLICATION,\n\n    /**\n     * No locks are used to synchronize an access to the [Lazy] instance value; if the instance is accessed from multiple threads, its behavior is undefined.\n     *\n     * This mode should not be used unless the [Lazy] instance is guaranteed never to be initialized from more than one thread.\n     */\n    NONE,\n}\n\n\ninternal object UNINITIALIZED_VALUE\n\n// internal to be called from lazy in JS\ninternal class UnsafeLazyImpl<out T>(initializer: () -> T) : Lazy<T>, Serializable {\n    private var initializer: (() -> T)? = initializer\n    private var _value: Any? = UNINITIALIZED_VALUE\n\n    override val value: T\n        get() {\n            if (_value === UNINITIALIZED_VALUE) {\n                _value = initializer!!()\n                initializer = null\n            }\n            @Suppress(\"UNCHECKED_CAST\")\n            return _value as T\n        }\n\n    override fun isInitialized(): Boolean = _value !== UNINITIALIZED_VALUE\n\n    override fun toString(): String = if (isInitialized()) value.toString() else \"Lazy value not initialized yet.\"\n\n    private fun writeReplace(): Any = InitializedLazyImpl(value)\n}\n\ninternal class InitializedLazyImpl<out T>(override val value: T) : Lazy<T>, Serializable {\n\n    override fun isInitialized(): Boolean = true\n\n    override fun toString(): String = value.toString()\n\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmName(\"TuplesKt\")\n\npackage kotlin\n\n\n/**\n * Represents a generic pair of two values.\n *\n * There is no meaning attached to values in this class, it can be used for any purpose.\n * Pair exhibits value semantics, i.e. two pairs are equal if both components are equal.\n *\n * An example of decomposing it into values:\n * @sample samples.misc.Tuples.pairDestructuring\n *\n * @param A type of the first value.\n * @param B type of the second value.\n * @property first First value.\n * @property second Second value.\n * @constructor Creates a new instance of Pair.\n */\npublic data class Pair<out A, out B>(\n    public val first: A,\n    public val second: B\n) : Serializable {\n\n    /**\n     * Returns string representation of the [Pair] including its [first] and [second] values.\n     */\n    public override fun toString(): String = \"($first, $second)\"\n}\n\n/**\n * Creates a tuple of type [Pair] from this and [that].\n *\n * This can be useful for creating [Map] literals with less noise, for example:\n * @sample samples.collections.Maps.Instantiation.mapFromPairs\n */\npublic infix fun <A, B> A.to(that: B): Pair<A, B> = Pair(this, that)\n\n/**\n * Converts this pair into a list.\n * @sample samples.misc.Tuples.pairToList\n */\npublic fun <T> Pair<T, T>.toList(): List<T> = listOf(first, second)\n\n/**\n * Represents a triad of values\n *\n * There is no meaning attached to values in this class, it can be used for any purpose.\n * Triple exhibits value semantics, i.e. two triples are equal if all three components are equal.\n * An example of decomposing it into values:\n * @sample samples.misc.Tuples.tripleDestructuring\n *\n * @param A type of the first value.\n * @param B type of the second value.\n * @param C type of the third value.\n * @property first First value.\n * @property second Second value.\n * @property third Third value.\n */\npublic data class Triple<out A, out B, out C>(\n    public val first: A,\n    public val second: B,\n    public val third: C\n) : Serializable {\n\n    /**\n     * Returns string representation of the [Triple] including its [first], [second] and [third] values.\n     */\n    public override fun toString(): String = \"($first, $second, $third)\"\n}\n\n/**\n * Converts this triple into a list.\n * @sample samples.misc.Tuples.tripleToList\n */\npublic fun <T> Triple<T, T, T>.toList(): List<T> = listOf(first, second, third)\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin\n\nimport kotlin.experimental.*\nimport kotlin.jvm.*\n\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@JvmInline\npublic value class ULong @PublishedApi internal constructor(@PublishedApi internal val data: Long) : Comparable<ULong> {\n\n    companion object {\n        /**\n         * A constant holding the minimum value an instance of ULong can have.\n         */\n        public const val MIN_VALUE: ULong = ULong(0)\n\n        /**\n         * A constant holding the maximum value an instance of ULong can have.\n         */\n        public const val MAX_VALUE: ULong = ULong(-1)\n\n        /**\n         * The number of bytes used to represent an instance of ULong in a binary form.\n         */\n        public const val SIZE_BYTES: Int = 8\n\n        /**\n         * The number of bits used to represent an instance of ULong in a binary form.\n         */\n        public const val SIZE_BITS: Int = 64\n    }\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UByte): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UShort): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun compareTo(other: UInt): Int = this.compareTo(other.toULong())\n\n    /**\n     * Compares this value with the specified value for order.\n     * Returns zero if this value is equal to the specified other value, a negative number if it's less than other,\n     * or a positive number if it's greater than other.\n     */\n    @kotlin.internal.InlineOnly\n    @Suppress(\"OVERRIDE_BY_INLINE\")\n    public override inline operator fun compareTo(other: ULong): Int = ulongCompare(this.data, other.data)\n\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UByte): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UShort): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: UInt): ULong = this.plus(other.toULong())\n    /** Adds the other value to this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun plus(other: ULong): ULong = ULong(this.data.plus(other.data))\n\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UByte): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UShort): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: UInt): ULong = this.minus(other.toULong())\n    /** Subtracts the other value from this value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun minus(other: ULong): ULong = ULong(this.data.minus(other.data))\n\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UByte): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UShort): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: UInt): ULong = this.times(other.toULong())\n    /** Multiplies this value by the other value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun times(other: ULong): ULong = ULong(this.data.times(other.data))\n\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UByte): ULong = this.div(other.toULong())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UShort): ULong = this.div(other.toULong())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: UInt): ULong = this.div(other.toULong())\n    /** Divides this value by the other value, truncating the result to an integer that is closer to zero. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun div(other: ULong): ULong = ulongDivide(this, other)\n\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UByte): ULong = this.rem(other.toULong())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UShort): ULong = this.rem(other.toULong())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: UInt): ULong = this.rem(other.toULong())\n    /**\n     * Calculates the remainder of truncating division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rem(other: ULong): ULong = ulongRemainder(this, other)\n\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UByte): ULong = this.floorDiv(other.toULong())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UShort): ULong = this.floorDiv(other.toULong())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: UInt): ULong = this.floorDiv(other.toULong())\n    /**\n     * Divides this value by the other value, flooring the result to an integer that is closer to negative infinity.\n     * \n     * For unsigned types, the results of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun floorDiv(other: ULong): ULong = div(other)\n\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UByte): UByte = this.mod(other.toULong()).toUByte()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UShort): UShort = this.mod(other.toULong()).toUShort()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: UInt): UInt = this.mod(other.toULong()).toUInt()\n    /**\n     * Calculates the remainder of flooring division of this value by the other value.\n     * \n     * The result is always less than the divisor.\n     * \n     * For unsigned types, the remainders of flooring division and truncating division are the same.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun mod(other: ULong): ULong = rem(other)\n\n    /**\n     * Returns this value incremented by one.\n     *\n     * @sample samples.misc.Builtins.inc\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun inc(): ULong = ULong(data.inc())\n\n    /**\n     * Returns this value decremented by one.\n     *\n     * @sample samples.misc.Builtins.dec\n     */\n    @kotlin.internal.InlineOnly\n    public inline operator fun dec(): ULong = ULong(data.dec())\n\n    /** Creates a range from this value to the specified [other] value. */\n    @kotlin.internal.InlineOnly\n    public inline operator fun rangeTo(other: ULong): ULongRange = ULongRange(this, other)\n\n    /**\n     * Shifts this value left by the [bitCount] number of bits.\n     *\n     * Note that only the six lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..63`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shl(bitCount: Int): ULong = ULong(data shl bitCount)\n\n    /**\n     * Shifts this value right by the [bitCount] number of bits, filling the leftmost bits with zeros.\n     *\n     * Note that only the six lowest-order bits of the [bitCount] are used as the shift distance.\n     * The shift distance actually used is therefore always in the range `0..63`.\n     */\n    @kotlin.internal.InlineOnly\n    public inline infix fun shr(bitCount: Int): ULong = ULong(data ushr bitCount)\n\n    /** Performs a bitwise AND operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun and(other: ULong): ULong = ULong(this.data and other.data)\n    /** Performs a bitwise OR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun or(other: ULong): ULong = ULong(this.data or other.data)\n    /** Performs a bitwise XOR operation between the two values. */\n    @kotlin.internal.InlineOnly\n    public inline infix fun xor(other: ULong): ULong = ULong(this.data xor other.data)\n    /** Inverts the bits in this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun inv(): ULong = ULong(data.inv())\n\n    /**\n     * Converts this [ULong] value to [Byte].\n     *\n     * If this value is less than or equals to [Byte.MAX_VALUE], the resulting `Byte` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Byte` value is represented by the least significant 8 bits of this `ULong` value.\n     * Note that the resulting `Byte` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toByte(): Byte = data.toByte()\n    /**\n     * Converts this [ULong] value to [Short].\n     *\n     * If this value is less than or equals to [Short.MAX_VALUE], the resulting `Short` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Short` value is represented by the least significant 16 bits of this `ULong` value.\n     * Note that the resulting `Short` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toShort(): Short = data.toShort()\n    /**\n     * Converts this [ULong] value to [Int].\n     *\n     * If this value is less than or equals to [Int.MAX_VALUE], the resulting `Int` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `Int` value is represented by the least significant 32 bits of this `ULong` value.\n     * Note that the resulting `Int` value may be negative.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toInt(): Int = data.toInt()\n    /**\n     * Converts this [ULong] value to [Long].\n     *\n     * If this value is less than or equals to [Long.MAX_VALUE], the resulting `Long` value represents\n     * the same numerical value as this `ULong`. Otherwise the result is negative.\n     *\n     * The resulting `Long` value has the same binary representation as this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toLong(): Long = data\n\n    /**\n     * Converts this [ULong] value to [UByte].\n     *\n     * If this value is less than or equals to [UByte.MAX_VALUE], the resulting `UByte` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UByte` value is represented by the least significant 8 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUByte(): UByte = data.toUByte()\n    /**\n     * Converts this [ULong] value to [UShort].\n     *\n     * If this value is less than or equals to [UShort.MAX_VALUE], the resulting `UShort` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UShort` value is represented by the least significant 16 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUShort(): UShort = data.toUShort()\n    /**\n     * Converts this [ULong] value to [UInt].\n     *\n     * If this value is less than or equals to [UInt.MAX_VALUE], the resulting `UInt` value represents\n     * the same numerical value as this `ULong`.\n     *\n     * The resulting `UInt` value is represented by the least significant 32 bits of this `ULong` value.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toUInt(): UInt = data.toUInt()\n    /** Returns this value. */\n    @kotlin.internal.InlineOnly\n    public inline fun toULong(): ULong = this\n\n    /**\n     * Converts this [ULong] value to [Float].\n     *\n     * The resulting value is the closest `Float` to this `ULong` value.\n     * In case when this `ULong` value is exactly between two `Float`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toFloat(): Float = this.toDouble().toFloat()\n    /**\n     * Converts this [ULong] value to [Double].\n     *\n     * The resulting value is the closest `Double` to this `ULong` value.\n     * In case when this `ULong` value is exactly between two `Double`s,\n     * the one with zero at least significant bit of mantissa is selected.\n     */\n    @kotlin.internal.InlineOnly\n    public inline fun toDouble(): Double = ulongToDouble(data)\n\n    public override fun toString(): String = ulongToString(data)\n\n}\n\n/**\n * Converts this [Byte] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Byte`.\n *\n * The least significant 8 bits of the resulting `ULong` value are the same as the bits of this `Byte` value,\n * whereas the most significant 56 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Byte.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Short] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Short`.\n *\n * The least significant 16 bits of the resulting `ULong` value are the same as the bits of this `Short` value,\n * whereas the most significant 48 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Short.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Int] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Int`.\n *\n * The least significant 32 bits of the resulting `ULong` value are the same as the bits of this `Int` value,\n * whereas the most significant 32 bits are filled with the sign bit of this value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Int.toULong(): ULong = ULong(this.toLong())\n/**\n * Converts this [Long] value to [ULong].\n *\n * If this value is positive, the resulting `ULong` value represents the same numerical value as this `Long`.\n *\n * The resulting `ULong` value has the same binary representation as this `Long` value.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Long.toULong(): ULong = ULong(this)\n\n/**\n * Converts this [Float] value to [ULong].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Float` value is negative or `NaN`, [ULong.MAX_VALUE] if it's bigger than `ULong.MAX_VALUE`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Float.toULong(): ULong = doubleToULong(this.toDouble())\n/**\n * Converts this [Double] value to [ULong].\n *\n * The fractional part, if any, is rounded down towards zero.\n * Returns zero if this `Double` value is negative or `NaN`, [ULong.MAX_VALUE] if it's bigger than `ULong.MAX_VALUE`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun Double.toULong(): ULong = doubleToULong(this)\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.experimental\n\n/** Performs a bitwise AND operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Byte.and(other: Byte): Byte = (this.toInt() and other.toInt()).toByte()\n\n/** Performs a bitwise OR operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Byte.or(other: Byte): Byte = (this.toInt() or other.toInt()).toByte()\n\n/** Performs a bitwise XOR operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Byte.xor(other: Byte): Byte = (this.toInt() xor other.toInt()).toByte()\n\n/** Inverts the bits in this value. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun Byte.inv(): Byte = (this.toInt().inv()).toByte()\n\n\n/** Performs a bitwise AND operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Short.and(other: Short): Short = (this.toInt() and other.toInt()).toShort()\n\n/** Performs a bitwise OR operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Short.or(other: Short): Short = (this.toInt() or other.toInt()).toShort()\n\n/** Performs a bitwise XOR operation between the two values. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline infix fun Short.xor(other: Short): Short = (this.toInt() xor other.toInt()).toShort()\n\n/** Inverts the bits in this value. */\n@SinceKotlin(\"1.1\")\n@kotlin.internal.InlineOnly\npublic inline fun Short.inv(): Short = (this.toInt().inv()).toShort()\n\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\n\n\nimport kotlin.internal.*\n\n/**\n * A range of values of type `UInt`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic class UIntRange(start: UInt, endInclusive: UInt) : UIntProgression(start, endInclusive, 1), ClosedRange<UInt> {\n    override val start: UInt get() = first\n    override val endInclusive: UInt get() = last\n\n    override fun contains(value: UInt): Boolean = first <= value && value <= last\n\n    /** \n     * Checks if the range is empty.\n     \n     * The range is empty if its start value is greater than the end value.\n     */\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is UIntRange && (isEmpty() && other.isEmpty() ||\n                first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * first.toInt() + last.toInt())\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type UInt. */\n        public val EMPTY: UIntRange = UIntRange(UInt.MAX_VALUE, UInt.MIN_VALUE)\n    }\n}\n\n/**\n * A progression of values of type `UInt`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic open class UIntProgression\ninternal constructor(\n    start: UInt,\n    endInclusive: UInt,\n    step: Int\n) : Iterable<UInt> {\n    init {\n        if (step == 0.toInt()) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Int.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Int.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: UInt = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: UInt = getProgressionLastElement(start, endInclusive, step)\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Int = step\n\n    final override fun iterator(): Iterator<UInt> = UIntProgressionIterator(first, last, step)\n\n    /** \n     * Checks if the progression is empty.\n     \n     * Progression with a positive step is empty if its first element is greater than the last element.\n     * Progression with a negative step is empty if its first element is less than the last element.\n     */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is UIntProgression && (isEmpty() && other.isEmpty() ||\n                first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * first.toInt() + last.toInt()) + step.toInt())\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates UIntProgression within the specified bounds of a closed range.\n\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Int.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: UInt, rangeEnd: UInt, step: Int): UIntProgression = UIntProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n\n/**\n * An iterator over a progression of values of type `UInt`.\n * @property step the number by which the value is incremented on each step.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"DEPRECATION_ERROR\")\nprivate class UIntProgressionIterator(first: UInt, last: UInt, step: Int) : UIntIterator() {\n    private val finalElement = last\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private val step = step.toUInt() // use 2-complement math for negative steps\n    private var next = if (hasNext) first else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextUInt(): UInt {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        } else {\n            next += step\n        }\n        return value\n    }\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.collections\n\n/** An iterator over a sequence of values of type `UByte`. */\n@Deprecated(\"This class is not going to be stabilized and is to be removed soon.\", level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\npublic abstract class UByteIterator : Iterator<UByte> {\n    final override fun next() = nextUByte()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextUByte(): UByte\n}\n\n/** An iterator over a sequence of values of type `UShort`. */\n@Deprecated(\"This class is not going to be stabilized and is to be removed soon.\", level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\npublic abstract class UShortIterator : Iterator<UShort> {\n    final override fun next() = nextUShort()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextUShort(): UShort\n}\n\n/** An iterator over a sequence of values of type `UInt`. */\n@Deprecated(\"This class is not going to be stabilized and is to be removed soon.\", level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\npublic abstract class UIntIterator : Iterator<UInt> {\n    final override fun next() = nextUInt()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextUInt(): UInt\n}\n\n/** An iterator over a sequence of values of type `ULong`. */\n@Deprecated(\"This class is not going to be stabilized and is to be removed soon.\", level = DeprecationLevel.ERROR)\n@SinceKotlin(\"1.3\")\npublic abstract class ULongIterator : Iterator<ULong> {\n    final override fun next() = nextULong()\n\n    /** Returns the next value in the sequence without boxing. */\n    public abstract fun nextULong(): ULong\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// Auto-generated file. DO NOT EDIT!\n\npackage kotlin.ranges\n\n\n\nimport kotlin.internal.*\n\n/**\n * A range of values of type `ULong`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic class ULongRange(start: ULong, endInclusive: ULong) : ULongProgression(start, endInclusive, 1), ClosedRange<ULong> {\n    override val start: ULong get() = first\n    override val endInclusive: ULong get() = last\n\n    override fun contains(value: ULong): Boolean = first <= value && value <= last\n\n    /** \n     * Checks if the range is empty.\n     \n     * The range is empty if its start value is greater than the end value.\n     */\n    override fun isEmpty(): Boolean = first > last\n\n    override fun equals(other: Any?): Boolean =\n        other is ULongRange && (isEmpty() && other.isEmpty() ||\n                first == other.first && last == other.last)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (first xor (first shr 32)).toInt() + (last xor (last shr 32)).toInt())\n\n    override fun toString(): String = \"$first..$last\"\n\n    companion object {\n        /** An empty range of values of type ULong. */\n        public val EMPTY: ULongRange = ULongRange(ULong.MAX_VALUE, ULong.MIN_VALUE)\n    }\n}\n\n/**\n * A progression of values of type `ULong`.\n */\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic open class ULongProgression\ninternal constructor(\n    start: ULong,\n    endInclusive: ULong,\n    step: Long\n) : Iterable<ULong> {\n    init {\n        if (step == 0.toLong()) throw kotlin.IllegalArgumentException(\"Step must be non-zero.\")\n        if (step == Long.MIN_VALUE) throw kotlin.IllegalArgumentException(\"Step must be greater than Long.MIN_VALUE to avoid overflow on negation.\")\n    }\n\n    /**\n     * The first element in the progression.\n     */\n    public val first: ULong = start\n\n    /**\n     * The last element in the progression.\n     */\n    public val last: ULong = getProgressionLastElement(start, endInclusive, step)\n\n    /**\n     * The step of the progression.\n     */\n    public val step: Long = step\n\n    final override fun iterator(): Iterator<ULong> = ULongProgressionIterator(first, last, step)\n\n    /** \n     * Checks if the progression is empty.\n     \n     * Progression with a positive step is empty if its first element is greater than the last element.\n     * Progression with a negative step is empty if its first element is less than the last element.\n     */\n    public open fun isEmpty(): Boolean = if (step > 0) first > last else first < last\n\n    override fun equals(other: Any?): Boolean =\n        other is ULongProgression && (isEmpty() && other.isEmpty() ||\n                first == other.first && last == other.last && step == other.step)\n\n    override fun hashCode(): Int =\n        if (isEmpty()) -1 else (31 * (31 * (first xor (first shr 32)).toInt() + (last xor (last shr 32)).toInt()) + (step xor (step ushr 32)).toInt())\n\n    override fun toString(): String = if (step > 0) \"$first..$last step $step\" else \"$first downTo $last step ${-step}\"\n\n    companion object {\n        /**\n         * Creates ULongProgression within the specified bounds of a closed range.\n\n         * The progression starts with the [rangeStart] value and goes toward the [rangeEnd] value not excluding it, with the specified [step].\n         * In order to go backwards the [step] must be negative.\n         *\n         * [step] must be greater than `Long.MIN_VALUE` and not equal to zero.\n         */\n        public fun fromClosedRange(rangeStart: ULong, rangeEnd: ULong, step: Long): ULongProgression = ULongProgression(rangeStart, rangeEnd, step)\n    }\n}\n\n\n/**\n * An iterator over a progression of values of type `ULong`.\n * @property step the number by which the value is incremented on each step.\n */\n@SinceKotlin(\"1.3\")\n@Suppress(\"DEPRECATION_ERROR\")\nprivate class ULongProgressionIterator(first: ULong, last: ULong, step: Long) : ULongIterator() {\n    private val finalElement = last\n    private var hasNext: Boolean = if (step > 0) first <= last else first >= last\n    private val step = step.toULong() // use 2-complement math for negative steps\n    private var next = if (hasNext) first else finalElement\n\n    override fun hasNext(): Boolean = hasNext\n\n    override fun nextULong(): ULong {\n        val value = next\n        if (value == finalElement) {\n            if (!hasNext) throw kotlin.NoSuchElementException()\n            hasNext = false\n        } else {\n            next += step\n        }\n        return value\n    }\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.internal\n\n// (a - b) mod c\nprivate fun differenceModulo(a: UInt, b: UInt, c: UInt): UInt {\n    val ac = a % c\n    val bc = b % c\n    return if (ac >= bc) ac - bc else ac - bc + c\n}\n\nprivate fun differenceModulo(a: ULong, b: ULong, c: ULong): ULong {\n    val ac = a % c\n    val bc = b % c\n    return if (ac >= bc) ac - bc else ac - bc + c\n}\n\n/**\n * Calculates the final element of a bounded arithmetic progression, i.e. the last element of the progression which is in the range\n * from [start] to [end] in case of a positive [step], or from [end] to [start] in case of a negative\n * [step].\n *\n * No validation on passed parameters is performed. The given parameters should satisfy the condition:\n *\n * - either `step > 0` and `start <= end`,\n * - or `step < 0` and `start >= end`.\n *\n * @param start first element of the progression\n * @param end ending bound for the progression\n * @param step increment, or difference of successive elements in the progression\n * @return the final element of the progression\n * @suppress\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun getProgressionLastElement(start: UInt, end: UInt, step: Int): UInt = when {\n    step > 0 -> if (start >= end) end else end - differenceModulo(end, start, step.toUInt())\n    step < 0 -> if (start <= end) end else end + differenceModulo(start, end, (-step).toUInt())\n    else -> throw kotlin.IllegalArgumentException(\"Step is zero.\")\n}\n\n/**\n * Calculates the final element of a bounded arithmetic progression, i.e. the last element of the progression which is in the range\n * from [start] to [end] in case of a positive [step], or from [end] to [start] in case of a negative\n * [step].\n *\n * No validation on passed parameters is performed. The given parameters should satisfy the condition:\n *\n * - either `step > 0` and `start <= end`,\n * - or `step < 0` and `start >= end`.\n *\n * @param start first element of the progression\n * @param end ending bound for the progression\n * @param step increment, or difference of successive elements in the progression\n * @return the final element of the progression\n * @suppress\n */\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal fun getProgressionLastElement(start: ULong, end: ULong, step: Long): ULong = when {\n    step > 0 -> if (start >= end) end else end - differenceModulo(end, start, step.toULong())\n    step < 0 -> if (start <= end) end else end + differenceModulo(start, end, (-step).toULong())\n    else -> throw kotlin.IllegalArgumentException(\"Step is zero.\")\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"MapsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to entries of this map in iteration order,\n * or throws [NoSuchElementException] if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Any> Map<out K, V>.firstNotNullOf(transform: (Map.Entry<K, V>) -> R?): R {\n    return firstNotNullOfOrNull(transform) ?: throw NoSuchElementException(\"No element of the map was transformed to a non-null value.\")\n}\n\n/**\n * Returns the first non-null value produced by [transform] function being applied to entries of this map in iteration order,\n * or `null` if no non-null value was produced.\n * \n * @sample samples.collections.Collections.Transformations.firstNotNullOf\n */\n@SinceKotlin(\"1.5\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Any> Map<out K, V>.firstNotNullOfOrNull(transform: (Map.Entry<K, V>) -> R?): R? {\n    for (element in this) {\n        val result = transform(element)\n        if (result != null) {\n            return result\n        }\n    }\n    return null\n}\n\n/**\n * Returns a [List] containing all key-value pairs.\n */\npublic fun <K, V> Map<out K, V>.toList(): List<Pair<K, V>> {\n    if (size == 0)\n        return emptyList()\n    val iterator = entries.iterator()\n    if (!iterator.hasNext())\n        return emptyList()\n    val first = iterator.next()\n    if (!iterator.hasNext())\n        return listOf(first.toPair())\n    val result = ArrayList<Pair<K, V>>(size)\n    result.add(first.toPair())\n    do {\n        result.add(iterator.next().toPair())\n    } while (iterator.hasNext())\n    return result\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each entry of original map.\n * \n * @sample samples.collections.Maps.Transformations.flatMap\n */\npublic inline fun <K, V, R> Map<out K, V>.flatMap(transform: (Map.Entry<K, V>) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each entry of original map.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequence\")\npublic inline fun <K, V, R> Map<out K, V>.flatMap(transform: (Map.Entry<K, V>) -> Sequence<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each entry of original map, to the given [destination].\n */\npublic inline fun <K, V, R, C : MutableCollection<in R>> Map<out K, V>.flatMapTo(destination: C, transform: (Map.Entry<K, V>) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each entry of original map, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.jvm.JvmName(\"flatMapSequenceTo\")\npublic inline fun <K, V, R, C : MutableCollection<in R>> Map<out K, V>.flatMapTo(destination: C, transform: (Map.Entry<K, V>) -> Sequence<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each entry in the original map.\n * \n * @sample samples.collections.Maps.Transformations.mapToList\n */\npublic inline fun <K, V, R> Map<out K, V>.map(transform: (Map.Entry<K, V>) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing only the non-null results of applying the given [transform] function\n * to each entry in the original map.\n * \n * @sample samples.collections.Maps.Transformations.mapNotNull\n */\npublic inline fun <K, V, R : Any> Map<out K, V>.mapNotNull(transform: (Map.Entry<K, V>) -> R?): List<R> {\n    return mapNotNullTo(ArrayList<R>(), transform)\n}\n\n/**\n * Applies the given [transform] function to each entry in the original map\n * and appends only the non-null results to the given [destination].\n */\npublic inline fun <K, V, R : Any, C : MutableCollection<in R>> Map<out K, V>.mapNotNullTo(destination: C, transform: (Map.Entry<K, V>) -> R?): C {\n    forEach { element -> transform(element)?.let { destination.add(it) } }\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each entry of the original map\n * and appends the results to the given [destination].\n */\npublic inline fun <K, V, R, C : MutableCollection<in R>> Map<out K, V>.mapTo(destination: C, transform: (Map.Entry<K, V>) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns `true` if all entries match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\npublic inline fun <K, V> Map<out K, V>.all(predicate: (Map.Entry<K, V>) -> Boolean): Boolean {\n    if (isEmpty()) return true\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if map has at least one entry.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\npublic fun <K, V> Map<out K, V>.any(): Boolean {\n    return !isEmpty()\n}\n\n/**\n * Returns `true` if at least one entry matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\npublic inline fun <K, V> Map<out K, V>.any(predicate: (Map.Entry<K, V>) -> Boolean): Boolean {\n    if (isEmpty()) return false\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of entries in this map.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.count(): Int {\n    return size\n}\n\n/**\n * Returns the number of entries matching the given [predicate].\n */\npublic inline fun <K, V> Map<out K, V>.count(predicate: (Map.Entry<K, V>) -> Boolean): Int {\n    if (isEmpty()) return 0\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Performs the given [action] on each entry.\n */\n@kotlin.internal.HidesMembers\npublic inline fun <K, V> Map<out K, V>.forEach(action: (Map.Entry<K, V>) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxBy(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V>? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first entry yielding the largest value of the given function or `null` if there are no entries.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxByOrNull(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V>? {\n    return entries.maxByOrNull(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxOf(selector: (Map.Entry<K, V>) -> Double): Double {\n    return entries.maxOf(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxOf(selector: (Map.Entry<K, V>) -> Float): Float {\n    return entries.maxOf(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxOf(selector: (Map.Entry<K, V>) -> R): R {\n    return entries.maxOf(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxOfOrNull(selector: (Map.Entry<K, V>) -> Double): Double? {\n    return entries.maxOfOrNull(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxOfOrNull(selector: (Map.Entry<K, V>) -> Float): Float? {\n    return entries.maxOfOrNull(selector)\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.maxOfOrNull(selector: (Map.Entry<K, V>) -> R): R? {\n    return entries.maxOfOrNull(selector)\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each entry in the map.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R> Map<out K, V>.maxOfWith(comparator: Comparator<in R>, selector: (Map.Entry<K, V>) -> R): R {\n    return entries.maxOfWith(comparator, selector)\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each entry in the map or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R> Map<out K, V>.maxOfWithOrNull(comparator: Comparator<in R>, selector: (Map.Entry<K, V>) -> R): R? {\n    return entries.maxOfWithOrNull(comparator, selector)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxWith(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V>? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first entry having the largest value according to the provided [comparator] or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.maxWithOrNull(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V>? {\n    return entries.maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.minBy(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V>? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first entry yielding the smallest value of the given function or `null` if there are no entries.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.minByOrNull(selector: (Map.Entry<K, V>) -> R): Map.Entry<K, V>? {\n    return entries.minByOrNull(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minOf(selector: (Map.Entry<K, V>) -> Double): Double {\n    return entries.minOf(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minOf(selector: (Map.Entry<K, V>) -> Float): Float {\n    return entries.minOf(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.minOf(selector: (Map.Entry<K, V>) -> R): R {\n    return entries.minOf(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minOfOrNull(selector: (Map.Entry<K, V>) -> Double): Double? {\n    return entries.minOfOrNull(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minOfOrNull(selector: (Map.Entry<K, V>) -> Float): Float? {\n    return entries.minOfOrNull(selector)\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each entry in the map or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R : Comparable<R>> Map<out K, V>.minOfOrNull(selector: (Map.Entry<K, V>) -> R): R? {\n    return entries.minOfOrNull(selector)\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each entry in the map.\n * \n * @throws NoSuchElementException if the map is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R> Map<out K, V>.minOfWith(comparator: Comparator<in R>, selector: (Map.Entry<K, V>) -> R): R {\n    return entries.minOfWith(comparator, selector)\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each entry in the map or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, R> Map<out K, V>.minOfWithOrNull(comparator: Comparator<in R>, selector: (Map.Entry<K, V>) -> R): R? {\n    return entries.minOfWithOrNull(comparator, selector)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\npublic fun <K, V> Map<out K, V>.minWith(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V>? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first entry having the smallest value according to the provided [comparator] or `null` if there are no entries.\n */\n@SinceKotlin(\"1.4\")\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.minWithOrNull(comparator: Comparator<in Map.Entry<K, V>>): Map.Entry<K, V>? {\n    return entries.minWithOrNull(comparator)\n}\n\n/**\n * Returns `true` if the map has no entries.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\npublic fun <K, V> Map<out K, V>.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no entries match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\npublic inline fun <K, V> Map<out K, V>.none(predicate: (Map.Entry<K, V>) -> Boolean): Boolean {\n    if (isEmpty()) return true\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each entry and returns the map itself afterwards.\n */\n@SinceKotlin(\"1.1\")\npublic inline fun <K, V, M : Map<out K, V>> M.onEach(action: (Map.Entry<K, V>) -> Unit): M {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each entry, providing sequential index with the entry,\n * and returns the map itself afterwards.\n * @param [action] function that takes the index of an entry and the entry itself\n * and performs the action on the entry.\n */\n@SinceKotlin(\"1.4\")\npublic inline fun <K, V, M : Map<out K, V>> M.onEachIndexed(action: (index: Int, Map.Entry<K, V>) -> Unit): M {\n    return apply { entries.forEachIndexed(action) }\n}\n\n/**\n * Creates an [Iterable] instance that wraps the original map returning its entries when being iterated.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> Map<out K, V>.asIterable(): Iterable<Map.Entry<K, V>> {\n    return entries\n}\n\n/**\n * Creates a [Sequence] instance that wraps the original map returning its entries when being iterated.\n */\npublic fun <K, V> Map<out K, V>.asSequence(): Sequence<Map.Entry<K, V>> {\n    return entries.asSequence()\n}\n\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"SetsKt\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns a set containing all elements of the original set except the given [element].\n * \n * The returned set preserves the element iteration order of the original set.\n */\npublic operator fun <T> Set<T>.minus(element: T): Set<T> {\n    val result = LinkedHashSet<T>(mapCapacity(size))\n    var removed = false\n    return this.filterTo(result) { if (!removed && it == element) { removed = true; false } else true }\n}\n\n/**\n * Returns a set containing all elements of the original set except the elements contained in the given [elements] array.\n * \n * The returned set preserves the element iteration order of the original set.\n * \n * Before Kotlin 1.6, the [elements] array may have been converted to a [HashSet] to speed up the operation, thus the elements were required to have\n * a correct and stable implementation of `hashCode()` that didn't change between successive invocations.\n * On JVM, you can enable this behavior back with the system property `kotlin.collections.convert_arg_to_set_in_removeAll` set to `true`.\n */\npublic operator fun <T> Set<T>.minus(elements: Array<out T>): Set<T> {\n    val result = LinkedHashSet<T>(this)\n    result.removeAll(elements)\n    return result\n}\n\n/**\n * Returns a set containing all elements of the original set except the elements contained in the given [elements] collection.\n * \n * The returned set preserves the element iteration order of the original set.\n * \n * Before Kotlin 1.6, the [elements] collection may have been converted to a [HashSet] to speed up the operation, thus the elements were required to have\n * a correct and stable implementation of `hashCode()` that didn't change between successive invocations.\n * On JVM, you can enable this behavior back with the system property `kotlin.collections.convert_arg_to_set_in_removeAll` set to `true`.\n */\npublic operator fun <T> Set<T>.minus(elements: Iterable<T>): Set<T> {\n    val other = elements.convertToSetForSetOperationWith(this)\n    if (other.isEmpty())\n        return this.toSet()\n    if (other is Set)\n        return this.filterNotTo(LinkedHashSet<T>()) { it in other }\n    val result = LinkedHashSet<T>(this)\n    result.removeAll(other)\n    return result\n}\n\n/**\n * Returns a set containing all elements of the original set except the elements contained in the given [elements] sequence.\n * \n * The returned set preserves the element iteration order of the original set.\n * \n * Before Kotlin 1.6, the [elements] sequence may have been converted to a [HashSet] to speed up the operation, thus the elements were required to have\n * a correct and stable implementation of `hashCode()` that didn't change between successive invocations.\n * On JVM, you can enable this behavior back with the system property `kotlin.collections.convert_arg_to_set_in_removeAll` set to `true`.\n */\npublic operator fun <T> Set<T>.minus(elements: Sequence<T>): Set<T> {\n    val result = LinkedHashSet<T>(this)\n    result.removeAll(elements)\n    return result\n}\n\n/**\n * Returns a set containing all elements of the original set except the given [element].\n * \n * The returned set preserves the element iteration order of the original set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Set<T>.minusElement(element: T): Set<T> {\n    return minus(element)\n}\n\n/**\n * Returns a set containing all elements of the original set and then the given [element] if it isn't already in this set.\n * \n * The returned set preserves the element iteration order of the original set.\n */\npublic operator fun <T> Set<T>.plus(element: T): Set<T> {\n    val result = LinkedHashSet<T>(mapCapacity(size + 1))\n    result.addAll(this)\n    result.add(element)\n    return result\n}\n\n/**\n * Returns a set containing all elements of the original set and the given [elements] array,\n * which aren't already in this set.\n * \n * The returned set preserves the element iteration order of the original set.\n */\npublic operator fun <T> Set<T>.plus(elements: Array<out T>): Set<T> {\n    val result = LinkedHashSet<T>(mapCapacity(this.size + elements.size))\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a set containing all elements of the original set and the given [elements] collection,\n * which aren't already in this set.\n * The returned set preserves the element iteration order of the original set.\n */\npublic operator fun <T> Set<T>.plus(elements: Iterable<T>): Set<T> {\n    val result = LinkedHashSet<T>(mapCapacity(elements.collectionSizeOrNull()?.let { this.size + it } ?: this.size * 2))\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a set containing all elements of the original set and the given [elements] sequence,\n * which aren't already in this set.\n * \n * The returned set preserves the element iteration order of the original set.\n */\npublic operator fun <T> Set<T>.plus(elements: Sequence<T>): Set<T> {\n    val result = LinkedHashSet<T>(mapCapacity(this.size * 2))\n    result.addAll(this)\n    result.addAll(elements)\n    return result\n}\n\n/**\n * Returns a set containing all elements of the original set and then the given [element] if it isn't already in this set.\n * \n * The returned set preserves the element iteration order of the original set.\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Set<T>.plusElement(element: T): Set<T> {\n    return plus(element)\n}\n\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines.cancellation\n\n@SinceKotlin(\"1.4\")\npublic actual open class CancellationException : IllegalStateException {\n    actual constructor() : super()\n    actual constructor(message: String?) : super(message)\n    constructor(message: String?, cause: Throwable?) : super(message, cause)\n    constructor(cause: Throwable?) : super(cause)\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// a package is omitted to get declarations directly under the module\n\n// TODO: Remove once JsReflectionAPICallChecker supports more reflection types\n@file:Suppress(\"Unsupported\")\n\nimport kotlin.reflect.*\nimport kotlin.reflect.js.internal.*\n\n@JsName(\"createKType\")\ninternal fun createKType(\n    classifier: KClassifier,\n    arguments: Array<KTypeProjection>,\n    isMarkedNullable: Boolean\n) =\n    KTypeImpl(classifier, arguments.asList(), isMarkedNullable)\n\n@JsName(\"createDynamicKType\")\ninternal fun createDynamicKType(): KType = DynamicKType\n\n@JsName(\"markKTypeNullable\")\ninternal fun markKTypeNullable(kType: KType) = KTypeImpl(kType.classifier!!, kType.arguments, true)\n\n@JsName(\"createKTypeParameter\")\ninternal fun createKTypeParameter(\n    name: String,\n    upperBounds: Array<KType>,\n    variance: String\n): KTypeParameter {\n    val kVariance = when (variance) {\n        \"in\" -> KVariance.IN\n        \"out\" -> KVariance.OUT\n        else -> KVariance.INVARIANT\n    }\n\n    return KTypeParameterImpl(name, upperBounds.asList(), kVariance, false)\n}\n\n@JsName(\"getStarKTypeProjection\")\ninternal fun getStarKTypeProjection(): KTypeProjection =\n    KTypeProjection.STAR\n\n@JsName(\"createCovariantKTypeProjection\")\ninternal fun createCovariantKTypeProjection(type: KType): KTypeProjection =\n    KTypeProjection.covariant(type)\n\n@JsName(\"createInvariantKTypeProjection\")\ninternal fun createInvariantKTypeProjection(type: KType): KTypeProjection =\n    KTypeProjection.invariant(type)\n\n@JsName(\"createContravariantKTypeProjection\")\ninternal fun createContravariantKTypeProjection(type: KType): KTypeProjection =\n    KTypeProjection.contravariant(type)\n","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\n/**\n * Returns the detailed description of this throwable with its stack trace.\n *\n * The detailed description includes:\n * - the short description (see [Throwable.toString]) of this throwable;\n * - the complete stack trace;\n * - detailed descriptions of the exceptions that were [suppressed][suppressedExceptions] in order to deliver this exception;\n * - the detailed description of each throwable in the [Throwable.cause] chain.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun Throwable.stackTraceToString(): String = ExceptionTraceBuilder().buildFor(this)\n\n/**\n * Prints the [detailed description][Throwable.stackTraceToString] of this throwable to console error output.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun Throwable.printStackTrace() {\n    console.error(this.stackTraceToString())\n}\n\n/**\n * Adds the specified exception to the list of exceptions that were\n * suppressed in order to deliver this exception.\n */\n@SinceKotlin(\"1.4\")\npublic actual fun Throwable.addSuppressed(exception: Throwable) {\n    if (this !== exception) {\n        val suppressed = this.asDynamic()._suppressed.unsafeCast<MutableList<Throwable>?>()\n        if (suppressed == null) {\n            this.asDynamic()._suppressed = mutableListOf(exception)\n        } else {\n            suppressed.add(exception)\n        }\n    }\n}\n\n/**\n * Returns a list of all exceptions that were suppressed in order to deliver this exception.\n */\n@SinceKotlin(\"1.4\")\npublic actual val Throwable.suppressedExceptions: List<Throwable>\n    get() {\n        return this.asDynamic()._suppressed?.unsafeCast<List<Throwable>>() ?: emptyList()\n    }\n\n\nprivate class ExceptionTraceBuilder {\n    private val target = StringBuilder()\n    private val visited = arrayOf<Throwable>()\n    private var topStack: String = \"\"\n    private var topStackStart: Int = 0\n\n    fun buildFor(exception: Throwable): String {\n        exception.dumpFullTrace(\"\", \"\")\n        return target.toString()\n    }\n\n    private fun hasSeen(exception: Throwable): Boolean = visited.any { it === exception }\n\n    private fun Throwable.dumpFullTrace(indent: String, qualifier: String) {\n        this.dumpSelfTrace(indent, qualifier) || return\n\n        var cause = this.cause\n        while (cause != null) {\n            cause.dumpSelfTrace(indent, \"Caused by: \") || return\n            cause = cause.cause\n        }\n    }\n\n    private fun Throwable.dumpSelfTrace(indent: String, qualifier: String): Boolean {\n        target.append(indent).append(qualifier)\n        val shortInfo = this.toString()\n        if (hasSeen(this)) {\n            target.append(\"[CIRCULAR REFERENCE, SEE ABOVE: \").append(shortInfo).append(\"]\\n\")\n            return false\n        }\n        visited.asDynamic().push(this)\n\n        var stack = this.asDynamic().stack as String?\n        if (stack != null) {\n            val stackStart = stack.indexOf(shortInfo).let { if (it < 0) 0 else it + shortInfo.length }\n            if (stackStart == 0) target.append(shortInfo).append(\"\\n\")\n            if (topStack.isEmpty()) {\n                topStack = stack\n                topStackStart = stackStart\n            } else {\n                stack = dropCommonFrames(stack, stackStart)\n            }\n            if (indent.isNotEmpty()) {\n                // indent stack, but avoid indenting exception message lines\n                val messageLines = if (stackStart == 0) 0 else 1 + shortInfo.count { c -> c == '\\n' }\n                stack.lineSequence().forEachIndexed { index: Int, line: String ->\n                    if (index >= messageLines) target.append(indent)\n                    target.append(line).append(\"\\n\")\n                }\n            } else {\n                target.append(stack).append(\"\\n\")\n            }\n        } else {\n            target.append(shortInfo).append(\"\\n\")\n        }\n\n        val suppressed = suppressedExceptions\n        if (suppressed.isNotEmpty()) {\n            val suppressedIndent = indent + \"    \"\n            for (s in suppressed) {\n                s.dumpFullTrace(suppressedIndent, \"Suppressed: \")\n            }\n        }\n        return true\n    }\n\n    private fun dropCommonFrames(stack: String, stackStart: Int): String {\n        var commonFrames: Int = 0\n        var lastBreak: Int = 0\n        var preLastBreak: Int = 0\n        for (pos in 0 until minOf(topStack.length - topStackStart, stack.length - stackStart)) {\n            val c = stack[stack.lastIndex - pos]\n            if (c != topStack[topStack.lastIndex - pos]) break\n            if (c == '\\n') {\n                commonFrames += 1\n                preLastBreak = lastBreak\n                lastBreak = pos\n            }\n        }\n        if (commonFrames <= 1) return stack\n        while (preLastBreak > 0 && stack[stack.lastIndex - (preLastBreak - 1)] == ' ')\n            preLastBreak -= 1\n\n        // leave 1 common frame to ease matching with the top exception stack\n        return stack.dropLast(preLastBreak) + \"... and ${commonFrames - 1} more common stack frames skipped\"\n    }\n}","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n@file:kotlin.jvm.JvmName(\"ComparisonsKt\")\n@file:kotlin.jvm.JvmMultifileClass\n\npackage kotlin.comparisons\n\n/**\n * Compares two values using the specified functions [selectors] to calculate the result of the comparison.\n * The functions are called sequentially, receive the given values [a] and [b] and return [Comparable]\n * objects. As soon as the [Comparable] instances returned by a function for [a] and [b] values do not\n * compare as equal, the result of that comparison is returned.\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithSelectors\n */\npublic fun <T> compareValuesBy(a: T, b: T, vararg selectors: (T) -> Comparable<*>?): Int {\n    require(selectors.size > 0)\n    return compareValuesByImpl(a, b, selectors)\n}\n\nprivate fun <T> compareValuesByImpl(a: T, b: T, selectors: Array<out (T) -> Comparable<*>?>): Int {\n    for (fn in selectors) {\n        val v1 = fn(a)\n        val v2 = fn(b)\n        val diff = compareValues(v1, v2)\n        if (diff != 0) return diff\n    }\n    return 0\n}\n\n/**\n * Compares two values using the specified [selector] function to calculate the result of the comparison.\n * The function is applied to the given values [a] and [b] and return [Comparable] objects.\n * The result of comparison of these [Comparable] instances is returned.\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareValuesBy(a: T, b: T, selector: (T) -> Comparable<*>?): Int {\n    return compareValues(selector(a), selector(b))\n}\n\n/**\n * Compares two values using the specified [selector] function to calculate the result of the comparison.\n * The function is applied to the given values [a] and [b] and return objects of type K which are then being\n * compared with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.compareValuesByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareValuesBy(a: T, b: T, comparator: Comparator<in K>, selector: (T) -> K): Int {\n    return comparator.compare(selector(a), selector(b))\n}\n\n//// Not so useful without type inference for receiver of expression\n//// compareValuesWith(v1, v2, compareBy { it.prop1 } thenByDescending { it.prop2 })\n///**\n// * Compares two values using the specified [comparator].\n// */\n//@Suppress(\"NOTHING_TO_INLINE\")\n//public inline fun <T> compareValuesWith(a: T, b: T, comparator: Comparator<T>): Int = comparator.compare(a, b)\n//\n\n\n/**\n * Compares two nullable [Comparable] values. Null is considered less than any value.\n *\n * @sample samples.comparisons.Comparisons.compareValues\n */\npublic fun <T : Comparable<*>> compareValues(a: T?, b: T?): Int {\n    if (a === b) return 0\n    if (a == null) return -1\n    if (b == null) return 1\n\n    @Suppress(\"UNCHECKED_CAST\")\n    return (a as Comparable<Any>).compareTo(b)\n}\n\n/**\n * Creates a comparator using the sequence of functions to calculate a result of comparison.\n * The functions are called sequentially, receive the given values `a` and `b` and return [Comparable]\n * objects. As soon as the [Comparable] instances returned by a function for `a` and `b` values do not\n * compare as equal, the result of that comparison is returned from the [Comparator].\n *\n * @sample samples.comparisons.Comparisons.compareByWithSelectors\n */\npublic fun <T> compareBy(vararg selectors: (T) -> Comparable<*>?): Comparator<T> {\n    require(selectors.size > 0)\n    return Comparator { a, b -> compareValuesByImpl(a, b, selectors) }\n}\n\n\n/**\n * Creates a comparator using the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.compareByWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareBy(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(a, b, selector) }\n\n/**\n * Creates a comparator using the [selector] function to transform values being compared and then applying\n * the specified [comparator] to compare transformed values.\n *\n * @sample samples.comparisons.Comparisons.compareByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareBy(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(a, b, comparator, selector) }\n\n/**\n * Creates a descending comparator using the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.compareByDescendingWithSingleSelector\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> compareByDescending(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(b, a, selector) }\n\n/**\n * Creates a descending comparator using the [selector] function to transform values being compared and then applying\n * the specified [comparator] to compare transformed values.\n *\n * Note that an order of [comparator] is reversed by this wrapper.\n *\n * @sample samples.comparisons.Comparisons.compareByDescendingWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> compareByDescending(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b -> compareValuesBy(b, a, comparator, selector) }\n\n/**\n * Creates a comparator comparing values after the primary comparator defined them equal. It uses\n * the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.thenBy\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenBy(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenBy.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(a, b, selector)\n    }\n\n/**\n * Creates a comparator comparing values after the primary comparator defined them equal. It uses\n * the [selector] function to transform values and then compares them with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.thenByWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> Comparator<T>.thenBy(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenBy.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(a, b, comparator, selector)\n    }\n\n/**\n * Creates a descending comparator using the primary comparator and\n * the function to transform value to a [Comparable] instance for comparison.\n *\n * @sample samples.comparisons.Comparisons.thenByDescending\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenByDescending(crossinline selector: (T) -> Comparable<*>?): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenByDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(b, a, selector)\n    }\n\n/**\n * Creates a descending comparator comparing values after the primary comparator defined them equal. It uses\n * the [selector] function to transform values and then compares them with the given [comparator].\n *\n * @sample samples.comparisons.Comparisons.thenByDescendingWithComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T, K> Comparator<T>.thenByDescending(comparator: Comparator<in K>, crossinline selector: (T) -> K): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenByDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else compareValuesBy(b, a, comparator, selector)\n    }\n\n\n/**\n * Creates a comparator using the primary comparator and function to calculate a result of comparison.\n *\n * @sample samples.comparisons.Comparisons.thenComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T> Comparator<T>.thenComparator(crossinline comparison: (a: T, b: T) -> Int): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@thenComparator.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparison(a, b)\n    }\n\n/**\n * Combines this comparator and the given [comparator] such that the latter is applied only\n * when the former considered values equal.\n *\n * @sample samples.comparisons.Comparisons.then\n */\npublic infix fun <T> Comparator<T>.then(comparator: Comparator<in T>): Comparator<T> =\n    Comparator { a, b ->\n        val previousCompare = this@then.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparator.compare(a, b)\n    }\n\n/**\n * Combines this comparator and the given [comparator] such that the latter is applied only\n * when the former considered values equal.\n *\n * @sample samples.comparisons.Comparisons.thenDescending\n */\npublic infix fun <T> Comparator<T>.thenDescending(comparator: Comparator<in T>): Comparator<T> =\n    Comparator<T> { a, b ->\n        val previousCompare = this@thenDescending.compare(a, b)\n        if (previousCompare != 0) previousCompare else comparator.compare(b, a)\n    }\n\n// Not so useful without type inference for receiver of expression\n/**\n * Extends the given [comparator] of non-nullable values to a comparator of nullable values\n * considering `null` value less than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Any> nullsFirst(comparator: Comparator<in T>): Comparator<T?> =\n    Comparator { a, b ->\n        when {\n            a === b -> 0\n            a == null -> -1\n            b == null -> 1\n            else -> comparator.compare(a, b)\n        }\n    }\n\n/**\n * Provides a comparator of nullable [Comparable] values\n * considering `null` value less than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Comparable<T>> nullsFirst(): Comparator<T?> = nullsFirst(naturalOrder())\n\n/**\n * Extends the given [comparator] of non-nullable values to a comparator of nullable values\n * considering `null` value greater than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Any> nullsLast(comparator: Comparator<in T>): Comparator<T?> =\n    Comparator { a, b ->\n        when {\n            a === b -> 0\n            a == null -> 1\n            b == null -> -1\n            else -> comparator.compare(a, b)\n        }\n    }\n\n/**\n * Provides a comparator of nullable [Comparable] values\n * considering `null` value greater than any other value.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastComparator\n */\n@kotlin.internal.InlineOnly\npublic inline fun <T : Comparable<T>> nullsLast(): Comparator<T?> = nullsLast(naturalOrder())\n\n/**\n * Returns a comparator that compares [Comparable] objects in natural order.\n *\n * @sample samples.comparisons.Comparisons.naturalOrderComparator\n */\npublic fun <T : Comparable<T>> naturalOrder(): Comparator<T> = @Suppress(\"UNCHECKED_CAST\") (NaturalOrderComparator as Comparator<T>)\n\n/**\n * Returns a comparator that compares [Comparable] objects in reversed natural order.\n *\n * @sample samples.comparisons.Comparisons.nullsFirstLastWithComparator\n */\npublic fun <T : Comparable<T>> reverseOrder(): Comparator<T> = @Suppress(\"UNCHECKED_CAST\") (ReverseOrderComparator as Comparator<T>)\n\n/**\n *  Returns a comparator that imposes the reverse ordering of this comparator.\n *\n *  @sample samples.comparisons.Comparisons.reversed\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun <T> Comparator<T>.reversed(): Comparator<T> = when (this) {\n    is ReversedComparator -> this.comparator\n    NaturalOrderComparator -> @Suppress(\"UNCHECKED_CAST\") (ReverseOrderComparator as Comparator<T>)\n    ReverseOrderComparator -> @Suppress(\"UNCHECKED_CAST\") (NaturalOrderComparator as Comparator<T>)\n    else -> ReversedComparator(this)\n}\n\n\nprivate class ReversedComparator<T>(public val comparator: Comparator<T>) : Comparator<T> {\n    override fun compare(a: T, b: T): Int = comparator.compare(b, a)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<T> = comparator\n}\n\nprivate object NaturalOrderComparator : Comparator<Comparable<Any>> {\n    override fun compare(a: Comparable<Any>, b: Comparable<Any>): Int = a.compareTo(b)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<Comparable<Any>> = ReverseOrderComparator\n}\n\nprivate object ReverseOrderComparator : Comparator<Comparable<Any>> {\n    override fun compare(a: Comparable<Any>, b: Comparable<Any>): Int = b.compareTo(a)\n    @Suppress(\"VIRTUAL_MEMBER_HIDDEN\")\n    fun reversed(): Comparator<Comparable<Any>> = NaturalOrderComparator\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin.coroutines.js.internal\n\nimport kotlin.coroutines.Continuation\nimport kotlin.coroutines.EmptyCoroutineContext\n\n@PublishedApi\n@SinceKotlin(\"1.3\")\ninternal val EmptyContinuation = Continuation<Any?>(EmptyCoroutineContext) { result ->\n    result.getOrThrow()\n}","/*\n * Copyright 2010-2020 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\nimport kotlin.native.concurrent.SharedImmutable\n\n/**\n * Defines deep recursive function that keeps its stack on the heap,\n * which allows very deep recursive computations that do not use the actual call stack.\n * To initiate a call to this deep recursive function use its [invoke] function.\n * As a rule of thumb, it should be used if recursion goes deeper than a thousand calls.\n *\n * The [DeepRecursiveFunction] takes one parameter of type [T] and returns a result of type [R].\n * The [block] of code defines the body of a recursive function. In this block\n * [callRecursive][DeepRecursiveScope.callRecursive] function can be used to make a recursive call\n * to the declared function. Other instances of [DeepRecursiveFunction] can be called\n * in this scope with `callRecursive` extension, too.\n *\n * For example, take a look at the following recursive tree class and a deeply\n * recursive instance of this tree with 100K nodes:\n *\n * ```\n * class Tree(val left: Tree? = null, val right: Tree? = null)\n * val deepTree = generateSequence(Tree()) { Tree(it) }.take(100_000).last()\n * ```\n *\n * A regular recursive function can be defined to compute a depth of a tree:\n *\n * ```\n * fun depth(t: Tree?): Int =\n *     if (t == null) 0 else max(depth(t.left), depth(t.right)) + 1\n * println(depth(deepTree)) // StackOverflowError\n * ```\n *\n * If this `depth` function is called for a `deepTree` it produces [StackOverflowError] because of deep recursion.\n * However, the `depth` function can be rewritten using `DeepRecursiveFunction` in the following way, and then\n * it successfully computes [`depth(deepTree)`][DeepRecursiveFunction.invoke] expression:\n *\n * ```\n * val depth = DeepRecursiveFunction<Tree?, Int> { t ->\n *     if (t == null) 0 else max(callRecursive(t.left), callRecursive(t.right)) + 1\n * }\n * println(depth(deepTree)) // Ok\n * ```\n *\n * Deep recursive functions can also mutually call each other using a heap for the stack via\n * [callRecursive][DeepRecursiveScope.callRecursive] extension. For example, the\n * following pair of mutually recursive functions computes the number of tree nodes at even depth in the tree.\n *\n * ```\n * val mutualRecursion = object {\n *     val even: DeepRecursiveFunction<Tree?, Int> = DeepRecursiveFunction { t ->\n *         if (t == null) 0 else odd.callRecursive(t.left) + odd.callRecursive(t.right) + 1\n *     }\n *     val odd: DeepRecursiveFunction<Tree?, Int> = DeepRecursiveFunction { t ->\n *         if (t == null) 0 else even.callRecursive(t.left) + even.callRecursive(t.right)\n *     }\n * }\n * ```\n *\n * @param [T] the function parameter type.\n * @param [R] the function result type.\n * @param block the function body.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic class DeepRecursiveFunction<T, R>(\n    internal val block: suspend DeepRecursiveScope<T, R>.(T) -> R\n)\n\n/**\n * Initiates a call to this deep recursive function, forming a root of the call tree.\n *\n * This operator should not be used from inside of [DeepRecursiveScope] as it uses the call stack slot for\n * initial recursive invocation. From inside of [DeepRecursiveScope] use\n * [callRecursive][DeepRecursiveScope.callRecursive].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic operator fun <T, R> DeepRecursiveFunction<T, R>.invoke(value: T): R =\n    DeepRecursiveScopeImpl<T, R>(block, value).runCallLoop()\n\n/**\n * A scope class for [DeepRecursiveFunction] function declaration that defines [callRecursive] methods to\n * recursively call this function or another [DeepRecursiveFunction] putting the call activation frame on the heap.\n *\n * @param [T] function parameter type.\n * @param [R] function result type.\n */\n@RestrictsSuspension\n@SinceKotlin(\"1.4\")\n@ExperimentalStdlibApi\npublic sealed class DeepRecursiveScope<T, R> {\n    /**\n     * Makes recursive call to this [DeepRecursiveFunction] function putting the call activation frame on the heap,\n     * as opposed to the actual call stack that is used by a regular recursive call.\n     */\n    public abstract suspend fun callRecursive(value: T): R\n\n    /**\n     * Makes call to the specified [DeepRecursiveFunction] function putting the call activation frame on the heap,\n     * as opposed to the actual call stack that is used by a regular call.\n     */\n    public abstract suspend fun <U, S> DeepRecursiveFunction<U, S>.callRecursive(value: U): S\n\n    @Deprecated(\n        level = DeprecationLevel.ERROR,\n        message =\n        \"'invoke' should not be called from DeepRecursiveScope. \" +\n                \"Use 'callRecursive' to do recursion in the heap instead of the call stack.\",\n        replaceWith = ReplaceWith(\"this.callRecursive(value)\")\n    )\n    @Suppress(\"UNUSED_PARAMETER\")\n    public operator fun DeepRecursiveFunction<*, *>.invoke(value: Any?): Nothing =\n        throw UnsupportedOperationException(\"Should not be called from DeepRecursiveScope\")\n}\n\n// ================== Implementation ==================\n\n@ExperimentalStdlibApi\nprivate typealias DeepRecursiveFunctionBlock = suspend DeepRecursiveScope<*, *>.(Any?) -> Any?\n\n@SharedImmutable\nprivate val UNDEFINED_RESULT = Result.success(COROUTINE_SUSPENDED)\n\n@Suppress(\"UNCHECKED_CAST\")\n@ExperimentalStdlibApi\nprivate class DeepRecursiveScopeImpl<T, R>(\n    block: suspend DeepRecursiveScope<T, R>.(T) -> R,\n    value: T\n) : DeepRecursiveScope<T, R>(), Continuation<R> {\n    // Active function block\n    private var function: DeepRecursiveFunctionBlock = block as DeepRecursiveFunctionBlock\n\n    // Value to call function with\n    private var value: Any? = value\n\n    // Continuation of the current call\n    private var cont: Continuation<Any?>? = this as Continuation<Any?>\n\n    // Completion result (completion of the whole call stack)\n    private var result: Result<Any?> = UNDEFINED_RESULT\n\n    override val context: CoroutineContext\n        get() = EmptyCoroutineContext\n\n    override fun resumeWith(result: Result<R>) {\n        this.cont = null\n        this.result = result\n    }\n\n    override suspend fun callRecursive(value: T): R = suspendCoroutineUninterceptedOrReturn { cont ->\n        // calling the same function that is currently active\n        this.cont = cont as Continuation<Any?>\n        this.value = value\n        COROUTINE_SUSPENDED\n    }\n\n    override suspend fun <U, S> DeepRecursiveFunction<U, S>.callRecursive(value: U): S = suspendCoroutineUninterceptedOrReturn { cont ->\n        // calling another recursive function\n        val function = block as DeepRecursiveFunctionBlock\n        with(this@DeepRecursiveScopeImpl) {\n            val currentFunction = this.function\n            if (function !== currentFunction) {\n                // calling a different function -- create a trampoline to restore function ref\n                this.function = function\n                this.cont = crossFunctionCompletion(currentFunction, cont as Continuation<Any?>)\n            } else {\n                // calling the same function -- direct\n                this.cont = cont as Continuation<Any?>\n            }\n            this.value = value\n        }\n        COROUTINE_SUSPENDED\n    }\n\n    private fun crossFunctionCompletion(\n        currentFunction: DeepRecursiveFunctionBlock,\n        cont: Continuation<Any?>\n    ): Continuation<Any?> = Continuation(EmptyCoroutineContext) {\n        this.function = currentFunction\n        // When going back from a trampoline we cannot just call cont.resume (stack usage!)\n        // We delegate the cont.resumeWith(it) call to runCallLoop\n        this.cont = cont\n        this.result = it\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    fun runCallLoop(): R {\n        while (true) {\n            // Note: cont is set to null in DeepRecursiveScopeImpl.resumeWith when the whole computation completes\n            val result = this.result\n            val cont = this.cont\n                ?: return (result as Result<R>).getOrThrow() // done -- final result\n            // The order of comparison is important here for that case of rogue class with broken equals\n            if (UNDEFINED_RESULT == result) {\n                // call \"function\" with \"value\" using \"cont\" as completion\n                val r = try {\n                    // This is block.startCoroutine(this, value, cont)\n                    function.startCoroutineUninterceptedOrReturn(this, value, cont)\n                } catch (e: Throwable) {\n                    cont.resumeWithException(e)\n                    continue\n                }\n                // If the function returns without suspension -- calls its continuation immediately\n                if (r !== COROUTINE_SUSPENDED)\n                    cont.resume(r as R)\n            } else {\n                // we returned from a crossFunctionCompletion trampoline -- call resume here\n                this.result = UNDEFINED_RESULT // reset result back\n                cont.resumeWith(result)\n            }\n        }\n    }\n}\n",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\npackage kotlin\n\nimport kotlin.internal.InlineOnly\n\n\n/**\n * Returns a hash code value for the object or zero if the object is `null`.\n *\n * @see Any.hashCode\n */\n@SinceKotlin(\"1.3\")\n@InlineOnly\npublic inline fun Any?.hashCode(): Int = this?.hashCode() ?: 0\n",null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,null,"/*\n * Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.util.reflect\n\nimport kotlin.reflect.*\n\npublic actual interface Type\n\npublic object JsType : Type\n\n@OptIn(ExperimentalStdlibApi::class)\npublic actual inline fun <reified T> typeInfo(): TypeInfo = try {\n    typeInfoImpl(JsType, T::class, typeOf<T>())\n} catch (_: dynamic) {\n    typeInfoImpl(JsType, T::class, null)\n}\n\npublic fun typeInfoImpl(reifiedType: Type, kClass: KClass<*>, kType: KType?): TypeInfo =\n    TypeInfoImpl(kClass, reifiedType, kType)\n\n/**\n * Check [this] is instance of [type].\n */\npublic actual fun Any.instanceOf(type: KClass<*>): Boolean = type.isInstance(this)\n\ninternal actual val KType.platformType: Type\n    get() = JsType\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.features\n\nimport io.ktor.client.*\nimport io.ktor.client.engine.*\nimport io.ktor.client.request.*\nimport io.ktor.network.sockets.*\nimport io.ktor.util.*\nimport io.ktor.utils.io.concurrent.*\nimport kotlinx.coroutines.*\n\n/**\n * Client HTTP timeout feature. There are no default values, so default timeouts will be taken from engine configuration\n * or considered as infinite time if engine doesn't provide them.\n */\npublic class HttpTimeout(\n    private val requestTimeoutMillis: Long?,\n    private val connectTimeoutMillis: Long?,\n    private val socketTimeoutMillis: Long?\n) {\n    /**\n     * [HttpTimeout] extension configuration that is used during installation.\n     */\n    public class HttpTimeoutCapabilityConfiguration {\n        private var _requestTimeoutMillis: Long? by shared(0)\n        private var _connectTimeoutMillis: Long? by shared(0)\n        private var _socketTimeoutMillis: Long? by shared(0)\n\n        /**\n         * Creates a new instance of [HttpTimeoutCapabilityConfiguration].\n         */\n        @InternalAPI\n        public constructor(\n            requestTimeoutMillis: Long? = null,\n            connectTimeoutMillis: Long? = null,\n            socketTimeoutMillis: Long? = null\n        ) {\n            this.requestTimeoutMillis = requestTimeoutMillis\n            this.connectTimeoutMillis = connectTimeoutMillis\n            this.socketTimeoutMillis = socketTimeoutMillis\n        }\n\n        /**\n         * Request timeout in milliseconds.\n         */\n        public var requestTimeoutMillis: Long?\n            get() = _requestTimeoutMillis\n            set(value) {\n                _requestTimeoutMillis = checkTimeoutValue(value)\n            }\n\n        /**\n         * Connect timeout in milliseconds.\n         */\n        public var connectTimeoutMillis: Long?\n            get() = _connectTimeoutMillis\n            set(value) {\n                _connectTimeoutMillis = checkTimeoutValue(value)\n            }\n\n        /**\n         * Socket timeout (read and write) in milliseconds.\n         */\n        public var socketTimeoutMillis: Long?\n            get() = _socketTimeoutMillis\n            set(value) {\n                _socketTimeoutMillis = checkTimeoutValue(value)\n            }\n\n        internal fun build(): HttpTimeout = HttpTimeout(requestTimeoutMillis, connectTimeoutMillis, socketTimeoutMillis)\n\n        private fun checkTimeoutValue(value: Long?): Long? {\n            require(value == null || value > 0) {\n                \"Only positive timeout values are allowed, for infinite timeout use HttpTimeout.INFINITE_TIMEOUT_MS\"\n            }\n            return value\n        }\n\n        override fun equals(other: Any?): Boolean {\n            if (this === other) return true\n            if (other == null || this::class != other::class) return false\n\n            other as HttpTimeoutCapabilityConfiguration\n\n            if (_requestTimeoutMillis != other._requestTimeoutMillis) return false\n            if (_connectTimeoutMillis != other._connectTimeoutMillis) return false\n            if (_socketTimeoutMillis != other._socketTimeoutMillis) return false\n\n            return true\n        }\n\n        override fun hashCode(): Int {\n            var result = _requestTimeoutMillis?.hashCode() ?: 0\n            result = 31 * result + (_connectTimeoutMillis?.hashCode() ?: 0)\n            result = 31 * result + (_socketTimeoutMillis?.hashCode() ?: 0)\n            return result\n        }\n\n        public companion object {\n            public val key: AttributeKey<HttpTimeoutCapabilityConfiguration> = AttributeKey(\"TimeoutConfiguration\")\n        }\n    }\n\n    /**\n     * Utils method that return true if at least one timeout is configured (has not null value).\n     */\n    private fun hasNotNullTimeouts() =\n        requestTimeoutMillis != null || connectTimeoutMillis != null || socketTimeoutMillis != null\n\n    /**\n     * Companion object for feature installation.\n     */\n    public companion object Feature :\n        HttpClientFeature<HttpTimeoutCapabilityConfiguration, HttpTimeout>,\n        HttpClientEngineCapability<HttpTimeoutCapabilityConfiguration> {\n\n        override val key: AttributeKey<HttpTimeout> = AttributeKey(\"TimeoutFeature\")\n\n        /**\n         * Infinite timeout in milliseconds.\n         */\n        public const val INFINITE_TIMEOUT_MS: Long = Long.MAX_VALUE\n\n        override fun prepare(block: HttpTimeoutCapabilityConfiguration.() -> Unit): HttpTimeout =\n            HttpTimeoutCapabilityConfiguration().apply(block).build()\n\n        override fun install(feature: HttpTimeout, scope: HttpClient) {\n            scope.requestPipeline.intercept(HttpRequestPipeline.Before) {\n                var configuration = context.getCapabilityOrNull(HttpTimeout)\n                if (configuration == null && feature.hasNotNullTimeouts()) {\n                    configuration = HttpTimeoutCapabilityConfiguration()\n                    context.setCapability(HttpTimeout, configuration)\n                }\n\n                configuration?.apply {\n                    connectTimeoutMillis = connectTimeoutMillis ?: feature.connectTimeoutMillis\n                    socketTimeoutMillis = socketTimeoutMillis ?: feature.socketTimeoutMillis\n                    requestTimeoutMillis = requestTimeoutMillis ?: feature.requestTimeoutMillis\n\n                    val requestTimeout = requestTimeoutMillis ?: feature.requestTimeoutMillis\n                    if (requestTimeout == null || requestTimeout == INFINITE_TIMEOUT_MS) return@apply\n\n                    val executionContext = context.executionContext\n                    val killer = scope.launch {\n                        delay(requestTimeout)\n                        executionContext.cancel(HttpRequestTimeoutException(context))\n                    }\n\n                    context.executionContext.invokeOnCompletion {\n                        killer.cancel()\n                    }\n                }\n            }\n        }\n    }\n}\n\n/**\n * Adds timeout boundaries to the request. Requires [HttpTimeout] feature to be installed.\n */\npublic fun HttpRequestBuilder.timeout(block: HttpTimeout.HttpTimeoutCapabilityConfiguration.() -> Unit): Unit =\n    setCapability(HttpTimeout, HttpTimeout.HttpTimeoutCapabilityConfiguration().apply(block))\n\n/**\n * This exception is thrown in case request timeout exceeded.\n */\npublic class HttpRequestTimeoutException(\n    request: HttpRequestBuilder\n) : CancellationException(\n    \"Request timeout has expired [url=${request.url.buildString()}, \" +\n        \"request_timeout=${request.getCapabilityOrNull(HttpTimeout)?.requestTimeoutMillis ?: \"unknown\"} ms]\"\n)\n\n/**\n * This exception is thrown in case connect timeout exceeded.\n */\npublic fun ConnectTimeoutException(\n    request: HttpRequestData,\n    cause: Throwable? = null\n): ConnectTimeoutException = ConnectTimeoutException(\n    \"Connect timeout has expired [url=${request.url}, \" +\n        \"connect_timeout=${request.getCapabilityOrNull(HttpTimeout)?.connectTimeoutMillis ?: \"unknown\"} ms]\",\n    cause\n)\n\n/**\n * This exception is thrown in case connect timeout exceeded.\n */\npublic fun ConnectTimeoutException(\n    url: String,\n    timeout: Long?,\n    cause: Throwable? = null\n): ConnectTimeoutException = ConnectTimeoutException(\n    \"Connect timeout has expired [url=$url, connect_timeout=${timeout ?: \"unknown\"} ms]\",\n    cause\n)\n\n/**\n * This exception is thrown in case socket timeout (read or write) exceeded.\n */\npublic fun SocketTimeoutException(\n    request: HttpRequestData,\n    cause: Throwable? = null\n): SocketTimeoutException = SocketTimeoutException(\n    \"Socket timeout has expired [url=${request.url}, \" +\n        \"socket_timeout=${request.getCapabilityOrNull(HttpTimeout)?.socketTimeoutMillis ?: \"unknown\"}] ms\",\n    cause\n)\n\n/**\n * Convert long timeout in milliseconds to int value. To do that we need to consider [HttpTimeout.INFINITE_TIMEOUT_MS]\n * as zero and convert timeout value to [Int].\n */\n@InternalAPI\npublic fun convertLongTimeoutToIntWithInfiniteAsZero(timeout: Long): Int = when {\n    timeout == HttpTimeout.INFINITE_TIMEOUT_MS -> 0\n    timeout < Int.MIN_VALUE -> Int.MIN_VALUE\n    timeout > Int.MAX_VALUE -> Int.MAX_VALUE\n    else -> timeout.toInt()\n}\n\n/**\n * Convert long timeout in milliseconds to long value. To do that we need to consider [HttpTimeout.INFINITE_TIMEOUT_MS]\n * as zero and convert timeout value to [Int].\n */\n@InternalAPI\npublic fun convertLongTimeoutToLongWithInfiniteAsZero(timeout: Long): Long = when (timeout) {\n    HttpTimeout.INFINITE_TIMEOUT_MS -> 0L\n    else -> timeout\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.features.cache\n\nimport io.ktor.client.call.*\nimport io.ktor.client.statement.*\nimport io.ktor.http.*\nimport io.ktor.util.date.*\nimport io.ktor.utils.io.*\nimport io.ktor.utils.io.core.*\n\ninternal suspend fun HttpCacheEntry(response: HttpResponse): HttpCacheEntry {\n    val body = response.content.readRemaining().readBytes()\n    response.complete()\n    return HttpCacheEntry(response.cacheExpires(), response.varyKeys(), response, body)\n}\n\n/**\n * Client single response cache with [expires] and [varyKeys].\n */\npublic class HttpCacheEntry internal constructor(\n    public val expires: GMTDate,\n    public val varyKeys: Map<String, String>,\n    public val response: HttpResponse,\n    public val body: ByteArray\n) {\n    internal val responseHeaders: Headers = Headers.build {\n        appendAll(response.headers)\n    }\n\n    internal fun produceResponse(): HttpResponse {\n        val currentClient = response.call.client ?: error(\"Failed to save response in cache in different thread.\")\n        val call = SavedHttpCall(currentClient, body)\n        call.response = SavedHttpResponse(call, body, response)\n        call.request = SavedHttpRequest(call, response.call.request)\n\n        return call.response\n    }\n\n    override fun equals(other: Any?): Boolean {\n        if (other == null || other !is HttpCacheEntry) return false\n        if (other === this) return true\n        return varyKeys == other.varyKeys\n    }\n\n    override fun hashCode(): Int {\n        return varyKeys.hashCode()\n    }\n}\n\ninternal fun HttpResponse.varyKeys(): Map<String, String> {\n    val validationKeys = vary() ?: return emptyMap()\n\n    val result = mutableMapOf<String, String>()\n    val requestHeaders = call.request.headers\n\n    for (key in validationKeys) {\n        result[key] = requestHeaders[key] ?: \"\"\n    }\n\n    return result\n}\n\ninternal fun HttpResponse.cacheExpires(fallback: () -> GMTDate = { GMTDate() }): GMTDate {\n    val cacheControl = cacheControl()\n\n    val isPrivate = CacheControl.PRIVATE in cacheControl\n\n    val maxAgeKey = if (isPrivate) \"s-max-age\" else \"max-age\"\n\n    val maxAge = cacheControl.firstOrNull { it.value.startsWith(maxAgeKey) }\n        ?.value?.split(\"=\")\n        ?.get(1)?.toInt()\n\n    if (maxAge != null) {\n        return call.response.requestTime + maxAge * 1000L\n    }\n\n    val expires = headers[HttpHeaders.Expires]\n    return expires?.let {\n        // Handle \"0\" case faster\n        if (it == \"0\" || it.isBlank()) return fallback()\n\n        return try {\n            it.fromHttpToGmtDate()\n        } catch (e: Throwable) {\n            fallback()\n        }\n    } ?: fallback()\n}\n\ninternal fun HttpCacheEntry.shouldValidate(): Boolean {\n    val cacheControl = responseHeaders[HttpHeaders.CacheControl]?.let { parseHeaderValue(it) } ?: emptyList()\n    val isStale = GMTDate() > expires\n    // must-revalidate; re-validate once STALE, and MUST NOT return a cached response once stale.\n    //  This is how majority of clients implement the RFC\n    //  OkHttp Implements this the same: https://github.com/square/okhttp/issues/4043#issuecomment-403679369\n    // Disabled for now, as we don't currently return a cached object when there's a network failure; must-revalidate\n    // works the same as being stale on the request side. On response side, must-revalidate would not return a cached\n    // object if we are stale and couldn't refresh.\n    // isStale = isStale && CacheControl.MUST_REVALIDATE in cacheControl\n    return isStale || CacheControl.NO_CACHE in cacheControl\n}\n","package io.ktor.utils.io\n\nimport io.ktor.utils.io.bits.Memory\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.core.internal.*\n\n/**\n * Await until at least [desiredSize] is available for read or EOF and invoke [block] function. The block function\n * should never capture a provided [Memory] instance outside otherwise an undefined behaviour may occur including\n * accidental crash or data corruption. Block function should return number of bytes consumed or 0.\n *\n * Specifying [desiredSize] larger than the channel's capacity leads to block function invocation earlier\n * when the channel is full. So specifying too big [desiredSize] is identical to specifying [desiredSize] equal to\n * the channel's capacity. The other case when a provided memory range could be less than [desiredSize] is that\n * all the requested bytes couldn't be represented as a single memory range due to internal implementation reasons.\n *\n * @return number of bytes consumed, possibly 0\n */\n@ExperimentalIoApi\npublic suspend inline fun ByteReadChannel.read(\n    desiredSize: Int = 1,\n    block: (source: Memory, start: Long, endExclusive: Long) -> Int\n): Int {\n    val buffer = requestBuffer(desiredSize) ?: Buffer.Empty\n\n    try {\n        val bytesRead = block(buffer.memory, buffer.readPosition.toLong(), buffer.writePosition.toLong())\n        completeReadingFromBuffer(buffer, bytesRead)\n        return bytesRead\n    } catch (cause: Throwable) {\n        completeReadingFromBuffer(buffer, 0)\n        throw cause\n    }\n\n    // we don't use finally here because of KT-37279\n}\n\n@Deprecated(\"Use read { } instead.\")\npublic interface ReadSession {\n    /**\n     * Number of bytes available for read. However it does not necessarily mean that all available bytes could be\n     * requested at once\n     */\n    public val availableForRead: Int\n\n    /**\n     * Discard at most [n] available bytes or 0 if no bytes available yet\n     * @return number of bytes actually discarded, could be 0\n     */\n    public fun discard(n: Int): Int\n\n    /**\n     * Request buffer range [atLeast] bytes length\n     *\n     * There are the following reasons for this function to return `null`:\n     * - not enough bytes available yet (should be at least `atLeast` bytes available)\n     * - due to buffer fragmentation it is impossible to represent the requested range as a single buffer range\n     * - end of stream encountered and all bytes were consumed\n     *\n     * @return buffer for the requested range or `null` if it is impossible to provide such a buffer view\n     * @throws Throwable if the channel has been closed with an exception or cancelled\n     */\n    @Suppress(\"DEPRECATION\")\n    public fun request(atLeast: Int = 1): IoBuffer?\n}\n\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Use read { } instead.\")\npublic interface SuspendableReadSession : ReadSession {\n    /**\n     * Suspend until [atLeast] bytes become available or end of stream encountered (possibly due to exceptional close)\n     *\n     * @return true if there are [atLeast] bytes available or false if end of stream encountered (there still could be\n     * bytes available but less than [atLeast])\n     * @throws Throwable if the channel has been closed with an exception or cancelled\n     * @throws IllegalArgumentException if [atLeast] is negative to too big (usually bigger than 4088)\n     */\n    public suspend fun await(atLeast: Int = 1): Boolean\n}\n\n@PublishedApi\ninternal suspend fun ByteReadChannel.requestBuffer(desiredSize: Int): Buffer? {\n    @Suppress(\"DEPRECATION\")\n    val readSession: SuspendableReadSession? = when {\n        this is SuspendableReadSession -> this\n        this is HasReadSession -> startReadSession()\n        else -> null\n    }\n\n    if (readSession != null) {\n        val buffer = readSession.request(desiredSize.coerceAtMost(Buffer.ReservedSize))\n        if (buffer != null) {\n            return buffer\n        }\n\n        return readSession.requestBufferSuspend(desiredSize)\n    }\n\n    return requestBufferFallback(desiredSize)\n}\n\n@PublishedApi\ninternal suspend fun ByteReadChannel.completeReadingFromBuffer(buffer: Buffer?, bytesRead: Int) {\n    check(bytesRead >= 0) { \"bytesRead shouldn't be negative: $bytesRead\" }\n    @Suppress(\"DEPRECATION\")\n    val readSession: SuspendableReadSession? = readSessionFor()\n\n    if (readSession != null) {\n        readSession.discard(bytesRead)\n        if (this is HasReadSession) {\n            endReadSession()\n        }\n        return\n    }\n\n    if (buffer is ChunkBuffer && buffer !== ChunkBuffer.Empty) {\n        buffer.release(ChunkBuffer.Pool)\n        discard(bytesRead.toLong())\n    }\n}\n\n@Suppress(\"DEPRECATION\")\nprivate suspend fun SuspendableReadSession.requestBufferSuspend(desiredSize: Int): Buffer? {\n    await(desiredSize)\n    return request(1)\n}\n\nprivate suspend fun ByteReadChannel.requestBufferFallback(desiredSize: Int): ChunkBuffer {\n    val chunk = ChunkBuffer.Pool.borrow()\n    val copied =\n        peekTo(chunk.memory, chunk.writePosition.toLong(), 0L, desiredSize.toLong(), chunk.writeRemaining.toLong())\n    chunk.commitWritten(copied.toInt())\n\n    return chunk\n}\n\ninternal interface HasReadSession {\n    @Suppress(\"DEPRECATION\")\n    public fun startReadSession(): SuspendableReadSession\n\n    public fun endReadSession()\n}\n\n@Suppress(\"DEPRECATION\", \"NOTHING_TO_INLINE\")\nprivate inline fun ByteReadChannel.readSessionFor(): SuspendableReadSession? = when {\n    this is HasReadSession -> startReadSession()\n    else -> null\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client\n\nimport io.ktor.client.call.*\nimport io.ktor.client.engine.*\nimport io.ktor.client.features.*\nimport io.ktor.client.request.*\nimport io.ktor.client.statement.*\nimport io.ktor.client.utils.checkCoroutinesVersion\nimport io.ktor.util.*\nimport io.ktor.utils.io.*\nimport io.ktor.utils.io.concurrent.*\nimport io.ktor.utils.io.core.*\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\n/**\n * Constructs an asynchronous [HttpClient] using optional [block] for configuring this client.\n *\n * The [HttpClientEngine] is selected from the dependencies.\n * https://ktor.io/clients/http-client/engines.html\n */\n@HttpClientDsl\npublic expect fun HttpClient(\n    block: HttpClientConfig<*>.() -> Unit = {}\n): HttpClient\n\n/**\n * Constructs an asynchronous [HttpClient] using the specified [engineFactory]\n * and an optional [block] for configuring this client.\n */\n@HttpClientDsl\npublic fun <T : HttpClientEngineConfig> HttpClient(\n    engineFactory: HttpClientEngineFactory<T>,\n    block: HttpClientConfig<T>.() -> Unit = {}\n): HttpClient {\n    val config: HttpClientConfig<T> = HttpClientConfig<T>().apply(block)\n    val engine = engineFactory.create(config.engineConfig)\n    val client = HttpClient(engine, config, manageEngine = true)\n\n    // If the engine was created using factory Ktor is responsible for its lifecycle management. Otherwise user has to\n    // close engine by themself.\n    client.coroutineContext[Job]!!.invokeOnCompletion {\n        engine.close()\n    }\n\n    return client\n}\n\n/**\n * Constructs an asynchronous [HttpClient] using the specified [engine]\n * and a [block] for configuring this client.\n */\n@HttpClientDsl\npublic fun HttpClient(\n    engine: HttpClientEngine,\n    block: HttpClientConfig<*>.() -> Unit\n): HttpClient = HttpClient(engine, HttpClientConfig<HttpClientEngineConfig>().apply(block), manageEngine = false)\n\n/**\n * Asynchronous client to perform HTTP requests.\n *\n * This is a generic implementation that uses a specific engine [HttpClientEngine].\n * @property engine: [HttpClientEngine] for executing requests.\n */\n@OptIn(InternalCoroutinesApi::class)\npublic class HttpClient(\n    public val engine: HttpClientEngine,\n    private val userConfig: HttpClientConfig<out HttpClientEngineConfig> = HttpClientConfig()\n) : CoroutineScope, Closeable {\n    private var manageEngine: Boolean by shared(false)\n\n    internal constructor(\n        engine: HttpClientEngine,\n        userConfig: HttpClientConfig<out HttpClientEngineConfig>,\n        manageEngine: Boolean\n    ) : this(engine, userConfig) {\n        this.manageEngine = manageEngine\n    }\n\n    private val closed = atomic(false)\n\n    private val clientJob: CompletableJob = Job(engine.coroutineContext[Job])\n\n    public override val coroutineContext: CoroutineContext = engine.coroutineContext + clientJob\n\n    /**\n     * Pipeline used for processing all the requests sent by this client.\n     */\n    public val requestPipeline: HttpRequestPipeline = HttpRequestPipeline(userConfig.developmentMode)\n\n    /**\n     * Pipeline used for processing all the responses sent by the server.\n     */\n    public val responsePipeline: HttpResponsePipeline = HttpResponsePipeline(userConfig.developmentMode)\n\n    /**\n     * Pipeline used for sending the request.\n     */\n    public val sendPipeline: HttpSendPipeline = HttpSendPipeline(userConfig.developmentMode)\n\n    /**\n     * Pipeline used for receiving request.\n     */\n    public val receivePipeline: HttpReceivePipeline = HttpReceivePipeline(userConfig.developmentMode)\n\n    /**\n     * Typed attributes used as a lightweight container for this client.\n     */\n    public val attributes: Attributes = Attributes(concurrent = true)\n\n    /**\n     * Dispatcher handles io operations.\n     */\n    @Deprecated(\n        \"[dispatcher] is deprecated. Use coroutineContext instead.\",\n        replaceWith = ReplaceWith(\"coroutineContext\"),\n        level = DeprecationLevel.ERROR\n    )\n    public val dispatcher: CoroutineDispatcher\n        get() = engine.dispatcher\n\n    /**\n     * Client engine config.\n     */\n    public val engineConfig: HttpClientEngineConfig = engine.config\n\n    internal val config = HttpClientConfig<HttpClientEngineConfig>()\n\n    init {\n        checkCoroutinesVersion()\n\n        if (manageEngine) {\n            clientJob.invokeOnCompletion {\n                if (it != null) {\n                    engine.cancel()\n                }\n            }\n        }\n\n        engine.install(this)\n\n        sendPipeline.intercept(HttpSendPipeline.Receive) { call ->\n            check(call is HttpClientCall) { \"Error: HttpClientCall expected, but found $call(${call::class}).\" }\n            val receivedCall = receivePipeline.execute(call, call.response).call\n            proceedWith(receivedCall)\n        }\n\n        with(userConfig) {\n            config.install(HttpRequestLifecycle)\n            config.install(BodyProgress)\n\n            if (useDefaultTransformers) {\n                config.install(HttpPlainText)\n                config.install(\"DefaultTransformers\") { defaultTransformers() }\n            }\n\n            config.install(HttpSend)\n\n            if (followRedirects) {\n                config.install(HttpRedirect)\n            }\n\n            config += this\n\n            config.addDefaultResponseValidation()\n\n            config.install(this@HttpClient)\n        }\n\n        makeShared()\n    }\n\n    /**\n     * Creates a new [HttpRequest] from a request [data] and a specific client [call].\n     */\n    @Deprecated(\n        \"Unbound [HttpClientCall] is deprecated. Consider using [request<HttpResponse>(builder)] instead.\",\n        level = DeprecationLevel.ERROR,\n        replaceWith = ReplaceWith(\n            \"this.request<HttpResponse>(builder)\",\n            \"io.ktor.client.statement.*\"\n        )\n    )\n    @InternalAPI\n    public suspend fun execute(builder: HttpRequestBuilder): HttpClientCall =\n        requestPipeline.execute(builder, builder.body) as HttpClientCall\n\n    /**\n     * Check if the specified [capability] is supported by this client.\n     */\n    public fun isSupported(capability: HttpClientEngineCapability<*>): Boolean {\n        return engine.supportedCapabilities.contains(capability)\n    }\n\n    /**\n     * Returns a new [HttpClient] copying this client configuration,\n     * and additionally configured by the [block] parameter.\n     */\n    public fun config(block: HttpClientConfig<*>.() -> Unit): HttpClient = HttpClient(\n        engine,\n        HttpClientConfig<HttpClientEngineConfig>().apply {\n            plusAssign(userConfig)\n            block()\n        },\n        manageEngine\n    )\n\n    /**\n     * Closes the underlying [engine].\n     */\n    override fun close() {\n        val success = closed.compareAndSet(false, true)\n        if (!success) return\n\n        val installedFeatures = attributes[FEATURE_INSTALLED_LIST]\n        installedFeatures.allKeys.forEach { key ->\n            @Suppress(\"UNCHECKED_CAST\")\n            val feature = installedFeatures[key as AttributeKey<Any>]\n\n            if (feature is Closeable) {\n                feature.close()\n            }\n        }\n\n        clientJob.complete()\n        if (manageEngine) {\n            engine.close()\n        }\n    }\n\n    override fun toString(): String = \"HttpClient[$engine]\"\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.Memory\nimport io.ktor.utils.io.bits.get\nimport io.ktor.utils.io.core.internal.*\nimport kotlin.jvm.JvmName\n\n/**\n * Usually shouldn't be implemented directly. Inherit [AbstractInput] instead.\n */\npublic expect interface Input : Closeable {\n    @Deprecated(\n        \"Not supported anymore. All operations are big endian by default. \" +\n            \"Use readXXXLittleEndian or readXXX then X.reverseByteOrder() instead.\",\n        level = DeprecationLevel.ERROR\n    )\n    public var byteOrder: ByteOrder\n\n    /**\n     * It is `true` when it is known that no more bytes will be available. When it is `false` then this means that\n     * it is not known yet or there are available bytes.\n     * Please note that `false` value doesn't guarantee that there are available bytes so `readByte()` may fail.\n     */\n    public val endOfInput: Boolean\n\n    /**\n     * Read the next upcoming byte\n     * @throws EOFException if no more bytes available.\n     */\n    public fun readByte(): Byte\n\n    /*\n     * Returns next byte (unsigned) or `-1` if no more bytes available\n     */\n    public fun tryPeek(): Int\n\n    /**\n     * Try to copy at least [min] but up to [max] bytes to the specified [destination] buffer from this input\n     * skipping [offset] bytes. If there are not enough bytes available to provide [min] bytes after skipping [offset]\n     * bytes then it will trigger the underlying source reading first and after that will\n     * simply copy available bytes even if EOF encountered so [min] is not a requirement but a desired number of bytes.\n     * It is safe to specify [max] greater than the destination free space.\n     * `min` shouldn't be bigger than the [destination] free space.\n     * This function could trigger the underlying source reading that may lead to blocking I/O.\n     * It is allowed to specify too big [offset] so in this case this function will always return `0` after prefetching\n     * all underlying bytes but note that it may lead to significant memory consumption.\n     * This function usually copy more bytes than [min] (unless `max = min`) but it is not guaranteed.\n     * When `0` is returned with `offset = 0` then it makes sense to check [endOfInput].\n     *\n     * @param destination to write bytes\n     * @param offset to skip input\n     * @param min bytes to be copied, shouldn't be greater than the buffer free space. Could be `0`.\n     * @param max bytes to be copied even if there are more bytes buffered, could be [Int.MAX_VALUE].\n     * @return number of bytes copied to the [destination] possibly `0`\n     */\n    public fun peekTo(\n        destination: Memory,\n        destinationOffset: Long,\n        offset: Long = 0,\n        min: Long = 1,\n        max: Long = Long.MAX_VALUE\n    ): Long\n\n    /**\n     * Discard at most [n] bytes\n     */\n    public fun discard(n: Long): Long\n\n    /**\n     * Close input including the underlying source. All pending bytes will be discarded.\n     * It is not recommended to invoke it with read operations in-progress concurrently.\n     */\n    override fun close()\n\n    /**\n     * Copy available bytes to the specified [buffer] but keep them available.\n     * The underlying implementation could trigger\n     * bytes population from the underlying source and block until any bytes available.\n     *\n     * Very similar to [readAvailable] but don't discard copied bytes.\n     *\n     * @return number of bytes were copied\n     */\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\", \"DEPRECATION\")\n    public fun peekTo(buffer: IoBuffer): Int {\n        return peekTo(buffer)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readShort(): Short {\n        return readShort()\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readInt(): Int {\n        return readInt()\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readLong(): Long {\n        return readLong()\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFloat(): Float {\n        return readFloat()\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readDouble(): Double {\n        return readDouble()\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFully(dst: ByteArray, offset: Int, length: Int) {\n        readFully(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFully(dst: ShortArray, offset: Int, length: Int) {\n        readFully(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFully(dst: IntArray, offset: Int, length: Int) {\n        readFully(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFully(dst: LongArray, offset: Int, length: Int) {\n        readFully(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFully(dst: FloatArray, offset: Int, length: Int) {\n        readFully(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFully(dst: DoubleArray, offset: Int, length: Int) {\n        readFully(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\", \"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFully(dst: IoBuffer, length: Int) {\n        readFully(dst, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readAvailable(dst: ByteArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readAvailable(dst: ShortArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readAvailable(dst: IntArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readAvailable(dst: LongArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readAvailable(dst: FloatArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readAvailable(dst: DoubleArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\", \"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readAvailable(dst: IoBuffer, length: Int): Int {\n        return readAvailable(dst, length)\n    }\n}\n\n/**\n * Discard all remaining bytes.\n * @return number of bytes were discarded\n */\npublic fun Input.discard(): Long {\n    return discard(Long.MAX_VALUE)\n}\n\n/**\n * Discard exactly [n] bytes or fail if not enough bytes in the input to be discarded.\n */\npublic fun Input.discardExact(n: Long) {\n    val discarded = discard(n)\n    if (discarded != n) {\n        throw IllegalStateException(\"Only $discarded bytes were discarded of $n requested\")\n    }\n}\n\n/**\n * Discard exactly [n] bytes or fail if not enough bytes in the input to be discarded.\n */\npublic fun Input.discardExact(n: Int) {\n    discardExact(n.toLong())\n}\n\n/**\n * Invoke [block] function for every chunk until end of input or [block] function return `false`\n * [block] function returns `true` to request more chunks or `false` to stop loop\n *\n * It is not guaranteed that every chunk will have fixed size but it will be never empty.\n * [block] function should never release provided buffer and should not write to it otherwise an undefined behaviour\n * could be observed\n */\n@DangerousInternalIoApi\npublic inline fun Input.takeWhile(block: (Buffer) -> Boolean) {\n    var release = true\n    var current = prepareReadFirstHead(1) ?: return\n\n    try {\n        do {\n            if (!block(current)) {\n                break\n            }\n            release = false\n            val next = prepareReadNextHead(current) ?: break\n            current = next\n            release = true\n        } while (true)\n    } finally {\n        if (release) {\n            completeReadHead(current)\n        }\n    }\n}\n\n/**\n * Invoke [block] function for every chunk until end of input or [block] function return zero\n * [block] function returns number of bytes required to read next primitive and shouldn't require too many bytes at once\n * otherwise it could fail with an exception.\n * It is not guaranteed that every chunk will have fixed size but it will be always at least requested bytes length.\n * [block] function should never release provided buffer and should not write to it otherwise an undefined behaviour\n * could be observed\n */\n@DangerousInternalIoApi\npublic inline fun Input.takeWhileSize(initialSize: Int = 1, block: (Buffer) -> Int) {\n    var release = true\n    var current = prepareReadFirstHead(initialSize) ?: return\n    var size = initialSize\n\n    try {\n        do {\n            val before = current.readRemaining\n            val after: Int\n\n            if (before >= size) {\n                try {\n                    size = block(current)\n                } finally {\n                    after = current.readRemaining\n                }\n            } else {\n                after = before\n            }\n\n            release = false\n\n            val next = when {\n                after == 0 -> prepareReadNextHead(current)\n                after < size || current.endGap < Buffer.ReservedSize -> {\n                    completeReadHead(current)\n                    prepareReadFirstHead(size)\n                }\n                else -> current\n            }\n\n            if (next == null) {\n                break\n            }\n\n            current = next\n            release = true\n        } while (size > 0)\n    } finally {\n        if (release) {\n            completeReadHead(current)\n        }\n    }\n}\n\n@ExperimentalIoApi\npublic fun Input.peekCharUtf8(): Char {\n    val rc = tryPeek()\n    if (rc and 0x80 == 0) return rc.toChar()\n    if (rc == -1) throw EOFException(\"Failed to peek a char: end of input\")\n\n    return peekCharUtf8Impl(rc)\n}\n\n/**\n * For every byte from this input invokes [block] function giving it as parameter.\n */\n@ExperimentalIoApi\npublic inline fun Input.forEach(block: (Byte) -> Unit) {\n    takeWhile { buffer ->\n        buffer.forEach(block)\n        true\n    }\n}\n\nprivate fun Input.peekCharUtf8Impl(first: Int): Char {\n    var rc = '?'\n    var found = false\n\n    takeWhileSize(byteCountUtf8(first)) {\n        it.decodeUTF8 { ch ->\n            found = true\n            rc = ch\n            false\n        }\n    }\n\n    if (!found) {\n        throw MalformedUTF8InputException(\"No UTF-8 character found\")\n    }\n\n    return rc\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\npublic fun Input.readAvailable(dst: IoBuffer, size: Int = dst.writeRemaining): Int = readAvailable(dst, size)\n\n@JvmName(\"readAvailable\")\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\npublic fun Input.readAvailableOld(dst: ByteArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return readAvailable(dst, offset, length)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readAvailable\")\npublic fun Input.readAvailableOld(dst: ShortArray, offset: Int = 0, length: Int = dst.size - offset): Int =\n    readAvailable(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readAvailable\")\npublic fun Input.readAvailableOld(dst: IntArray, offset: Int = 0, length: Int = dst.size - offset): Int =\n    readAvailable(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readAvailable\")\npublic fun Input.readAvailableOld(dst: LongArray, offset: Int = 0, length: Int = dst.size - offset): Int =\n    readAvailable(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readAvailable\")\npublic fun Input.readAvailableOld(dst: FloatArray, offset: Int = 0, length: Int = dst.size - offset): Int =\n    readAvailable(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readAvailable\")\npublic fun Input.readAvailableOld(dst: DoubleArray, offset: Int = 0, length: Int = dst.size - offset): Int =\n    readAvailable(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\npublic fun Input.readFully(dst: IoBuffer, size: Int = dst.writeRemaining): Unit = readFully(dst, size)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readFully\")\npublic fun Input.readFullyOld(dst: ByteArray, offset: Int = 0, length: Int = dst.size - offset): Unit =\n    readFully(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readFully\")\npublic fun Input.readFullyOld(dst: ShortArray, offset: Int = 0, length: Int = dst.size - offset): Unit =\n    readFully(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readFully\")\npublic fun Input.readFullyOld(dst: IntArray, offset: Int = 0, length: Int = dst.size - offset): Unit =\n    readFully(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readFully\")\npublic fun Input.readFullyOld(dst: LongArray, offset: Int = 0, length: Int = dst.size - offset): Unit =\n    readFully(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readFully\")\npublic fun Input.readFullyOld(dst: FloatArray, offset: Int = 0, length: Int = dst.size - offset): Unit =\n    readFully(dst, offset, length)\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n@JvmName(\"readFully\")\npublic fun Input.readFullyOld(dst: DoubleArray, offset: Int = 0, length: Int = dst.size - offset): Unit =\n    readFully(dst, offset, length)\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client\n\nimport io.ktor.client.engine.*\nimport io.ktor.client.features.*\nimport io.ktor.client.utils.sharedMap\nimport io.ktor.util.*\nimport io.ktor.utils.io.concurrent.*\nimport kotlin.collections.set\n\n/**\n * Mutable configuration used by [HttpClient].\n */\n@HttpClientDsl\npublic class HttpClientConfig<T : HttpClientEngineConfig> {\n    private val features: MutableMap<AttributeKey<*>, (HttpClient) -> Unit> = sharedMap()\n    private val featureConfigurations: MutableMap<AttributeKey<*>, Any.() -> Unit> = sharedMap()\n\n    private val customInterceptors: MutableMap<String, (HttpClient) -> Unit> = sharedMap()\n\n    internal var engineConfig: T.() -> Unit by shared {}\n\n    /**\n     * Configure engine parameters.\n     */\n    public fun engine(block: T.() -> Unit) {\n        val oldConfig = engineConfig\n        engineConfig = {\n            oldConfig()\n            block()\n        }\n    }\n\n    /**\n     * Use [HttpRedirect] feature to automatically follow redirects.\n     */\n    public var followRedirects: Boolean by shared(true)\n\n    /**\n     * Use [defaultTransformers] to automatically handle simple [ContentType].\n     */\n    public var useDefaultTransformers: Boolean by shared(true)\n\n    /**\n     * Terminate [HttpClient.receivePipeline] if status code is not successful (>=300).\n     */\n    public var expectSuccess: Boolean by shared(true)\n\n    /**\n     * Indicate if client should use development mode. In development mode client pipelines have advanced stack traces.\n     */\n    public var developmentMode: Boolean by shared(PlatformUtils.IS_DEVELOPMENT_MODE)\n\n    /**\n     * Installs a specific [feature] and optionally [configure] it.\n     */\n    public fun <TBuilder : Any, TFeature : Any> install(\n        feature: HttpClientFeature<TBuilder, TFeature>,\n        configure: TBuilder.() -> Unit = {}\n    ) {\n        val previousConfigBlock = featureConfigurations[feature.key]\n        featureConfigurations[feature.key] = {\n            previousConfigBlock?.invoke(this)\n\n            @Suppress(\"UNCHECKED_CAST\")\n            (this as TBuilder).configure()\n        }\n\n        if (features.containsKey(feature.key)) return\n\n        features[feature.key] = { scope ->\n            val attributes = scope.attributes.computeIfAbsent(FEATURE_INSTALLED_LIST) { Attributes(concurrent = true) }\n            val config = scope.config.featureConfigurations[feature.key]!!\n            val featureData = feature.prepare(config)\n\n            feature.install(featureData, scope)\n            attributes.put(feature.key, featureData)\n        }\n    }\n\n    /**\n     * Installs an interceptor defined by [block].\n     * The [key] parameter is used as a unique name, that also prevents installing duplicated interceptors.\n     */\n    public fun install(key: String, block: HttpClient.() -> Unit) {\n        customInterceptors[key] = block\n    }\n\n    /**\n     * Applies all the installed [features] and [customInterceptors] from this configuration\n     * into the specified [client].\n     */\n    public fun install(client: HttpClient) {\n        features.values.forEach { client.apply(it) }\n        customInterceptors.values.forEach { client.apply(it) }\n    }\n\n    /**\n     * Clones this [HttpClientConfig] duplicating all the [features] and [customInterceptors].\n     */\n    public fun clone(): HttpClientConfig<T> {\n        val result = HttpClientConfig<T>()\n        result += this\n        return result\n    }\n\n    /**\n     * Install features from [other] client config.\n     */\n    public operator fun plusAssign(other: HttpClientConfig<out T>) {\n        followRedirects = other.followRedirects\n        useDefaultTransformers = other.useDefaultTransformers\n        expectSuccess = other.expectSuccess\n\n        features += other.features\n        featureConfigurations += other.featureConfigurations\n        customInterceptors += other.customInterceptors\n    }\n}\n\n/**\n * Dsl marker for [HttpClient] dsl.\n */\n@DslMarker\npublic annotation class HttpClientDsl\n","/*\n * Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.client.content\n\nimport io.ktor.client.call.*\nimport io.ktor.client.utils.*\nimport io.ktor.http.*\nimport io.ktor.http.content.*\nimport io.ktor.util.*\nimport io.ktor.utils.io.*\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\n/**\n * Callback that can be registered to listen for upload/download progress\n * @param bytesSentTotal number of transmitted bytes\n * @param contentLength body size. Can be -1 if the size is unknown\n */\npublic typealias ProgressListener = suspend (bytesSentTotal: Long, contentLength: Long) -> Unit\n\ninternal class ObservableContent(\n    delegate: OutgoingContent,\n    private val callContext: CoroutineContext,\n    private val listener: ProgressListener\n) : OutgoingContent.ReadChannelContent() {\n\n    private val content: ByteReadChannel = when (delegate) {\n        is ByteArrayContent -> ByteReadChannel(delegate.bytes())\n        is ProtocolUpgrade -> throw UnsupportedContentTypeException(delegate)\n        is NoContent -> ByteReadChannel.Empty\n        is ReadChannelContent -> delegate.readFrom()\n        is WriteChannelContent -> GlobalScope.writer(callContext, autoFlush = true) {\n            delegate.writeTo(channel)\n        }.channel\n    }\n\n    @Suppress(\"CanBePrimaryConstructorProperty\") // required to avoid InvalidMutabilityException on native\n    private val delegate = delegate\n\n    override val contentType: ContentType?\n        get() = delegate.contentType\n    override val contentLength: Long?\n        get() = delegate.contentLength\n    override val status: HttpStatusCode?\n        get() = delegate.status\n    override val headers: Headers\n        get() = delegate.headers\n\n    override fun <T : Any> getProperty(key: AttributeKey<T>): T? = delegate.getProperty(key)\n    override fun <T : Any> setProperty(key: AttributeKey<T>, value: T?): Unit = delegate.setProperty(key, value)\n\n    override fun readFrom(): ByteReadChannel = content.observable(callContext, contentLength, listener)\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.engine\n\nimport io.ktor.util.*\nimport io.ktor.utils.io.core.*\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\n/**\n * Abstract implementation of [HttpClientEngine] responsible for lifecycle control of [dispatcher] and\n * [coroutineContext] as well as proper call context management. Should be considered as the best parent class for\n * custom [HttpClientEngine] implementations.\n */\npublic abstract class HttpClientEngineBase(private val engineName: String) : HttpClientEngine {\n    private val closed = atomic(false)\n\n    override val coroutineContext: CoroutineContext by lazy {\n        SilentSupervisor() + dispatcher + CoroutineName(\"$engineName-context\")\n    }\n\n    override fun close() {\n        if (!closed.compareAndSet(false, true)) return\n\n        val requestJob = coroutineContext[Job] as? CompletableJob ?: return\n\n        requestJob.complete()\n        requestJob.invokeOnCompletion {\n            dispatcher.close()\n        }\n    }\n}\n\n/**\n * Exception that indicates that client engine is already closed.\n */\npublic class ClientEngineClosedException(override val cause: Throwable? = null) :\n    IllegalStateException(\"Client already closed\")\n\n/**\n * Close [CoroutineDispatcher] if it's [Closeable].\n */\nprivate fun CoroutineDispatcher.close() = try {\n    (this as? Closeable)?.close()\n} catch (ignore: Throwable) {\n    // Some closeable dispatchers like Dispatchers.IO can't be closed.\n}\n","package io.ktor.client.engine\n\nimport io.ktor.http.*\nimport io.ktor.util.network.*\n\n/**\n * Proxy configuration.\n *\n * See [ProxyBuilder] to create proxy.\n */\npublic expect class ProxyConfig\n\n/**\n * Type of configured proxy.\n */\npublic expect val ProxyConfig.type: ProxyType\n\n/**\n * Types of proxy\n */\n@Suppress(\"NO_EXPLICIT_VISIBILITY_IN_API_MODE_WARNING\", \"KDocMissingDocumentation\")\npublic enum class ProxyType {\n    SOCKS,\n    HTTP,\n    UNKNOWN\n}\n\n/**\n * Resolve remote address of [ProxyConfig].\n *\n * This operation can block.\n */\npublic expect fun ProxyConfig.resolveAddress(): NetworkAddress\n\n/**\n * [ProxyConfig] factory.\n */\npublic expect object ProxyBuilder {\n    /**\n     * Create http proxy from [url].\n     */\n    public fun http(url: Url): ProxyConfig\n\n    /**\n     * Create socks proxy from [host] and [port].\n     */\n    public fun socks(host: String, port: Int): ProxyConfig\n}\n\n/**\n * Create http proxy from [urlString].\n */\npublic fun ProxyBuilder.http(urlString: String): ProxyConfig = http(Url(urlString))\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.call\n\nimport io.ktor.client.*\nimport io.ktor.client.request.*\nimport io.ktor.client.statement.*\nimport io.ktor.http.*\nimport io.ktor.util.date.*\nimport io.ktor.utils.io.*\nimport io.ktor.utils.io.core.*\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\ninternal class SavedHttpCall(client: HttpClient, private val responseBody: ByteArray) : HttpClientCall(client) {\n\n    /** Returns new read channel of a response body */\n    override suspend fun getResponseContent(): ByteReadChannel {\n        return ByteReadChannel(responseBody)\n    }\n\n    override val allowDoubleReceive: Boolean = true\n}\n\ninternal class SavedHttpRequest(\n    override val call: SavedHttpCall,\n    origin: HttpRequest\n) : HttpRequest by origin\n\ninternal class SavedHttpResponse(\n    override val call: SavedHttpCall,\n    body: ByteArray,\n    origin: HttpResponse\n) : HttpResponse() {\n    private val context = Job()\n\n    override val status: HttpStatusCode = origin.status\n\n    override val version: HttpProtocolVersion = origin.version\n\n    override val requestTime: GMTDate = origin.requestTime\n\n    override val responseTime: GMTDate = origin.responseTime\n\n    override val headers: Headers = origin.headers\n\n    override val coroutineContext: CoroutineContext = origin.coroutineContext + context\n\n    override val content: ByteReadChannel = ByteReadChannel(body)\n}\n\n/**\n * Fetch data for [HttpClientCall] and close the origin.\n */\npublic suspend fun HttpClientCall.save(): HttpClientCall {\n    val currentClient = client ?: error(\"Failed to save call in different native thread.\")\n\n    val responseBody = response.content.readRemaining().readBytes()\n\n    return SavedHttpCall(currentClient, responseBody).also { result ->\n        result.request = SavedHttpRequest(result, request)\n        result.response = SavedHttpResponse(result, responseBody, response)\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.call\n\nimport kotlin.reflect.*\nimport io.ktor.util.reflect.Type as NewType\nimport io.ktor.util.reflect.TypeInfo as NewTypeInfo\nimport io.ktor.util.reflect.instanceOf as newInstanceOf\nimport io.ktor.util.reflect.typeInfo as newTypeInfo\n\n/**\n * Information about type.\n */\n@Deprecated(\n    \"This was moved to another package.\",\n    replaceWith = ReplaceWith(\"Type\", \"io.ktor.util.reflect.Type\")\n)\npublic typealias Type = NewType\n\n@Deprecated(\n    \"This was moved to another package.\",\n    replaceWith = ReplaceWith(\"TypeBase\", \"io.ktor.util.reflect.TypeBase\")\n)\n@PublishedApi\ninternal open class TypeBase<T>\n\n/**\n * Ktor type information.\n * @param type: source KClass<*>\n * @param reifiedType: type with substituted generics\n * @param kotlinType: kotlin reified type with all generic type parameters.\n */\n@Deprecated(\n    \"This was moved to another package.\",\n    replaceWith = ReplaceWith(\"TypeInfo\", \"io.ktor.util.reflect.TypeInfo\")\n)\npublic data class TypeInfo(\n    override val type: KClass<*>,\n    override val reifiedType: Type,\n    override val kotlinType: KType? = null\n) : NewTypeInfo\n\n/**\n * Returns [TypeInfo] for the specified type [T]\n */\n@Deprecated(\n    \"This was moved to another package.\",\n    replaceWith = ReplaceWith(\"typeInfo<T>()\", \"io.ktor.util.reflect.typeInfo\")\n)\npublic inline fun <reified T> typeInfo(): TypeInfo {\n    val info = newTypeInfo<T>()\n    return TypeInfo(info.type, info.reifiedType, info.kotlinType)\n}\n\n/**\n * Check [this] is instance of [type].\n */\n@Deprecated(\n    \"This was moved to another package.\",\n    replaceWith = ReplaceWith(\"this.instanceOf(type)\", \"io.ktor.util.reflect.instanceOf\")\n)\ninternal fun Any.instanceOf(type: KClass<*>): Boolean = newInstanceOf(type)\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.call\n\nimport io.ktor.client.*\nimport io.ktor.client.request.*\nimport io.ktor.http.*\nimport io.ktor.http.content.*\n\n@Suppress(\"KDocMissingDocumentation\")\npublic class UnsupportedContentTypeException(content: OutgoingContent) :\n    IllegalStateException(\"Failed to write body: ${content::class}\")\n\n@Suppress(\"KDocMissingDocumentation\", \"UNUSED\")\npublic class UnsupportedUpgradeProtocolException(\n    url: Url\n) : IllegalArgumentException(\"Unsupported upgrade protocol exception: $url\")\n\n/**\n * Constructs a [HttpClientCall] from this [HttpClient] and\n * with the specified HTTP request [builder].\n */\n@Deprecated(\n    \"Unbound [HttpClientCall] is deprecated. Consider using [request<HttpResponse>(builder)] instead.\",\n    level = DeprecationLevel.ERROR,\n    replaceWith = ReplaceWith(\"this.request<HttpResponse>(builder)\", \"io.ktor.client.statement.*\")\n)\n@Suppress(\"UNUSED\", \"UNUSED_PARAMETER\", \"RedundantSuspendModifier\")\npublic suspend fun HttpClient.call(builder: HttpRequestBuilder): HttpClientCall =\n    error(\"Unbound [HttpClientCall] is deprecated. Consider using [request<HttpResponse>(builder)] instead.\")\n\n/**\n * Constructs a [HttpClientCall] from this [HttpClient],\n * an [url] and an optional [block] configuring a [HttpRequestBuilder].\n */\n@Deprecated(\n    \"Unbound [HttpClientCall] is deprecated. Consider using [request<HttpResponse>(urlString, block)] instead.\",\n    level = DeprecationLevel.ERROR,\n    replaceWith = ReplaceWith(\n        \"this.request<HttpResponse>(urlString, block)\",\n        \"io.ktor.client.statement.*\"\n    )\n)\n@Suppress(\"UNUSED\", \"UNUSED_PARAMETER\", \"RedundantSuspendModifier\")\npublic suspend fun HttpClient.call(\n    urlString: String,\n    block: suspend HttpRequestBuilder.() -> Unit = {}\n): HttpClientCall = error(\n    \"Unbound [HttpClientCall] is deprecated. Consider using [request<HttpResponse>(urlString, block)] instead.\"\n)\n\n/**\n * Constructs a [HttpClientCall] from this [HttpClient],\n * an [url] and an optional [block] configuring a [HttpRequestBuilder].\n */\n@Deprecated(\n    \"Unbound [HttpClientCall] is deprecated. Consider using [request<HttpResponse>(url, block)] instead.\",\n    level = DeprecationLevel.ERROR,\n    replaceWith = ReplaceWith(\"this.request<HttpResponse>(url, block)\", \"io.ktor.client.statement.*\")\n)\n@Suppress(\"UNUSED\", \"UNUSED_PARAMETER\", \"RedundantSuspendModifier\")\npublic suspend fun HttpClient.call(\n    url: Url,\n    block: suspend HttpRequestBuilder.() -> Unit = {}\n): HttpClientCall = error(\n    \"Unbound [HttpClientCall] is deprecated. Consider using [request<HttpResponse>(url, block)] instead.\"\n)\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.engine\n\nimport io.ktor.client.*\nimport io.ktor.client.call.*\nimport io.ktor.client.request.*\nimport io.ktor.http.*\nimport io.ktor.util.*\nimport io.ktor.util.pipeline.*\nimport io.ktor.utils.io.*\nimport io.ktor.utils.io.core.*\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\nimport kotlin.native.concurrent.*\n\n@SharedImmutable\ninternal val CALL_COROUTINE = CoroutineName(\"call-context\")\n\n/**\n * Base interface use to define engines for [HttpClient].\n */\npublic interface HttpClientEngine : CoroutineScope, Closeable {\n    /**\n     * [CoroutineDispatcher] specified for io operations.\n     */\n    public val dispatcher: CoroutineDispatcher\n\n    /**\n     * Engine configuration\n     */\n    public val config: HttpClientEngineConfig\n\n    /**\n     * Set of supported engine extensions.\n     */\n    public val supportedCapabilities: Set<HttpClientEngineCapability<*>>\n        get() = emptySet()\n\n    private val closed: Boolean\n        get() = !(coroutineContext[Job]?.isActive ?: false)\n\n    /**\n     * Creates a new [HttpClientCall] specific for this engine, using a request [data].\n     */\n    @InternalAPI\n    public suspend fun execute(data: HttpRequestData): HttpResponseData\n\n    /**\n     * Install engine into [HttpClient].\n     */\n    @InternalAPI\n    public fun install(client: HttpClient) {\n        client.sendPipeline.intercept(HttpSendPipeline.Engine) { content ->\n            val requestData = HttpRequestBuilder().apply {\n                takeFromWithExecutionContext(context)\n                body = content\n            }.build()\n\n            validateHeaders(requestData)\n            checkExtensions(requestData)\n\n            val responseData = executeWithinCallContext(requestData)\n            val call = HttpClientCall(client, requestData, responseData)\n\n            proceedWith(call)\n        }\n    }\n\n    /**\n     * Create call context and use it as a coroutine context to [execute] request.\n     */\n    private suspend fun executeWithinCallContext(requestData: HttpRequestData): HttpResponseData {\n        val callContext = createCallContext(requestData.executionContext)\n        callContext.makeShared()\n\n        val context = callContext + KtorCallContextElement(callContext)\n        return async(context) {\n            if (closed) {\n                throw ClientEngineClosedException()\n            }\n\n            execute(requestData)\n        }.await()\n    }\n\n    private fun checkExtensions(requestData: HttpRequestData) {\n        for (requestedExtension in requestData.requiredCapabilities) {\n            require(supportedCapabilities.contains(requestedExtension)) { \"Engine doesn't support $requestedExtension\" }\n        }\n    }\n}\n\n/**\n * Factory of [HttpClientEngine] with a specific [T] of [HttpClientEngineConfig].\n */\npublic interface HttpClientEngineFactory<out T : HttpClientEngineConfig> {\n    /**\n     * Creates a new [HttpClientEngine] optionally specifying a [block] configuring [T].\n     */\n    public fun create(block: T.() -> Unit = {}): HttpClientEngine\n}\n\n/**\n * Creates a new [HttpClientEngineFactory] based on this one\n * with further configurations from the [nested] block.\n */\npublic fun <T : HttpClientEngineConfig> HttpClientEngineFactory<T>.config(\n    nested: T.() -> Unit\n): HttpClientEngineFactory<T> {\n    val parent = this\n\n    return object : HttpClientEngineFactory<T> {\n        override fun create(block: T.() -> Unit): HttpClientEngine = parent.create {\n            nested()\n            block()\n        }\n    }\n}\n\n/**\n * Create call context with the specified [parentJob] to be used during call execution in the engine. Call context\n * inherits [coroutineContext], but overrides job and coroutine name so that call job's parent is [parentJob] and\n * call coroutine's name is \"call-context\".\n */\ninternal expect suspend fun HttpClientEngine.createCallContext(parentJob: Job): CoroutineContext\n\n/**\n * Validates request headers and fails if there are unsafe headers supplied\n */\nprivate fun validateHeaders(request: HttpRequestData) {\n    val requestHeaders = request.headers\n    val unsafeRequestHeaders = requestHeaders.names().filter {\n        it in HttpHeaders.UnsafeHeadersList\n    }\n    if (unsafeRequestHeaders.isNotEmpty()) {\n        throw UnsafeHeaderException(unsafeRequestHeaders.toString())\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.engine\n\nimport io.ktor.client.utils.*\nimport io.ktor.http.*\nimport io.ktor.http.content.*\nimport io.ktor.util.*\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\n/**\n * Default user agent to use in ktor client.\n */\n@InternalAPI\npublic val KTOR_DEFAULT_USER_AGENT: String = \"Ktor client\"\n\n/**\n * Merge headers from [content] and [requestHeaders] according to [OutgoingContent] properties\n */\n@InternalAPI\npublic fun mergeHeaders(\n    requestHeaders: Headers,\n    content: OutgoingContent,\n    block: (key: String, value: String) -> Unit\n) {\n    buildHeaders {\n        appendAll(requestHeaders)\n        appendAll(content.headers)\n    }.forEach { key, values ->\n        if (HttpHeaders.ContentLength == key) return@forEach // set later\n        if (HttpHeaders.ContentType == key) return@forEach // set later\n\n        // https://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.2\n        block(key, values.joinToString(\",\"))\n    }\n\n    val missingAgent = requestHeaders[HttpHeaders.UserAgent] == null && content.headers[HttpHeaders.UserAgent] == null\n    if (missingAgent && needUserAgent()) {\n        block(HttpHeaders.UserAgent, KTOR_DEFAULT_USER_AGENT)\n    }\n\n    val type = content.contentType?.toString() ?: content.headers[HttpHeaders.ContentType]\n    val length = content.contentLength?.toString() ?: content.headers[HttpHeaders.ContentLength]\n\n    type?.let { block(HttpHeaders.ContentType, it) }\n    length?.let { block(HttpHeaders.ContentLength, it) }\n}\n\n/**\n * Returns current call context if exists, otherwise null.\n */\n@InternalAPI\npublic suspend fun callContext(): CoroutineContext = coroutineContext[KtorCallContextElement]!!.callContext\n\n/**\n * Coroutine context element containing call job.\n */\ninternal class KtorCallContextElement(val callContext: CoroutineContext) : CoroutineContext.Element {\n    override val key: CoroutineContext.Key<*>\n        get() = KtorCallContextElement\n\n    public companion object : CoroutineContext.Key<KtorCallContextElement>\n}\n\n/**\n * Attach [callJob] to user job using the following logic: when user job completes with exception, [callJob] completes\n * with exception too.\n */\n@OptIn(InternalCoroutinesApi::class)\ninternal suspend inline fun attachToUserJob(callJob: Job) {\n    val userJob = coroutineContext[Job] ?: return\n\n    val cleanupHandler = userJob.invokeOnCompletion(onCancelling = true) { cause ->\n        cause ?: return@invokeOnCompletion\n        callJob.cancel(CancellationException(cause.message))\n    }\n\n    callJob.invokeOnCompletion {\n        cleanupHandler.dispose()\n    }\n}\n\nprivate fun needUserAgent(): Boolean = !PlatformUtils.IS_BROWSER\n","/*\n * Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.client.features\n\nimport io.ktor.client.*\nimport io.ktor.client.call.*\nimport io.ktor.client.content.*\nimport io.ktor.client.features.observer.*\nimport io.ktor.client.request.*\nimport io.ktor.client.statement.*\nimport io.ktor.client.utils.*\nimport io.ktor.http.*\nimport io.ktor.http.content.*\nimport io.ktor.util.*\nimport io.ktor.util.pipeline.*\nimport kotlin.native.concurrent.*\n\n@SharedImmutable\nprivate val UploadProgressListenerAttributeKey =\n    AttributeKey<ProgressListener>(\"UploadProgressListenerAttributeKey\")\n\n@SharedImmutable\nprivate val DownloadProgressListenerAttributeKey =\n    AttributeKey<ProgressListener>(\"DownloadProgressListenerAttributeKey\")\n\n/**\n * Feature that provides observable progress for uploads and downloads\n */\npublic class BodyProgress internal constructor() {\n\n    private fun handle(scope: HttpClient) {\n        val observableContentPhase = PipelinePhase(\"ObservableContent\")\n        scope.requestPipeline.insertPhaseAfter(reference = HttpRequestPipeline.Render, phase = observableContentPhase)\n        scope.requestPipeline.intercept(observableContentPhase) { content ->\n            val listener = context.attributes\n                .getOrNull(UploadProgressListenerAttributeKey) ?: return@intercept\n\n            val observableContent = ObservableContent(content as OutgoingContent, context.executionContext, listener)\n            proceedWith(observableContent)\n        }\n\n        scope.receivePipeline.intercept(HttpReceivePipeline.After) { response ->\n            val listener = context.request.attributes\n                .getOrNull(DownloadProgressListenerAttributeKey) ?: return@intercept\n            val observableCall = context.withObservableDownload(listener)\n\n            context.response = observableCall.response\n            context.request = observableCall.request\n\n            proceedWith(context.response)\n        }\n    }\n\n    public companion object Feature : HttpClientFeature<Unit, BodyProgress> {\n        override val key: AttributeKey<BodyProgress> = AttributeKey(\"BodyProgress\")\n\n        override fun prepare(block: Unit.() -> Unit): BodyProgress {\n            return BodyProgress()\n        }\n\n        override fun install(feature: BodyProgress, scope: HttpClient) {\n            feature.handle(scope)\n        }\n    }\n}\n\ninternal fun HttpClientCall.withObservableDownload(listener: ProgressListener): HttpClientCall {\n    val observableByteChannel = response.content.observable(coroutineContext, response.contentLength(), listener)\n    return wrapWithContent(observableByteChannel)\n}\n\n/**\n * Registers listener to observe download progress.\n */\npublic fun HttpRequestBuilder.onDownload(listener: ProgressListener?) {\n    if (listener == null) {\n        attributes.remove(DownloadProgressListenerAttributeKey)\n    } else {\n        attributes.put(DownloadProgressListenerAttributeKey, listener)\n    }\n}\n\n/**\n * Registers listener to observe upload progress.\n */\npublic fun HttpRequestBuilder.onUpload(listener: ProgressListener?) {\n    if (listener == null) {\n        attributes.remove(UploadProgressListenerAttributeKey)\n    } else {\n        attributes.put(UploadProgressListenerAttributeKey, listener)\n    }\n}\n","/*\n * Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.client.features\n\nimport io.ktor.client.*\nimport io.ktor.util.*\nimport io.ktor.util.converters.DataConversion\n\n/**\n * Object for installing [io.ktor.util.converters.DataConversion] as feature\n */\npublic object DataConversion : HttpClientFeature<DataConversion.Configuration, DataConversion> {\n    override val key: AttributeKey<DataConversion> = AttributeKey(\"DataConversion\")\n\n    override fun prepare(block: DataConversion.Configuration.() -> Unit): DataConversion {\n        val configuration = DataConversion.Configuration().apply(block)\n        return DataConversion(configuration)\n    }\n\n    override fun install(feature: DataConversion, scope: HttpClient) {\n        // no op\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.features\n\nimport io.ktor.client.*\nimport io.ktor.client.request.*\nimport io.ktor.util.*\n\n/**\n * [Feature] is used to set request default parameters.\n */\npublic class DefaultRequest(private val builder: HttpRequestBuilder.() -> Unit) {\n\n    public companion object Feature : HttpClientFeature<HttpRequestBuilder, DefaultRequest> {\n        override val key: AttributeKey<DefaultRequest> = AttributeKey(\"DefaultRequest\")\n\n        override fun prepare(block: HttpRequestBuilder.() -> Unit): DefaultRequest =\n            DefaultRequest(block)\n\n        override fun install(feature: DefaultRequest, scope: HttpClient) {\n            scope.requestPipeline.intercept(HttpRequestPipeline.Before) {\n                context.apply(feature.builder)\n            }\n        }\n    }\n}\n\n/**\n * Set request default parameters.\n */\npublic fun HttpClientConfig<*>.defaultRequest(block: HttpRequestBuilder.() -> Unit) {\n    install(DefaultRequest) {\n        block()\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.features\n\nimport io.ktor.client.*\nimport io.ktor.client.call.*\nimport io.ktor.client.statement.*\nimport io.ktor.util.*\nimport io.ktor.utils.io.concurrent.*\nimport kotlin.jvm.*\nimport kotlin.native.concurrent.*\n\n@SharedImmutable\nprivate val ValidateMark = AttributeKey<Unit>(\"ValidateMark\")\n\n/**\n * Default response validation.\n * Check the response status code in range (0..299).\n */\npublic fun HttpClientConfig<*>.addDefaultResponseValidation() {\n    HttpResponseValidator {\n        @Suppress(\"DEPRECATION\")\n        expectSuccess = this@addDefaultResponseValidation.expectSuccess\n\n        validateResponse { response ->\n            val expectSuccess = response.call.attributes[ExpectSuccessAttributeKey]\n            if (!expectSuccess) {\n                return@validateResponse\n            }\n\n            val statusCode = response.status.value\n            val originCall = response.call\n            if (statusCode < 300 || originCall.attributes.contains(ValidateMark)) {\n                return@validateResponse\n            }\n\n            val exceptionCall = originCall.save().apply {\n                attributes.put(ValidateMark, Unit)\n            }\n\n            val exceptionResponse = exceptionCall.response\n            val exceptionResponseText = exceptionResponse.readText()\n            when (statusCode) {\n                in 300..399 -> throw RedirectResponseException(exceptionResponse, exceptionResponseText)\n                in 400..499 -> throw ClientRequestException(exceptionResponse, exceptionResponseText)\n                in 500..599 -> throw ServerResponseException(exceptionResponse, exceptionResponseText)\n                else -> throw ResponseException(exceptionResponse, exceptionResponseText)\n            }\n        }\n    }\n}\n\ninternal const val NO_RESPONSE_TEXT: String = \"<no response text provided>\"\ninternal const val DEPRECATED_EXCEPTION_CTOR: String = \"Please, provide response text in constructor\"\n\n/**\n * Base for default response exceptions.\n * @param [response]: origin response\n */\npublic open class ResponseException(\n    response: HttpResponse,\n    cachedResponseText: String\n) : IllegalStateException(\"Bad response: $response. Text: \\\"$cachedResponseText\\\"\") {\n    @Deprecated(level = DeprecationLevel.WARNING, message = DEPRECATED_EXCEPTION_CTOR)\n    public constructor(response: HttpResponse) : this(response, NO_RESPONSE_TEXT)\n\n    @delegate:Transient\n    private val _response: HttpResponse? by threadLocal(response)\n    public val response: HttpResponse\n        get() = _response ?: error(\"Failed to access response from a different native thread\")\n}\n\n/**\n * Unhandled redirect exception.\n */\n@Suppress(\"KDocMissingDocumentation\")\npublic class RedirectResponseException(response: HttpResponse, cachedResponseText: String) :\n    ResponseException(response, cachedResponseText) {\n    @Deprecated(level = DeprecationLevel.WARNING, message = DEPRECATED_EXCEPTION_CTOR)\n    public constructor(response: HttpResponse) : this(response, NO_RESPONSE_TEXT)\n\n    override val message: String? = \"Unhandled redirect: ${response.call.request.url}. \" +\n        \"Status: ${response.status}. Text: \\\"$cachedResponseText\\\"\"\n}\n\n/**\n * Server error exception.\n */\n@Suppress(\"KDocMissingDocumentation\")\npublic class ServerResponseException(\n    response: HttpResponse,\n    cachedResponseText: String\n) : ResponseException(response, cachedResponseText) {\n    @Deprecated(level = DeprecationLevel.WARNING, message = DEPRECATED_EXCEPTION_CTOR)\n    public constructor(response: HttpResponse) : this(response, NO_RESPONSE_TEXT)\n\n    override val message: String? = \"Server error(${response.call.request.url}: \" +\n        \"${response.status}. Text: \\\"$cachedResponseText\\\"\"\n}\n\n/**\n * Bad client request exception.\n */\n@Suppress(\"KDocMissingDocumentation\")\npublic class ClientRequestException(\n    response: HttpResponse,\n    cachedResponseText: String\n) : ResponseException(response, cachedResponseText) {\n    @Deprecated(level = DeprecationLevel.WARNING, message = DEPRECATED_EXCEPTION_CTOR)\n    public constructor(response: HttpResponse) : this(response, NO_RESPONSE_TEXT)\n\n    override val message: String = \"Client request(${response.call.request.url}) \" +\n        \"invalid: ${response.status}. Text: \\\"$cachedResponseText\\\"\"\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.features\n\nimport io.ktor.client.*\nimport io.ktor.client.request.*\nimport io.ktor.client.statement.*\nimport io.ktor.http.*\nimport io.ktor.http.content.*\nimport io.ktor.utils.io.*\nimport io.ktor.utils.io.core.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.CancellationException\n\n/**\n * Install default transformers.\n * Usually installed by default so there is no need to use it\n * unless you have disabled it via [HttpClientConfig.useDefaultTransformers].\n */\npublic fun HttpClient.defaultTransformers() {\n    val client = this\n\n    requestPipeline.intercept(HttpRequestPipeline.Render) { body ->\n        if (context.headers[HttpHeaders.Accept] == null) {\n            context.headers.append(HttpHeaders.Accept, \"*/*\")\n        }\n\n        val contentType = context.headers[HttpHeaders.ContentType]?.let {\n            ContentType.parse(it)\n        }\n\n        val content = when (body) {\n            is String -> {\n                TextContent(body, contentType ?: ContentType.Text.Plain)\n            }\n            is ByteArray -> object : OutgoingContent.ByteArrayContent() {\n                override val contentType: ContentType = contentType ?: ContentType.Application.OctetStream\n                override val contentLength: Long = body.size.toLong()\n                override fun bytes(): ByteArray = body\n            }\n            is ByteReadChannel -> object : OutgoingContent.ReadChannelContent() {\n                override val contentType: ContentType = contentType ?: ContentType.Application.OctetStream\n                override fun readFrom(): ByteReadChannel = body\n            }\n            else -> null\n        }\n\n        if (content != null) {\n            context.headers.remove(HttpHeaders.ContentType)\n            proceedWith(content)\n        }\n    }\n\n    responsePipeline.intercept(HttpResponsePipeline.Parse) { (info, body) ->\n        if (body !is ByteReadChannel) return@intercept\n        val response = context.response\n        val contentLength = response.headers[HttpHeaders.ContentLength]?.toLong() ?: Long.MAX_VALUE\n\n        when (info.type) {\n            Unit::class -> {\n                body.cancel()\n                proceedWith(HttpResponseContainer(info, Unit))\n            }\n            Int::class -> {\n                proceedWith(HttpResponseContainer(info, body.readRemaining().readText().toInt()))\n            }\n            ByteReadPacket::class,\n            Input::class -> {\n                proceedWith(HttpResponseContainer(info, body.readRemaining()))\n            }\n            ByteArray::class -> {\n                val readRemaining = body.readRemaining(contentLength)\n                if (contentLength < Long.MAX_VALUE) {\n                    check(readRemaining.remaining == contentLength) {\n                        \"Expected $contentLength, actual ${readRemaining.remaining}\"\n                    }\n                }\n\n                proceedWith(HttpResponseContainer(info, readRemaining.readBytes()))\n            }\n            ByteReadChannel::class -> {\n                // the response job could be already completed so the job holder\n                // could be cancelled immediately, but it doesn't matter\n                // since the copying job is running under the client job\n                val responseJobHolder = Job(response.coroutineContext[Job])\n                val channel: ByteReadChannel = writer(client.coroutineContext) {\n                    try {\n                        body.copyTo(channel, limit = Long.MAX_VALUE)\n                    } catch (cause: CancellationException) {\n                        response.cancel(cause)\n                        throw cause\n                    } catch (cause: Throwable) {\n                        response.cancel(\"Receive failed\", cause)\n                        throw cause\n                    } finally {\n                        response.complete()\n                    }\n                }.also { writerJob ->\n                    writerJob.invokeOnCompletion {\n                        responseJobHolder.complete()\n                    }\n                }.channel\n\n                proceedWith(HttpResponseContainer(info, channel))\n            }\n            HttpStatusCode::class -> {\n                body.cancel()\n                proceedWith(HttpResponseContainer(info, response.status))\n            }\n        }\n    }\n\n    platformDefaultTransformers()\n}\n\ninternal expect fun HttpClient.platformDefaultTransformers()\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.features\n\nimport io.ktor.client.*\nimport io.ktor.util.*\n\n@Deprecated(\n    \"[BadResponseStatusException] is deprecated. Use [ResponseException] instead.\",\n    ReplaceWith(\"ResponseException\"),\n    DeprecationLevel.ERROR\n)\n@Suppress(\"KDocMissingDocumentation\")\npublic typealias BadResponseStatusException = ResponseException\n\n@Deprecated(\n    \"Use [HttpCallValidator] instead.\",\n    ReplaceWith(\"HttpCallValidator\"),\n    DeprecationLevel.ERROR\n)\n@Suppress(\"KDocMissingDocumentation\")\npublic class ExpectSuccess {\n    @Suppress(\"DEPRECATION_ERROR\")\n    public companion object : HttpClientFeature<Unit, ExpectSuccess> {\n\n        override val key: AttributeKey<ExpectSuccess>\n            get() = error(\"Deprecated\")\n\n        override fun prepare(block: Unit.() -> Unit): ExpectSuccess {\n            error(\"Deprecated\")\n        }\n\n        override fun install(feature: ExpectSuccess, scope: HttpClient) {\n            error(\"Deprecated\")\n        }\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.features\n\nimport io.ktor.client.*\nimport io.ktor.client.features.HttpCallValidator.*\nimport io.ktor.client.request.*\nimport io.ktor.client.statement.*\nimport io.ktor.client.utils.*\nimport io.ktor.util.*\nimport io.ktor.util.pipeline.*\nimport kotlin.native.concurrent.*\n\n/**\n * Response validator method.\n *\n * You could throw an exception to fail the response.\n */\npublic typealias ResponseValidator = suspend (response: HttpResponse) -> Unit\n\n/**\n * Response exception handler method.\n */\npublic typealias CallExceptionHandler = suspend (cause: Throwable) -> Unit\n\n/**\n * Response validator feature is used for validate response and handle response exceptions.\n *\n * See also [Config] for additional details.\n */\npublic class HttpCallValidator internal constructor(\n    private val responseValidators: List<ResponseValidator>,\n    private val callExceptionHandlers: List<CallExceptionHandler>,\n    private val expectSuccess: Boolean\n) {\n\n    /**\n     * Response validator feature is used for validate response and handle response exceptions.\n     *\n     * See also [Config] for additional details.\n     */\n    @Deprecated(\n        \"This is going to become internal. \" +\n            \"Please file a ticket and clarify, why do you need it.\"\n    )\n    public constructor(\n        responseValidators: List<ResponseValidator>,\n        callExceptionHandlers: List<CallExceptionHandler>\n    ) : this(responseValidators, callExceptionHandlers, true)\n\n    private suspend fun validateResponse(response: HttpResponse) {\n        responseValidators.forEach { it(response) }\n    }\n\n    private suspend fun processException(cause: Throwable) {\n        callExceptionHandlers.forEach { it(cause) }\n    }\n\n    /**\n     * [HttpCallValidator] configuration.\n     */\n    public class Config {\n        internal val responseValidators: MutableList<ResponseValidator> = mutableListOf()\n        internal val responseExceptionHandlers: MutableList<CallExceptionHandler> = mutableListOf()\n\n        /**\n         * Terminate [HttpClient.receivePipeline] if status code is not successful (>=300).\n         */\n\n        @Deprecated(\n            \"This property is ignored. Please use `expectSuccess` property in HttpClientConfig. \" +\n                \"This is going to become internal.\"\n        )\n        public var expectSuccess: Boolean = true\n\n        /**\n         * Add [CallExceptionHandler].\n         * Last added handler executes first.\n         */\n        public fun handleResponseException(block: CallExceptionHandler) {\n            responseExceptionHandlers += block\n        }\n\n        /**\n         * Add [ResponseValidator].\n         * Last added validator executes first.\n         */\n        public fun validateResponse(block: ResponseValidator) {\n            responseValidators += block\n        }\n    }\n\n    public companion object : HttpClientFeature<Config, HttpCallValidator> {\n        override val key: AttributeKey<HttpCallValidator> = AttributeKey(\"HttpResponseValidator\")\n\n        override fun prepare(block: Config.() -> Unit): HttpCallValidator {\n            val config = Config().apply(block)\n\n            return HttpCallValidator(\n                config.responseValidators.reversed(),\n                config.responseExceptionHandlers.reversed(),\n                config.expectSuccess\n            )\n        }\n\n        override fun install(feature: HttpCallValidator, scope: HttpClient) {\n            scope.requestPipeline.intercept(HttpRequestPipeline.Before) {\n                try {\n                    context.attributes.computeIfAbsent(ExpectSuccessAttributeKey) { feature.expectSuccess }\n                    proceedWith(it)\n                } catch (cause: Throwable) {\n                    val unwrappedCause = cause.unwrapCancellationException()\n                    feature.processException(unwrappedCause)\n                    throw unwrappedCause\n                }\n            }\n\n            val BeforeReceive = PipelinePhase(\"BeforeReceive\")\n            scope.responsePipeline.insertPhaseBefore(HttpResponsePipeline.Receive, BeforeReceive)\n            scope.responsePipeline.intercept(BeforeReceive) { container ->\n                try {\n                    proceedWith(container)\n                } catch (cause: Throwable) {\n                    val unwrappedCause = cause.unwrapCancellationException()\n                    feature.processException(unwrappedCause)\n                    throw unwrappedCause\n                }\n            }\n\n            scope[HttpSend].intercept { call, _ ->\n                feature.validateResponse(call.response)\n                call\n            }\n        }\n    }\n}\n\n/**\n * Install [HttpCallValidator] with [block] configuration.\n */\npublic fun HttpClientConfig<*>.HttpResponseValidator(block: HttpCallValidator.Config.() -> Unit) {\n    install(HttpCallValidator, block)\n}\n\n/**\n * Terminate [HttpClient.receivePipeline] if status code is not successful (>=300).\n */\npublic var HttpRequestBuilder.expectSuccess: Boolean\n    get() = attributes.getOrNull(ExpectSuccessAttributeKey) ?: true\n    set(value) = attributes.put(ExpectSuccessAttributeKey, value)\n\n@SharedImmutable\ninternal val ExpectSuccessAttributeKey = AttributeKey<Boolean>(\"ExpectSuccessAttributeKey\")\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.features\n\nimport io.ktor.client.*\nimport io.ktor.util.*\nimport kotlin.native.concurrent.*\n\n@SharedImmutable\ninternal val FEATURE_INSTALLED_LIST = AttributeKey<Attributes>(\"ApplicationFeatureRegistry\")\n\n/**\n * Base interface representing a [HttpClient] feature.\n */\npublic interface HttpClientFeature<out TConfig : Any, TFeature : Any> {\n    /**\n     * The [AttributeKey] for this feature.\n     */\n    public val key: AttributeKey<TFeature>\n\n    /**\n     * Builds a [TFeature] by calling the [block] with a [TConfig] config instance as receiver.\n     */\n    public fun prepare(block: TConfig.() -> Unit = {}): TFeature\n\n    /**\n     * Installs the [feature] class for a [HttpClient] defined at [scope].\n     */\n    public fun install(feature: TFeature, scope: HttpClient)\n}\n\n/**\n * Try to get the [feature] installed in this client. Returns `null` if the feature was not previously installed.\n */\npublic fun <B : Any, F : Any> HttpClient.feature(feature: HttpClientFeature<B, F>): F? =\n    attributes.getOrNull(FEATURE_INSTALLED_LIST)?.getOrNull(feature.key)\n\n/**\n * Find the [feature] installed in [HttpClient].\n *\n * @throws [IllegalStateException] if [feature] is not installed.\n */\npublic operator fun <B : Any, F : Any> HttpClient.get(feature: HttpClientFeature<B, F>): F {\n    val requestedFeature = feature(feature)\n    if (requestedFeature != null) {\n        return requestedFeature\n    }\n\n    val message = \"Feature $feature is not installed. Consider using `install(${feature.key})` in client config first.\"\n    error(message)\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.features\n\nimport io.ktor.client.*\nimport io.ktor.client.call.*\nimport io.ktor.client.request.*\nimport io.ktor.client.statement.*\nimport io.ktor.http.*\nimport io.ktor.http.content.*\nimport io.ktor.util.*\nimport io.ktor.utils.io.*\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.*\nimport kotlin.math.*\n\n/**\n * [HttpClient] feature that encodes [String] request bodies to [TextContent]\n * and processes the response body as [String].\n *\n * To configure charsets set following properties in [HttpPlainText.Config].\n */\npublic class HttpPlainText internal constructor(\n    charsets: Set<Charset>,\n    charsetQuality: Map<Charset, Float>,\n    sendCharset: Charset?,\n    private val responseCharsetFallback: Charset\n) {\n    private val requestCharset: Charset\n    private val acceptCharsetHeader: String\n\n    init {\n        val withQuality = charsetQuality.toList().sortedByDescending { it.second }\n        val withoutQuality = charsets.filter { !charsetQuality.containsKey(it) }.sortedBy { it.name }\n\n        acceptCharsetHeader = buildString {\n            withoutQuality.forEach {\n                if (length > 0) append(\",\")\n                append(it.name)\n            }\n\n            withQuality.forEach { (charset, quality) ->\n                if (length > 0) append(\",\")\n\n                check(quality in 0.0..1.0)\n\n                val truncatedQuality = (100 * quality).roundToInt() / 100.0\n                append(\"${charset.name};q=$truncatedQuality\")\n            }\n\n            if (isEmpty()) {\n                append(responseCharsetFallback.name)\n            }\n        }\n\n        requestCharset = sendCharset\n            ?: withoutQuality.firstOrNull() ?: withQuality.firstOrNull()?.first ?: Charsets.UTF_8\n    }\n\n    /**\n     * Charset configuration for [HttpPlainText] feature.\n     */\n    public class Config {\n        internal val charsets: MutableSet<Charset> = mutableSetOf()\n        internal val charsetQuality: MutableMap<Charset, Float> = mutableMapOf()\n\n        /**\n         * Add [charset] to allowed list with selected [quality].\n         */\n        public fun register(charset: Charset, quality: Float? = null) {\n            quality?.let { check(it in 0.0..1.0) }\n\n            charsets.add(charset)\n\n            if (quality == null) {\n                charsetQuality.remove(charset)\n            } else {\n                charsetQuality[charset] = quality\n            }\n        }\n\n        /**\n         * Explicit [Charset] for sending content.\n         *\n         * Use first with the highest quality from [register] charset if null.\n         */\n        public var sendCharset: Charset? = null\n\n        /**\n         * Fallback charset for the response.\n         * Use it if no charset specified.\n         */\n        public var responseCharsetFallback: Charset = Charsets.UTF_8\n\n        /**\n         * Default [Charset] to use.\n         */\n        @Suppress(\"unused\")\n        @Deprecated(\n            \"Use [register] method instead.\",\n            replaceWith = ReplaceWith(\"register()\"),\n            level = DeprecationLevel.ERROR\n        )\n        public var defaultCharset: Charset = Charsets.UTF_8\n    }\n\n    @Suppress(\"KDocMissingDocumentation\")\n    public companion object Feature : HttpClientFeature<Config, HttpPlainText> {\n        override val key: AttributeKey<HttpPlainText> = AttributeKey(\"HttpPlainText\")\n\n        override fun prepare(block: Config.() -> Unit): HttpPlainText {\n            val config = Config().apply(block)\n\n            with(config) {\n                return HttpPlainText(\n                    charsets,\n                    charsetQuality,\n                    sendCharset,\n                    responseCharsetFallback\n                )\n            }\n        }\n\n        override fun install(feature: HttpPlainText, scope: HttpClient) {\n            scope.requestPipeline.intercept(HttpRequestPipeline.Render) { content ->\n                feature.addCharsetHeaders(context)\n\n                if (content !is String) {\n                    return@intercept\n                }\n\n                val contentType = context.contentType()\n                if (contentType != null && contentType.contentType != ContentType.Text.Plain.contentType) {\n                    return@intercept\n                }\n\n                val contentCharset = contentType?.charset()\n                proceedWith(feature.wrapContent(content, contentCharset))\n            }\n\n            scope.responsePipeline.intercept(HttpResponsePipeline.Parse) { (info, body) ->\n                if (info.type != String::class || body !is ByteReadChannel) return@intercept\n\n                val bodyBytes = body.readRemaining()\n                val content = feature.read(context, bodyBytes)\n                proceedWith(HttpResponseContainer(info, content))\n            }\n        }\n    }\n\n    private fun wrapContent(content: String, contentCharset: Charset?): Any {\n        val charset = contentCharset ?: requestCharset\n        return TextContent(content, ContentType.Text.Plain.withCharset(charset))\n    }\n\n    internal fun read(call: HttpClientCall, body: Input): String {\n        val actualCharset = call.response.charset() ?: responseCharsetFallback\n        return body.readText(charset = actualCharset)\n    }\n\n    internal fun addCharsetHeaders(context: HttpRequestBuilder) {\n        if (context.headers[HttpHeaders.AcceptCharset] != null) return\n        context.headers[HttpHeaders.AcceptCharset] = acceptCharsetHeader\n    }\n\n    /**\n     * Deprecated\n     */\n    @Suppress(\"unused\", \"UNUSED_PARAMETER\")\n    @Deprecated(\n        \"Use [Config.register] method instead.\",\n        replaceWith = ReplaceWith(\"register()\"),\n        level = DeprecationLevel.ERROR\n    )\n    public var defaultCharset: Charset\n        get() = error(\"defaultCharset is deprecated\")\n        set(value) = error(\"defaultCharset is deprecated\")\n}\n\n/**\n * Configure client charsets.\n *\n * ```kotlin\n * val client = HttpClient {\n *     Charsets {\n *         register(Charsets.UTF_8)\n *         register(Charsets.ISO_8859_1, quality = 0.1)\n *     }\n * }\n * ```\n */\n@Suppress(\"FunctionName\")\npublic fun HttpClientConfig<*>.Charsets(block: HttpPlainText.Config.() -> Unit) {\n    install(HttpPlainText, block)\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.features\n\nimport io.ktor.client.*\nimport io.ktor.client.call.*\nimport io.ktor.client.request.*\nimport io.ktor.http.*\nimport io.ktor.util.*\nimport kotlinx.atomicfu.*\nimport kotlin.jvm.*\nimport kotlin.native.concurrent.*\n\n@ThreadLocal\nprivate val ALLOWED_FOR_REDIRECT: Set<HttpMethod> = setOf(HttpMethod.Get, HttpMethod.Head)\n\n/**\n * [HttpClient] feature that handles http redirect\n */\npublic class HttpRedirect {\n    private val _checkHttpMethod = atomic(true)\n    private val _allowHttpsDowngrade = atomic(false)\n\n    /**\n     * Check if the HTTP method is allowed for redirect.\n     * Only [HttpMethod.Get] and [HttpMethod.Head] is allowed for implicit redirect.\n     *\n     * Please note: changing this flag could lead to security issues, consider changing the request URL instead.\n     */\n    public var checkHttpMethod: Boolean\n        get() = _checkHttpMethod.value\n        set(value) {\n            _checkHttpMethod.value = value\n        }\n\n    /**\n     * `true` value allows client redirect with downgrade from https to plain http.\n     */\n    public var allowHttpsDowngrade: Boolean\n        get() = _allowHttpsDowngrade.value\n        set(value) {\n            _allowHttpsDowngrade.value = value\n        }\n\n    public companion object Feature : HttpClientFeature<HttpRedirect, HttpRedirect> {\n        override val key: AttributeKey<HttpRedirect> = AttributeKey(\"HttpRedirect\")\n\n        override fun prepare(block: HttpRedirect.() -> Unit): HttpRedirect = HttpRedirect().apply(block)\n\n        override fun install(feature: HttpRedirect, scope: HttpClient) {\n            scope[HttpSend].intercept { origin, context ->\n                if (feature.checkHttpMethod && origin.request.method !in ALLOWED_FOR_REDIRECT) {\n                    return@intercept origin\n                }\n\n                handleCall(context, origin, feature.allowHttpsDowngrade)\n            }\n        }\n\n        private suspend fun Sender.handleCall(\n            context: HttpRequestBuilder,\n            origin: HttpClientCall,\n            allowHttpsDowngrade: Boolean\n        ): HttpClientCall {\n            if (!origin.response.status.isRedirect()) return origin\n\n            var call = origin\n            var requestBuilder = context\n            val originProtocol = origin.request.url.protocol\n            val originAuthority = origin.request.url.authority\n            while (true) {\n                val location = call.response.headers[HttpHeaders.Location]\n\n                requestBuilder = HttpRequestBuilder().apply {\n                    takeFromWithExecutionContext(requestBuilder)\n                    url.parameters.clear()\n                    url.parameters.urlEncodingOption = UrlEncodingOption.NO_ENCODING\n\n                    location?.let { url.takeFrom(it) }\n\n                    /**\n                     * Disallow redirect with a security downgrade.\n                     */\n                    if (!allowHttpsDowngrade && originProtocol.isSecure() && !url.protocol.isSecure()) {\n                        return call\n                    }\n\n                    if (originAuthority != url.authority) {\n                        headers.remove(HttpHeaders.Authorization)\n                    }\n                }\n\n                call = execute(requestBuilder)\n                if (!call.response.status.isRedirect()) return call\n            }\n        }\n    }\n}\n\nprivate fun HttpStatusCode.isRedirect(): Boolean = when (value) {\n    HttpStatusCode.MovedPermanently.value,\n    HttpStatusCode.Found.value,\n    HttpStatusCode.TemporaryRedirect.value,\n    HttpStatusCode.PermanentRedirect.value,\n    HttpStatusCode.SeeOther.value -> true\n    else -> false\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.features\n\nimport io.ktor.client.*\nimport io.ktor.client.request.*\nimport io.ktor.util.*\nimport io.ktor.utils.io.*\nimport kotlinx.coroutines.*\n\n/**\n * Client HTTP feature that sets up [HttpRequestBuilder.executionContext] and completes it when the pipeline is fully\n * processed.\n */\ninternal class HttpRequestLifecycle {\n    /**\n     * Companion object for feature installation.\n     */\n    companion object Feature : HttpClientFeature<Unit, HttpRequestLifecycle> {\n\n        override val key: AttributeKey<HttpRequestLifecycle> = AttributeKey(\"RequestLifecycle\")\n\n        override fun prepare(block: Unit.() -> Unit): HttpRequestLifecycle = HttpRequestLifecycle()\n\n        override fun install(feature: HttpRequestLifecycle, scope: HttpClient) {\n            scope.requestPipeline.intercept(HttpRequestPipeline.Before) {\n                val executionContext = Job(context.executionContext).also {\n                    it.makeShared()\n                }\n\n                attachToClientEngineJob(executionContext, scope.coroutineContext[Job]!!)\n\n                try {\n                    context.executionContext = executionContext\n                    proceed()\n                } catch (cause: Throwable) {\n                    executionContext.completeExceptionally(cause)\n                    throw cause\n                } finally {\n                    executionContext.complete()\n                }\n            }\n        }\n    }\n}\n\n/**\n * Attach client engine job.\n */\nprivate fun attachToClientEngineJob(\n    requestJob: CompletableJob,\n    clientEngineJob: Job\n) {\n    clientEngineJob.makeShared()\n\n    val handler = clientEngineJob.invokeOnCompletion { cause ->\n        if (cause != null) {\n            requestJob.cancel(\"Engine failed\", cause)\n        } else {\n            requestJob.complete()\n        }\n    }\n\n    requestJob.invokeOnCompletion {\n        handler.dispose()\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.features\n\nimport io.ktor.client.*\nimport io.ktor.client.call.*\nimport io.ktor.client.request.*\nimport io.ktor.client.utils.*\nimport io.ktor.http.content.*\nimport io.ktor.util.*\nimport io.ktor.utils.io.*\nimport io.ktor.utils.io.concurrent.*\nimport kotlinx.coroutines.*\n\n/**\n * HttpSend pipeline interceptor function\n */\npublic typealias HttpSendInterceptor = suspend Sender.(HttpClientCall, HttpRequestBuilder) -> HttpClientCall\n\n/**\n * HttpSend pipeline interceptor function backward compatible with previous implementation.\n */\npublic typealias HttpSendInterceptorBackwardCompatible = suspend Sender.(HttpClientCall) -> HttpClientCall\n\n/**\n * This interface represents a request send pipeline interceptor chain\n */\npublic interface Sender {\n    /**\n     * Execute send pipeline. It could start pipeline execution or replace the call\n     */\n    public suspend fun execute(requestBuilder: HttpRequestBuilder): HttpClientCall\n}\n\n/**\n * This is internal feature that is always installed.\n * @property maxSendCount is a maximum number of requests that can be sent during a call\n */\npublic class HttpSend(\n    maxSendCount: Int = 20\n) {\n    public var maxSendCount: Int by shared(maxSendCount)\n\n    private val interceptors: MutableList<HttpSendInterceptor> = sharedList()\n\n    init {\n        makeShared()\n    }\n\n    /**\n     * Install send pipeline starter interceptor\n     */\n    public fun intercept(block: HttpSendInterceptor) {\n        interceptors += block\n    }\n\n    /**\n     * Install send pipeline starter interceptor (backward compatible function).\n     */\n    @Deprecated(\"Intercept with one parameter is deprecated, use both call and request builder as parameters.\")\n    public fun intercept(block: HttpSendInterceptorBackwardCompatible) {\n        interceptors += { call, _ ->\n            block(call)\n        }\n    }\n\n    /**\n     * Feature installation object\n     */\n    public companion object Feature : HttpClientFeature<HttpSend, HttpSend> {\n        override val key: AttributeKey<HttpSend> = AttributeKey(\"HttpSend\")\n\n        override fun prepare(block: HttpSend.() -> Unit): HttpSend = HttpSend().apply(block)\n\n        override fun install(feature: HttpSend, scope: HttpClient) {\n            // default send scenario\n            scope.requestPipeline.intercept(HttpRequestPipeline.Send) { content ->\n                check(content is OutgoingContent) {\n                    \"\"\"\n|Fail to serialize body. Content has type: ${content::class}, but OutgoingContent expected.\n|If you expect serialized body, please check that you have installed the corresponding feature(like `Json`) and set `Content-Type` header.\"\"\"\n                        .trimMargin()\n                }\n                context.body = content\n\n                val sender = DefaultSender(feature.maxSendCount, scope)\n                var currentCall = sender.execute(context)\n                var callChanged: Boolean\n\n                do {\n                    callChanged = false\n\n                    passInterceptors@ for (interceptor in feature.interceptors) {\n                        val transformed = interceptor(sender, currentCall, context)\n                        if (transformed === currentCall) continue@passInterceptors\n\n                        currentCall = transformed\n                        callChanged = true\n                        break@passInterceptors\n                    }\n                } while (callChanged)\n\n                proceedWith(currentCall)\n            }\n        }\n    }\n\n    private class DefaultSender(\n        private val maxSendCount: Int,\n        private val client: HttpClient\n    ) : Sender {\n        private var sentCount: Int = 0\n        private var currentCall: HttpClientCall? = null\n\n        override suspend fun execute(requestBuilder: HttpRequestBuilder): HttpClientCall {\n            currentCall?.cancel()\n\n            if (sentCount >= maxSendCount) {\n                throw SendCountExceedException(\n                    \"Max send count $maxSendCount exceeded. Consider increasing the property \" +\n                        \"maxSendCount if more is required.\"\n                )\n            }\n\n            sentCount++\n            val sendResult = client.sendPipeline.execute(\n                requestBuilder,\n                requestBuilder.body\n            )\n\n            val call = sendResult as? HttpClientCall\n                ?: error(\"Failed to execute send pipeline. Expected [HttpClientCall], but received $sendResult\")\n\n            currentCall = call\n            return call\n        }\n    }\n}\n\n/**\n * Thrown when too many actual requests were sent during a client call.\n * It could be caused by infinite or too long redirect sequence.\n * Maximum number of requests is limited by [HttpSend.maxSendCount]\n */\npublic class SendCountExceedException(message: String) : IllegalStateException(message)\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.features.cache\n\nimport io.ktor.client.*\nimport io.ktor.client.engine.*\nimport io.ktor.client.features.*\nimport io.ktor.client.features.cache.storage.*\nimport io.ktor.client.request.*\nimport io.ktor.client.statement.*\nimport io.ktor.http.*\nimport io.ktor.http.content.*\nimport io.ktor.util.*\nimport io.ktor.util.pipeline.*\n\ninternal object CacheControl {\n    internal val NO_STORE = HeaderValue(\"no-store\")\n    internal val NO_CACHE = HeaderValue(\"no-cache\")\n    internal val PRIVATE = HeaderValue(\"private\")\n    internal val MUST_REVALIDATE = HeaderValue(\"must-revalidate\")\n}\n\n/**\n * This feature allows using HTTP cache.\n *\n * For detailed description follow: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control\n */\npublic class HttpCache(\n    public val publicStorage: HttpCacheStorage,\n    public val privateStorage: HttpCacheStorage\n) {\n    /**\n     * [HttpCache] configuration.\n     */\n    public class Config {\n        /**\n         * Storage for public cache entries.\n         *\n         * Use [HttpCacheStorage.Unlimited] by default.\n         */\n        public var publicStorage: HttpCacheStorage = HttpCacheStorage.Unlimited()\n\n        /**\n         * Storage for private cache entries.\n         *\n         * [HttpCacheStorage.Unlimited] by default.\n         *\n         * Consider using [HttpCacheStorage.Disabled] if the client used as intermediate.\n         */\n        public var privateStorage: HttpCacheStorage = HttpCacheStorage.Unlimited()\n    }\n\n    public companion object : HttpClientFeature<Config, HttpCache> {\n        override val key: AttributeKey<HttpCache> = AttributeKey(\"HttpCache\")\n\n        override fun prepare(block: Config.() -> Unit): HttpCache {\n            val config = Config().apply(block)\n\n            with(config) {\n                return HttpCache(publicStorage, privateStorage)\n            }\n        }\n\n        override fun install(feature: HttpCache, scope: HttpClient) {\n            val CachePhase = PipelinePhase(\"Cache\")\n            scope.sendPipeline.insertPhaseAfter(HttpSendPipeline.State, CachePhase)\n\n            scope.sendPipeline.intercept(CachePhase) { content ->\n                if (content !is OutgoingContent.NoContent) return@intercept\n                if (context.method != HttpMethod.Get || !context.url.protocol.canStore()) return@intercept\n\n                val cache = feature.findResponse(context, content) ?: return@intercept\n                if (!cache.shouldValidate()) {\n                    finish()\n                    proceedWith(cache.produceResponse().call)\n\n                    return@intercept\n                }\n\n                cache.responseHeaders[HttpHeaders.ETag]?.let { etag ->\n                    context.header(HttpHeaders.IfNoneMatch, etag)\n                }\n\n                cache.responseHeaders[HttpHeaders.LastModified]?.let {\n                    context.header(HttpHeaders.IfModifiedSince, it)\n                }\n            }\n\n            scope.receivePipeline.intercept(HttpReceivePipeline.State) { response ->\n                if (context.request.method != HttpMethod.Get) return@intercept\n\n                if (response.status.isSuccess()) {\n                    val reusableResponse = feature.cacheResponse(response)\n                    proceedWith(reusableResponse)\n                    return@intercept\n                }\n\n                if (response.status == HttpStatusCode.NotModified) {\n                    response.complete()\n                    val responseFromCache = feature.findAndRefresh(context.request, response)\n                        ?: throw InvalidCacheStateException(context.request.url)\n\n                    proceedWith(responseFromCache)\n                }\n            }\n        }\n    }\n\n    private suspend fun cacheResponse(response: HttpResponse): HttpResponse {\n        val request = response.call.request\n        val responseCacheControl: List<HeaderValue> = response.cacheControl()\n\n        val storage = if (CacheControl.PRIVATE in responseCacheControl) privateStorage else publicStorage\n\n        if (CacheControl.NO_STORE in responseCacheControl) {\n            return response\n        }\n\n        val cacheEntry = storage.store(request.url, response)\n        return cacheEntry.produceResponse()\n    }\n\n    private fun findAndRefresh(request: HttpRequest, response: HttpResponse): HttpResponse? {\n        val url = response.call.request.url\n        val cacheControl = response.cacheControl()\n\n        val storage = if (CacheControl.PRIVATE in cacheControl) privateStorage else publicStorage\n\n        val varyKeysFrom304 = response.varyKeys()\n        val cache = findResponse(storage, varyKeysFrom304, url, request) ?: return null\n        val newVaryKeys = if (varyKeysFrom304.isNullOrEmpty()) cache.varyKeys else varyKeysFrom304\n        storage.store(url, HttpCacheEntry(response.cacheExpires(), newVaryKeys, cache.response, cache.body))\n        return cache.produceResponse()\n    }\n\n    private fun findResponse(\n        storage: HttpCacheStorage,\n        varyKeys: Map<String, String>,\n        url: Url,\n        request: HttpRequest\n    ): HttpCacheEntry? = when {\n        varyKeys.isNotEmpty() -> {\n            storage.find(url, varyKeys)\n        }\n        else -> {\n            val requestHeaders = mergedHeadersLookup(request.content, request.headers::get, request.headers::getAll)\n            storage.findByUrl(url)\n                .sortedByDescending { it.response.responseTime }\n                .firstOrNull { cachedResponse ->\n                    cachedResponse.varyKeys.all { (key, value) -> requestHeaders(key) == value }\n                }\n        }\n    }\n\n    private fun findResponse(context: HttpRequestBuilder, content: OutgoingContent): HttpCacheEntry? {\n        val url = Url(context.url)\n        val lookup = mergedHeadersLookup(content, context.headers::get, context.headers::getAll)\n\n        val cachedResponses = privateStorage.findByUrl(url) + publicStorage.findByUrl(url)\n        for (item in cachedResponses) {\n            val varyKeys = item.varyKeys\n            if (varyKeys.isEmpty() || varyKeys.all { (key, value) -> lookup(key) == value }) {\n                return item\n            }\n        }\n\n        return null\n    }\n}\n\nprivate fun mergedHeadersLookup(\n    content: OutgoingContent,\n    headerExtractor: (String) -> String?,\n    allHeadersExtractor: (String) -> List<String>?,\n): (String) -> String = block@{ header ->\n    return@block when (header) {\n        HttpHeaders.ContentLength -> content.contentLength?.toString() ?: \"\"\n        HttpHeaders.ContentType -> content.contentType?.toString() ?: \"\"\n        HttpHeaders.UserAgent -> {\n            content.headers[HttpHeaders.UserAgent] ?: headerExtractor(HttpHeaders.UserAgent) ?: KTOR_DEFAULT_USER_AGENT\n        }\n        else -> {\n            val value = content.headers.getAll(header) ?: allHeadersExtractor(header) ?: emptyList()\n            value.joinToString(\";\")\n        }\n    }\n}\n\n@Suppress(\"KDocMissingDocumentation\")\npublic class InvalidCacheStateException(requestUrl: Url) : IllegalStateException(\n    \"The entry for url: $requestUrl was removed from cache\"\n)\n\nprivate fun URLProtocol.canStore(): Boolean = name == \"http\" || name == \"https\"\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.features.cookies\n\nimport io.ktor.client.*\nimport io.ktor.client.features.*\nimport io.ktor.client.features.cookies.HttpCookies.*\nimport io.ktor.client.request.*\nimport io.ktor.client.statement.*\nimport io.ktor.http.*\nimport io.ktor.util.*\nimport io.ktor.utils.io.core.*\nimport kotlinx.coroutines.*\n\n/**\n * [HttpClient] plugin that handles sent `Cookie`, and received `Set-Cookie` headers,\n * using a specific [storage] for storing and retrieving cookies.\n *\n * You can configure the [Config.storage] and to provide [Config.default] blocks to set\n * cookies when installing.\n */\npublic class HttpCookies(\n    private val storage: CookiesStorage,\n    private val defaults: List<suspend CookiesStorage.() -> Unit>\n) : Closeable {\n    @OptIn(DelicateCoroutinesApi::class)\n    private val initializer: Job = GlobalScope.launch(Dispatchers.Unconfined) {\n        defaults.forEach { it(storage) }\n    }\n\n    /**\n     * Find all cookies by [requestUrl].\n     */\n    public suspend fun get(requestUrl: Url): List<Cookie> {\n        initializer.join()\n        return storage.get(requestUrl)\n    }\n\n    /**\n     * Add cookies in request header (presumably added through [HttpRequestBuilder.cookie]) into storage,\n     * so to manage their life cycle properly.\n     */\n    internal suspend fun captureHeaderCookies(builder: HttpRequestBuilder) {\n        with(builder) {\n            val url = builder.url.clone().build()\n            val cookies = headers[HttpHeaders.Cookie]?.let { cookieHeader ->\n                parseClientCookiesHeader(cookieHeader).map { (name, encodedValue) -> Cookie(name, encodedValue) }\n            }\n            cookies?.forEach { storage.addCookie(url, it) }\n        }\n    }\n\n    internal suspend fun sendCookiesWith(builder: HttpRequestBuilder) {\n        val cookies = get(builder.url.clone().build())\n\n        with(builder) {\n            if (cookies.isNotEmpty()) {\n                headers[HttpHeaders.Cookie] = renderClientCookies(cookies)\n            } else {\n                headers.remove(HttpHeaders.Cookie)\n            }\n        }\n    }\n\n    internal suspend fun saveCookiesFrom(response: HttpResponse) {\n        val url = response.request.url\n        response.setCookie().forEach {\n            storage.addCookie(url, it)\n        }\n    }\n\n    override fun close() {\n        storage.close()\n    }\n\n    /**\n     * [HttpCookies] configuration.\n     */\n    public class Config {\n        private val defaults = mutableListOf<suspend CookiesStorage.() -> Unit>()\n\n        /**\n         * [CookiesStorage] that will be used at this plugin.\n         * By default it just uses an initially empty in-memory [AcceptAllCookiesStorage].\n         */\n        public var storage: CookiesStorage = AcceptAllCookiesStorage()\n\n        /**\n         * Registers a [block] that will be called when the configuration is complete the specified [storage].\n         * The [block] can potentially add new cookies by calling [CookiesStorage.addCookie].\n         */\n        public fun default(block: suspend CookiesStorage.() -> Unit) {\n            defaults.add(block)\n        }\n\n        internal fun build(): HttpCookies = HttpCookies(storage, defaults)\n    }\n\n    public companion object : HttpClientFeature<Config, HttpCookies> {\n        override fun prepare(block: Config.() -> Unit): HttpCookies = Config().apply(block).build()\n\n        override val key: AttributeKey<HttpCookies> = AttributeKey(\"HttpCookies\")\n\n        override fun install(plugin: HttpCookies, scope: HttpClient) {\n            scope.requestPipeline.intercept(HttpRequestPipeline.State) {\n                plugin.captureHeaderCookies(context)\n            }\n            scope.sendPipeline.intercept(HttpSendPipeline.State) {\n                plugin.sendCookiesWith(context)\n            }\n\n            scope.receivePipeline.intercept(HttpReceivePipeline.State) { response ->\n                plugin.saveCookiesFrom(response)\n            }\n        }\n    }\n}\n\nprivate fun renderClientCookies(cookies: List<Cookie>): String =\n    cookies.joinToString(\";\", transform = ::renderCookieHeader)\n\n/**\n * Gets all the cookies for the specified [url] for this [HttpClient].\n */\npublic suspend fun HttpClient.cookies(url: Url): List<Cookie> = feature(HttpCookies)?.get(url) ?: emptyList()\n\n/**\n * Gets all the cookies for the specified [urlString] for this [HttpClient].\n */\npublic suspend fun HttpClient.cookies(urlString: String): List<Cookie> =\n    feature(HttpCookies)?.get(Url(urlString)) ?: emptyList()\n\n/**\n * Find the [Cookie] by [name]\n */\npublic operator fun List<Cookie>.get(name: String): Cookie? = find { it.name == name }\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.features.observer\n\nimport io.ktor.client.*\nimport io.ktor.client.features.*\nimport io.ktor.client.statement.*\nimport io.ktor.util.*\nimport io.ktor.utils.io.*\nimport kotlinx.coroutines.*\n\n/**\n * [ResponseObserver] callback.\n */\npublic typealias ResponseHandler = suspend (HttpResponse) -> Unit\n\n/**\n * Observe response feature.\n */\npublic class ResponseObserver(\n    private val responseHandler: ResponseHandler\n) {\n    public class Config {\n        internal var responseHandler: ResponseHandler = {}\n\n        /**\n         * Set response handler for logging.\n         */\n        public fun onResponse(block: ResponseHandler) {\n            responseHandler = block\n        }\n    }\n\n    public companion object Feature : HttpClientFeature<Config, ResponseObserver> {\n\n        override val key: AttributeKey<ResponseObserver> = AttributeKey(\"BodyInterceptor\")\n\n        override fun prepare(block: Config.() -> Unit): ResponseObserver =\n            ResponseObserver(Config().apply(block).responseHandler)\n\n        override fun install(feature: ResponseObserver, scope: HttpClient) {\n            scope.receivePipeline.intercept(HttpReceivePipeline.After) { response ->\n                val (loggingContent, responseContent) = response.content.split(response)\n\n                val newClientCall = context.wrapWithContent(responseContent)\n                val sideCall = newClientCall.wrapWithContent(loggingContent)\n\n                scope.launch {\n                    try {\n                        feature.responseHandler(sideCall.response)\n                    } catch (_: Throwable) {\n                    }\n\n                    val content = sideCall.response.content\n                    if (!content.isClosedForRead) {\n                        content.discard()\n                    }\n                }\n\n                context.response = newClientCall.response\n                context.request = newClientCall.request\n                proceedWith(context.response)\n            }\n        }\n    }\n}\n\n/**\n * Install [ResponseObserver] feature in client.\n */\npublic fun HttpClientConfig<*>.ResponseObserver(block: ResponseHandler) {\n    install(ResponseObserver) {\n        responseHandler = block\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.features.websocket\n\nimport io.ktor.client.*\nimport io.ktor.client.call.*\nimport io.ktor.client.engine.*\nimport io.ktor.client.features.*\nimport io.ktor.client.request.*\nimport io.ktor.client.statement.*\nimport io.ktor.http.*\nimport io.ktor.http.cio.websocket.*\nimport io.ktor.util.*\nimport kotlin.native.concurrent.*\n\n@ExperimentalWebSocketExtensionApi\n@SharedImmutable\nprivate val REQUEST_EXTENSIONS_KEY = AttributeKey<List<WebSocketExtension<*>>>(\"Websocket extensions\")\n\n/**\n * Indicates if a client engine supports WebSockets.\n */\npublic object WebSocketCapability : HttpClientEngineCapability<Unit> {\n    override fun toString(): String = \"WebSocketCapability\"\n}\n\n/**\n * Indicates if a client engine supports extensions for WebSocket feature.\n */\npublic object WebSocketExtensionsCapability : HttpClientEngineCapability<Unit> {\n    override fun toString(): String = \"WebSocketExtensionsCapability\"\n}\n\n/**\n * Client WebSocket feature.\n *\n * @property pingInterval - interval between [FrameType.PING] messages.\n * @property maxFrameSize - max size of single websocket frame.\n * @property extensionsConfig - extensions configuration\n */\n@OptIn(WebSocketInternalAPI::class)\npublic class WebSockets @OptIn(ExperimentalWebSocketExtensionApi::class)\ninternal constructor(\n    public val pingInterval: Long,\n    public val maxFrameSize: Long,\n    private val extensionsConfig: WebSocketExtensionsConfig\n) {\n    /**\n     * Client WebSocket feature.\n     *\n     * @property pingInterval - interval between [FrameType.PING] messages.\n     * @property maxFrameSize - max size of single websocket frame.\n     */\n    @OptIn(ExperimentalWebSocketExtensionApi::class)\n    public constructor(\n        pingInterval: Long = -1L,\n        maxFrameSize: Long = Int.MAX_VALUE.toLong(),\n    ) : this(pingInterval, maxFrameSize, WebSocketExtensionsConfig())\n\n    /**\n     * Client WebSocket feature.\n     */\n    @OptIn(ExperimentalWebSocketExtensionApi::class)\n    public constructor() : this(-1L, Int.MAX_VALUE.toLong(), WebSocketExtensionsConfig())\n\n    @ExperimentalWebSocketExtensionApi\n    private fun installExtensions(context: HttpRequestBuilder) {\n        val installed = extensionsConfig.build()\n        context.attributes.put(REQUEST_EXTENSIONS_KEY, installed)\n\n        val protocols = installed.flatMap { it.protocols }\n        addNegotiatedProtocols(context, protocols)\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    @ExperimentalWebSocketExtensionApi\n    private fun completeNegotiation(\n        call: HttpClientCall\n    ): List<WebSocketExtension<*>> {\n        val serverExtensions: List<WebSocketExtensionHeader> = call.response\n            .headers[HttpHeaders.SecWebSocketExtensions]\n            ?.let { parseWebSocketExtensions(it) } ?: emptyList()\n\n        val clientExtensions = call.attributes[REQUEST_EXTENSIONS_KEY]\n\n        return clientExtensions.filter { it.clientNegotiation(serverExtensions) }\n    }\n\n    @OptIn(ExperimentalWebSocketExtensionApi::class)\n    private fun addNegotiatedProtocols(context: HttpRequestBuilder, protocols: List<WebSocketExtensionHeader>) {\n        if (protocols.isEmpty()) return\n\n        val headerValue = protocols.joinToString(\";\")\n        context.header(HttpHeaders.SecWebSocketExtensions, headerValue)\n    }\n\n    internal fun convertSessionToDefault(session: WebSocketSession): DefaultWebSocketSession {\n        if (session is DefaultWebSocketSession) return session\n\n        return DefaultWebSocketSession(session, pingInterval, timeoutMillis = pingInterval * 2).also {\n            it.maxFrameSize = this@WebSockets.maxFrameSize\n        }\n    }\n\n    init {\n    }\n\n    /**\n     * [WebSockets] configuration.\n     */\n    public class Config {\n        @ExperimentalWebSocketExtensionApi\n        internal val extensionsConfig: WebSocketExtensionsConfig = WebSocketExtensionsConfig()\n\n        /**\n         * Sets interval of sending ping frames.\n         *\n         * Value -1L is for disabled ping.\n         */\n        public var pingInterval: Long = -1L\n\n        /**\n         * Sets maximum frame size in bytes.\n         */\n        public var maxFrameSize: Long = Int.MAX_VALUE.toLong()\n\n        /**\n         * Configure WebSocket extensions.\n         */\n        @ExperimentalWebSocketExtensionApi\n        public fun extensions(block: WebSocketExtensionsConfig.() -> Unit) {\n            extensionsConfig.apply(block)\n        }\n    }\n\n    /**\n     * Add WebSockets support for ktor http client.\n     */\n    public companion object Feature : HttpClientFeature<Config, WebSockets> {\n        override val key: AttributeKey<WebSockets> = AttributeKey(\"Websocket\")\n\n        @OptIn(ExperimentalWebSocketExtensionApi::class)\n        override fun prepare(block: Config.() -> Unit): WebSockets {\n            val config = Config().apply(block)\n            return WebSockets(config.pingInterval, config.maxFrameSize, config.extensionsConfig)\n        }\n\n        @OptIn(ExperimentalWebSocketExtensionApi::class)\n        override fun install(feature: WebSockets, scope: HttpClient) {\n            val extensionsSupported = scope.engine.supportedCapabilities.contains(WebSocketExtensionsCapability)\n\n            scope.requestPipeline.intercept(HttpRequestPipeline.Render) {\n                if (!context.url.protocol.isWebsocket()) return@intercept\n                context.setCapability(WebSocketCapability, Unit)\n\n                if (extensionsSupported) {\n                    feature.installExtensions(context)\n                }\n\n                proceedWith(WebSocketContent())\n            }\n\n            scope.responsePipeline.intercept(HttpResponsePipeline.Transform) { (info, session) ->\n                if (session !is WebSocketSession) return@intercept\n\n                val clientSession: ClientWebSocketSession = when (info.type) {\n                    DefaultClientWebSocketSession::class -> {\n                        val defaultSession = feature.convertSessionToDefault(session)\n                        val clientSession = DefaultClientWebSocketSession(context, defaultSession)\n\n                        val negotiated = if (extensionsSupported) {\n                            feature.completeNegotiation(context)\n                        } else emptyList()\n\n                        clientSession.apply {\n                            start(negotiated)\n                        }\n                    }\n                    else -> DelegatingClientWebSocketSession(context, session)\n                }\n\n                val response = HttpResponseContainer(info, clientSession)\n                proceedWith(response)\n            }\n        }\n    }\n}\n\n@Suppress(\"KDocMissingDocumentation\")\npublic class WebSocketException(message: String) : IllegalStateException(message)\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.features.websocket\n\nimport io.ktor.client.*\nimport io.ktor.client.request.*\nimport io.ktor.client.statement.*\nimport io.ktor.http.*\nimport io.ktor.http.cio.websocket.*\n\n/**\n * Install [WebSockets] feature using the [config] as configuration.\n */\npublic fun HttpClientConfig<*>.WebSockets(config: WebSockets.Config.() -> Unit) {\n    install(WebSockets) {\n        config()\n    }\n}\n\n/**\n * Open [DefaultClientWebSocketSession].\n */\n@OptIn(WebSocketInternalAPI::class)\npublic suspend fun HttpClient.webSocketSession(\n    block: HttpRequestBuilder.() -> Unit\n): DefaultClientWebSocketSession = request {\n    url {\n        protocol = URLProtocol.WS\n        port = protocol.defaultPort\n    }\n    block()\n}\n\n/**\n * Open [DefaultClientWebSocketSession].\n */\n@OptIn(WebSocketInternalAPI::class)\npublic suspend fun HttpClient.webSocketSession(\n    method: HttpMethod = HttpMethod.Get,\n    host: String = \"localhost\",\n    port: Int = DEFAULT_PORT,\n    path: String = \"/\",\n    block: HttpRequestBuilder.() -> Unit = {}\n): DefaultClientWebSocketSession = webSocketSession {\n    this.method = method\n    url(\"ws\", host, port, path)\n    block()\n}\n\n/**\n * Open [block] with [DefaultClientWebSocketSession].\n */\npublic suspend fun HttpClient.webSocket(\n    request: HttpRequestBuilder.() -> Unit,\n    block: suspend DefaultClientWebSocketSession.() -> Unit\n) {\n    val session = request<HttpStatement> {\n        url {\n            protocol = URLProtocol.WS\n            port = protocol.defaultPort\n        }\n        request()\n    }\n\n    session.receive<DefaultClientWebSocketSession, Unit> {\n        try {\n            block(it)\n        } finally {\n            it.close()\n        }\n    }\n}\n\n/**\n * Open [block] with [DefaultClientWebSocketSession].\n */\npublic suspend fun HttpClient.webSocket(\n    method: HttpMethod = HttpMethod.Get,\n    host: String = \"localhost\",\n    port: Int = DEFAULT_PORT,\n    path: String = \"/\",\n    request: HttpRequestBuilder.() -> Unit = {},\n    block: suspend DefaultClientWebSocketSession.() -> Unit\n) {\n    webSocket(\n        {\n            this.method = method\n            url(\"ws\", host, port, path)\n            request()\n        },\n        block\n    )\n}\n\n/**\n * Open [block] with [DefaultClientWebSocketSession].\n */\npublic suspend fun HttpClient.webSocket(\n    urlString: String,\n    request: HttpRequestBuilder.() -> Unit = {},\n    block: suspend DefaultClientWebSocketSession.() -> Unit\n) {\n    webSocket(\n        HttpMethod.Get,\n        \"localhost\",\n        DEFAULT_PORT,\n        \"/\",\n        {\n            url.protocol = URLProtocol.WS\n            url.port = port\n\n            url.takeFrom(urlString)\n            request()\n        },\n        block\n    )\n}\n\n/**\n * Open [block] with [DefaultClientWebSocketSession].\n */\npublic suspend fun HttpClient.ws(\n    method: HttpMethod = HttpMethod.Get,\n    host: String = \"localhost\",\n    port: Int = DEFAULT_PORT,\n    path: String = \"/\",\n    request: HttpRequestBuilder.() -> Unit = {},\n    block: suspend DefaultClientWebSocketSession.() -> Unit\n): Unit = webSocket(method, host, port, path, request, block)\n\n/**\n * Open [block] with [DefaultClientWebSocketSession].\n */\npublic suspend fun HttpClient.ws(\n    request: HttpRequestBuilder.() -> Unit,\n    block: suspend DefaultClientWebSocketSession.() -> Unit\n): Unit = webSocket(request, block)\n\n/**\n * Open [block] with [DefaultClientWebSocketSession].\n */\npublic suspend fun HttpClient.ws(\n    urlString: String,\n    request: HttpRequestBuilder.() -> Unit = {},\n    block: suspend DefaultClientWebSocketSession.() -> Unit\n): Unit = webSocket(urlString, request, block)\n\n/**\n * Open [block] with secure [DefaultClientWebSocketSession].\n */\npublic suspend fun HttpClient.wss(\n    request: HttpRequestBuilder.() -> Unit,\n    block: suspend DefaultClientWebSocketSession.() -> Unit\n): Unit = webSocket(\n    {\n        url.protocol = URLProtocol.WSS\n        url.port = url.protocol.defaultPort\n        request()\n    },\n    block = block\n)\n\n/**\n * Open [block] with secure [DefaultClientWebSocketSession].\n */\npublic suspend fun HttpClient.wss(\n    urlString: String,\n    request: HttpRequestBuilder.() -> Unit = {},\n    block: suspend DefaultClientWebSocketSession.() -> Unit\n): Unit = wss(\n    {\n        url.takeFrom(urlString)\n        request()\n    },\n    block = block\n)\n\n/**\n * Open [block] with secure [DefaultClientWebSocketSession].\n */\npublic suspend fun HttpClient.wss(\n    method: HttpMethod = HttpMethod.Get,\n    host: String = \"localhost\",\n    port: Int = DEFAULT_PORT,\n    path: String = \"/\",\n    request: HttpRequestBuilder.() -> Unit = {},\n    block: suspend DefaultClientWebSocketSession.() -> Unit\n): Unit = webSocket(\n    method,\n    host,\n    port,\n    path,\n    request = {\n        url.protocol = URLProtocol.WSS\n        url.port = port\n\n        request()\n    },\n    block = block\n)\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.request\n\nimport io.ktor.http.*\nimport io.ktor.http.content.*\nimport io.ktor.util.*\nimport io.ktor.utils.io.*\n\n@Suppress(\"KDocMissingDocumentation\")\n@InternalAPI\npublic abstract class ClientUpgradeContent : OutgoingContent.NoContent() {\n    private val content: ByteChannel by lazy { ByteChannel() }\n\n    public val output: ByteWriteChannel get() = content\n\n    public suspend fun pipeTo(output: ByteWriteChannel) {\n        content.copyAndClose(output)\n    }\n\n    public abstract fun verify(headers: Headers)\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.request\n\nimport io.ktor.client.call.*\nimport io.ktor.http.*\nimport io.ktor.http.content.*\nimport io.ktor.util.*\nimport kotlin.coroutines.*\n\n/**\n * Default [HttpRequest] implementation.\n */\n@InternalAPI\npublic open class DefaultHttpRequest(override val call: HttpClientCall, data: HttpRequestData) : HttpRequest {\n    override val coroutineContext: CoroutineContext get() = call.coroutineContext\n\n    override val method: HttpMethod = data.method\n\n    override val url: Url = data.url\n\n    override val content: OutgoingContent = data.body\n\n    override val headers: Headers = data.headers\n\n    override val attributes: Attributes = data.attributes\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.request\n\nimport io.ktor.client.*\nimport io.ktor.http.*\n\n/**\n * Executes a [HttpClient] GET request, with the specified [url] as Url and\n * an optional [block] receiving an [HttpRequestBuilder] for further configuring the request.\n *\n * Tries to receive a specific type [T], if fails, an exception is thrown.\n */\npublic suspend inline fun <reified T> HttpClient.get(\n    url: Url,\n    block: HttpRequestBuilder.() -> Unit = {}\n): T = get {\n    this.url.takeFrom(url)\n    block()\n}\n\n/**\n * Executes a [HttpClient] POST request, with the specified [url] as Url and\n * an optional [block] receiving an [HttpRequestBuilder] for further configuring the request.\n *\n * Tries to receive a specific type [T], if fails, an exception is thrown.\n */\npublic suspend inline fun <reified T> HttpClient.post(\n    url: Url,\n    block: HttpRequestBuilder.() -> Unit = {}\n): T = post {\n    this.url.takeFrom(url)\n    block()\n}\n\n/**\n * Executes a [HttpClient] PUT request, with the specified [url] as Url and\n * an optional [block] receiving an [HttpRequestBuilder] for further configuring the request.\n *\n * Tries to receive a specific type [T], if fails, an exception is thrown.\n */\npublic suspend inline fun <reified T> HttpClient.put(\n    url: Url,\n    block: HttpRequestBuilder.() -> Unit = {}\n): T = put {\n    this.url.takeFrom(url)\n    block()\n}\n\n/**\n * Executes a [HttpClient] PATCH request, with the specified [url] as Url and\n * an optional [block] receiving an [HttpRequestBuilder] for further configuring the request.\n *\n * Tries to receive a specific type [T], if fails, an exception is thrown.\n */\npublic suspend inline fun <reified T> HttpClient.patch(\n    url: Url,\n    block: HttpRequestBuilder.() -> Unit = {}\n): T = patch {\n    this.url.takeFrom(url)\n    block()\n}\n\n/**\n * Executes a [HttpClient] OPTIONS request, with the specified [url] as Url and\n * an optional [block] receiving an [HttpRequestBuilder] for further configuring the request.\n *\n * Tries to receive a specific type [T], if fails, an exception is thrown.\n */\npublic suspend inline fun <reified T> HttpClient.options(\n    url: Url,\n    block: HttpRequestBuilder.() -> Unit = {}\n): T = options {\n    this.url.takeFrom(url)\n    block()\n}\n\n/**\n * Executes a [HttpClient] HEAD request, with the specified [url] as Url and\n * an optional [block] receiving an [HttpRequestBuilder] for further configuring the request.\n *\n * Tries to receive a specific type [T], if fails, an exception is thrown.\n */\npublic suspend inline fun <reified T> HttpClient.head(\n    url: Url,\n    block: HttpRequestBuilder.() -> Unit = {}\n): T = head {\n    this.url.takeFrom(url)\n    block()\n}\n\n/**\n * Executes a [HttpClient] HEAD request, with the specified [url] as Url and\n * an optional [block] receiving an [HttpRequestBuilder] for further configuring the request.\n *\n * Tries to receive a specific type [T], if fails, an exception is thrown.\n */\npublic suspend inline fun <reified T> HttpClient.delete(\n    url: Url,\n    block: HttpRequestBuilder.() -> Unit = {}\n): T = delete {\n    this.url.takeFrom(url)\n    block()\n}\n\n/**\n * Sets the [HttpRequestBuilder.url] from [url].\n */\npublic fun HttpRequestBuilder.url(url: Url): Unit { // ktlint-disable no-unit-return\n    this.url.takeFrom(url)\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.request.forms\n\nimport io.ktor.http.*\nimport io.ktor.http.content.*\nimport io.ktor.utils.io.*\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.*\nimport kotlin.native.concurrent.*\nimport kotlin.random.*\n\n@ThreadLocal\nprivate val RN_BYTES = \"\\r\\n\".toByteArray()\n\n/**\n * [OutgoingContent] with for application/x-www-form-urlencoded formatted request.\n *\n * @param formData: data to send.\n */\npublic class FormDataContent(\n    public val formData: Parameters\n) : OutgoingContent.ByteArrayContent() {\n    private val content = formData.formUrlEncode().toByteArray()\n\n    override val contentLength: Long = content.size.toLong()\n    override val contentType: ContentType = ContentType.Application.FormUrlEncoded.withCharset(Charsets.UTF_8)\n\n    override fun bytes(): ByteArray = content\n}\n\n/**\n * [OutgoingContent] for multipart/form-data formatted request.\n *\n * @param parts: form part data\n */\npublic class MultiPartFormDataContent(\n    parts: List<PartData>\n) : OutgoingContent.WriteChannelContent() {\n    private val boundary: String = generateBoundary()\n    private val BOUNDARY_BYTES = \"--$boundary\\r\\n\".toByteArray()\n    private val LAST_BOUNDARY_BYTES = \"--$boundary--\\r\\n\".toByteArray()\n\n    private val BODY_OVERHEAD_SIZE = LAST_BOUNDARY_BYTES.size\n    private val PART_OVERHEAD_SIZE = RN_BYTES.size * 2 + BOUNDARY_BYTES.size\n\n    private val rawParts: List<PreparedPart> = parts.map { part ->\n        val headersBuilder = BytePacketBuilder()\n        for ((key, values) in part.headers.entries()) {\n            headersBuilder.writeText(\"$key: ${values.joinToString(\"; \")}\")\n            headersBuilder.writeFully(RN_BYTES)\n        }\n\n        val bodySize = part.headers[HttpHeaders.ContentLength]?.toLong()\n        when (part) {\n            is PartData.FileItem -> {\n                val headers = headersBuilder.build().readBytes()\n                val size = bodySize?.plus(PART_OVERHEAD_SIZE)?.plus(headers.size)\n                PreparedPart(headers, part.provider, size)\n            }\n            is PartData.BinaryItem -> {\n                val headers = headersBuilder.build().readBytes()\n                val size = bodySize?.plus(PART_OVERHEAD_SIZE)?.plus(headers.size)\n                PreparedPart(headers, part.provider, size)\n            }\n            is PartData.FormItem -> {\n                val bytes = buildPacket { writeText(part.value) }.readBytes()\n                val provider = { buildPacket { writeFully(bytes) } }\n                if (bodySize == null) {\n                    headersBuilder.writeText(\"${HttpHeaders.ContentLength}: ${bytes.size}\")\n                    headersBuilder.writeFully(RN_BYTES)\n                }\n\n                val headers = headersBuilder.build().readBytes()\n                val size = bytes.size + PART_OVERHEAD_SIZE + headers.size\n                PreparedPart(headers, provider, size.toLong())\n            }\n        }\n    }\n\n    override val contentLength: Long?\n\n    override val contentType: ContentType = ContentType.MultiPart.FormData.withParameter(\"boundary\", boundary)\n\n    init {\n        var rawLength: Long? = 0\n        for (part in rawParts) {\n            val size = part.size\n            if (size == null) {\n                rawLength = null\n                break\n            }\n\n            rawLength = rawLength?.plus(size)\n        }\n\n        if (rawLength != null) {\n            rawLength += BODY_OVERHEAD_SIZE\n        }\n\n        contentLength = rawLength\n    }\n\n    override suspend fun writeTo(channel: ByteWriteChannel) {\n        try {\n            for (part in rawParts) {\n                channel.writeFully(BOUNDARY_BYTES)\n                channel.writeFully(part.headers)\n                channel.writeFully(RN_BYTES)\n\n                part.provider().use { input ->\n                    input.copyTo(channel)\n                }\n\n                channel.writeFully(RN_BYTES)\n            }\n\n            channel.writeFully(LAST_BOUNDARY_BYTES)\n        } catch (cause: Throwable) {\n            channel.close(cause)\n        } finally {\n            channel.close()\n        }\n    }\n}\n\nprivate fun generateBoundary(): String = buildString {\n    repeat(32) {\n        append(Random.nextInt().toString(16))\n    }\n}.take(70)\n\nprivate class PreparedPart(\n    val headers: ByteArray,\n    val provider: () -> Input,\n    val size: Long?\n)\n\nprivate suspend fun Input.copyTo(channel: ByteWriteChannel) {\n    if (this is ByteReadPacket) {\n        channel.writePacket(this)\n        return\n    }\n\n    while (!this@copyTo.endOfInput) {\n        channel.write { freeSpace, startOffset, endExclusive ->\n            this@copyTo.readAvailable(freeSpace, startOffset, endExclusive - startOffset).toInt()\n        }\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.request.forms\n\nimport io.ktor.client.*\nimport io.ktor.client.request.*\nimport io.ktor.http.*\nimport io.ktor.http.content.*\n\n/**\n * Submit [formParameters] request.\n *\n * If [encodeInQuery] specified encode [formParameters] in url parameters and use [HttpMethod.Get] for the request.\n * Otherwise send [HttpMethod.Post] request with [formParameters] encoded in body.\n *\n * [formParameters] encoded using application/x-www-form-urlencoded format.\n */\npublic suspend inline fun <reified T> HttpClient.submitForm(\n    formParameters: Parameters = Parameters.Empty,\n    encodeInQuery: Boolean = false,\n    block: HttpRequestBuilder.() -> Unit = {}\n): T = request {\n    if (encodeInQuery) {\n        method = HttpMethod.Get\n        url.parameters.appendAll(formParameters)\n    } else {\n        method = HttpMethod.Post\n        body = FormDataContent(formParameters)\n    }\n\n    block()\n}\n\n/**\n * Submit [formParameters] request.\n *\n * If [encodeInQuery] specified encode [formParameters] in url parameters and use [HttpMethod.Get] for the request.\n * Otherwise send [HttpMethod.Post] request with [formParameters] encoded in body.\n *\n * [url] destination\n * [formParameters] encoded using application/x-www-form-urlencoded format.\n */\npublic suspend inline fun <reified T> HttpClient.submitForm(\n    url: String,\n    formParameters: Parameters = Parameters.Empty,\n    encodeInQuery: Boolean = false,\n    block: HttpRequestBuilder.() -> Unit = {}\n): T = submitForm(formParameters, encodeInQuery) {\n    url(url)\n    block()\n}\n\n/**\n * Send [HttpMethod.Post] request with [formData] encoded in body.\n * [formData] encoded using multipart/form-data format.\n * https://tools.ietf.org/html/rfc2045\n */\npublic suspend inline fun <reified T> HttpClient.submitFormWithBinaryData(\n    formData: List<PartData>,\n    block: HttpRequestBuilder.() -> Unit = {}\n): T = request {\n    method = HttpMethod.Post\n    body = MultiPartFormDataContent(formData)\n    block()\n}\n\n/**\n * Send [HttpMethod.Post] request with [formData] encoded in body.\n * [url] destination\n * [formData] encoded using multipart/form-data format.\n *\n * https://tools.ietf.org/html/rfc2045\n */\npublic suspend inline fun <reified T> HttpClient.submitFormWithBinaryData(\n    url: String,\n    formData: List<PartData>,\n    block: HttpRequestBuilder.() -> Unit = {}\n): T = submitFormWithBinaryData(formData) {\n    url(url)\n    block()\n}\n\n/**\n * Submit [formParameters] request.\n *\n * If [encodeInQuery] specified encode [formParameters] in url parameters and use [HttpMethod.Get] for the request.\n * Otherwise send [HttpMethod.Post] request with [formParameters] encoded in body.\n *\n * [formParameters] encoded using application/x-www-form-urlencoded format.\n */\npublic suspend inline fun <reified T> HttpClient.submitForm(\n    scheme: String = \"http\",\n    host: String = \"localhost\",\n    port: Int = 80,\n    path: String = \"/\",\n    formParameters: Parameters = Parameters.Empty,\n    encodeInQuery: Boolean = false,\n    block: HttpRequestBuilder.() -> Unit = {}\n): T = submitForm(formParameters, encodeInQuery) {\n    url(scheme, host, port, path)\n    apply(block)\n}\n\n/**\n * Send [HttpMethod.Post] request with [formData] encoded in body.\n * [formData] encoded using multipart/form-data format.\n * https://tools.ietf.org/html/rfc2045\n */\npublic suspend inline fun <reified T> HttpClient.submitFormWithBinaryData(\n    scheme: String = \"http\",\n    host: String = \"localhost\",\n    port: Int = 80,\n    path: String = \"/\",\n    formData: List<PartData> = emptyList(),\n    block: HttpRequestBuilder.() -> Unit = {}\n): T = submitFormWithBinaryData(formData) {\n    url(scheme, host, port, path)\n    apply(block)\n}\n","@file:Suppress(\"RedundantModalityModifier\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.pool.*\nimport kotlin.Boolean\nimport kotlin.Char\nimport kotlin.CharSequence\nimport kotlin.Deprecated\nimport kotlin.DeprecationLevel\nimport kotlin.Int\nimport kotlin.PublishedApi\nimport kotlin.String\nimport kotlin.Suppress\nimport kotlin.jvm.*\n\n/**\n * A builder that provides ability to build byte packets with no knowledge of it's size.\n * Unlike Java's ByteArrayOutputStream it doesn't copy the whole content every time it's internal buffer overflows\n * but chunks buffers instead. Packet building via [build] function is O(1) operation and only does instantiate\n * a new [ByteReadPacket]. Once a byte packet has been built via [build] function call, the builder could be\n * reused again. You also can discard all written bytes via [reset] or [release]. Please note that an instance of\n * builder need to be terminated either via [build] function invocation or via [release] call otherwise it will\n * cause byte buffer leak so that may have performance impact.\n *\n * Byte packet builder is also an [Appendable] so it does append UTF-8 characters to a packet\n *\n * ```\n * buildPacket {\n *     listOf(1,2,3).joinTo(this, separator = \",\")\n * }\n * ```\n */\npublic class BytePacketBuilder(\n    private var headerSizeHint: Int = 0,\n    pool: ObjectPool<ChunkBuffer>\n) : @Suppress(\"DEPRECATION_ERROR\")\nBytePacketBuilderPlatformBase(pool) {\n\n    init {\n        require(headerSizeHint >= 0) { \"shouldn't be negative: headerSizeHint = $headerSizeHint\" }\n    }\n\n    /**\n     * Number of bytes written to the builder after the creation or the last reset.\n     */\n    public val size: Int\n        get() = _size\n\n    /**\n     * If no bytes were written or the builder has been reset.\n     */\n    public val isEmpty: Boolean\n        get() = _size == 0\n\n    /**\n     * If at least one byte was written after the creation or the last reset.\n     */\n    public val isNotEmpty: Boolean\n        get() = _size > 0\n\n    @PublishedApi\n    internal val _pool: ObjectPool<ChunkBuffer>\n        get() = pool\n\n    /**\n     * Does nothing for memory-backed output\n     */\n    final override fun closeDestination() {\n    }\n\n    /**\n     * Does nothing for memory-backed output\n     */\n    final override fun flush(source: Memory, offset: Int, length: Int) {\n    }\n\n    override fun append(c: Char): BytePacketBuilder {\n        return super.append(c) as BytePacketBuilder\n    }\n\n    override fun append(csq: CharSequence?): BytePacketBuilder {\n        return super.append(csq) as BytePacketBuilder\n    }\n\n    override fun append(csq: CharSequence?, start: Int, end: Int): BytePacketBuilder {\n        return super.append(csq, start, end) as BytePacketBuilder\n    }\n\n    @Suppress(\"DEPRECATION_ERROR\", \"UNUSED\")\n    @Deprecated(\"Binary compatibility\", level = DeprecationLevel.HIDDEN)\n    @JvmName(\"append\")\n    public fun appendOld(c: Char): BytePacketBuilderBase = append(c)\n\n    @Suppress(\"DEPRECATION_ERROR\", \"UNUSED\")\n    @Deprecated(\"Binary compatibility\", level = DeprecationLevel.HIDDEN)\n    @JvmName(\"append\")\n    public fun appendOld(csq: CharSequence?): BytePacketBuilderBase = append(csq)\n\n    @Suppress(\"DEPRECATION_ERROR\", \"UNUSED\")\n    @Deprecated(\"Binary compatibility\", level = DeprecationLevel.HIDDEN)\n    @JvmName(\"append\")\n    public fun appendOld(csq: CharSequence?, start: Int, end: Int): BytePacketBuilderBase = append(csq, start, end)\n\n    /**\n     * Creates a temporary packet view of the packet being build without discarding any bytes from the builder.\n     * This is similar to `build().copy()` except that the builder keeps already written bytes untouched.\n     * A temporary view packet is passed as argument to [block] function and it shouldn't leak outside of this block\n     * otherwise an unexpected behaviour may occur.\n     */\n    @Suppress(\"unused\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun <R> preview(block: (tmp: ByteReadPacket) -> R): R {\n        return preview(block)\n    }\n\n    /**\n     * Builds byte packet instance and resets builder's state to be able to build another one packet if needed\n     */\n    public fun build(): ByteReadPacket {\n        val size = size\n        val head = stealAll()\n\n        return when (head) {\n            null -> ByteReadPacket.Empty\n            else -> ByteReadPacket(head, size.toLong(), pool)\n        }\n    }\n\n    /**\n     * Discard all written bytes and prepare to build another packet.\n     */\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun reset() {\n        release()\n    }\n\n    @PublishedApi\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"unused\")\n    internal fun preview(): ByteReadPacket {\n        return preview()\n    }\n\n    override fun toString(): String {\n        return \"BytePacketBuilder($size bytes written)\"\n    }\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.pool.*\nimport kotlin.contracts.*\n\n/**\n * A read-write facade to actual buffer of fixed size. Multiple views could share the same actual buffer.\n * Concurrent unsafe. The only concurrent-safe operation is [release].\n * In most cases [ByteReadPacket] and [BytePacketBuilder] should be used instead.\n */\n@Suppress(\"DIFFERENT_NAMES_FOR_THE_SAME_PARAMETER_IN_SUPERTYPES\", \"DEPRECATION\")\n@Deprecated(\"Use Memory, Input or Output instead.\")\npublic expect class IoBuffer : Input, Output, ChunkBuffer {\n\n    @Suppress(\"ConvertSecondaryConstructorToPrimary\")\n    public constructor(memory: Memory, origin: ChunkBuffer?)\n\n    internal constructor(memory: Memory, origin: ChunkBuffer?, parentPool: ObjectPool<IoBuffer>?)\n\n    @Deprecated(\n        \"Not supported anymore. All operations are big endian by default. \" +\n            \"Read/write with readXXXLittleEndian/writeXXXLittleEndian or \" +\n            \"do readXXX/writeXXX with X.reverseByteOrder() instead.\",\n        level = DeprecationLevel.ERROR\n    )\n    final override var byteOrder: ByteOrder\n\n    override fun close()\n\n    final override fun flush()\n\n    public fun release(pool: ObjectPool<IoBuffer>)\n\n    @Suppress(\"DEPRECATION\")\n    public companion object {\n        /**\n         * Number of bytes usually reserved in the end of chunk\n         * when several instances of [ChunkBuffer] are connected into a chain (usually inside of [ByteReadPacket]\n         * or [BytePacketBuilder])\n         */\n        @DangerousInternalIoApi\n        public val ReservedSize: Int\n\n        /**\n         * The empty buffer singleton: it has zero capacity for read and write.\n         */\n        public val Empty: IoBuffer\n\n        /**\n         * The default buffer pool\n         */\n        public val Pool: ObjectPool<IoBuffer>\n\n        /**\n         * Pool that always instantiates new buffers instead of reusing it\n         */\n        public val NoPool: ObjectPool<IoBuffer>\n\n        /**\n         * A pool that always returns [IoBuffer.Empty]\n         */\n        public val EmptyPool: ObjectPool<IoBuffer>\n    }\n}\n\n/**\n * Read the specified number of bytes specified (optional, read all remaining by default)\n */\npublic fun Buffer.readBytes(count: Int = readRemaining): ByteArray {\n    if (count == 0) {\n        return EmptyByteArray\n    }\n\n    val result = ByteArray(count)\n    readFully(result)\n    return result\n}\n\n@Suppress(\"DEPRECATION\")\ninternal fun IoBuffer.releaseImpl() {\n    releaseImpl(IoBuffer.Pool)\n}\n\n@Deprecated(\n    \"IoBuffer now contains ObjectPool reference\",\n    level = DeprecationLevel.WARNING,\n    replaceWith = ReplaceWith(\"releaseImpl()\")\n)\n@Suppress(\"DEPRECATION\")\ninternal fun IoBuffer.releaseImpl(pool: ObjectPool<IoBuffer>) {\n    if (!release()) return\n\n    val origin = origin\n    val poolToUse = (parentPool ?: pool) as ObjectPool<IoBuffer>\n\n    when (origin) {\n        is IoBuffer -> {\n            unlink()\n            origin.release(pool)\n        }\n        else -> {\n            poolToUse.recycle(this)\n        }\n    }\n}\n\n@Suppress(\"DEPRECATION\", \"DEPRECATION_ERROR\")\ninternal object EmptyBufferPoolImpl : NoPoolImpl<IoBuffer>() {\n    override fun borrow() = IoBuffer.Empty\n}\n\ninternal fun ChunkBuffer?.releaseAll(pool: ObjectPool<ChunkBuffer>) {\n    var current = this\n    while (current != null) {\n        val next = current.cleanNext()\n        current.release(pool)\n        current = next\n    }\n}\n\ninternal inline fun ChunkBuffer.forEachChunk(block: (ChunkBuffer) -> Unit) {\n    contract {\n        callsInPlace(block, InvocationKind.AT_LEAST_ONCE)\n    }\n    var current = this\n    do {\n        block(current)\n        current = current.next ?: break\n    } while (true)\n}\n\n/**\n * Copy every element of the chain starting from this and setup next links.\n */\ninternal fun ChunkBuffer.copyAll(): ChunkBuffer {\n    val copied = duplicate()\n    val next = this.next ?: return copied\n\n    return next.copyAll(copied, copied)\n}\n\nprivate tailrec fun ChunkBuffer.copyAll(head: ChunkBuffer, prev: ChunkBuffer): ChunkBuffer {\n    val copied = duplicate()\n    prev.next = copied\n\n    val next = this.next ?: return head\n\n    return next.copyAll(head, copied)\n}\n\ninternal tailrec fun ChunkBuffer.findTail(): ChunkBuffer {\n    val next = this.next ?: return this\n    return next.findTail()\n}\n\n/**\n * Summarize remainings of all elements of the chain\n */\n@DangerousInternalIoApi\npublic fun ChunkBuffer.remainingAll(): Long = remainingAll(0L)\n\n@Suppress(\"DEPRECATION\", \"UNUSED\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\npublic fun remainingAll(buffer: IoBuffer): Long = buffer.remainingAll()\n\nprivate tailrec fun ChunkBuffer.remainingAll(n: Long): Long {\n    val rem = readRemaining.toLong() + n\n    val next = this.next ?: return rem\n\n    return next.remainingAll(rem)\n}\n\ninternal tailrec fun ChunkBuffer.isEmpty(): Boolean {\n    if (readRemaining > 0) return false\n    val next = this.next ?: return true\n    return next.isEmpty()\n}\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun Long.coerceAtMostMaxInt(): Int = minOf(this, Int.MAX_VALUE.toLong()).toInt()\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun Long.coerceAtMostMaxIntOrFail(message: String): Int {\n    if (this > Int.MAX_VALUE.toLong()) throw IllegalArgumentException(message)\n    return this.toInt()\n}\n\ninternal fun Buffer.peekTo(destination: Memory, destinationOffset: Long, offset: Long, min: Long, max: Long): Long {\n    val size = minOf(\n        destination.size - destinationOffset,\n        max,\n        readRemaining.toLong()\n    )\n\n    memory.copyTo(\n        destination,\n        readPosition + offset,\n        size,\n        destinationOffset\n    )\n\n    return size\n}\n\npublic class BufferLimitExceededException(message: String) : Exception(message)\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.request.forms\n\nimport io.ktor.http.*\nimport io.ktor.http.content.*\nimport io.ktor.util.*\nimport io.ktor.utils.io.core.*\nimport kotlin.contracts.*\n\n/**\n * Multipart form item. Use it to build form in client.\n *\n * @param key multipart name\n * @param value content, could be [String], [Number], [ByteArray], [ByteReadPacket] or [InputProvider]\n * @param headers part headers, note that some servers may fail if an unknown header provided\n */\npublic data class FormPart<T : Any>(val key: String, val value: T, val headers: Headers = Headers.Empty)\n\n/**\n * Build multipart form from [values].\n */\npublic fun formData(vararg values: FormPart<*>): List<PartData> {\n    val result = mutableListOf<PartData>()\n\n    values.forEach { (key, value, headers) ->\n        val partHeaders = HeadersBuilder().apply {\n            append(HttpHeaders.ContentDisposition, \"form-data; name=${key.escapeIfNeeded()}\")\n            appendAll(headers)\n        }\n\n        val part = when (value) {\n            is String -> PartData.FormItem(value, {}, partHeaders.build())\n            is Number -> PartData.FormItem(value.toString(), {}, partHeaders.build())\n            is ByteArray -> {\n                partHeaders.append(HttpHeaders.ContentLength, value.size.toString())\n                PartData.BinaryItem({ ByteReadPacket(value) }, {}, partHeaders.build())\n            }\n            is ByteReadPacket -> {\n                partHeaders.append(HttpHeaders.ContentLength, value.remaining.toString())\n                PartData.BinaryItem({ value.copy() }, { value.close() }, partHeaders.build())\n            }\n            is InputProvider -> {\n                val size = value.size\n                if (size != null) {\n                    partHeaders.append(HttpHeaders.ContentLength, size.toString())\n                }\n                PartData.BinaryItem(value.block, {}, partHeaders.build())\n            }\n            is Input -> error(\"Can't use [Input] as part of form: $value. Consider using [InputProvider] instead.\")\n            else -> error(\"Unknown form content type: $value\")\n        }\n\n        result += part\n    }\n\n    return result\n}\n\n/**\n * Build multipart form using [block] function.\n */\npublic fun formData(block: FormBuilder.() -> Unit): List<PartData> =\n    formData(*FormBuilder().apply(block).build().toTypedArray())\n\n/**\n * Form builder type used in [formData] builder function.\n */\npublic class FormBuilder internal constructor() {\n    private val parts = mutableListOf<FormPart<*>>()\n\n    /**\n     * Append a pair [key]:[value] with optional [headers].\n     */\n    @InternalAPI\n    public fun <T : Any> append(key: String, value: T, headers: Headers = Headers.Empty) {\n        parts += FormPart(key, value, headers)\n    }\n\n    /**\n     * Append a pair [key]:[value] with optional [headers].\n     */\n    public fun append(key: String, value: String, headers: Headers = Headers.Empty) {\n        parts += FormPart(key, value, headers)\n    }\n\n    /**\n     * Append a pair [key]:[value] with optional [headers].\n     */\n    public fun append(key: String, value: Number, headers: Headers = Headers.Empty) {\n        parts += FormPart(key, value, headers)\n    }\n\n    /**\n     * Append a pair [key]:[value] with optional [headers].\n     */\n    public fun append(key: String, value: ByteArray, headers: Headers = Headers.Empty) {\n        parts += FormPart(key, value, headers)\n    }\n\n    /**\n     * Append a pair [key]:[value] with optional [headers].\n     */\n    public fun append(key: String, value: InputProvider, headers: Headers = Headers.Empty) {\n        parts += FormPart(key, value, headers)\n    }\n\n    /**\n     * Append a pair [key]:[InputProvider(block)] with optional [headers].\n     */\n    public fun appendInput(key: String, headers: Headers = Headers.Empty, size: Long? = null, block: () -> Input) {\n        parts += FormPart(key, InputProvider(size, block), headers)\n    }\n\n    /**\n     * Append a pair [key]:[value] with optional [headers].\n     */\n    public fun append(key: String, value: ByteReadPacket, headers: Headers = Headers.Empty) {\n        parts += FormPart(key, value, headers)\n    }\n\n    /**\n     * Append a pair [key]:[value] with optional [headers].\n     */\n    @Suppress(\"UNUSED_PARAMETER\")\n    @Deprecated(\n        \"Input is not reusable. Please use [InputProvider] instead.\",\n        level = DeprecationLevel.ERROR,\n        replaceWith = ReplaceWith(\"appendInput(key, headers) { /* create fresh input here */ }\")\n    )\n    public fun append(key: String, value: Input, headers: Headers = Headers.Empty) {\n        error(\"Input is not reusable. Please use [InputProvider] instead.\")\n    }\n\n    /**\n     * Append a form [part].\n     */\n    public fun <T : Any> append(part: FormPart<T>) {\n        parts += part\n    }\n\n    internal fun build(): List<FormPart<*>> = parts\n}\n\n/**\n * Append a form part with the specified [key] using [bodyBuilder] for it's body.\n */\n@OptIn(ExperimentalContracts::class)\npublic inline fun FormBuilder.append(\n    key: String,\n    headers: Headers = Headers.Empty,\n    size: Long? = null,\n    crossinline bodyBuilder: BytePacketBuilder.() -> Unit\n) {\n    contract {\n        callsInPlace(bodyBuilder, InvocationKind.EXACTLY_ONCE)\n    }\n    append(FormPart(key, InputProvider(size) { buildPacket { bodyBuilder() } }, headers))\n}\n\n/**\n * Reusable [Input] form entry.\n *\n * @property size estimate for data produced by the block or `null` if no size estimation known\n * @param block: content generator\n */\npublic class InputProvider(public val size: Long? = null, public val block: () -> Input)\n\n/**\n * Append a form part with the specified [key], [filename] and optional [contentType] using [bodyBuilder] for it's body.\n */\n@OptIn(ExperimentalContracts::class)\npublic fun FormBuilder.append(\n    key: String,\n    filename: String,\n    contentType: ContentType? = null,\n    size: Long? = null,\n    bodyBuilder: BytePacketBuilder.() -> Unit\n) {\n    contract {\n        callsInPlace(bodyBuilder, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val headersBuilder = HeadersBuilder()\n    headersBuilder[HttpHeaders.ContentDisposition] = \"filename=${filename.escapeIfNeeded()}\"\n    contentType?.run { headersBuilder[HttpHeaders.ContentType] = this.toString() }\n    val headers = headersBuilder.build()\n\n    append(key, headers, size, bodyBuilder)\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.request\n\nimport io.ktor.client.*\nimport io.ktor.client.call.*\nimport io.ktor.client.engine.*\nimport io.ktor.client.utils.*\nimport io.ktor.http.*\nimport io.ktor.http.content.*\nimport io.ktor.util.*\nimport io.ktor.util.date.*\nimport io.ktor.utils.io.*\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\n/**\n * A request for [HttpClient], first part of [HttpClientCall].\n */\npublic interface HttpRequest : HttpMessage, CoroutineScope {\n    /**\n     * The associated [HttpClientCall] containing both\n     * the underlying [HttpClientCall.request] and [HttpClientCall.response].\n     */\n    public val call: HttpClientCall\n\n    override val coroutineContext: CoroutineContext get() = call.coroutineContext\n\n    /**\n     * The [HttpMethod] or HTTP VERB used for this request.\n     */\n    public val method: HttpMethod\n\n    /**\n     * The [Url] representing the endpoint and the uri for this request.\n     */\n    public val url: Url\n\n    /**\n     * Typed [Attributes] associated to this call serving as a lightweight container.\n     */\n    public val attributes: Attributes\n\n    @Deprecated(\n        \"Binary compatibility.\",\n        level = DeprecationLevel.HIDDEN\n    )\n    @Suppress(\"unused\", \"KDocMissingDocumentation\")\n    public val executionContext: Job\n        get() = coroutineContext[Job]!!\n\n    /**\n     * An [OutgoingContent] representing the request body\n     */\n    public val content: OutgoingContent\n}\n\n/**\n * Class for building [HttpRequestData].\n */\npublic class HttpRequestBuilder : HttpMessageBuilder {\n    /**\n     * [URLBuilder] to configure the URL for this request.\n     */\n    public val url: URLBuilder = URLBuilder()\n\n    /**\n     * [HttpMethod] used by this request. [HttpMethod.Get] by default.\n     */\n    public var method: HttpMethod = HttpMethod.Get\n\n    /**\n     * [HeadersBuilder] to configure the headers for this request.\n     */\n    override val headers: HeadersBuilder = HeadersBuilder()\n\n    /**\n     * The [body] for this request. Initially [EmptyContent].\n     */\n    public var body: Any = EmptyContent\n\n    /**\n     * A deferred used to control the execution of this request.\n     */\n    public var executionContext: Job = SupervisorJob()\n        .also { it.makeShared() }\n        internal set(value) {\n            value.makeShared()\n            field = value\n        }\n\n    /**\n     * Call specific attributes.\n     */\n    public val attributes: Attributes = Attributes(concurrent = true)\n\n    /**\n     * Executes a [block] that configures the [URLBuilder] associated to this request.\n     */\n    public fun url(block: URLBuilder.(URLBuilder) -> Unit): Unit = url.block(url)\n\n    /**\n     * Create immutable [HttpRequestData]\n     */\n    public fun build(): HttpRequestData = HttpRequestData(\n        url.build(),\n        method,\n        headers.build(),\n        body as? OutgoingContent ?: error(\"No request transformation found: $body\"),\n        executionContext,\n        attributes\n    )\n\n    /**\n     * Set request specific attributes specified by [block].\n     */\n    public fun setAttributes(block: Attributes.() -> Unit) {\n        attributes.apply(block)\n    }\n\n    /**\n     * Mutates [this] copying all the data from another [builder] using it as base.\n     */\n    @InternalAPI\n    public fun takeFromWithExecutionContext(builder: HttpRequestBuilder): HttpRequestBuilder {\n        executionContext = builder.executionContext\n        return takeFrom(builder)\n    }\n\n    /**\n     * Mutates [this] copying all the data but execution context from another [builder] using it as base.\n     */\n    public fun takeFrom(builder: HttpRequestBuilder): HttpRequestBuilder {\n        method = builder.method\n        body = builder.body\n        url.takeFrom(builder.url)\n        url.encodedPath = if (url.encodedPath.isBlank()) \"/\" else url.encodedPath\n        headers.appendAll(builder.headers)\n        attributes.putAll(builder.attributes)\n\n        return this\n    }\n\n    /**\n     * Set capability configuration.\n     */\n    public fun <T : Any> setCapability(key: HttpClientEngineCapability<T>, capability: T) {\n        val capabilities = attributes.computeIfAbsent(ENGINE_CAPABILITIES_KEY) { sharedMap() }\n        capabilities[key] = capability\n    }\n\n    /**\n     * Retrieve capability by key.\n     */\n    public fun <T : Any> getCapabilityOrNull(key: HttpClientEngineCapability<T>): T? {\n        @Suppress(\"UNCHECKED_CAST\")\n        return attributes.getOrNull(ENGINE_CAPABILITIES_KEY)?.get(key) as T?\n    }\n\n    public companion object\n}\n\n/**\n * Actual data of the [HttpRequest], including [url], [method], [headers], [body] and [executionContext].\n * Built by [HttpRequestBuilder].\n */\npublic class HttpRequestData @InternalAPI constructor(\n    public val url: Url,\n    public val method: HttpMethod,\n    public val headers: Headers,\n    public val body: OutgoingContent,\n    public val executionContext: Job,\n    public val attributes: Attributes\n) {\n    /**\n     * Retrieve extension by its key.\n     */\n    public fun <T> getCapabilityOrNull(key: HttpClientEngineCapability<T>): T? {\n        @Suppress(\"UNCHECKED_CAST\")\n        return attributes.getOrNull(ENGINE_CAPABILITIES_KEY)?.get(key) as T?\n    }\n\n    /**\n     * All extension keys associated with this request.\n     */\n    internal val requiredCapabilities: Set<HttpClientEngineCapability<*>> =\n        attributes.getOrNull(ENGINE_CAPABILITIES_KEY)?.keys ?: emptySet()\n\n    override fun toString(): String = \"HttpRequestData(url=$url, method=$method)\"\n}\n\n/**\n * Data prepared for [HttpResponse].\n */\npublic class HttpResponseData constructor(\n    public val statusCode: HttpStatusCode,\n    public val requestTime: GMTDate,\n    public val headers: Headers,\n    public val version: HttpProtocolVersion,\n    public val body: Any,\n    public val callContext: CoroutineContext\n) {\n    public val responseTime: GMTDate = GMTDate()\n\n    override fun toString(): String = \"HttpResponseData=(statusCode=$statusCode)\"\n}\n\n/**\n * Executes a [block] that configures the [HeadersBuilder] associated to this request.\n */\npublic fun HttpRequestBuilder.headers(block: HeadersBuilder.() -> Unit): HeadersBuilder = headers.apply(block)\n\n/**\n * Mutates [this] copying all the data from another [request] using it as base.\n */\npublic fun HttpRequestBuilder.takeFrom(request: HttpRequest): HttpRequestBuilder {\n    method = request.method\n    body = request.content\n    url.takeFrom(request.url)\n    headers.appendAll(request.headers)\n    attributes.putAll(request.attributes)\n    return this\n}\n\n/**\n * Executes a [block] that configures the [URLBuilder] associated to this request.\n */\npublic fun HttpRequestBuilder.url(block: URLBuilder.() -> Unit): Unit = block(url)\n\n/**\n * Sets the [HttpRequestBuilder] from [request].\n */\npublic fun HttpRequestBuilder.takeFrom(request: HttpRequestData): HttpRequestBuilder {\n    method = request.method\n    body = request.body\n    url.takeFrom(request.url)\n    headers.appendAll(request.headers)\n    attributes.putAll(request.attributes)\n\n    return this\n}\n\n/**\n * Executes a [block] that configures the [URLBuilder] associated to thisrequest.\n */\npublic operator fun HttpRequestBuilder.Companion.invoke(block: URLBuilder.() -> Unit): HttpRequestBuilder =\n    HttpRequestBuilder().apply { url(block) }\n\n/**\n * Sets the [url] using the specified [scheme], [host], [port] and [path].\n */\npublic fun HttpRequestBuilder.url(\n    scheme: String = \"http\",\n    host: String = \"localhost\",\n    port: Int = DEFAULT_PORT,\n    path: String = \"/\",\n    block: URLBuilder.() -> Unit = {}\n): Unit { // ktlint-disable filename no-unit-return\n    url.apply {\n        protocol = URLProtocol.createOrDefault(scheme)\n        this.host = host\n        this.port = port\n        encodedPath = path\n        block(url)\n    }\n}\n\n/**\n * Constructs a [HttpRequestBuilder] from URL information: [scheme], [host], [port] and [path]\n * and optionally further configures it using [block].\n */\npublic operator fun HttpRequestBuilder.Companion.invoke(\n    scheme: String = \"http\",\n    host: String = \"localhost\",\n    port: Int = DEFAULT_PORT,\n    path: String = \"/\",\n    block: URLBuilder.() -> Unit = {}\n): HttpRequestBuilder = HttpRequestBuilder().apply { url(scheme, host, port, path, block) }\n\n/**\n * Sets the [HttpRequestBuilder.url] from [urlString].\n */\npublic fun HttpRequestBuilder.url(urlString: String): Unit { // ktlint-disable filename no-unit-return\n    url.takeFrom(urlString)\n}\n\n@InternalAPI\n@Suppress(\"KDocMissingDocumentation\")\npublic fun HttpRequestData.isUpgradeRequest(): Boolean {\n    return body is ClientUpgradeContent\n}\n","@file:Suppress(\"RedundantModalityModifier\", \"FunctionName\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.pool.*\n\n/**\n * Read-only immutable byte packet. Could be consumed only once however it does support [copy] that doesn't copy every byte\n * but creates a new view instead. Once packet created it should be either completely read (consumed) or released\n * via [release].\n */\npublic class ByteReadPacket internal constructor(\n    head: ChunkBuffer,\n    remaining: Long,\n    pool: ObjectPool<ChunkBuffer>\n) :\n    @Suppress(\"DEPRECATION_ERROR\")\n    ByteReadPacketPlatformBase(head, remaining, pool),\n    Input {\n    public constructor(head: ChunkBuffer, pool: ObjectPool<ChunkBuffer>) : this(head, head.remainingAll(), pool)\n\n    @Suppress(\"DEPRECATION\", \"UNUSED\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public constructor(head: IoBuffer, pool: ObjectPool<ChunkBuffer>) : this(head, head.remainingAll(), pool)\n\n    init {\n        markNoMoreChunksAvailable()\n    }\n\n    /**\n     * Returns a copy of the packet. The original packet and the copy could be used concurrently. Both need to be\n     * either completely consumed or released via [release]\n     */\n    public final fun copy(): ByteReadPacket = ByteReadPacket(head.copyAll(), remaining, pool)\n\n    final override fun fill(): ChunkBuffer? = null\n\n    final override fun fill(destination: Memory, offset: Int, length: Int): Int {\n        return 0\n    }\n\n    final override fun closeSource() {\n    }\n\n    override fun toString(): String {\n        return \"ByteReadPacket($remaining bytes remaining)\"\n    }\n\n    public companion object {\n        public val Empty: ByteReadPacket = ByteReadPacket(ChunkBuffer.Empty, 0L, ChunkBuffer.EmptyPool)\n\n        @DangerousInternalIoApi\n        public val ReservedSize: Int\n            get() = Buffer.ReservedSize\n    }\n}\n\n@Suppress(\"DEPRECATION\")\n@DangerousInternalIoApi\n@Deprecated(\n    \"Will be removed in future releases.\",\n    level = DeprecationLevel.ERROR,\n    replaceWith = ReplaceWith(\"AbstractInput\", \"io.ktor.utils.io.core.AbstractInput\")\n)\npublic abstract class ByteReadPacketPlatformBase protected constructor(\n    head: ChunkBuffer,\n    remaining: Long,\n    pool: ObjectPool<ChunkBuffer>\n) : ByteReadPacketBase(head, remaining, pool) {\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public constructor(\n        head: IoBuffer,\n        remaining: Long,\n        pool: ObjectPool<ChunkBuffer>\n    ) : this(head as ChunkBuffer, remaining, pool)\n}\n\npublic expect fun ByteReadPacket(\n    array: ByteArray,\n    offset: Int = 0,\n    length: Int = array.size,\n    block: (ByteArray) -> Unit\n): ByteReadPacket\n\n@Suppress(\"NOTHING_TO_INLINE\")\npublic inline fun ByteReadPacket(array: ByteArray, offset: Int = 0, length: Int = array.size): ByteReadPacket {\n    return ByteReadPacket(array, offset, length) {}\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.statement\n\nimport io.ktor.client.call.*\nimport io.ktor.client.request.*\nimport io.ktor.http.*\nimport io.ktor.util.*\nimport io.ktor.util.date.*\nimport io.ktor.utils.io.*\nimport kotlin.coroutines.*\n\n@InternalAPI\npublic class DefaultHttpResponse(\n    override val call: HttpClientCall,\n    responseData: HttpResponseData\n) : HttpResponse() {\n    override val coroutineContext: CoroutineContext = responseData.callContext\n\n    override val status: HttpStatusCode = responseData.statusCode\n\n    override val version: HttpProtocolVersion = responseData.version\n\n    override val requestTime: GMTDate = responseData.requestTime\n\n    override val responseTime: GMTDate = responseData.responseTime\n\n    override val content: ByteReadChannel = responseData.body as? ByteReadChannel\n        ?: ByteReadChannel.Empty\n\n    override val headers: Headers = responseData.headers\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.request\n\nimport io.ktor.http.*\nimport io.ktor.util.date.*\n\n/**\n * Gets the associated URL's host.\n */\npublic var HttpRequestBuilder.host: String\n    get() = url.host\n    set(value) {\n        url.host = value\n    }\n\n/**\n * Gets the associated URL's port.\n */\npublic var HttpRequestBuilder.port: Int\n    get() = url.port\n    set(value) {\n        url.port = value\n    }\n\n/**\n * Sets a single header of [key] with a specific [value] if the value is not null.\n */\npublic fun HttpRequestBuilder.header(key: String, value: Any?): Unit =\n    value?.let { headers.append(key, it.toString()) } ?: Unit\n\n/**\n * Sets a single header of [key] with a specific [value] if the value is not null.\n */\npublic fun HttpRequestBuilder.cookie(\n    name: String,\n    value: String,\n    maxAge: Int = 0,\n    expires: GMTDate? = null,\n    domain: String? = null,\n    path: String? = null,\n    secure: Boolean = false,\n    httpOnly: Boolean = false,\n    extensions: Map<String, String?> = emptyMap()\n): Unit { // ktlint-disable no-unit-return\n    val renderedCookie = Cookie(\n        name = name,\n        value = value,\n        maxAge = maxAge,\n        expires = expires,\n        domain = domain,\n        path = path,\n        secure = secure,\n        httpOnly = httpOnly,\n        extensions = extensions\n    ).let(::renderCookieHeader)\n\n    if (HttpHeaders.Cookie !in headers) {\n        headers.append(HttpHeaders.Cookie, renderedCookie)\n        return\n    }\n    // Client cookies are stored in a single header \"Cookies\" and multiple values are separated with \";\"\n    headers[HttpHeaders.Cookie] = headers[HttpHeaders.Cookie] + \"; \" + renderedCookie\n}\n\n/**\n * Sets a single URL query parameter of [key] with a specific [value] if the value is not null. Can not be used to set\n * form parameters in the body.\n */\npublic fun HttpRequestBuilder.parameter(key: String, value: Any?): Unit =\n    value?.let { url.parameters.append(key, it.toString()) } ?: Unit\n\n/**\n * Sets the `Accept` header with a specific [contentType].\n */\npublic fun HttpRequestBuilder.accept(contentType: ContentType): Unit =\n    headers.append(HttpHeaders.Accept, contentType.toString())\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\n@file:Suppress(\"KDocMissingDocumentation\")\n\npackage io.ktor.client.response\n\nimport io.ktor.http.*\nimport io.ktor.utils.io.charsets.*\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\n@Deprecated(\n    \"Unbound streaming [HttpResponse] is deprecated. Consider using [HttpStatement] instead.\",\n    level = DeprecationLevel.ERROR,\n    replaceWith = ReplaceWith(\"HttpStatement\", \"io.ktor.client.statement.*\")\n)\npublic class HttpResponse : CoroutineScope, HttpMessage {\n    override val coroutineContext: CoroutineContext\n        get() = error(\"Unbound streaming [HttpResponse] is deprecated. Consider using [HttpStatement] instead.\")\n    override val headers: Headers\n        get() = error(\"Unbound streaming [HttpResponse] is deprecated. Consider using [HttpStatement] instead.\")\n}\n\n@Suppress(\"DEPRECATION_ERROR\", \"unused\", \"UNUSED_PARAMETER\", \"RedundantSuspendModifier\")\n@Deprecated(\n    \"Unbound streaming [HttpResponse] is deprecated. Consider using [HttpStatement] instead.\",\n    level = DeprecationLevel.ERROR\n)\npublic suspend fun HttpResponse.readText(charset: Charset? = null): String {\n    error(\"Unbound streaming [HttpResponse] is deprecated. Consider using [HttpStatement] instead.\")\n}\n\n/**\n * Exactly reads [count] bytes of the [HttpResponse.content].\n */\n@Deprecated(\n    \"Unbound streaming [HttpResponse] is deprecated. Consider using [HttpStatement] instead.\",\n    level = DeprecationLevel.ERROR\n)\n@Suppress(\"DEPRECATION_ERROR\", \"unused\", \"UNUSED_PARAMETER\", \"RedundantSuspendModifier\")\npublic suspend fun HttpResponse.readBytes(count: Int): ByteArray {\n    error(\"Unbound streaming [HttpResponse] is deprecated. Consider using [HttpStatement] instead.\")\n}\n\n/**\n * Reads the whole [HttpResponse.content] if Content-Length was specified.\n * Otherwise it just reads one byte.\n */\n@Deprecated(\n    \"Unbound streaming [HttpResponse] is deprecated. Consider using [HttpStatement] instead.\",\n    level = DeprecationLevel.ERROR\n)\n@Suppress(\"DEPRECATION_ERROR\", \"unused\", \"UNUSED_PARAMETER\", \"RedundantSuspendModifier\")\npublic suspend fun HttpResponse.readBytes(): ByteArray {\n    error(\"Unbound streaming [HttpResponse] is deprecated. Consider using [HttpStatement] instead.\")\n}\n\n/**\n * Efficiently discards the remaining bytes of [HttpResponse.content].\n */\n@Deprecated(\n    \"Unbound streaming [HttpResponse] is deprecated. Consider using [HttpStatement] instead.\",\n    level = DeprecationLevel.ERROR\n)\n@Suppress(\"DEPRECATION_ERROR\", \"unused\", \"UNUSED_PARAMETER\", \"RedundantSuspendModifier\")\npublic suspend fun HttpResponse.discardRemaining() {\n    error(\"Unbound streaming [HttpResponse] is deprecated. Consider using [HttpStatement] instead.\")\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.statement\n\nimport io.ktor.client.*\nimport io.ktor.client.call.*\nimport io.ktor.client.request.*\nimport io.ktor.http.*\nimport io.ktor.util.*\nimport io.ktor.util.date.*\nimport io.ktor.utils.io.*\nimport kotlinx.coroutines.*\n\n/**\n * A response for [HttpClient], second part of [HttpClientCall].\n */\npublic abstract class HttpResponse : HttpMessage, CoroutineScope {\n    /**\n     * The associated [HttpClientCall] containing both\n     * the underlying [HttpClientCall.request] and [HttpClientCall.response].\n     */\n    public abstract val call: HttpClientCall\n\n    /**\n     * The [HttpStatusCode] returned by the server. It includes both,\n     * the [HttpStatusCode.description] and the [HttpStatusCode.value] (code).\n     */\n    public abstract val status: HttpStatusCode\n\n    /**\n     * HTTP version. Usually [HttpProtocolVersion.HTTP_1_1] or [HttpProtocolVersion.HTTP_2_0].\n     */\n    public abstract val version: HttpProtocolVersion\n\n    /**\n     * [GMTDate] of the request start.\n     */\n    public abstract val requestTime: GMTDate\n\n    /**\n     * [GMTDate] of the response start.\n     */\n    public abstract val responseTime: GMTDate\n\n    /**\n     * Unmodified [ByteReadChannel] with the raw payload of the response.\n     *\n     * **Note:** this content doesn't go through any interceptors from [HttpResponsePipeline].\n     * If you need modified content, use [HttpResponse::receive<ByteReadChannel>] function.\n     */\n    public abstract val content: ByteReadChannel\n\n    override fun toString(): String = \"HttpResponse[${request.url}, $status]\"\n}\n\n/**\n * [HttpRequest] associated with this response.\n */\npublic val HttpResponse.request: HttpRequest get() = call.request\n\n@Suppress(\"unused\", \"KDocMissingDocumentation\")\n@Deprecated(\"Close is obsolete for [HttpResponse]\", replaceWith = ReplaceWith(\"this\"))\npublic fun HttpResponse.close() {\n}\n\n@Suppress(\"UNUSED_PARAMETER\", \"KDocMissingDocumentation\", \"unused\")\n@Deprecated(\"Use is obsolete for [HttpResponse]\", replaceWith = ReplaceWith(\"this.also(block)\"))\npublic fun HttpResponse.use(block: () -> Unit) {\n}\n\n@Suppress(\"unused\", \"KDocMissingDocumentation\")\n@Deprecated(\"[response] is obsolete for [HttpResponse]\", replaceWith = ReplaceWith(\"this\"))\npublic val HttpResponse.response: HttpResponse\n    get() = this\n\n@InternalAPI\n@PublishedApi\ninternal fun HttpResponse.complete() {\n    val job = coroutineContext[Job]!! as CompletableJob\n    job.complete()\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.statement\n\nimport io.ktor.client.*\nimport io.ktor.client.call.*\nimport io.ktor.util.pipeline.*\nimport io.ktor.util.reflect.TypeInfo\nimport io.ktor.client.call.TypeInfo as DeprecatedTypeInfo\n\n/**\n * [HttpClient] Pipeline used for executing [HttpResponse].\n */\npublic class HttpResponsePipeline(\n    override val developmentMode: Boolean = false\n) : Pipeline<HttpResponseContainer, HttpClientCall>(\n    Receive,\n    Parse,\n    Transform,\n    State,\n    After\n) {\n    public companion object Phases {\n        /**\n         * The earliest phase that happens before any other\n         */\n        public val Receive: PipelinePhase = PipelinePhase(\"Receive\")\n\n        /**\n         * Decode response body\n         */\n        public val Parse: PipelinePhase = PipelinePhase(\"Parse\")\n\n        /**\n         * Transform response body to expected format\n         */\n        public val Transform: PipelinePhase = PipelinePhase(\"Transform\")\n\n        /**\n         * Use this phase to store request shared state\n         */\n        public val State: PipelinePhase = PipelinePhase(\"State\")\n\n        /**\n         * Latest response pipeline phase\n         */\n        public val After: PipelinePhase = PipelinePhase(\"After\")\n    }\n}\n\n/**\n * [HttpClient] Pipeline used for receiving [HttpResponse] without any processing.\n */\npublic class HttpReceivePipeline(\n    override val developmentMode: Boolean = false\n) : Pipeline<HttpResponse, HttpClientCall>(Before, State, After) {\n    public companion object Phases {\n        /**\n         * The earliest phase that happens before any other\n         */\n        public val Before: PipelinePhase = PipelinePhase(\"Before\")\n\n        /**\n         * Use this phase to store request shared state\n         */\n        public val State: PipelinePhase = PipelinePhase(\"State\")\n\n        /**\n         * Latest response pipeline phase\n         */\n        public val After: PipelinePhase = PipelinePhase(\"After\")\n    }\n}\n\n/**\n * Class representing a typed [response] with an attached [expectedType].\n * @param expectedType: information about expected type.\n * @param response: current response state.\n */\npublic data class HttpResponseContainer(val expectedType: DeprecatedTypeInfo, val response: Any) {\n    public constructor(expectedType: TypeInfo, response: Any) : this(\n        DeprecatedTypeInfo(expectedType.type, expectedType.reifiedType, expectedType.kotlinType),\n        response\n    )\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.statement\n\nimport io.ktor.utils.io.*\nimport io.ktor.utils.io.core.*\n\n/**\n * Exactly reads [count] bytes of the [HttpResponse.content].\n */\npublic suspend fun HttpResponse.readBytes(count: Int): ByteArray = ByteArray(count).also {\n    content.readFully(it)\n}\n\n/**\n * Reads the whole [HttpResponse.content] if Content-Length was specified.\n * Otherwise it just reads one byte.\n */\npublic suspend fun HttpResponse.readBytes(): ByteArray = content.readRemaining().readBytes()\n\n/**\n * Efficiently discards the remaining bytes of [HttpResponse.content].\n */\npublic suspend fun HttpResponse.discardRemaining() {\n    content.discard()\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.utils\n\n/**\n * List of [CacheControl] known values.\n */\n@Suppress(\"KDocMissingDocumentation\", \"MemberVisibilityCanBePrivate\")\npublic object CacheControl {\n    public const val MAX_AGE: String = \"max-age\"\n    public const val MIN_FRESH: String = \"min-fresh\"\n    public const val ONLY_IF_CACHED: String = \"only-if-cached\"\n\n    public const val MAX_STALE: String = \"max-stale\"\n    public const val NO_CACHE: String = \"no-cache\"\n    public const val NO_STORE: String = \"no-store\"\n    public const val NO_TRANSFORM: String = \"no-transform\"\n\n    public const val MUST_REVALIDATE: String = \"must-revalidate\"\n    public const val PUBLIC: String = \"public\"\n    public const val PRIVATE: String = \"private\"\n    public const val PROXY_REVALIDATE: String = \"proxy-revalidate\"\n    public const val S_MAX_AGE: String = \"s-maxage\"\n\n    // ------- binary compatibility\n\n    @Suppress(\"unused\", \"KDocMissingDocumentation\", \"FunctionName\")\n    @Deprecated(\"Compatibility\", level = DeprecationLevel.HIDDEN)\n    public fun getMAX_AGE(): String = MAX_AGE\n\n    @Suppress(\"unused\", \"KDocMissingDocumentation\", \"FunctionName\")\n    @Deprecated(\"Compatibility\", level = DeprecationLevel.HIDDEN)\n    public fun getMIN_FRESH(): String = MIN_FRESH\n\n    @Suppress(\"unused\", \"KDocMissingDocumentation\", \"FunctionName\")\n    @Deprecated(\"Compatibility\", level = DeprecationLevel.HIDDEN)\n    public fun getONLY_IF_CACHED(): String = ONLY_IF_CACHED\n\n    @Suppress(\"unused\", \"KDocMissingDocumentation\", \"FunctionName\")\n    @Deprecated(\"Compatibility\", level = DeprecationLevel.HIDDEN)\n    public fun getMAX_STALE(): String = MAX_STALE\n\n    @Suppress(\"unused\", \"KDocMissingDocumentation\", \"FunctionName\")\n    @Deprecated(\"Compatibility\", level = DeprecationLevel.HIDDEN)\n    public fun getNO_CACHE(): String = NO_CACHE\n\n    @Suppress(\"unused\", \"KDocMissingDocumentation\", \"FunctionName\")\n    @Deprecated(\"Compatibility\", level = DeprecationLevel.HIDDEN)\n    public fun getNO_STORE(): String = NO_STORE\n\n    @Suppress(\"unused\", \"KDocMissingDocumentation\", \"FunctionName\")\n    @Deprecated(\"Compatibility\", level = DeprecationLevel.HIDDEN)\n    public fun getNO_TRANSFORM(): String = NO_TRANSFORM\n\n    @Suppress(\"unused\", \"KDocMissingDocumentation\", \"FunctionName\")\n    @Deprecated(\"Compatibility\", level = DeprecationLevel.HIDDEN)\n    public fun getMUST_REVALIDATE(): String = MUST_REVALIDATE\n\n    @Suppress(\"unused\", \"KDocMissingDocumentation\", \"FunctionName\")\n    @Deprecated(\"Compatibility\", level = DeprecationLevel.HIDDEN)\n    public fun getPUBLIC(): String = PUBLIC\n\n    @Suppress(\"unused\", \"KDocMissingDocumentation\", \"FunctionName\")\n    @Deprecated(\"Compatibility\", level = DeprecationLevel.HIDDEN)\n    public fun getPRIVATE(): String = PRIVATE\n\n    @Suppress(\"unused\", \"KDocMissingDocumentation\", \"FunctionName\")\n    @Deprecated(\"Compatibility\", level = DeprecationLevel.HIDDEN)\n    public fun getPROXY_REVALIDATE(): String = PROXY_REVALIDATE\n\n    @Suppress(\"unused\", \"KDocMissingDocumentation\", \"FunctionName\")\n    @Deprecated(\"Compatibility\", level = DeprecationLevel.HIDDEN)\n    public fun getS_MAX_AGE(): String = S_MAX_AGE\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.utils\n\nimport io.ktor.http.*\nimport io.ktor.http.content.*\nimport io.ktor.utils.io.*\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\n/**\n * Concrete [OutgoingContent] without a payload.\n */\npublic object EmptyContent : OutgoingContent.NoContent() {\n    override val contentLength: Long = 0\n\n    override fun toString(): String = \"EmptyContent\"\n}\n\n/**\n * Generates a new [OutgoingContent] of the same abstract type\n * but with [OutgoingContent.headers] transformed by the specified [block].\n */\npublic fun OutgoingContent.wrapHeaders(block: (Headers) -> Headers): OutgoingContent = when (this) {\n    is OutgoingContent.NoContent -> object : OutgoingContent.NoContent() {\n        override val contentLength: Long? get() = this@wrapHeaders.contentLength\n        override val contentType: ContentType? get() = this@wrapHeaders.contentType\n        override val status: HttpStatusCode? get() = this@wrapHeaders.status\n\n        override val headers: Headers = block(this@wrapHeaders.headers)\n    }\n    is OutgoingContent.ReadChannelContent -> object : OutgoingContent.ReadChannelContent() {\n        override val contentLength: Long? get() = this@wrapHeaders.contentLength\n        override val contentType: ContentType? get() = this@wrapHeaders.contentType\n        override val status: HttpStatusCode? get() = this@wrapHeaders.status\n\n        override val headers: Headers = block(this@wrapHeaders.headers)\n\n        override fun readFrom(): ByteReadChannel = this@wrapHeaders.readFrom()\n\n        override fun readFrom(range: LongRange): ByteReadChannel = this@wrapHeaders.readFrom(range)\n    }\n    is OutgoingContent.WriteChannelContent -> object : OutgoingContent.WriteChannelContent() {\n        override val contentLength: Long? get() = this@wrapHeaders.contentLength\n        override val contentType: ContentType? get() = this@wrapHeaders.contentType\n        override val status: HttpStatusCode? get() = this@wrapHeaders.status\n\n        override val headers: Headers = block(this@wrapHeaders.headers)\n\n        override suspend fun writeTo(channel: ByteWriteChannel) = this@wrapHeaders.writeTo(channel)\n    }\n    is OutgoingContent.ByteArrayContent -> object : OutgoingContent.ByteArrayContent() {\n        override val contentLength: Long? get() = this@wrapHeaders.contentLength\n        override val contentType: ContentType? get() = this@wrapHeaders.contentType\n        override val status: HttpStatusCode? get() = this@wrapHeaders.status\n\n        override val headers: Headers = block(this@wrapHeaders.headers)\n\n        override fun bytes(): ByteArray = this@wrapHeaders.bytes()\n    }\n    is OutgoingContent.ProtocolUpgrade -> object : OutgoingContent.ProtocolUpgrade() {\n        override val contentLength: Long? get() = this@wrapHeaders.contentLength\n        override val contentType: ContentType? get() = this@wrapHeaders.contentType\n\n        override val headers: Headers = block(this@wrapHeaders.headers)\n\n        override suspend fun upgrade(\n            input: ByteReadChannel,\n            output: ByteWriteChannel,\n            engineContext: CoroutineContext,\n            userContext: CoroutineContext\n        ): Job = this@wrapHeaders.upgrade(input, output, engineContext, userContext)\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.utils\n\nimport io.ktor.util.*\nimport io.ktor.util.collections.*\n\ninternal fun <K : Any, V : Any> sharedMap(): MutableMap<K, V> {\n    if (PlatformUtils.IS_NATIVE) {\n        return ConcurrentMap()\n    }\n\n    return mutableMapOf()\n}\n\ninternal fun <V> sharedList(): MutableList<V> {\n    if (PlatformUtils.IS_NATIVE) {\n        return ConcurrentList()\n    }\n\n    return mutableListOf()\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.utils\n\nimport io.ktor.http.*\nimport io.ktor.util.*\n\n/**\n * Builds an instance of [Headers] using the [block] function.\n */\npublic fun buildHeaders(block: HeadersBuilder.() -> Unit = {}): Headers =\n    HeadersBuilder().apply(block).build()\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.network.sockets\n\nimport io.ktor.client.features.*\nimport io.ktor.client.request.*\nimport io.ktor.util.*\nimport io.ktor.utils.io.*\nimport io.ktor.utils.io.errors.*\nimport kotlinx.coroutines.*\n\n/**\n * This exception is thrown in case connect timeout exceeded.\n */\npublic expect class ConnectTimeoutException(message: String, cause: Throwable? = null) : IOException\n\n/**\n * This exception is thrown in case socket timeout (read or write) exceeded.\n */\npublic expect class SocketTimeoutException(message: String, cause: Throwable? = null) : IOException\n\n/**\n * Returns [ByteReadChannel] with [ByteChannel.close] handler that returns [SocketTimeoutException] instead of\n * [SocketTimeoutException].\n */\n@InternalAPI\npublic fun CoroutineScope.mapEngineExceptions(input: ByteReadChannel, request: HttpRequestData): ByteReadChannel {\n    if (PlatformUtils.IS_NATIVE) {\n        return input\n    }\n\n    val replacementChannel = ByteChannelWithMappedExceptions(request)\n\n    writer(channel = replacementChannel) {\n        try {\n            input.copyAndClose(replacementChannel)\n        } catch (cause: Throwable) {\n            input.cancel(cause)\n        }\n    }\n\n    return replacementChannel\n}\n\n/**\n * Returns [ByteWriteChannel] with [ByteChannel.close] handler that returns [SocketTimeoutException] instead of\n * [SocketTimeoutException].\n */\n@InternalAPI\npublic fun CoroutineScope.mapEngineExceptions(output: ByteWriteChannel, request: HttpRequestData): ByteWriteChannel {\n    if (PlatformUtils.IS_NATIVE) {\n        return output\n    }\n\n    val replacementChannel = ByteChannelWithMappedExceptions(request)\n\n    writer(channel = replacementChannel) {\n        try {\n            replacementChannel.copyAndClose(output)\n        } catch (cause: Throwable) {\n            replacementChannel.close(cause)\n        }\n    }\n\n    return replacementChannel\n}\n\n/**\n * Creates [ByteChannel] that maps close exceptions (close the channel with [SocketTimeoutException] if asked to\n * close it with [SocketTimeoutException]).\n */\ninternal expect fun ByteChannelWithMappedExceptions(request: HttpRequestData): ByteChannel\n","package io.ktor.client.engine\n\nimport io.ktor.http.*\nimport io.ktor.util.network.*\n\n/**\n * Proxy configuration.\n *\n * See [ProxyBuilder] to create proxy.\n */\npublic actual class ProxyConfig\n\n/**\n * [ProxyConfig] factory.\n */\npublic actual object ProxyBuilder {\n    /**\n     * Create http proxy from [url].\n     */\n    public actual fun http(url: Url): ProxyConfig {\n        error(\"Proxy unsupported in js client engine.\")\n    }\n\n    /**\n     * Create socks proxy from [host] and [port].\n     */\n    public actual fun socks(host: String, port: Int): ProxyConfig {\n        error(\"Proxy unsupported in js client engine.\")\n    }\n}\n\n/**\n * Resolve remote address of [ProxyConfig].\n *\n * This operations can block.\n */\npublic actual fun ProxyConfig.resolveAddress(): NetworkAddress {\n    error(\"Proxy unsupported in js client engine.\")\n}\n\n/**\n * Type of configured proxy.\n */\npublic actual val ProxyConfig.type: ProxyType\n    get() = error(\"Proxy unsupported in js client engine.\")\n","/*\n * Copyright 2014-2019 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.client.engine.js\n\nimport io.ktor.client.engine.*\n\n/**\n * [HttpClientEngineFactory] using a fetch API to execute requests.\n */\npublic object Js : HttpClientEngineFactory<HttpClientEngineConfig> {\n    override fun create(block: HttpClientEngineConfig.() -> Unit): HttpClientEngine =\n        JsClientEngine(HttpClientEngineConfig().apply(block))\n}\n\n@JsName(\"JsClient\")\npublic fun JsClient(): HttpClientEngineFactory<HttpClientEngineConfig> = Js\n","/*\n * Copyright 2014-2019 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.client.engine.js\n\nimport io.ktor.client.engine.*\nimport io.ktor.client.engine.js.compatibility.*\nimport io.ktor.client.features.*\nimport io.ktor.client.features.websocket.*\nimport io.ktor.client.request.*\nimport io.ktor.client.utils.*\nimport io.ktor.http.*\nimport io.ktor.util.*\nimport io.ktor.util.date.*\nimport kotlinx.coroutines.*\nimport org.w3c.dom.*\nimport org.w3c.dom.events.*\nimport kotlin.coroutines.*\n\ninternal class JsClientEngine(override val config: HttpClientEngineConfig) : HttpClientEngineBase(\"ktor-js\") {\n\n    override val dispatcher = Dispatchers.Default\n\n    override val supportedCapabilities = setOf(HttpTimeout, WebSocketCapability)\n\n    init {\n        check(config.proxy == null) { \"Proxy unsupported in Js engine.\" }\n    }\n\n    override suspend fun execute(data: HttpRequestData): HttpResponseData {\n        val callContext = callContext()\n\n        if (data.isUpgradeRequest()) {\n            return executeWebSocketRequest(data, callContext)\n        }\n\n        val requestTime = GMTDate()\n        val rawRequest = data.toRaw(callContext)\n        val rawResponse = commonFetch(data.url.toString(), rawRequest)\n\n        val status = HttpStatusCode(rawResponse.status.toInt(), rawResponse.statusText)\n        val headers = rawResponse.headers.mapToKtor()\n        val version = HttpProtocolVersion.HTTP_1_1\n\n        val body = CoroutineScope(callContext).readBody(rawResponse)\n\n        return HttpResponseData(\n            status,\n            requestTime,\n            headers,\n            version,\n            body,\n            callContext\n        )\n    }\n\n    // Adding \"_capturingHack\" to reduce chances of JS IR backend to rename variable,\n    // so it can be accessed inside js(\"\") function\n    private fun createWebSocket(urlString_capturingHack: String, headers: Headers): WebSocket {\n        return if (PlatformUtils.IS_NODE) {\n            val ws_capturingHack = js(\"eval('require')('ws')\")\n            val headers_capturingHack: dynamic = object {}\n            headers.forEach { name, values ->\n                headers_capturingHack[name] = values.joinToString(\",\")\n            }\n            js(\"new ws_capturingHack(urlString_capturingHack, { headers: headers_capturingHack } )\")\n        } else {\n            js(\"new WebSocket(urlString_capturingHack)\")\n        }\n    }\n\n    private suspend fun executeWebSocketRequest(\n        request: HttpRequestData,\n        callContext: CoroutineContext\n    ): HttpResponseData {\n        val requestTime = GMTDate()\n\n        val urlString = request.url.toString()\n        val socket: WebSocket = createWebSocket(urlString, request.headers)\n\n        try {\n            socket.awaitConnection()\n        } catch (cause: Throwable) {\n            callContext.cancel(CancellationException(\"Failed to connect to $urlString\", cause))\n            throw cause\n        }\n\n        val session = JsWebSocketSession(callContext, socket)\n\n        return HttpResponseData(\n            HttpStatusCode.OK,\n            requestTime,\n            Headers.Empty,\n            HttpProtocolVersion.HTTP_1_1,\n            session,\n            callContext\n        )\n    }\n}\n\nprivate suspend fun WebSocket.awaitConnection(): WebSocket = suspendCancellableCoroutine { continuation ->\n    if (continuation.isCancelled) return@suspendCancellableCoroutine\n\n    val eventListener = { event: Event ->\n        when (event.type) {\n            \"open\" -> continuation.resume(this)\n            \"error\" -> continuation.resumeWithException(WebSocketException(JSON.stringify(event)))\n        }\n    }\n\n    addEventListener(\"open\", callback = eventListener)\n    addEventListener(\"error\", callback = eventListener)\n\n    continuation.invokeOnCancellation {\n        removeEventListener(\"open\", callback = eventListener)\n        removeEventListener(\"error\", callback = eventListener)\n\n        if (it != null) {\n            this@awaitConnection.close()\n        }\n    }\n}\n\nprivate fun io.ktor.client.fetch.Headers.mapToKtor(): Headers = buildHeaders {\n    this@mapToKtor.asDynamic().forEach { value: String, key: String ->\n        append(key, value)\n    }\n\n    Unit\n}\n\n/**\n * Wrapper for javascript `error` objects.\n * @property origin: fail reason\n */\npublic class JsError(public val origin: dynamic) : Throwable(\"Error from javascript[$origin].\")\n","/*\n * Copyright 2014-2019 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.client.engine.js\n\nimport io.ktor.client.engine.*\nimport io.ktor.client.fetch.RequestInit\nimport io.ktor.client.request.*\nimport io.ktor.http.content.*\nimport io.ktor.utils.io.*\nimport io.ktor.utils.io.core.*\nimport kotlinx.coroutines.*\nimport org.khronos.webgl.Uint8Array\nimport org.w3c.fetch.*\nimport kotlin.coroutines.*\n\ninternal suspend fun HttpRequestData.toRaw(callContext: CoroutineContext): RequestInit {\n    val jsHeaders = js(\"({})\")\n    mergeHeaders(this@toRaw.headers, this@toRaw.body) { key, value ->\n        jsHeaders[key] = value\n    }\n\n    val bodyBytes = when (val content = body) {\n        is OutgoingContent.ByteArrayContent -> content.bytes()\n        is OutgoingContent.ReadChannelContent -> content.readFrom().readRemaining().readBytes()\n        is OutgoingContent.WriteChannelContent -> {\n            GlobalScope.writer(callContext) {\n                content.writeTo(channel)\n            }.channel.readRemaining().readBytes()\n        }\n        else -> null\n    }\n\n    return buildObject {\n        method = this@toRaw.method.value\n        headers = jsHeaders\n        redirect = RequestRedirect.FOLLOW\n\n        bodyBytes?.let { body = Uint8Array(it.toTypedArray()) }\n    }\n}\n\ninternal fun <T> buildObject(block: T.() -> Unit): T = (js(\"{}\") as T).apply(block)\n","/*\n * Copyright 2014-2019 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.client.engine.js\n\nimport kotlinx.coroutines.*\nimport org.khronos.webgl.*\nimport kotlin.coroutines.*\nimport kotlin.js.*\n\ninternal external interface ReadableStream {\n    public fun getReader(): ReadableStreamReader\n}\n\ninternal external interface ReadResult {\n    val done: Boolean\n    val value: Uint8Array?\n}\n\ninternal external interface ReadableStreamReader {\n    public fun cancel(reason: dynamic): Promise<dynamic>\n    public fun read(): Promise<ReadResult>\n}\n\ninternal suspend fun ReadableStreamReader.readChunk(): Uint8Array? = suspendCancellableCoroutine { continuation ->\n    read().then {\n        val chunk = it.value\n        val result = if (it.done || chunk == null) null else chunk\n        continuation.resumeWith(Result.success(result))\n    }.catch { cause ->\n        continuation.resumeWithException(cause)\n    }\n}\n\n@Suppress(\"UnsafeCastFromDynamic\")\ninternal fun Uint8Array.asByteArray(): ByteArray {\n    return Int8Array(buffer, byteOffset, length).asDynamic()\n}\n","/*\n * Copyright 2014-2019 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.client.engine.js.browser\n\nimport io.ktor.client.engine.js.*\nimport io.ktor.client.engine.js.ReadableStream\nimport io.ktor.client.fetch.*\nimport io.ktor.utils.io.*\nimport kotlinx.coroutines.*\n\ninternal fun CoroutineScope.readBodyBrowser(response: Response): ByteReadChannel {\n    @Suppress(\"UNCHECKED_CAST_TO_EXTERNAL_INTERFACE\")\n    val stream = response.body as? ReadableStream ?: error(\"Fail to obtain native stream: ${response.asDynamic()}\")\n    return channelFromStream(stream)\n}\n\ninternal fun CoroutineScope.channelFromStream(\n    stream: ReadableStream\n): ByteReadChannel = writer {\n    val reader = stream.getReader()\n    while (true) {\n        try {\n            val chunk = reader.readChunk() ?: break\n            channel.writeFully(chunk.asByteArray())\n        } catch (cause: Throwable) {\n            reader.cancel(cause)\n            throw cause\n        }\n    }\n}.channel\n","/*\n * Copyright 2014-2019 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.client.engine.js.compatibility\n\nimport io.ktor.client.engine.js.browser.*\nimport io.ktor.client.engine.js.node.*\nimport io.ktor.client.fetch.*\nimport io.ktor.util.*\nimport io.ktor.utils.io.*\nimport kotlinx.coroutines.*\nimport kotlin.js.Promise\n\ninternal suspend fun commonFetch(\n    input: String,\n    init: RequestInit\n): Response = suspendCancellableCoroutine { continuation ->\n    val controller = AbortController()\n    init.signal = controller.signal\n\n    continuation.invokeOnCancellation {\n        controller.abort()\n    }\n\n    val promise: Promise<Response> = if (PlatformUtils.IS_BROWSER) {\n        fetch(input, init)\n    } else {\n        jsRequireNodeFetch()(input, init)\n    }\n\n    promise.then(\n        onFulfilled = {\n            continuation.resumeWith(Result.success(it))\n        },\n        onRejected = {\n            continuation.resumeWith(Result.failure(Error(\"Fail to fetch\", it)))\n        }\n    )\n}\n\ninternal fun AbortController(): AbortController {\n    return if (PlatformUtils.IS_BROWSER) {\n        js(\"new AbortController()\")\n    } else {\n        val controller = js(\"eval('require')('abort-controller')\")\n        js(\"new controller()\")\n    }\n}\n\ninternal fun CoroutineScope.readBody(\n    response: Response\n): ByteReadChannel = if (PlatformUtils.IS_BROWSER) {\n    readBodyBrowser(response)\n} else {\n    readBodyNode(response)\n}\n\nprivate fun jsRequireNodeFetch(): dynamic = try {\n    js(\"eval('require')('node-fetch')\")\n} catch (cause: dynamic) {\n    throw Error(\"Error loading module 'node-fetch': $cause\")\n}\n","/*\n * Copyright 2014-2019 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.client\n\nimport io.ktor.client.engine.js.*\n\n/**\n * Constructs an asynchronous [HttpClient] using optional [block] for configuring this client.\n *\n * The [HttpClientEngine] is selected from the dependencies.\n * https://ktor.io/clients/http-client/engines.html\n */\npublic actual fun HttpClient(\n    block: HttpClientConfig<*>.() -> Unit\n): HttpClient = HttpClient(JsClient(), block)\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.engine\n\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\n/**\n * Create call context with the specified [parentJob] to be used during call execution in the engine. Call context\n * inherits [coroutineContext], but overrides job and coroutine name so that call job's parent is [parentJob] and\n * call coroutine's name is \"call-context\".\n */\ninternal actual suspend fun HttpClientEngine.createCallContext(parentJob: Job): CoroutineContext {\n    val callJob = Job(parentJob)\n    val callContext = coroutineContext + callJob + CALL_COROUTINE\n\n    attachToUserJob(callJob)\n\n    return callContext\n}\n","/*\n * Copyright 2014-2019 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.client.engine.js.node\n\nimport io.ktor.client.engine.js.*\nimport io.ktor.client.fetch.*\nimport io.ktor.utils.io.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport org.khronos.webgl.ArrayBuffer\nimport org.khronos.webgl.Uint8Array\n\ninternal fun CoroutineScope.readBodyNode(response: Response): ByteReadChannel = writer {\n    val body: dynamic = response.body ?: error(\"Fail to get body\")\n\n    val responseData = Channel<ByteArray>(1)\n\n    body.on(\"data\") { chunk: ArrayBuffer ->\n        val result = responseData.offer(Uint8Array(chunk).asByteArray())\n        body.pause()\n    }\n\n    body.on(\"error\") { error ->\n        val cause = JsError(error)\n        responseData.close(cause)\n        channel.close(cause)\n    }\n\n    body.on(\"end\") {\n        responseData.close()\n    }\n\n    try {\n        for (chunk in responseData) {\n            channel.writeFully(chunk)\n            body.resume()\n        }\n    } catch (cause: Throwable) {\n        body.destroy(cause)\n        throw cause\n    }\n\n    Unit\n}.channel\n","/*\n * Copyright 2014-2019 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.client.features\n\nimport io.ktor.client.*\n\ninternal actual fun HttpClient.platformDefaultTransformers() {}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.client.features.websocket\n\nimport io.ktor.http.cio.websocket.*\nimport io.ktor.utils.io.core.*\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\nimport org.khronos.webgl.*\nimport org.w3c.dom.*\nimport kotlin.coroutines.*\n\ninternal class JsWebSocketSession(\n    override val coroutineContext: CoroutineContext,\n    private val websocket: WebSocket\n) : DefaultWebSocketSession {\n    private val _closeReason: CompletableDeferred<CloseReason> = CompletableDeferred()\n    private val _incoming: Channel<Frame> = Channel(Channel.UNLIMITED)\n    private val _outgoing: Channel<Frame> = Channel(Channel.UNLIMITED)\n\n    override val incoming: ReceiveChannel<Frame> = _incoming\n    override val outgoing: SendChannel<Frame> = _outgoing\n\n    @ExperimentalWebSocketExtensionApi\n    override val extensions: List<WebSocketExtension<*>> get() = emptyList()\n\n    override val closeReason: Deferred<CloseReason?> = _closeReason\n\n    override var maxFrameSize: Long\n        get() = Long.MAX_VALUE\n        set(value) {}\n\n    init {\n        websocket.binaryType = BinaryType.ARRAYBUFFER\n\n        websocket.addEventListener(\n            \"message\",\n            callback = {\n                val event = it.unsafeCast<MessageEvent>()\n\n                launch {\n                    val data = event.data\n\n                    val frame: Frame = when (data) {\n                        is ArrayBuffer -> Frame.Binary(false, Int8Array(data).unsafeCast<ByteArray>())\n                        is String -> Frame.Text(data)\n                        else -> {\n                            val error = IllegalStateException(\"Unknown frame type: ${event.type}\")\n                            _closeReason.completeExceptionally(error)\n                            throw error\n                        }\n                    }\n\n                    _incoming.offer(frame)\n                }\n            }\n        )\n\n        websocket.addEventListener(\n            \"error\",\n            callback = {\n                val cause = WebSocketException(\"$it\")\n                _closeReason.completeExceptionally(cause)\n                _incoming.close(cause)\n                _outgoing.cancel()\n            }\n        )\n\n        websocket.addEventListener(\n            \"close\",\n            callback = { event: dynamic ->\n                launch {\n                    val reason = CloseReason(event.code as Short, event.reason as String)\n                    _closeReason.complete(reason)\n                    _incoming.send(Frame.Close(reason))\n                    _incoming.close()\n\n                    _outgoing.cancel()\n                }\n            }\n        )\n\n        launch {\n            @OptIn(ExperimentalCoroutinesApi::class)\n            _outgoing.consumeEach {\n                when (it.frameType) {\n                    FrameType.TEXT -> {\n                        val text = it.data\n                        websocket.send(String(text))\n                    }\n                    FrameType.BINARY -> {\n                        val source = it.data as Int8Array\n                        val frameData = source.buffer.slice(\n                            source.byteOffset,\n                            source.byteOffset + source.byteLength\n                        )\n\n                        websocket.send(frameData)\n                    }\n                    FrameType.CLOSE -> {\n                        val data = buildPacket { writeFully(it.data) }\n                        val code = data.readShort()\n                        val reason = data.readText()\n                        _closeReason.complete(CloseReason(code, reason))\n                        if (code.isReservedStatusCode()) {\n                            websocket.close()\n                        } else {\n                            websocket.close(code, reason)\n                        }\n                    }\n                    FrameType.PING, FrameType.PONG -> {\n                        // ignore\n                    }\n                }\n            }\n        }\n\n        coroutineContext[Job]?.invokeOnCompletion { cause ->\n            if (cause == null) {\n                websocket.close()\n            } else {\n                websocket.close(CloseReason.Codes.INTERNAL_ERROR.code, \"Client failed\")\n            }\n        }\n    }\n\n    @OptIn(ExperimentalWebSocketExtensionApi::class)\n    override fun start(negotiatedExtensions: List<WebSocketExtension<*>>) {\n        require(negotiatedExtensions.isEmpty()) { \"Extensions are not supported.\" }\n    }\n\n    override suspend fun flush() {\n    }\n\n    @Deprecated(\n        \"Use cancel() instead.\",\n        ReplaceWith(\"cancel()\", \"kotlinx.coroutines.cancel\")\n    )\n    override fun terminate() {\n        _incoming.cancel()\n        _outgoing.cancel()\n        _closeReason.cancel(\"WebSocket terminated\")\n        websocket.close()\n    }\n\n    private fun Short.isReservedStatusCode(): Boolean {\n        return CloseReason.Codes.byCode(this).let { resolved ->\n            @Suppress(\"DEPRECATION\")\n            resolved == null || resolved == CloseReason.Codes.CLOSED_ABNORMALLY\n        }\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http.cio\n\nimport io.ktor.http.cio.internals.*\nimport io.ktor.utils.io.*\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.pool.*\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\nimport kotlin.native.concurrent.*\n\nprivate const val MAX_CHUNK_SIZE_LENGTH = 128\nprivate const val CHUNK_BUFFER_POOL_SIZE = 2048\n\nprivate const val DEFAULT_BYTE_BUFFER_SIZE = 4088\n\n@ThreadLocal\nprivate val ChunkSizeBufferPool: ObjectPool<StringBuilder> =\n    object : DefaultPool<StringBuilder>(CHUNK_BUFFER_POOL_SIZE) {\n        override fun produceInstance(): StringBuilder = StringBuilder(MAX_CHUNK_SIZE_LENGTH)\n        override fun clearInstance(instance: StringBuilder) = instance.apply { clear() }\n    }\n\n/**\n * Decoder job type\n */\npublic typealias DecoderJob = WriterJob\n\n/**\n * Start a chunked stream decoder coroutine\n */\n@Deprecated(\n    \"Specify content length if known or pass -1L\",\n    ReplaceWith(\"decodeChunked(input, -1L)\")\n)\npublic fun CoroutineScope.decodeChunked(input: ByteReadChannel): DecoderJob =\n    decodeChunked(input, -1L)\n\n/**\n * Start a chunked stream decoder coroutine\n */\npublic fun CoroutineScope.decodeChunked(input: ByteReadChannel, contentLength: Long): DecoderJob =\n    writer(coroutineContext) {\n        decodeChunked(input, channel, contentLength)\n    }\n\n/**\n * Decode chunked transfer encoding from the [input] channel and write the result in [out].\n *\n * @throws EOFException if stream has ended unexpectedly.\n * @throws ParserException if the format is invalid.\n */\npublic suspend fun decodeChunked(input: ByteReadChannel, out: ByteWriteChannel) {\n    return decodeChunked(input, out, -1L)\n}\n\n/**\n * Chunked stream decoding loop\n */\n@Deprecated(\n    \"The contentLength is ignored for chunked transfer encoding\",\n    ReplaceWith(\"decodeChunked(input, out)\")\n)\npublic suspend fun decodeChunked(input: ByteReadChannel, out: ByteWriteChannel, contentLength: Long) {\n    val chunkSizeBuffer = ChunkSizeBufferPool.borrow()\n    var totalBytesCopied = 0L\n\n    try {\n        while (true) {\n            chunkSizeBuffer.clear()\n            if (!input.readUTF8LineTo(chunkSizeBuffer, MAX_CHUNK_SIZE_LENGTH)) {\n                throw EOFException(\"Chunked stream has ended unexpectedly: no chunk size\")\n            } else if (chunkSizeBuffer.isEmpty()) {\n                throw EOFException(\"Invalid chunk size: empty\")\n            }\n\n            val chunkSize =\n                if (chunkSizeBuffer.length == 1 && chunkSizeBuffer[0] == '0') 0 else chunkSizeBuffer.parseHexLong()\n\n            if (chunkSize > 0) {\n                input.copyTo(out, chunkSize)\n                out.flush()\n                totalBytesCopied += chunkSize\n            }\n\n            chunkSizeBuffer.clear()\n            if (!input.readUTF8LineTo(chunkSizeBuffer, 2)) {\n                throw EOFException(\"Invalid chunk: content block of size $chunkSize ended unexpectedly\")\n            }\n            if (chunkSizeBuffer.isNotEmpty()) {\n                throw EOFException(\"Invalid chunk: content block should end with CR+LF\")\n            }\n\n            if (chunkSize == 0L) break\n        }\n    } catch (t: Throwable) {\n        out.close(t)\n        throw t\n    } finally {\n        ChunkSizeBufferPool.recycle(chunkSizeBuffer)\n        out.close()\n    }\n}\n\n/**\n * Encoder job type\n */\npublic typealias EncoderJob = ReaderJob\n\n/**\n * Start chunked stream encoding coroutine\n */\npublic suspend fun encodeChunked(\n    output: ByteWriteChannel,\n    coroutineContext: CoroutineContext\n): EncoderJob = GlobalScope.reader(coroutineContext, autoFlush = false) {\n    encodeChunked(output, channel)\n}\n\n/**\n * Chunked stream encoding loop\n */\npublic suspend fun encodeChunked(output: ByteWriteChannel, input: ByteReadChannel) {\n    try {\n        while (!input.isClosedForRead) {\n            input.read { source, startIndex, endIndex ->\n                if (endIndex == startIndex) return@read 0\n                output.writeChunk(source, startIndex.toInt(), endIndex.toInt())\n            }\n        }\n\n        input.rethrowCloseCause()\n        output.writeFully(LastChunkBytes)\n    } catch (cause: Throwable) {\n        output.close(cause)\n        input.cancel(cause)\n    } finally {\n        output.flush()\n    }\n}\n\nprivate fun ByteReadChannel.rethrowCloseCause() {\n    val cause = when (this) {\n        is ByteChannel -> closedCause\n        else -> null\n    }\n    if (cause != null) throw cause\n}\n\n@SharedImmutable\nprivate const val CrLfShort: Short = 0x0d0a\n\n@ThreadLocal\nprivate val CrLf = \"\\r\\n\".toByteArray()\n\n@ThreadLocal\nprivate val LastChunkBytes = \"0\\r\\n\\r\\n\".toByteArray()\n\nprivate suspend fun ByteWriteChannel.writeChunk(memory: Memory, startIndex: Int, endIndex: Int): Int {\n    val size = endIndex - startIndex\n    writeIntHex(size)\n    writeShort(CrLfShort)\n\n    writeFully(memory, startIndex, endIndex)\n    writeFully(CrLf)\n    flush()\n\n    return size\n}\n","package io.ktor.utils.io\n\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\n/**\n * A coroutine job that is reading from a byte channel\n */\npublic interface ReaderJob : Job {\n    /**\n     * A reference to the channel that this coroutine is reading from\n     */\n    public val channel: ByteWriteChannel\n}\n\n/**\n * A coroutine job that is writing to a byte channel\n */\npublic interface WriterJob : Job {\n    /**\n     * A reference to the channel that this coroutine is writing to\n     */\n    public val channel: ByteReadChannel\n}\n\npublic interface ReaderScope : CoroutineScope {\n    public val channel: ByteReadChannel\n}\n\npublic interface WriterScope : CoroutineScope {\n    public val channel: ByteWriteChannel\n}\n\npublic fun CoroutineScope.reader(\n    coroutineContext: CoroutineContext = EmptyCoroutineContext,\n    channel: ByteChannel,\n    block: suspend ReaderScope.() -> Unit\n): ReaderJob = launchChannel(coroutineContext, channel, attachJob = false, block = block)\n\npublic fun CoroutineScope.reader(\n    coroutineContext: CoroutineContext = EmptyCoroutineContext,\n    autoFlush: Boolean = false,\n    block: suspend ReaderScope.() -> Unit\n): ReaderJob = launchChannel(coroutineContext, ByteChannel(autoFlush), attachJob = true, block = block)\n\n@Deprecated(\"Use scope.reader instead\")\npublic fun reader(\n    coroutineContext: CoroutineContext,\n    channel: ByteChannel,\n    parent: Job? = null,\n    block: suspend ReaderScope.() -> Unit\n): ReaderJob {\n    val newContext = if (parent != null) GlobalScope.newCoroutineContext(coroutineContext + parent)\n    else GlobalScope.newCoroutineContext(coroutineContext)\n\n    return CoroutineScope(newContext).reader(EmptyCoroutineContext, channel, block)\n}\n\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Use scope.reader instead\")\npublic fun reader(\n    coroutineContext: CoroutineContext,\n    autoFlush: Boolean = false,\n    parent: Job? = null,\n    block: suspend ReaderScope.() -> Unit\n): ReaderJob {\n    val channel = ByteChannel(autoFlush)\n    return reader(coroutineContext, channel, parent, block).also {\n        channel.attachJob(it)\n    }\n}\n\npublic fun CoroutineScope.writer(\n    coroutineContext: CoroutineContext = EmptyCoroutineContext,\n    channel: ByteChannel,\n    block: suspend WriterScope.() -> Unit\n): WriterJob = launchChannel(coroutineContext, channel, attachJob = false, block = block)\n\npublic fun CoroutineScope.writer(\n    coroutineContext: CoroutineContext = EmptyCoroutineContext,\n    autoFlush: Boolean = false,\n    block: suspend WriterScope.() -> Unit\n): WriterJob = launchChannel(coroutineContext, ByteChannel(autoFlush), attachJob = true, block = block)\n\n@Deprecated(\"Use scope.writer instead\")\npublic fun writer(\n    coroutineContext: CoroutineContext,\n    channel: ByteChannel,\n    parent: Job? = null,\n    block: suspend WriterScope.() -> Unit\n): WriterJob {\n    val newContext = if (parent != null) GlobalScope.newCoroutineContext(coroutineContext + parent)\n    else GlobalScope.newCoroutineContext(coroutineContext)\n\n    return CoroutineScope(newContext).writer(EmptyCoroutineContext, channel, block)\n}\n\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Use scope.writer instead\")\npublic fun writer(\n    coroutineContext: CoroutineContext,\n    autoFlush: Boolean = false,\n    parent: Job? = null,\n    block: suspend WriterScope.() -> Unit\n): WriterJob {\n    val channel = ByteChannel(autoFlush)\n    return writer(coroutineContext, channel, parent, block).also {\n        channel.attachJob(it)\n    }\n}\n\n/**\n * @param S not exactly safe (unchecked cast is used) so should be [ReaderScope] or [WriterScope]\n */\n@OptIn(ExperimentalStdlibApi::class)\nprivate fun <S : CoroutineScope> CoroutineScope.launchChannel(\n    context: CoroutineContext,\n    channel: ByteChannel,\n    attachJob: Boolean,\n    block: suspend S.() -> Unit\n): ChannelJob {\n    val dispatcher = coroutineContext[CoroutineDispatcher]\n    val job = launch(context) {\n        if (attachJob) {\n            channel.attachJob(coroutineContext[Job]!!)\n        }\n\n        @Suppress(\"UNCHECKED_CAST\")\n        val scope = ChannelScope(this, channel) as S\n\n        try {\n            block(scope)\n        } catch (cause: Throwable) {\n            if (dispatcher != Dispatchers.Unconfined && dispatcher != null) {\n                throw cause\n            }\n\n            channel.cancel(cause)\n        }\n    }\n\n    job.invokeOnCompletion { cause ->\n        channel.close(cause)\n    }\n\n    return ChannelJob(job, channel)\n}\n\nprivate class ChannelScope(\n    delegate: CoroutineScope,\n    override val channel: ByteChannel\n) : ReaderScope, WriterScope, CoroutineScope by delegate\n\nprivate class ChannelJob(\n    private val delegate: Job,\n    override val channel: ByteChannel\n) : ReaderJob, WriterJob, Job by delegate {\n    override fun toString(): String = \"ChannelJob[$delegate]\"\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.internal.*\n\n@Suppress(\"NOTHING_TO_INLINE\")\npublic inline fun String.toByteArray(charset: Charset = Charsets.UTF_8): ByteArray =\n    charset.newEncoder().encodeToByteArray(this, 0, length)\n\n/**\n * Create an instance of [String] from the specified [bytes] range starting at [offset] and bytes [length]\n * interpreting characters in the specified [charset].\n */\n@Suppress(\"FunctionName\")\npublic expect fun String(\n    bytes: ByteArray,\n    offset: Int = 0,\n    length: Int = bytes.size,\n    charset: Charset = Charsets.UTF_8\n): String\n\n/**\n * Read a string line considering optionally specified [estimate] but up to optional [limit] characters length\n * (does fail once limit exceeded) or return `null` if the packet is empty\n */\npublic fun ByteReadPacket.readUTF8Line(estimate: Int = 16, limit: Int = Int.MAX_VALUE): String? {\n    if (isEmpty) return null\n    val sb = StringBuilder(estimate)\n    return if (readUTF8LineTo(sb, limit)) sb.toString() else null\n}\n\n/**\n * Read a string line considering optionally specified [estimate] but up to optional [limit] characters length\n * (does fail once limit exceeded) or return `null` if the packet is empty\n */\npublic fun Input.readUTF8Line(estimate: Int = 16, limit: Int = Int.MAX_VALUE): String? {\n    val sb = StringBuilder(estimate)\n    return if (readUTF8LineTo(sb, limit)) sb.toString() else null\n}\n\n/**\n * Reads UTF-8 line and append all line characters to [out] except line endings. Supports CR, LF and CR+LF\n * @return `true` if some characters were appended or line ending reached (empty line) or `false` if packet\n * is empty\n */\npublic fun Input.readUTF8LineTo(out: Appendable, limit: Int): Boolean {\n    var decoded = 0\n    var size = 1\n    var cr = false\n    var end = false\n\n    takeWhileSize { buffer ->\n        var skip = 0\n        size = buffer.decodeUTF8 { ch ->\n            when (ch) {\n                '\\r' -> {\n                    if (cr) {\n                        end = true\n                        return@decodeUTF8 false\n                    }\n                    cr = true\n                    true\n                }\n                '\\n' -> {\n                    end = true\n                    skip = 1\n                    false\n                }\n                else -> {\n                    if (cr) {\n                        end = true\n                        return@decodeUTF8 false\n                    }\n\n                    if (decoded == limit) bufferLimitExceeded(limit)\n                    decoded++\n                    out.append(ch)\n                    true\n                }\n            }\n        }\n\n        if (skip > 0) {\n            buffer.discardExact(skip)\n        }\n\n        if (end) 0 else size.coerceAtLeast(1)\n    }\n\n    if (size > 1) prematureEndOfStream(size)\n\n    return decoded > 0 || !endOfInput\n}\n\n/**\n * Reads UTF-8 characters until one of the specified [delimiters] found, [limit] exceeded or end of stream encountered\n *\n * @throws BufferLimitExceededException\n * @returns a string of characters read before delimiter\n */\npublic fun Input.readUTF8UntilDelimiter(delimiters: String, limit: Int = Int.MAX_VALUE): String {\n    return buildString {\n        readUTF8UntilDelimiterTo(this, delimiters, limit)\n    }\n}\n\n/**\n * Reads UTF-8 characters to [out] buffer until one of the specified [delimiters] found, [limit] exceeded\n * or end of stream encountered\n *\n * @throws BufferLimitExceededException\n * @returns number of characters copied (possibly zero)\n */\npublic fun Input.readUTF8UntilDelimiterTo(out: Appendable, delimiters: String, limit: Int = Int.MAX_VALUE): Int {\n    var decoded = 0\n    var delimiter = false\n\n    takeWhile { buffer ->\n        buffer.decodeASCII { ch ->\n            if (ch in delimiters) {\n                delimiter = true\n                false\n            } else {\n                if (decoded == limit) bufferLimitExceeded(limit)\n                decoded++\n                out.append(ch)\n                true\n            }\n        }\n    }\n\n    if (!delimiter) {\n        decoded = readUTF8UntilDelimiterToSlowUtf8(out, delimiters, limit, decoded)\n    }\n\n    return decoded\n}\n\n/**\n * Reads UTF-8 characters to [out] buffer until one of the specified [delimiters] found, [limit] exceeded\n * or end of stream encountered\n *\n * @throws BufferLimitExceededException\n * @returns number of characters copied (possibly zero)\n */\npublic fun Input.readUTF8UntilDelimiterTo(out: Output, delimiters: String, limit: Int = Int.MAX_VALUE): Int {\n    val delimitersCount = delimiters.length\n    if (delimitersCount == 1 && delimiters[0].isAsciiChar()) {\n        return readUntilDelimiter(delimiters[0].toByte(), out).toInt()\n    } else if (delimitersCount == 2 && delimiters[0].isAsciiChar() && delimiters[1].isAsciiChar()) {\n        return readUntilDelimiters(delimiters[0].toByte(), delimiters[1].toByte(), out).toInt()\n    }\n\n    return readUTFUntilDelimiterToSlowAscii(delimiters, limit, out)\n}\n\n@Suppress(\"unused\", \"DEPRECATION_ERROR\")\n@Deprecated(\"Use Output version instead\", level = DeprecationLevel.HIDDEN)\npublic fun Input.readUTF8UntilDelimiterTo(\n    out: BytePacketBuilderBase,\n    delimiters: String,\n    limit: Int = Int.MAX_VALUE\n): Int {\n    return readUTF8UntilDelimiterTo(out as Output, delimiters, limit)\n}\n\n/**\n * Read exactly [n] bytes (consumes all remaining if [n] is not specified but up to [Int.MAX_VALUE] bytes).\n * Does fail if not enough bytes remaining.\n */\npublic fun ByteReadPacket.readBytes(\n    n: Int = remaining.coerceAtMostMaxIntOrFail(\"Unable to convert to a ByteArray: packet is too big\")\n): ByteArray = when {\n    n != 0 -> ByteArray(n).also { readFully(it, 0, n) }\n    else -> EmptyByteArray\n}\n\n/**\n * Reads exactly [n] bytes from the input or fails if not enough bytes available.\n */\npublic fun Input.readBytes(n: Int): ByteArray = readBytesOf(n, n)\n\n/**\n * Reads all remaining bytes from the input\n */\npublic fun Input.readBytes(): ByteArray = readBytesOf()\n\n/**\n * Reads at least [min] but no more than [max] bytes from the input to a new byte array\n * @throws EOFException if not enough bytes available to get [min] bytes\n */\npublic fun Input.readBytesOf(min: Int = 0, max: Int = Int.MAX_VALUE): ByteArray = if (min == max && min == 0) {\n    EmptyByteArray\n} else if (min == max) {\n    ByteArray(min).also { readFully(it, 0, min) }\n} else {\n    var array = ByteArray(max.toLong().coerceAtMost(sizeEstimate()).coerceAtLeast(min.toLong()).toInt())\n    var size = 0\n\n    while (size < max) {\n        val partSize = minOf(max, array.size) - size\n        val rc = readAvailable(array, size, partSize)\n        if (rc <= 0) break\n        size += rc\n        if (array.size == size) {\n            array = array.copyOf(size * 2)\n        }\n    }\n\n    if (size < min) {\n        throw EOFException(\"Not enough bytes available to read $min bytes: ${min - size} more required\")\n    }\n\n    if (size == array.size) array else array.copyOf(size)\n}\n\n/**\n * Reads at most [max] characters decoding bytes with specified [decoder]. Extra character bytes will remain unconsumed\n * @return number of characters copied to [out]\n */\n@Deprecated(\n    \"Use CharsetDecoder.decode instead\",\n    ReplaceWith(\"decoder.decode(this, out, max)\", \"io.ktor.utils.io.charsets.decode\"),\n    level = DeprecationLevel.ERROR\n)\npublic fun Input.readText(out: Appendable, decoder: CharsetDecoder, max: Int = Int.MAX_VALUE): Int {\n    return decoder.decode(this, out, max)\n}\n\n/**\n * Reads at most [max] characters decoding bytes with specified [charset]. Extra character bytes will remain unconsumed\n * @return number of characters copied to [out]\n */\npublic fun Input.readText(out: Appendable, charset: Charset = Charsets.UTF_8, max: Int = Int.MAX_VALUE): Int {\n    return charset.newDecoder().decode(this, out, max)\n}\n\n/**\n * Reads at most [max] characters decoding bytes with specified [decoder]. Extra character bytes will remain unconsumed\n * @return a decoded string\n */\n@Deprecated(\n    \"Use CharsetDecoder.decode instead\",\n    ReplaceWith(\"decoder.decode(this, max)\", \"io.ktor.utils.io.charsets.decode\")\n)\npublic fun Input.readText(decoder: CharsetDecoder, max: Int = Int.MAX_VALUE): String {\n    return decoder.decode(this, max)\n}\n\n/**\n * Reads at most [max] characters decoding bytes with specified [charset]. Extra character bytes will remain unconsumed\n * @return a decoded string\n */\npublic fun Input.readText(charset: Charset = Charsets.UTF_8, max: Int = Int.MAX_VALUE): String {\n    return charset.newDecoder().decode(this, max)\n}\n\n/**\n * Reads at most [max] characters decoding bytes with specified [charset]. Extra character bytes will remain unconsumed\n * @return a decoded string\n */\npublic fun Buffer.readText(charset: Charset = Charsets.UTF_8, max: Int = Int.MAX_VALUE): String = buildString {\n    charset.newDecoder().decodeBuffer(this@readText, this, true, max)\n}\n\n/**\n * Read exactly [n] characters interpreting bytes in the specified [charset].\n */\n@Deprecated(\n    \"Use readTextExactCharacters instead.\",\n    ReplaceWith(\"readTextExactCharacters(n, charset)\")\n)\npublic fun Input.readTextExact(charset: Charset = Charsets.UTF_8, n: Int): String {\n    return readTextExactCharacters(n, charset)\n}\n\n/**\n * Read exactly [charactersCount] characters interpreting bytes in the specified [charset].\n */\npublic fun Input.readTextExactCharacters(charactersCount: Int, charset: Charset = Charsets.UTF_8): String {\n    val s = readText(charset, charactersCount)\n    if (s.length < charactersCount) {\n        prematureEndOfStreamToReadChars(charactersCount)\n    }\n    return s\n}\n\n/**\n * Read exactly the specified number of [bytes]\n * interpreting bytes in the specified [charset] (optional, UTF-8 by default).\n */\n@Deprecated(\"Parameters order is changed.\", ReplaceWith(\"readTextExactBytes(bytes, charset)\"))\npublic fun Input.readTextExactBytes(charset: Charset = Charsets.UTF_8, bytes: Int): String {\n    return readTextExactBytes(bytes, charset)\n}\n\n/**\n * Read exactly [bytesCount] interpreting bytes in the specified [charset] (optional, UTF-8 by default).\n */\npublic fun Input.readTextExactBytes(bytesCount: Int, charset: Charset = Charsets.UTF_8): String {\n    return charset.newDecoder().decodeExactBytes(this, inputLength = bytesCount)\n}\n\n/**\n * Writes [text] characters in range \\[[fromIndex] .. [toIndex]) with the specified [encoder]\n */\n@Deprecated(\n    \"Use the implementation with Charset instead\",\n    ReplaceWith(\n        \"writeText(text, fromIndex, toIndex, encoder.charset)\",\n        \"io.ktor.utils.io.charsets.charset\"\n    ),\n    level = DeprecationLevel.ERROR\n)\npublic fun Output.writeText(\n    text: CharSequence,\n    fromIndex: Int = 0,\n    toIndex: Int = text.length,\n    encoder: CharsetEncoder\n) {\n    encoder.encodeToImpl(this, text, fromIndex, toIndex)\n}\n\n/**\n * Writes [text] characters in range \\[[fromIndex] .. [toIndex]) with the specified [charset]\n */\npublic fun Output.writeText(\n    text: CharSequence,\n    fromIndex: Int = 0,\n    toIndex: Int = text.length,\n    charset: Charset = Charsets.UTF_8\n) {\n    if (charset === Charsets.UTF_8) {\n        return writeTextUtf8(text, fromIndex, toIndex)\n    }\n\n    charset.newEncoder().encodeToImpl(this, text, fromIndex, toIndex)\n}\n\n/**\n * Writes [text] characters in range \\[[fromIndex] .. [toIndex]) with the specified [charset]\n */\npublic fun Output.writeText(\n    text: CharArray,\n    fromIndex: Int = 0,\n    toIndex: Int = text.size,\n    charset: Charset = Charsets.UTF_8\n) {\n    if (charset === Charsets.UTF_8) {\n        return writeTextUtf8(CharArraySequence(text, 0, text.size), fromIndex, toIndex)\n    }\n\n    charset.newEncoder().encode(text, fromIndex, toIndex, this)\n}\n\nprivate fun Output.writeTextUtf8(text: CharSequence, fromIndex: Int, toIndex: Int) {\n    var index = fromIndex\n    writeWhileSize(1) { buffer ->\n        val memory = buffer.memory\n        val dstOffset = buffer.writePosition\n        val dstLimit = buffer.limit\n\n        val (characters, bytes) = memory.encodeUTF8(text, index, toIndex, dstOffset, dstLimit)\n\n        index += characters.toInt()\n        buffer.commitWritten(bytes.toInt())\n\n        when {\n            characters.toInt() == 0 && index < toIndex -> 8\n            index < toIndex -> 1\n            else -> 0\n        }\n    }\n}\n\ninternal expect fun String.getCharsInternal(dst: CharArray, dstOffset: Int)\n\n@Suppress(\"NOTHING_TO_INLINE\")\nprivate inline fun Char.isAsciiChar() = toInt() <= 0x7f\n\nprivate fun Input.readUTFUntilDelimiterToSlowAscii(delimiters: String, limit: Int, out: Output): Int {\n    var decoded = 0\n    var delimiter = false\n\n    takeWhile { buffer ->\n        val before = buffer.readRemaining\n\n        val rc = buffer.decodeASCII { ch ->\n            if (ch in delimiters) {\n                delimiter = true\n                false\n            } else {\n                if (decoded == limit) bufferLimitExceeded(limit)\n                decoded++\n                true\n            }\n        }\n\n        val delta = before - buffer.readRemaining\n        if (delta > 0) {\n            buffer.rewind(delta)\n            out.writeFully(buffer, delta)\n        }\n\n        rc\n    }\n\n    if (!delimiter && !endOfInput) {\n        decoded = readUTF8UntilDelimiterToSlowUtf8(out, delimiters, limit, decoded)\n    }\n\n    return decoded\n}\n\nprivate fun Input.readUTF8UntilDelimiterToSlowUtf8(\n    out: Output,\n    delimiters: String,\n    limit: Int,\n    decoded0: Int\n): Int {\n    var decoded = decoded0\n    var size = 1\n\n    takeWhileSize { buffer ->\n        val before = buffer.readRemaining\n\n        size = buffer.decodeUTF8 { ch ->\n            if (ch in delimiters) {\n                false\n            } else {\n                if (decoded == limit) {\n                    bufferLimitExceeded(limit)\n                }\n                decoded++\n                true\n            }\n        }\n\n        val delta = before - buffer.readRemaining\n        if (delta > 0) {\n            buffer.rewind(delta)\n            out.writeFully(buffer, delta)\n        }\n\n        size = if (size == -1) 0 else size.coerceAtLeast(1)\n        size\n    }\n\n    if (size > 1) prematureEndOfStream(size)\n\n    return decoded\n}\n\nprivate fun Input.readUTF8UntilDelimiterToSlowUtf8(\n    out: Appendable,\n    delimiters: String,\n    limit: Int,\n    decoded0: Int\n): Int {\n    var decoded = decoded0\n    var size = 1\n\n    takeWhileSize { buffer ->\n        size = buffer.decodeUTF8 { ch ->\n            if (ch in delimiters) {\n                false\n            } else {\n                if (decoded == limit) {\n                    bufferLimitExceeded(limit)\n                }\n                decoded++\n                out.append(ch)\n                true\n            }\n        }\n\n        size = if (size == -1) 0 else size.coerceAtLeast(1)\n        size\n    }\n\n    if (size > 1) prematureEndOfStream(size)\n\n    return decoded\n}\n\nprivate fun bufferLimitExceeded(limit: Int): Nothing {\n    throw BufferLimitExceededException(\"Too many characters before delimiter: limit $limit exceeded\")\n}\n\n@PublishedApi\ninternal fun prematureEndOfStream(size: Int): Nothing =\n    throw EOFException(\"Premature end of stream: expected $size bytes\")\n\n@PublishedApi\ninternal fun prematureEndOfStream(size: Long): Nothing =\n    throw EOFException(\"Premature end of stream: expected $size bytes\")\n\nprivate fun prematureEndOfStreamToReadChars(charactersCount: Int): Nothing =\n    throw EOFException(\"Not enough input bytes to read $charactersCount characters.\")\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http.cio.internals\n\nimport io.ktor.http.*\nimport io.ktor.utils.io.*\nimport io.ktor.utils.io.core.*\nimport kotlin.native.concurrent.*\n\ninternal const val HTAB: Char = '\\u0009'\n\ninternal fun CharSequence.hashCodeLowerCase(start: Int = 0, end: Int = length): Int {\n    var hashCode = 0\n    for (pos in start until end) {\n        val v = get(pos).toInt().toLowerCase()\n        hashCode = 31 * hashCode + v\n    }\n\n    return hashCode\n}\n\ninternal fun CharSequence.equalsLowerCase(start: Int = 0, end: Int = length, other: CharSequence): Boolean {\n    if (end - start != other.length) return false\n\n    for (pos in start until end) {\n        if (get(pos).toInt().toLowerCase() != other[pos - start].toInt().toLowerCase()) return false\n    }\n\n    return true\n}\n\n@Suppress(\"NOTHING_TO_INLINE\")\nprivate inline fun Int.toLowerCase() =\n    if (this in 'A'.toInt()..'Z'.toInt()) 'a'.toInt() + (this - 'A'.toInt()) else this\n\n@SharedImmutable\ninternal val DefaultHttpMethods =\n    AsciiCharTree.build(HttpMethod.DefaultMethods, { it.value.length }, { m, idx -> m.value[idx] })\n\n@SharedImmutable\nprivate val HexTable = (0..0xff).map { v ->\n    when {\n        v in 0x30..0x39 -> v - 0x30L\n        v >= 'a'.toLong() && v <= 'f'.toLong() -> v - 'a'.toLong() + 10\n        v >= 'A'.toLong() && v <= 'F'.toLong() -> v - 'A'.toLong() + 10\n        else -> -1L\n    }\n}.toLongArray()\n\n@SharedImmutable\ninternal val HexLetterTable: ByteArray = (0..0xf).map {\n    if (it < 0xa) (0x30 + it).toByte() else ('a' + it - 0x0a).toInt().toByte()\n}.toByteArray()\n\ninternal fun CharSequence.parseHexLong(): Long {\n    var result = 0L\n    val table = HexTable\n    for (i in 0 until length) {\n        val v = this[i].toInt() and 0xffff\n        val digit = if (v < 0xff) table[v] else -1L\n        if (digit == -1L) hexNumberFormatException(this, i)\n        result = (result shl 4) or digit\n    }\n\n    return result\n}\n\ninternal fun CharSequence.parseDecLong(): Long {\n    val length = length\n    if (length > 19) numberFormatException(this)\n    if (length == 19) return parseDecLongWithCheck()\n\n    var result = 0L\n    for (i in 0 until length) {\n        val digit = this[i].toLong() - 0x30L\n        if (digit < 0 || digit > 9) numberFormatException(this, i)\n\n        result = (result shl 3) + (result shl 1) + digit\n    }\n\n    return result\n}\n\nprivate fun CharSequence.parseDecLongWithCheck(): Long {\n    var result = 0L\n    for (i in 0 until length) {\n        val digit = this[i].toLong() - 0x30L\n        if (digit < 0 || digit > 9) numberFormatException(this, i)\n\n        result = (result shl 3) + (result shl 1) + digit\n        if (result < 0) numberFormatException(this)\n    }\n\n    return result\n}\n\ninternal fun Buffer.writeIntHex(value: Int) {\n    require(value > 0) { \"Does only work for positive numbers\" } // zero is not included!\n    var current = value\n    val table = HexLetterTable\n    var digits = 0\n\n    while (digits++ < 8) {\n        val v = current ushr 28\n        current = current shl 4\n\n        if (v != 0) {\n            writeByte(table[v])\n            break\n        }\n    }\n\n    while (digits++ < 8) {\n        val v = current ushr 28\n        current = current shl 4\n        writeByte(table[v])\n    }\n}\n\ninternal suspend fun ByteWriteChannel.writeIntHex(value: Int) {\n    require(value > 0) { \"Does only work for positive numbers\" } // zero is not included!\n    var current = value\n    val table = HexLetterTable\n    var digits = 0\n\n    while (digits++ < 8) {\n        val v = current ushr 28\n        current = current shl 4\n\n        if (v != 0) {\n            writeByte(table[v])\n            break\n        }\n    }\n\n    while (digits++ < 8) {\n        val v = current ushr 28\n        current = current shl 4\n        writeByte(table[v])\n    }\n}\n\nprivate fun hexNumberFormatException(s: CharSequence, idx: Int): Nothing {\n    throw NumberFormatException(\"Invalid HEX number: $s, wrong digit: ${s[idx]}\")\n}\n\nprivate fun numberFormatException(cs: CharSequence, idx: Int) {\n    throw NumberFormatException(\"Invalid number: $cs, wrong digit: ${cs[idx]} at position $idx\")\n}\n\nprivate fun numberFormatException(cs: CharSequence) {\n    throw NumberFormatException(\"Invalid number $cs: too large for Long type\")\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http.cio\n\nimport io.ktor.http.cio.internals.*\nimport io.ktor.util.*\nimport io.ktor.utils.io.pool.*\nimport kotlin.native.concurrent.*\n\nprivate const val EXPECTED_HEADERS_QTY = 64\n\n/*\n * index array structure\n * [0] = name hash\n * [1] = value hash\n * [2] name start index\n * [3] name end (excl) index\n * [4] value start index\n * [5] value end (excl) index\n * [6] next entry index (multiplied) with the same name hash\n * [7] reserved\n */\nprivate const val HEADER_SIZE = 8\nprivate const val HEADER_ARRAY_POOL_SIZE = 1000\n\n@ThreadLocal\nprivate val EMPTY_INT_ARRAY = IntArray(0)\n\n/**\n * A headers map data structure used in CIO\n */\n@Suppress(\"KDocMissingDocumentation\")\n@InternalAPI\npublic class HttpHeadersMap internal constructor(private val builder: CharArrayBuilder) {\n    public var size: Int = 0\n        private set\n\n    private var indexes = IntArrayPool.borrow()\n\n    public fun put(\n        nameHash: Int,\n        valueHash: Int,\n        nameStartIndex: Int,\n        nameEndIndex: Int,\n        valueStartIndex: Int,\n        valueEndIndex: Int\n    ) {\n        val base = size * HEADER_SIZE\n        val array = indexes\n\n        if (base >= indexes.size) TODO(\"Implement headers overflow\")\n\n        array[base + 0] = nameHash\n        array[base + 1] = valueHash\n        array[base + 2] = nameStartIndex\n        array[base + 3] = nameEndIndex\n        array[base + 4] = valueStartIndex\n        array[base + 5] = valueEndIndex\n        array[base + 6] = -1 // TODO\n        array[base + 7] = -1\n\n        size++\n    }\n\n    public fun find(name: String, fromIndex: Int = 0): Int {\n        val nameHash = name.hashCodeLowerCase()\n        for (i in fromIndex until size) {\n            val offset = i * HEADER_SIZE\n            if (indexes[offset] == nameHash) {\n                return i\n            }\n        }\n\n        return -1\n    }\n\n    public operator fun get(name: String): CharSequence? {\n        val nameHash = name.hashCodeLowerCase()\n        for (i in 0 until size) {\n            val offset = i * HEADER_SIZE\n            if (indexes[offset] == nameHash) {\n                return builder.subSequence(indexes[offset + 4], indexes[offset + 5])\n            }\n        }\n\n        return null\n    }\n\n    public fun getAll(name: String): Sequence<CharSequence> {\n        val nameHash = name.hashCodeLowerCase()\n        return generateSequence(0) { if (it + 1 >= size) null else it + 1 }\n            .map { it * HEADER_SIZE }\n            .filter { indexes[it] == nameHash }\n            .map { builder.subSequence(indexes[it + 4], indexes[it + 5]) }\n    }\n\n    public fun nameAt(idx: Int): CharSequence {\n        require(idx >= 0)\n        require(idx < size)\n\n        val offset = idx * HEADER_SIZE\n        val array = indexes\n\n        val nameStart = array[offset + 2]\n        val nameEnd = array[offset + 3]\n\n        return builder.subSequence(nameStart, nameEnd)\n    }\n\n    public fun valueAt(idx: Int): CharSequence {\n        require(idx >= 0)\n        require(idx < size)\n\n        val offset = idx * HEADER_SIZE\n        val array = indexes\n\n        val nameStart = array[offset + 4]\n        val nameEnd = array[offset + 5]\n\n        return builder.subSequence(nameStart, nameEnd)\n    }\n\n    public fun release() {\n        size = 0\n        val indexes = indexes\n        this.indexes = EMPTY_INT_ARRAY\n\n        if (indexes !== EMPTY_INT_ARRAY) IntArrayPool.recycle(indexes)\n    }\n\n    override fun toString(): String {\n        return buildString { dumpTo(\"\", this) }\n    }\n}\n\n/**\n * Dump header values to [out], useful for debugging\n */\n@InternalAPI\npublic fun HttpHeadersMap.dumpTo(indent: String, out: Appendable) {\n    for (i in 0 until size) {\n        out.append(indent)\n        out.append(nameAt(i))\n        out.append(\" => \")\n        out.append(valueAt(i))\n        out.append(\"\\n\")\n    }\n}\n\n@ThreadLocal\nprivate val IntArrayPool: DefaultPool<IntArray> = object : DefaultPool<IntArray>(HEADER_ARRAY_POOL_SIZE) {\n    override fun produceInstance(): IntArray = IntArray(EXPECTED_HEADERS_QTY * HEADER_SIZE)\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http.cio\n\nimport io.ktor.http.*\nimport io.ktor.http.cio.internals.*\nimport io.ktor.utils.io.core.*\n\n/**\n * Represents a base HTTP message type for request and response\n * @property headers request/response headers\n */\npublic abstract class HttpMessage internal constructor(\n    public val headers: HttpHeadersMap,\n    private val builder: CharArrayBuilder\n) : Closeable {\n\n    /**\n     * Release all memory resources hold by this message\n     */\n    public fun release() {\n        builder.release()\n        headers.release()\n    }\n\n    /**\n     * Release all memory resources hold by this message\n     */\n    override fun close() {\n        release()\n    }\n}\n\n/**\n * Represents an HTTP request\n * @property method\n * @property uri\n * @property version\n */\npublic class Request internal constructor(\n    public val method: HttpMethod,\n    public val uri: CharSequence,\n    public val version: CharSequence,\n    headers: HttpHeadersMap,\n    builder: CharArrayBuilder\n) : HttpMessage(headers, builder)\n\n/**\n * Represents an HTTP response\n * @property version\n * @property status\n * @property statusText\n */\npublic class Response internal constructor(\n    public val version: CharSequence,\n    public val status: Int,\n    public val statusText: CharSequence,\n    headers: HttpHeadersMap,\n    builder: CharArrayBuilder\n) : HttpMessage(headers, builder)\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http.cio.internals\n\ninternal class AsciiCharTree<T : Any>(val root: Node<T>) {\n    public class Node<T>(val ch: Char, val exact: List<T>, val children: List<Node<T>>) {\n        val array = Array(0x100) { chi -> children.singleOrNull { it.ch.toInt() == chi } }\n    }\n\n    public fun search(\n        sequence: CharSequence,\n        fromIdx: Int = 0,\n        end: Int = sequence.length,\n        lowerCase: Boolean = false,\n        stopPredicate: (Char, Int) -> Boolean\n    ): List<T> {\n        if (sequence.isEmpty()) throw IllegalArgumentException(\"Couldn't search in char tree for empty string\")\n        var node = root\n\n        for (index in fromIdx until end) {\n            val current = sequence[index]\n            val currentCode = current.toInt()\n\n            if (stopPredicate(current, currentCode)) break\n\n            val nextNode = node.array[currentCode]\n                ?: (if (lowerCase) node.array[current.toLowerCase().toInt()] else null)\n                ?: return emptyList()\n\n            node = nextNode\n        }\n\n        return node.exact\n    }\n\n    public companion object {\n        public fun <T : CharSequence> build(from: List<T>): AsciiCharTree<T> {\n            return build(from, { it.length }, { s, idx -> s[idx] })\n        }\n\n        public fun <T : Any> build(from: List<T>, length: (T) -> Int, charAt: (T, Int) -> Char): AsciiCharTree<T> {\n            val maxLen = from.maxByOrNull(length)?.let(length)\n                ?: throw NoSuchElementException(\"Unable to build char tree from an empty list\")\n\n            if (from.any { length(it) == 0 }) throw IllegalArgumentException(\"There should be no empty entries\")\n\n            val root = ArrayList<Node<T>>()\n            build(root, from, maxLen, 0, length, charAt)\n            root.trimToSize()\n            return AsciiCharTree(Node('\\u0000', emptyList(), root))\n        }\n\n        private fun <T : Any> build(\n            resultList: MutableList<Node<T>>,\n            from: List<T>,\n            maxLength: Int,\n            idx: Int,\n            length: (T) -> Int,\n            charAt: (T, Int) -> Char\n        ) {\n            from.groupBy { charAt(it, idx) }.forEach { (ch, list) ->\n                val nextIdx = idx + 1\n                val children = ArrayList<Node<T>>()\n                build(children, list.filter { length(it) > nextIdx }, maxLength, nextIdx, length, charAt)\n                children.trimToSize()\n                resultList.add(Node(ch, list.filter { length(it) == nextIdx }, children))\n            }\n        }\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http.cio\n\nimport io.ktor.http.*\nimport io.ktor.util.*\n\n/**\n * An adapter from CIO low-level headers map to ktor [Headers] interface\n */\n@InternalAPI\npublic class CIOHeaders(private val headers: HttpHeadersMap) : Headers {\n\n    private val names: Set<String> by lazy(LazyThreadSafetyMode.NONE) {\n        LinkedHashSet<String>(headers.size).apply {\n            for (i in 0 until headers.size) {\n                add(headers.nameAt(i).toString())\n            }\n        }\n    }\n\n    override val caseInsensitiveName: Boolean get() = true\n\n    override fun names(): Set<String> = names\n    override fun get(name: String): String? = headers[name]?.toString()\n\n    override fun getAll(name: String): List<String>? =\n        headers.getAll(name).map { it.toString() }.toList().takeIf { it.isNotEmpty() }\n\n    override fun isEmpty(): Boolean = headers.size == 0\n    override fun entries(): Set<Map.Entry<String, List<String>>> {\n        return (0 until headers.size).map { idx -> Entry(idx) }.toSet()\n    }\n\n    private inner class Entry(private val idx: Int) : Map.Entry<String, List<String>> {\n        override val key: String get() = headers.nameAt(idx).toString()\n        override val value: List<String> get() = listOf(headers.valueAt(idx).toString())\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http.cio.websocket\n\nimport io.ktor.util.*\nimport kotlin.jvm.*\n\n/**\n * Websocket close reason\n * @property code - close reason code as per RFC 6455, recommended to be one of [CloseReason.Codes]\n * @property message - a close reason message, could be empty\n */\npublic data class CloseReason(val code: Short, val message: String) {\n    public constructor(code: Codes, message: String) : this(code.code, message)\n\n    /**\n     * An enum value for this [code] or `null` if the [code] is not listed in [Codes]\n     */\n    val knownReason: Codes?\n        get() = Codes.byCode(code)\n\n    override fun toString(): String {\n        return \"CloseReason(reason=${knownReason ?: code}, message=$message)\"\n    }\n\n    /**\n     * Standard close reason codes\n     *\n     * see https://tools.ietf.org/html/rfc6455#section-7.4 for list of codes\n     */\n    @Suppress(\"KDocMissingDocumentation\")\n    public enum class Codes(public val code: Short) {\n        NORMAL(1000),\n        GOING_AWAY(1001),\n        PROTOCOL_ERROR(1002),\n        CANNOT_ACCEPT(1003),\n\n        @InternalAPI\n        @Deprecated(\"This code MUST NOT be set as a status code in a Close control frame by an endpoint\")\n        CLOSED_ABNORMALLY(1006),\n        NOT_CONSISTENT(1007),\n        VIOLATED_POLICY(1008),\n        TOO_BIG(1009),\n        NO_EXTENSION(1010),\n        INTERNAL_ERROR(1011),\n        SERVICE_RESTART(1012),\n        TRY_AGAIN_LATER(1013);\n\n        public companion object {\n            private val byCodeMap = values().associateBy { it.code }\n\n            @Deprecated(\n                \"Use INTERNAL_ERROR instead.\",\n                ReplaceWith(\n                    \"INTERNAL_ERROR\",\n                    \"io.ktor.http.cio.websocket.CloseReason.Codes.INTERNAL_ERROR\"\n                )\n            )\n            @JvmField\n            @Suppress(\"UNUSED\")\n            public val UNEXPECTED_CONDITION: Codes = INTERNAL_ERROR\n\n            /**\n             * Get enum value by close reason code\n             * @return enum instance or null if [code] is not in standard\n             */\n            public fun byCode(code: Short): Codes? = byCodeMap[code]\n        }\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http.cio.internals\n\nimport io.ktor.utils.io.pool.*\nimport kotlin.native.concurrent.*\n\nprivate const val CHAR_ARRAY_POOL_SIZE = 4096\n\n/**\n * Number of characters that an array from the pool can store\n */\ninternal const val CHAR_BUFFER_ARRAY_LENGTH: Int = 4096 / 2\n\n@ThreadLocal\ninternal val CharArrayPool: ObjectPool<CharArray> = object : DefaultPool<CharArray>(CHAR_ARRAY_POOL_SIZE) {\n    override fun produceInstance(): CharArray = CharArray(CHAR_BUFFER_ARRAY_LENGTH)\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http.cio.internals\n\ninternal fun nextToken(text: CharSequence, range: MutableRange): CharSequence {\n    val spaceOrEnd = findSpaceOrEnd(text, range)\n    val s = text.subSequence(range.start, spaceOrEnd)\n    range.start = spaceOrEnd\n    return s\n}\n\ninternal fun skipSpacesAndHorizontalTabs(\n    text: CharArrayBuilder,\n    start: Int,\n    end: Int\n): Int {\n    var index = start\n    while (index < end) {\n        val ch = text[index]\n        if (!ch.isWhitespace() && ch != HTAB) break\n        index++\n    }\n    return index\n}\n\ninternal fun skipSpaces(text: CharSequence, range: MutableRange) {\n    var idx = range.start\n    val end = range.end\n\n    if (idx >= end || !text[idx].isWhitespace()) return\n    idx++\n\n    while (idx < end) {\n        if (!text[idx].isWhitespace()) break\n        idx++\n    }\n\n    range.start = idx\n}\n\ninternal fun findSpaceOrEnd(text: CharSequence, range: MutableRange): Int {\n    var idx = range.start\n    val end = range.end\n\n    if (idx >= end || text[idx].isWhitespace()) return idx\n    idx++\n\n    while (idx < end) {\n        if (text[idx].isWhitespace()) return idx\n        idx++\n    }\n\n    return idx\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http.cio.websocket\n\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.*\nimport kotlinx.coroutines.*\n\n/**\n * A frame received or ready to be sent. It is not reusable and not thread-safe\n * @property fin is it final fragment, should be always `true` for control frames and if no fragmentation is used\n * @property frameType enum value\n * @property data - a frame content or fragment content\n * @property disposableHandle could be invoked when the frame is processed\n */\npublic expect sealed class Frame private constructor(\n    fin: Boolean,\n    frameType: FrameType,\n    data: ByteArray,\n    disposableHandle: DisposableHandle = NonDisposableHandle,\n    rsv1: Boolean = false,\n    rsv2: Boolean = false,\n    rsv3: Boolean = false\n) {\n    public val fin: Boolean\n\n    /**\n     * First extension bit.\n     */\n    public val rsv1: Boolean\n\n    /**\n     * Second extension bit.\n     */\n    public val rsv2: Boolean\n\n    /**\n     * Third extension bit.\n     */\n    public val rsv3: Boolean\n\n    public val frameType: FrameType\n\n    public val data: ByteArray\n\n    public val disposableHandle: DisposableHandle\n\n    /**\n     * Represents an application level binary frame.\n     * In a RAW web socket session a big text frame could be fragmented\n     * (separated into several text frames so they have [fin] = false except the last one).\n     * Note that usually there is no need to handle fragments unless you have a RAW web socket session.\n     */\n    public class Binary public constructor(\n        fin: Boolean,\n        data: ByteArray,\n        rsv1: Boolean = false,\n        rsv2: Boolean = false,\n        rsv3: Boolean = false\n    ) : Frame {\n        public constructor(fin: Boolean, data: ByteArray)\n        public constructor(fin: Boolean, packet: ByteReadPacket)\n    }\n\n    /**\n     * Represents an application level text frame.\n     * In a RAW web socket session a big text frame could be fragmented\n     * (separated into several text frames so they have [fin] = false except the last one).\n     * Please note that a boundary between fragments could be in the middle of multi-byte (unicode) character\n     * so don't apply String constructor to every fragment but use decoder loop instead of concatenate fragments first.\n     * Note that usually there is no need to handle fragments unless you have a RAW web socket session.\n     */\n    public class Text public constructor(\n        fin: Boolean,\n        data: ByteArray,\n        rsv1: Boolean = false,\n        rsv2: Boolean = false,\n        rsv3: Boolean = false,\n    ) : Frame {\n        public constructor(fin: Boolean, data: ByteArray)\n        public constructor(text: String)\n        public constructor(fin: Boolean, packet: ByteReadPacket)\n    }\n\n    /**\n     * Represents a low-level level close frame. It could be sent to indicate web socket session end.\n     * Usually there is no need to send/handle it unless you have a RAW web socket session.\n     */\n    public class Close(data: ByteArray) : Frame {\n        public constructor(reason: CloseReason)\n        public constructor(packet: ByteReadPacket)\n        public constructor()\n    }\n\n    /**\n     * Represents a low-level ping frame. Could be sent to test connection (peer should reply with [Pong]).\n     * Usually there is no need to send/handle it unless you have a RAW web socket session.\n     */\n    public class Ping(data: ByteArray) : Frame {\n        public constructor(packet: ByteReadPacket)\n    }\n\n    /**\n     * Represents a low-level pong frame. Should be sent in reply to a [Ping] frame.\n     * Usually there is no need to send/handle it unless you have a RAW web socket session.\n     */\n    public class Pong(\n        data: ByteArray,\n        disposableHandle: DisposableHandle = NonDisposableHandle\n    ) : Frame {\n        public constructor(packet: ByteReadPacket)\n    }\n\n    /**\n     * Creates a frame copy\n     */\n    public fun copy(): Frame\n\n    public companion object {\n        /**\n         * Create a particular [Frame] instance by frame type\n         */\n        public fun byType(fin: Boolean, frameType: FrameType, data: ByteArray): Frame\n\n        /**\n         * Create a particular [Frame] instance by frame type\n         */\n        public fun byType(\n            fin: Boolean,\n            frameType: FrameType,\n            data: ByteArray,\n            rsv1: Boolean,\n            rsv2: Boolean,\n            rsv3: Boolean\n        ): Frame\n    }\n}\n\n/**\n * Read text content from text frame. Shouldn't be used for fragmented frames: such frames need to be reassembled first\n */\npublic fun Frame.Text.readText(): String {\n    require(fin) { \"Text could be only extracted from non-fragmented frame\" }\n    return Charsets.UTF_8.newDecoder().decode(buildPacket { writeFully(data) })\n}\n\n/**\n * Read binary content from a frame. For fragmented frames only returns this fragment.\n */\npublic fun Frame.readBytes(): ByteArray {\n    return data.copyOf()\n}\n\n/**\n * Read close reason from close frame or null if no close reason provided\n */\n@Suppress(\"CONFLICTING_OVERLOADS\")\npublic fun Frame.Close.readReason(): CloseReason? {\n    if (data.size < 2) {\n        return null\n    }\n\n    val packet = buildPacket { writeFully(data) }\n\n    val code = packet.readShort()\n    val message = packet.readText()\n\n    return CloseReason(code, message)\n}\n\ninternal object NonDisposableHandle : DisposableHandle {\n    override fun dispose() {}\n    override fun toString(): String = \"NonDisposableHandle\"\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http.cio.websocket\n\n/**\n * Frame types enum\n * @property controlFrame if this is control frame type\n * @property opcode - frame type id that is used to transport it\n */\npublic enum class FrameType(public val controlFrame: Boolean, public val opcode: Int) {\n    /**\n     * Regular application level text frame\n     */\n    TEXT(false, 1),\n\n    /**\n     * Regular application level binary frame\n     */\n    BINARY(false, 2),\n\n    /**\n     * Low level close frame type\n     */\n    CLOSE(true, 8),\n\n    /**\n     * Low level ping frame type\n     */\n    PING(true, 9),\n\n    /**\n     * Low level pong frame type\n     */\n    PONG(true, 0xa);\n\n    public companion object {\n        private val maxOpcode = values().maxByOrNull { it.opcode }!!.opcode\n\n        private val byOpcodeArray = Array(maxOpcode + 1) { op -> values().singleOrNull { it.opcode == op } }\n\n        /**\n         * Find [FrameType] instance by numeric [opcode]\n         * @return a [FrameType] instance or `null` of the [opcode] value is not valid\n         */\n        public operator fun get(opcode: Int): FrameType? = if (opcode in 0..maxOpcode) byOpcodeArray[opcode] else null\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http.cio\n\nimport io.ktor.http.*\nimport io.ktor.utils.io.core.*\n\n/**\n * Builds an HTTP request or response\n */\npublic actual class RequestResponseBuilder actual constructor() {\n    private val packet = BytePacketBuilder()\n\n    /**\n     * Append response status line\n     */\n    public actual fun responseLine(version: CharSequence, status: Int, statusText: CharSequence) {\n        packet.writeText(version)\n        packet.writeByte(SP)\n        packet.writeText(status.toString())\n        packet.writeByte(SP)\n        packet.writeText(statusText)\n        packet.writeByte(CR)\n        packet.writeByte(LF)\n    }\n\n    /**\n     * Append request line\n     */\n    public actual fun requestLine(method: HttpMethod, uri: CharSequence, version: CharSequence) {\n        packet.writeText(method.value)\n        packet.writeByte(SP)\n        packet.writeText(uri)\n        packet.writeByte(SP)\n        packet.writeText(version)\n        packet.writeByte(CR)\n        packet.writeByte(LF)\n    }\n\n    /**\n     * Append a line\n     */\n    public actual fun line(line: CharSequence) {\n        packet.append(line)\n        packet.writeByte(CR)\n        packet.writeByte(LF)\n    }\n\n    /**\n     * Append raw bytes\n     */\n    public actual fun bytes(content: ByteArray, offset: Int, length: Int) {\n        packet.writeFully(content, offset, length)\n    }\n\n    /**\n     * Append header line\n     */\n    public actual fun headerLine(name: CharSequence, value: CharSequence) {\n        packet.append(name)\n        packet.append(\": \")\n        packet.append(value)\n        packet.writeByte(CR)\n        packet.writeByte(LF)\n    }\n\n    /**\n     * Append an empty line (CR + LF in fact)\n     */\n    public actual fun emptyLine() {\n        packet.writeByte(CR)\n        packet.writeByte(LF)\n    }\n\n    /**\n     * Build a packet of request/response\n     */\n    public actual fun build(): ByteReadPacket = packet.build()\n\n    /**\n     * Release all resources hold by the builder\n     */\n    public actual fun release() {\n        packet.release()\n    }\n}\n\nprivate const val SP: Byte = 0x20\nprivate const val CR: Byte = 0x0d\nprivate const val LF: Byte = 0x0a\n","/*\n * Copyright 2014-2019 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.http.cio.websocket\n\nimport io.ktor.util.*\nimport kotlinx.coroutines.*\n\n/**\n * Default websocket session with ping-pong and timeout processing and built-in [closeReason] population\n */\npublic actual interface DefaultWebSocketSession : WebSocketSession {\n    /**\n     * A close reason for this session. It could be `null` if a session is terminated with no close reason\n     * (for example due to connection failure).\n     */\n    public actual val closeReason: Deferred<CloseReason?>\n\n    /**\n     * Start WebSocket conversation.\n     *\n     * @param negotiatedExtensions specify negotiated extensions list to use in current session.\n     */\n    @InternalAPI\n    @OptIn(ExperimentalWebSocketExtensionApi::class)\n    public actual fun start(negotiatedExtensions: List<WebSocketExtension<*>>)\n}\n\n/**\n * Create [DefaultWebSocketSession] from session.\n */\npublic actual fun DefaultWebSocketSession(\n    session: WebSocketSession,\n    pingInterval: Long,\n    timeoutMillis: Long\n): DefaultWebSocketSession = error(\"There is no CIO js websocket implementation. Consider using platform default.\")\n","// ktlint-disable filename\n/*\n * Copyright 2014-2019 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.http.cio.websocket\n\nimport io.ktor.utils.io.core.*\nimport kotlinx.coroutines.*\n\n/**\n * A frame received or ready to be sent. It is not reusable and not thread-safe\n * @property fin is it final fragment, should be always `true` for control frames and if no fragmentation is used\n * @property frameType enum value\n * @property data - a frame content or fragment content\n * @property disposableHandle could be invoked when the frame is processed\n */\npublic actual sealed class Frame actual constructor(\n    public actual val fin: Boolean,\n    public actual val frameType: FrameType,\n    public actual val data: ByteArray,\n    public actual val disposableHandle: DisposableHandle,\n    public actual open val rsv1: Boolean,\n    public actual open val rsv2: Boolean,\n    public actual open val rsv3: Boolean\n) {\n    /**\n     * Represents an application level binary frame.\n     * In a RAW web socket session a big text frame could be fragmented\n     * (separated into several text frames so they have [fin] = false except the last one).\n     * Note that usually there is no need to handle fragments unless you have a RAW web socket session.\n     */\n    public actual class Binary actual constructor(\n        fin: Boolean,\n        data: ByteArray,\n        rsv1: Boolean,\n        rsv2: Boolean,\n        rsv3: Boolean\n    ) : Frame(fin, FrameType.BINARY, data, NonDisposableHandle, rsv1, rsv2, rsv3) {\n        public actual constructor(fin: Boolean, data: ByteArray) : this(fin, data, false, false, false)\n        public actual constructor(fin: Boolean, packet: ByteReadPacket) : this(fin, packet.readBytes())\n    }\n\n    /**\n     * Represents an application level text frame.\n     * In a RAW web socket session a big text frame could be fragmented\n     * (separated into several text frames so they have [fin] = false except the last one).\n     * Please note that a boundary between fragments could be in the middle of multi-byte (unicode) character\n     * so don't apply String constructor to every fragment but use decoder loop instead of concatenate fragments first.\n     * Note that usually there is no need to handle fragments unless you have a RAW web socket session.\n     */\n    public actual class Text actual constructor(\n        fin: Boolean,\n        data: ByteArray,\n        rsv1: Boolean,\n        rsv2: Boolean,\n        rsv3: Boolean\n    ) : Frame(fin, FrameType.TEXT, data, NonDisposableHandle, rsv1, rsv2, rsv3) {\n        public actual constructor(fin: Boolean, data: ByteArray) : this(fin, data, false, false, false)\n        public actual constructor(text: String) : this(true, text.toByteArray())\n        public actual constructor(fin: Boolean, packet: ByteReadPacket) : this(fin, packet.readBytes())\n    }\n\n    /**\n     * Represents a low-level level close frame. It could be sent to indicate web socket session end.\n     * Usually there is no need to send/handle it unless you have a RAW web socket session.\n     */\n    public actual class Close actual constructor(\n        data: ByteArray\n    ) : Frame(true, FrameType.CLOSE, data, NonDisposableHandle, false, false, false) {\n        public actual constructor(reason: CloseReason) : this(\n            buildPacket {\n                writeShort(reason.code)\n                writeText(reason.message)\n            }\n        )\n\n        public actual constructor(packet: ByteReadPacket) : this(packet.readBytes())\n        public actual constructor() : this(Empty)\n    }\n\n    /**\n     * Represents a low-level ping frame. Could be sent to test connection (peer should reply with [Pong]).\n     * Usually there is no need to send/handle it unless you have a RAW web socket session.\n     */\n    public actual class Ping actual constructor(\n        data: ByteArray\n    ) : Frame(true, FrameType.PING, data, NonDisposableHandle, false, false, false) {\n        public actual constructor(packet: ByteReadPacket) : this(packet.readBytes())\n    }\n\n    /**\n     * Represents a low-level pong frame. Should be sent in reply to a [Ping] frame.\n     * Usually there is no need to send/handle it unless you have a RAW web socket session.\n     */\n    public actual class Pong actual constructor(\n        data: ByteArray,\n        disposableHandle: DisposableHandle\n    ) : Frame(true, FrameType.PONG, data, disposableHandle, false, false, false) {\n        public actual constructor(packet: ByteReadPacket) : this(packet.readBytes(), NonDisposableHandle)\n    }\n\n    override fun toString(): String = \"Frame $frameType (fin=$fin, buffer len = ${data.size})\"\n\n    /**\n     * Creates a frame copy.\n     */\n    public actual fun copy(): Frame = byType(fin, frameType, data.copyOf(), rsv1, rsv2, rsv3)\n\n    public actual companion object {\n        private val Empty: ByteArray = ByteArray(0)\n\n        /**\n         * Create a particular [Frame] instance by frame type.\n         */\n        public actual fun byType(\n            fin: Boolean,\n            frameType: FrameType,\n            data: ByteArray\n        ): Frame = when (frameType) {\n            FrameType.BINARY -> Binary(fin, data)\n            FrameType.TEXT -> Text(fin, data)\n            FrameType.CLOSE -> Close(data)\n            FrameType.PING -> Ping(data)\n            FrameType.PONG -> Pong(data, NonDisposableHandle)\n        }\n\n        /**\n         * Create a particular [Frame] instance by frame type.\n         */\n        public actual fun byType(\n            fin: Boolean,\n            frameType: FrameType,\n            data: ByteArray,\n            rsv1: Boolean,\n            rsv2: Boolean,\n            rsv3: Boolean\n        ): Frame = when (frameType) {\n            FrameType.BINARY -> Binary(fin, data, rsv1, rsv2, rsv3)\n            FrameType.TEXT -> Text(fin, data, rsv1, rsv2, rsv3)\n            FrameType.CLOSE -> Close(data)\n            FrameType.PING -> Ping(data)\n            FrameType.PONG -> Pong(data, NonDisposableHandle)\n        }\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"UtilsKt\")\n\npackage io.ktor.http.cio.websocket\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline infix fun Byte.xor(other: Byte) = toInt().xor(other.toInt()).toByte()\n\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun Boolean.flagAt(at: Int) = if (this) 1 shl at else 0\n","// ktlint-disable filename\n/*\n * Copyright 2014-2019 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.http.cio.websocket\n\nimport kotlinx.coroutines.*\nimport kotlinx.coroutines.channels.*\n\n/**\n * Represents a web socket session between two peers\n */\npublic actual interface WebSocketSession : CoroutineScope {\n    /**\n     * Incoming frames channel\n     */\n    public actual val incoming: ReceiveChannel<Frame>\n\n    /**\n     * Outgoing frames channel. It could have limited capacity so sending too much frames may lead to suspension at\n     * corresponding send invocations. It also may suspend if a peer doesn't read frames for some reason.\n     */\n    public actual val outgoing: SendChannel<Frame>\n\n    /**\n     * Negotiated WebSocket extensions.\n     */\n    @ExperimentalWebSocketExtensionApi\n    public actual val extensions: List<WebSocketExtension<*>>\n\n    /**\n     * Enqueue frame, may suspend if outgoing queue is full. May throw an exception if outgoing channel is already\n     * closed so it is impossible to transfer any message. Frames that were sent after close frame could be silently\n     * ignored. Please note that close frame could be sent automatically in reply to a peer close frame unless it is\n     * raw websocket session.\n     */\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual suspend fun send(frame: Frame) {\n        outgoing.send(frame)\n    }\n\n    /**\n     * Flush all outstanding messages and suspend until all earlier sent messages will be written. Could be called\n     * at any time even after close. May return immediately if the connection is already terminated.\n     * However it may also fail with an exception (or cancellation) at any point due to session failure.\n     * Please note that [flush] doesn't guarantee that frames were actually delivered.\n     */\n    public actual suspend fun flush()\n\n    /**\n     * Initiate connection termination immediately. Termination may complete asynchronously.\n     */\n    @Deprecated(\n        \"Use cancel() instead.\",\n        ReplaceWith(\"cancel()\", \"kotlinx.coroutines.cancel\")\n    )\n    public actual fun terminate()\n\n    /**\n     * Specifies frame size limit. Connection will be closed if violated\n     */\n    public actual var maxFrameSize: Long\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\npackage io.ktor.http\n\nimport io.ktor.util.*\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.*\nimport kotlin.native.concurrent.*\n\n@SharedImmutable\nprivate val URL_ALPHABET = (('a'..'z') + ('A'..'Z') + ('0'..'9')).map { it.toByte() }\n\n@SharedImmutable\nprivate val URL_ALPHABET_CHARS = (('a'..'z') + ('A'..'Z') + ('0'..'9'))\n\n@SharedImmutable\nprivate val HEX_ALPHABET = ('a'..'f') + ('A'..'F') + ('0'..'9')\n\n/**\n * https://tools.ietf.org/html/rfc3986#section-2\n */\n@SharedImmutable\nprivate val URL_PROTOCOL_PART = listOf(\n    ':', '/', '?', '#', '[', ']', '@', // general\n    '!', '$', '&', '\\'', '(', ')', '*', ',', ';', '=', // sub-components\n    '-', '.', '_', '~', '+' // unreserved\n).map { it.toByte() }\n\n/**\n * from `pchar` in https://tools.ietf.org/html/rfc3986#section-2\n */\n@SharedImmutable\nprivate val VALID_PATH_PART = listOf(\n    ':', '@',\n    '!', '$', '&', '\\'', '(', ')', '*', '+', ',', ';', '=',\n    '-', '.', '_', '~'\n)\n\n/**\n * Oauth specific percent encoding\n * https://tools.ietf.org/html/rfc5849#section-3.6\n */\n@SharedImmutable\nprivate val OAUTH_SYMBOLS = listOf('-', '.', '_', '~').map { it.toByte() }\n\ninternal val LETTERS_AND_NUMBERS = ('a'..'z').toSet() + ('A'..'Z').toSet() + ('0'..'9').toSet()\n\n/**\n * https://tools.ietf.org/html/rfc7230#section-3.2.6\n */\ninternal val TOKENS: Set<Char> =\n    setOf('!', '#', '%', '&', '\\'', '*', '+', '-', '.', '^', '_', '`', '|', '~') + LETTERS_AND_NUMBERS\n\n/**\n * Encode url part as specified in\n * https://tools.ietf.org/html/rfc3986#section-2\n */\npublic fun String.encodeURLQueryComponent(\n    encodeFull: Boolean = false,\n    spaceToPlus: Boolean = false,\n    charset: Charset = Charsets.UTF_8\n): String = buildString {\n    val content = charset.newEncoder().encode(this@encodeURLQueryComponent)\n    content.forEach {\n        when {\n            it == ' '.toByte() -> if (spaceToPlus) append('+') else append(\"%20\")\n            it in URL_ALPHABET || (!encodeFull && it in URL_PROTOCOL_PART) -> append(it.toChar())\n            else -> append(it.percentEncode())\n        }\n    }\n}\n\n/**\n * Encode URL path or component. It escapes all illegal or ambiguous characters\n */\npublic fun String.encodeURLPath(): String = buildString {\n    val charset = Charsets.UTF_8\n\n    var index = 0\n    while (index < this@encodeURLPath.length) {\n        val current = this@encodeURLPath[index]\n        if (current == '/' || current in URL_ALPHABET_CHARS || current in VALID_PATH_PART) {\n            append(current)\n            index++\n            continue\n        }\n\n        if (current == '%' &&\n            index + 2 < this@encodeURLPath.length &&\n            this@encodeURLPath[index + 1] in HEX_ALPHABET &&\n            this@encodeURLPath[index + 2] in HEX_ALPHABET\n        ) {\n            append(current)\n            append(this@encodeURLPath[index + 1])\n            append(this@encodeURLPath[index + 2])\n\n            index += 3\n            continue\n        }\n\n        val symbolSize = if (current.isSurrogate()) 2 else 1\n        // we need to call newEncoder() for every symbol, otherwise it won't work\n        charset.newEncoder().encode(this@encodeURLPath, index, index + symbolSize).forEach {\n            append(it.percentEncode())\n        }\n        index += symbolSize\n    }\n}\n\n/**\n * Encode [this] in percent encoding specified here:\n * https://tools.ietf.org/html/rfc5849#section-3.6\n */\npublic fun String.encodeOAuth(): String = encodeURLParameter()\n\n/**\n * Encode [this] as query parameter key.\n */\npublic fun String.encodeURLParameter(\n    spaceToPlus: Boolean = false\n): String = buildString {\n    val content = Charsets.UTF_8.newEncoder().encode(this@encodeURLParameter)\n    content.forEach {\n        when {\n            it in URL_ALPHABET || it in OAUTH_SYMBOLS -> append(it.toChar())\n            spaceToPlus && it == ' '.toByte() -> append('+')\n            else -> append(it.percentEncode())\n        }\n    }\n}\n\n/**\n * Encode [this] as query parameter value.\n */\ninternal fun String.encodeURLParameterValue(): String = encodeURLParameter(spaceToPlus = true)\n\n/**\n * Decode URL query component\n */\npublic fun String.decodeURLQueryComponent(\n    start: Int = 0,\n    end: Int = length,\n    plusIsSpace: Boolean = false,\n    charset: Charset = Charsets.UTF_8\n): String = decodeScan(start, end, plusIsSpace, charset)\n\n/**\n * Decode percent encoded URL part within the specified range [[start], [end]).\n * This function is not intended to decode urlencoded forms so it doesn't decode plus character to space.\n */\npublic fun String.decodeURLPart(\n    start: Int = 0,\n    end: Int = length,\n    charset: Charset = Charsets.UTF_8\n): String = decodeScan(start, end, false, charset)\n\nprivate fun String.decodeScan(start: Int, end: Int, plusIsSpace: Boolean, charset: Charset): String {\n    for (index in start until end) {\n        val ch = this[index]\n        if (ch == '%' || (plusIsSpace && ch == '+')) {\n            return decodeImpl(start, end, index, plusIsSpace, charset)\n        }\n    }\n    return if (start == 0 && end == length) toString() else substring(start, end)\n}\n\nprivate fun CharSequence.decodeImpl(\n    start: Int,\n    end: Int,\n    prefixEnd: Int,\n    plusIsSpace: Boolean,\n    charset: Charset\n): String {\n    val length = end - start\n    // if length is big, it probably means it is encoded\n    val sbSize = if (length > 255) length / 3 else length\n    val sb = StringBuilder(sbSize)\n\n    if (prefixEnd > start) {\n        sb.append(this, start, prefixEnd)\n    }\n\n    var index = prefixEnd\n\n    // reuse ByteArray for hex decoding stripes\n    var bytes: ByteArray? = null\n\n    while (index < end) {\n        val c = this[index]\n        when {\n            plusIsSpace && c == '+' -> {\n                sb.append(' ')\n                index++\n            }\n            c == '%' -> {\n                // if ByteArray was not needed before, create it with an estimate of remaining string be all hex\n                if (bytes == null) {\n                    bytes = ByteArray((end - index) / 3)\n                }\n\n                // fill ByteArray with all the bytes, so Charset can decode text\n                var count = 0\n                while (index < end && this[index] == '%') {\n                    if (index + 2 >= end) {\n                        throw URLDecodeException(\n                            \"Incomplete trailing HEX escape: ${substring(index)}, in $this at $index\"\n                        )\n                    }\n\n                    val digit1 = charToHexDigit(this[index + 1])\n                    val digit2 = charToHexDigit(this[index + 2])\n                    if (digit1 == -1 || digit2 == -1) {\n                        throw URLDecodeException(\n                            \"Wrong HEX escape: %${this[index + 1]}${this[index + 2]}, in $this, at $index\"\n                        )\n                    }\n\n                    bytes[count++] = (digit1 * 16 + digit2).toByte()\n                    index += 3\n                }\n\n                // Decode chars from bytes and put into StringBuilder\n                // Note: Tried using ByteBuffer and using enc.decode()  it's slower\n                sb.append(String(bytes, offset = 0, length = count, charset = charset))\n            }\n            else -> {\n                sb.append(c)\n                index++\n            }\n        }\n    }\n\n    return sb.toString()\n}\n\n/**\n * URL decoder exception\n */\npublic class URLDecodeException(message: String) : Exception(message)\n\nprivate fun Byte.percentEncode(): String = buildString(3) {\n    val code = toInt() and 0xff\n    append('%')\n    append(hexDigitToChar(code shr 4))\n    append(hexDigitToChar(code and 0x0f))\n}\n\nprivate fun charToHexDigit(c2: Char) = when (c2) {\n    in '0'..'9' -> c2 - '0'\n    in 'A'..'F' -> c2 - 'A' + 10\n    in 'a'..'f' -> c2 - 'a' + 10\n    else -> -1\n}\n\nprivate fun hexDigitToChar(digit: Int): Char = when (digit) {\n    in 0..9 -> '0' + digit\n    else -> 'A' + digit - 10\n}\n\nprivate fun ByteReadPacket.forEach(block: (Byte) -> Unit) {\n    takeWhile { buffer ->\n        while (buffer.canRead()) {\n            block(buffer.readByte())\n        }\n        true\n    }\n}\n","/*\n * Copyright 2010-2018 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"StringsKt\")\n\npackage kotlin.text\n\n/**\n * Converts the string into a regular expression [Regex] with the default options.\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.toRegex(): Regex = Regex(this)\n\n/**\n * Converts the string into a regular expression [Regex] with the specified single [option].\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.toRegex(option: RegexOption): Regex = Regex(this, option)\n\n/**\n * Converts the string into a regular expression [Regex] with the specified set of [options].\n */\n@kotlin.internal.InlineOnly\npublic inline fun String.toRegex(options: Set<RegexOption>): Regex = Regex(this, options)\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util\n\n/**\n * Escapes the characters in a String using HTML entities\n */\npublic fun String.escapeHTML(): String {\n    val text = this@escapeHTML\n    if (text.isEmpty()) return text\n\n    return buildString(length) {\n        for (idx in 0 until text.length) {\n            val ch = text[idx]\n            when (ch) {\n                '\\'' -> append(\"&#x27;\")\n                '\\\"' -> append(\"&quot;\")\n                '&' -> append(\"&amp;\")\n                '<' -> append(\"&lt;\")\n                '>' -> append(\"&gt;\")\n                else -> append(ch)\n            }\n        }\n    }\n}\n\n/**\n * Splits the given string into two parts before and after separator.\n *\n * Useful together with destructuring declarations\n */\npublic inline fun String.chomp(\n    separator: String,\n    onMissingDelimiter: () -> Pair<String, String>\n): Pair<String, String> {\n    val idx = indexOf(separator)\n    return when (idx) {\n        -1 -> onMissingDelimiter()\n        else -> substring(0, idx) to substring(idx + 1)\n    }\n}\n\n/**\n * Does the same as the regular [toLowerCase] except that locale-specific rules are not applied to ASCII characters\n * so latin characters are converted by the original english rules.\n */\n@InternalAPI\npublic fun String.toLowerCasePreservingASCIIRules(): String {\n    val firstIndex = indexOfFirst {\n        toLowerCasePreservingASCII(it) != it\n    }\n\n    if (firstIndex == -1) {\n        return this\n    }\n\n    val original = this\n    return buildString(length) {\n        append(original, 0, firstIndex)\n\n        for (index in firstIndex..original.lastIndex) {\n            append(toLowerCasePreservingASCII(original[index]))\n        }\n    }\n}\n\n/**\n * Does the same as the regular [toUpperCase] except that locale-specific rules are not applied to ASCII characters\n * so latin characters are converted by the original english rules.\n */\n@InternalAPI\npublic fun String.toUpperCasePreservingASCIIRules(): String {\n    val firstIndex = indexOfFirst {\n        toUpperCasePreservingASCII(it) != it\n    }\n\n    if (firstIndex == -1) {\n        return this\n    }\n\n    val original = this\n    return buildString(length) {\n        append(original, 0, firstIndex)\n\n        for (index in firstIndex..original.lastIndex) {\n            append(toUpperCasePreservingASCII(original[index]))\n        }\n    }\n}\n\nprivate fun toLowerCasePreservingASCII(ch: Char): Char = when (ch) {\n    in 'A'..'Z' -> ch + 32\n    in '\\u0000'..'\\u007f' -> ch\n    else -> ch.toLowerCase()\n}\n\nprivate fun toUpperCasePreservingASCII(ch: Char): Char = when (ch) {\n    in 'a'..'z' -> ch - 32\n    in '\\u0000'..'\\u007f' -> ch\n    else -> ch.toLowerCase()\n}\n\ninternal fun String.caseInsensitive(): CaseInsensitiveString = CaseInsensitiveString(this)\n\ninternal class CaseInsensitiveString(val content: String) {\n    private val hash = content.toLowerCase().hashCode()\n\n    override fun equals(other: Any?): Boolean =\n        (other as? CaseInsensitiveString)?.content?.equals(content, ignoreCase = true) == true\n\n    override fun hashCode(): Int = hash\n\n    override fun toString(): String = content\n}\n","package io.ktor.utils.io.core\n\npublic expect interface Closeable {\n    public fun close()\n}\n\npublic inline fun <C : Closeable, R> C.use(block: (C) -> R): R {\n    var closed = false\n\n    return try {\n        block(this)\n    } catch (first: Throwable) {\n        try {\n            closed = true\n            close()\n        } catch (second: Throwable) {\n            first.addSuppressedInternal(second)\n        }\n\n        throw first\n    } finally {\n        if (!closed) {\n            close()\n        }\n    }\n}\n\n@PublishedApi\ninternal expect fun Throwable.addSuppressedInternal(other: Throwable)\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http\n\n/**\n * Represents `Content-Disposition` header value\n */\npublic class ContentDisposition(disposition: String, parameters: List<HeaderValueParam> = emptyList()) :\n    HeaderValueWithParameters(disposition, parameters) {\n    /**\n     * Content disposition value without parameters\n     */\n    public val disposition: String get() = content\n\n    /**\n     * Content disposition name (from parameter named `name`)\n     */\n    public val name: String?\n        get() = parameter(Parameters.Name)\n\n    /**\n     * Creates new with parameter appended\n     */\n    public fun withParameter(key: String, value: String): ContentDisposition =\n        ContentDisposition(disposition, parameters + HeaderValueParam(key, value))\n\n    /**\n     * Creates new with parameters appended\n     */\n    public fun withParameters(newParameters: List<HeaderValueParam>): ContentDisposition =\n        ContentDisposition(disposition, parameters + newParameters)\n\n    override fun equals(other: Any?): Boolean =\n        other is ContentDisposition &&\n            disposition == other.disposition &&\n            parameters == other.parameters\n\n    override fun hashCode(): Int = disposition.hashCode() * 31 + parameters.hashCode()\n\n    @Suppress(\"unused\", \"PublicApiImplicitType\")\n    public companion object {\n        /**\n         * `Content-Disposition: file`\n         */\n        public val File: ContentDisposition = ContentDisposition(\"file\")\n\n        /**\n         * `Content-Disposition: mixed`\n         */\n        public val Mixed: ContentDisposition = ContentDisposition(\"mixed\")\n\n        /**\n         * `Content-Disposition: attachment`\n         */\n        public val Attachment: ContentDisposition = ContentDisposition(\"attachment\")\n\n        /**\n         * `Content-Disposition: inline`\n         */\n        public val Inline: ContentDisposition = ContentDisposition(\"inline\")\n\n        /**\n         * Parse `Content-Disposition` header [value]\n         */\n        public fun parse(value: String): ContentDisposition = parse(value) { v, p -> ContentDisposition(v, p) }\n    }\n\n    /**\n     * Frequently used content disposition parameter names\n     */\n    @Suppress(\"KDocMissingDocumentation\", \"unused\", \"PublicApiImplicitType\")\n    public object Parameters {\n        public const val FileName: String = \"filename\"\n        public const val FileNameAsterisk: String = \"filename*\"\n        public const val Name: String = \"name\"\n        public const val CreationDate: String = \"creation-date\"\n        public const val ModificationDate: String = \"modification-date\"\n        public const val ReadDate: String = \"read-date\"\n        public const val Size: String = \"size\"\n        public const val Handling: String = \"handling\"\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http\n\n/**\n * Set `E-Tag` header\n */\npublic fun HeadersBuilder.etag(entityTag: String): Unit = set(HttpHeaders.ETag, entityTag)\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http\n\n/**\n * Represents a value for a `Cache-Control` header\n *\n * @param visibility specifies an optional visibility such as private or public\n */\npublic sealed class CacheControl(public val visibility: Visibility?) {\n\n    /**\n     * Controls caching by proxies\n     */\n    public enum class Visibility(internal val headerValue: String) {\n        /**\n         * Specifies that the response is cacheable by clients and shared (proxy) caches.\n         */\n        Public(\"public\"),\n\n        /**\n         * Specifies that the response is cacheable only on the client and not by shared (proxy server) caches.\n         */\n        Private(\"private\")\n    }\n\n    /**\n     * Represents a no-cache cache control value\n     */\n    public class NoCache(visibility: Visibility?) : CacheControl(visibility) {\n        override fun toString(): String = if (visibility == null) {\n            \"no-cache\"\n        } else {\n            \"no-cache, ${visibility.headerValue}\"\n        }\n\n        override fun equals(other: Any?): Boolean {\n            return other is NoCache && visibility == other.visibility\n        }\n\n        override fun hashCode(): Int {\n            return visibility.hashCode()\n        }\n    }\n\n    /**\n     * Represents a no-store cache control value\n     */\n    public class NoStore(visibility: Visibility?) : CacheControl(visibility) {\n        override fun toString(): String = if (visibility == null) {\n            \"no-store\"\n        } else {\n            \"no-store, ${visibility.headerValue}\"\n        }\n\n        override fun equals(other: Any?): Boolean {\n            return other is NoStore && other.visibility == visibility\n        }\n\n        override fun hashCode(): Int {\n            return visibility.hashCode()\n        }\n    }\n\n    /**\n     * Represents a cache control value with the specified max ages and re-validation strategies\n     * @property maxAgeSeconds max-age in seconds\n     * @property proxyMaxAgeSeconds max-age in seconds for caching proxies\n     * @property mustRevalidate `true` if a client must validate in spite of age\n     * @property proxyRevalidate `true` if a caching proxy must revalidate in spite of age\n     */\n    public class MaxAge(\n        public val maxAgeSeconds: Int,\n        public val proxyMaxAgeSeconds: Int? = null,\n        public val mustRevalidate: Boolean = false,\n        public val proxyRevalidate: Boolean = false,\n        visibility: Visibility? = null\n    ) : CacheControl(visibility) {\n        override fun toString(): String {\n            val parts = ArrayList<String>(5)\n            parts.add(\"max-age=$maxAgeSeconds\")\n            if (proxyMaxAgeSeconds != null) {\n                parts.add(\"s-maxage=$proxyMaxAgeSeconds\")\n            }\n            if (mustRevalidate) {\n                parts.add(\"must-revalidate\")\n            }\n            if (proxyRevalidate) {\n                parts.add(\"proxy-revalidate\")\n            }\n            if (visibility != null) {\n                parts.add(visibility.headerValue)\n            }\n\n            return parts.joinToString(\", \")\n        }\n\n        override fun equals(other: Any?): Boolean {\n            return other === this || (\n                other is MaxAge &&\n                    other.maxAgeSeconds == maxAgeSeconds &&\n                    other.proxyMaxAgeSeconds == proxyMaxAgeSeconds &&\n                    other.mustRevalidate == mustRevalidate &&\n                    other.proxyRevalidate == proxyRevalidate &&\n                    other.visibility == visibility\n                )\n        }\n\n        override fun hashCode(): Int {\n            var result = maxAgeSeconds\n            result = 31 * result + (proxyMaxAgeSeconds ?: 0)\n            result = 31 * result + mustRevalidate.hashCode()\n            result = 31 * result + proxyRevalidate.hashCode()\n            result = 31 * result + visibility.hashCode()\n            return result\n        }\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http\n\nimport io.ktor.util.*\nimport kotlin.native.concurrent.*\n\n/** Separator symbols listed in RFC https://tools.ietf.org/html/rfc2616#section-2.2 */\n@SharedImmutable\nprivate val HeaderFieldValueSeparators =\n    setOf('(', ')', '<', '>', '@', ',', ';', ':', '\\\\', '\\\"', '/', '[', ']', '?', '=', '{', '}', ' ', '\\t', '\\n', '\\r')\n\n/**\n * Represents a header value that consist of [content] followed by [parameters].\n * Useful for headers such as `Content-Type`, `Content-Disposition` and so on.\n *\n * @property content header's content without parameters\n * @property parameters\n */\npublic abstract class HeaderValueWithParameters(\n    protected val content: String,\n    public val parameters: List<HeaderValueParam> = emptyList()\n) {\n\n    /**\n     * The first value for the parameter with [name] comparing case-insensitively or `null` if no such parameters found\n     */\n    public fun parameter(name: String): String? =\n        parameters.firstOrNull { it.name.equals(name, ignoreCase = true) }?.value\n\n    override fun toString(): String = when {\n        parameters.isEmpty() -> content\n        else -> {\n            val size = content.length + parameters.sumBy { it.name.length + it.value.length + 3 }\n            StringBuilder(size).apply {\n                append(content)\n                for (index in 0 until parameters.size) {\n                    val (name, value) = parameters[index]\n                    append(\"; \")\n                    append(name)\n                    append(\"=\")\n                    value.escapeIfNeededTo(this)\n                }\n            }.toString()\n        }\n    }\n\n    public companion object {\n        /**\n         * Parse header with parameter and pass it to [init] function to instantiate particular type\n         */\n        public inline fun <R> parse(value: String, init: (String, List<HeaderValueParam>) -> R): R {\n            val headerValue = parseHeaderValue(value).single()\n            return init(headerValue.value, headerValue.params)\n        }\n    }\n}\n\n/**\n * Append formatted header value to the builder\n */\npublic fun StringValuesBuilder.append(name: String, value: HeaderValueWithParameters) {\n    append(name, value.toString())\n}\n\n/**\n * Escape using double quotes if needed or keep as is if no dangerous strings found\n */\n@InternalAPI\npublic fun String.escapeIfNeeded(): String = when {\n    checkNeedEscape() -> quote()\n    else -> this\n}\n\n@Suppress(\"NOTHING_TO_INLINE\")\nprivate inline fun String.escapeIfNeededTo(out: StringBuilder) {\n    when {\n        checkNeedEscape() -> out.append(this.quote())\n        else -> out.append(this)\n    }\n}\n\nprivate fun String.checkNeedEscape(): Boolean {\n    if (isEmpty()) return true\n    if (isQuoted()) return false\n\n    for (index in 0 until length) {\n        if (HeaderFieldValueSeparators.contains(this[index])) return true\n    }\n\n    return false\n}\n\nprivate fun String.isQuoted(): Boolean {\n    if (length < 2) {\n        return false\n    }\n    if (first() != '\"' || last() != '\"') {\n        return false\n    }\n    var startIndex = 1\n    do {\n        val index = indexOf('\"', startIndex)\n        if (index == lastIndex) {\n            break\n        }\n\n        var slashesCount = 0\n        var slashIndex = index - 1\n        while (this[slashIndex] == '\\\\') {\n            slashesCount++\n            slashIndex--\n        }\n        if (slashesCount % 2 == 0) {\n            return false\n        }\n\n        startIndex = index + 1\n    } while (startIndex < length)\n\n    return true\n}\n\n/**\n * Escape string using double quotes\n */\n@InternalAPI\npublic fun String.quote(): String = buildString { this@quote.quoteTo(this) }\n\nprivate fun String.quoteTo(out: StringBuilder) {\n    out.append(\"\\\"\")\n    for (i in 0 until length) {\n        val ch = this[i]\n        when (ch) {\n            '\\\\' -> out.append(\"\\\\\\\\\")\n            '\\n' -> out.append(\"\\\\n\")\n            '\\r' -> out.append(\"\\\\r\")\n            '\\t' -> out.append(\"\\\\t\")\n            '\\\"' -> out.append(\"\\\\\\\"\")\n            else -> out.append(ch)\n        }\n    }\n    out.append(\"\\\"\")\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http\n\nimport io.ktor.util.*\n\n/**\n * Format `Content-Range` header value\n */\npublic fun contentRangeHeaderValue(\n    range: LongRange?,\n    fullLength: Long? = null,\n    unit: RangeUnits = RangeUnits.Bytes\n): String =\n    contentRangeHeaderValue(range, fullLength, unit.unitToken)\n\n/**\n * Format `Content-Range` header value\n */\npublic fun contentRangeHeaderValue(\n    range: LongRange?,\n    fullLength: Long? = null,\n    unit: String = RangeUnits.Bytes.unitToken\n): String = buildString {\n    append(unit)\n    append(\" \")\n    if (range != null) {\n        append(range.start)\n        append('-')\n        append(range.endInclusive)\n    } else {\n        append('*')\n    }\n    append('/')\n    append(fullLength ?: \"*\")\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http\n\nimport io.ktor.utils.io.charsets.*\n\n/**\n * Represents a value for a `Content-Type` header.\n * @property contentType represents a type part of the media type.\n * @property contentSubtype represents a subtype part of the media type.\n */\npublic class ContentType private constructor(\n    public val contentType: String,\n    public val contentSubtype: String,\n    existingContent: String,\n    parameters: List<HeaderValueParam> = emptyList()\n) : HeaderValueWithParameters(existingContent, parameters) {\n\n    public constructor(\n        contentType: String,\n        contentSubtype: String,\n        parameters: List<HeaderValueParam> = emptyList()\n    ) : this(\n        contentType,\n        contentSubtype,\n        \"$contentType/$contentSubtype\",\n        parameters\n    )\n\n    /**\n     * Creates a copy of `this` type with the added parameter with the [name] and [value].\n     */\n    public fun withParameter(name: String, value: String): ContentType {\n        if (hasParameter(name, value)) return this\n\n        return ContentType(contentType, contentSubtype, content, parameters + HeaderValueParam(name, value))\n    }\n\n    private fun hasParameter(name: String, value: String): Boolean = when (parameters.size) {\n        0 -> false\n        1 -> parameters[0].let { it.name.equals(name, ignoreCase = true) && it.value.equals(value, ignoreCase = true) }\n        else -> parameters.any { it.name.equals(name, ignoreCase = true) && it.value.equals(value, ignoreCase = true) }\n    }\n\n    /**\n     * Creates a copy of `this` type without any parameters\n     */\n    public fun withoutParameters(): ContentType = when {\n        parameters.isEmpty() -> this\n        else -> ContentType(contentType, contentSubtype)\n    }\n\n    /**\n     * Checks if `this` type matches a [pattern] type taking into account placeholder symbols `*` and parameters.\n     */\n    public fun match(pattern: ContentType): Boolean {\n        if (pattern.contentType != \"*\" && !pattern.contentType.equals(contentType, ignoreCase = true)) {\n            return false\n        }\n\n        if (pattern.contentSubtype != \"*\" && !pattern.contentSubtype.equals(contentSubtype, ignoreCase = true)) {\n            return false\n        }\n\n        for ((patternName, patternValue) in pattern.parameters) {\n            val matches = when (patternName) {\n                \"*\" -> {\n                    when (patternValue) {\n                        \"*\" -> true\n                        else -> parameters.any { p -> p.value.equals(patternValue, ignoreCase = true) }\n                    }\n                }\n                else -> {\n                    val value = parameter(patternName)\n                    when (patternValue) {\n                        \"*\" -> value != null\n                        else -> value.equals(patternValue, ignoreCase = true)\n                    }\n                }\n            }\n\n            if (!matches) {\n                return false\n            }\n        }\n        return true\n    }\n\n    /**\n     * Checks if `this` type matches a [pattern] type taking into account placeholder symbols `*` and parameters.\n     */\n    public fun match(pattern: String): Boolean = match(parse(pattern))\n\n    override fun equals(other: Any?): Boolean =\n        other is ContentType &&\n            contentType.equals(other.contentType, ignoreCase = true) &&\n            contentSubtype.equals(other.contentSubtype, ignoreCase = true) &&\n            parameters == other.parameters\n\n    override fun hashCode(): Int {\n        var result = contentType.toLowerCase().hashCode()\n        result += 31 * result + contentSubtype.toLowerCase().hashCode()\n        result += 31 * parameters.hashCode()\n        return result\n    }\n\n    public companion object {\n        /**\n         * Parses a string representing a `Content-Type` header into a [ContentType] instance.\n         */\n        public fun parse(value: String): ContentType {\n            if (value.isBlank()) return Any\n\n            return parse(value) { parts, parameters ->\n                val slash = parts.indexOf('/')\n\n                if (slash == -1) {\n                    if (parts.trim() == \"*\") {\n                        return Any\n                    }\n\n                    throw BadContentTypeFormatException(value)\n                }\n\n                val type = parts.substring(0, slash).trim()\n\n                if (type.isEmpty()) {\n                    throw BadContentTypeFormatException(value)\n                }\n\n                val subtype = parts.substring(slash + 1).trim()\n\n                if (type.contains(' ') || subtype.contains(' ')) {\n                    throw BadContentTypeFormatException(value)\n                }\n\n                if (subtype.isEmpty() || subtype.contains('/')) {\n                    throw BadContentTypeFormatException(value)\n                }\n\n                ContentType(type, subtype, parameters)\n            }\n        }\n\n        /**\n         * Represents a pattern `* / *` to match any content type.\n         */\n        public val Any: ContentType = ContentType(\"*\", \"*\")\n    }\n\n    /**\n     * Provides a list of standard subtypes of an `application` content type.\n     */\n    @Suppress(\"KDocMissingDocumentation\", \"unused\")\n    public object Application {\n        /**\n         * Represents a pattern `application / *` to match any application content type.\n         */\n        public val Any: ContentType = ContentType(\"application\", \"*\")\n        public val Atom: ContentType = ContentType(\"application\", \"atom+xml\")\n        public val Cbor: ContentType = ContentType(\"application\", \"cbor\")\n        public val Json: ContentType = ContentType(\"application\", \"json\")\n        public val HalJson: ContentType = ContentType(\"application\", \"hal+json\")\n        public val JavaScript: ContentType = ContentType(\"application\", \"javascript\")\n        public val OctetStream: ContentType = ContentType(\"application\", \"octet-stream\")\n        public val FontWoff: ContentType = ContentType(\"application\", \"font-woff\")\n        public val Rss: ContentType = ContentType(\"application\", \"rss+xml\")\n        public val Xml: ContentType = ContentType(\"application\", \"xml\")\n        public val Xml_Dtd: ContentType = ContentType(\"application\", \"xml-dtd\")\n        public val Zip: ContentType = ContentType(\"application\", \"zip\")\n        public val GZip: ContentType = ContentType(\"application\", \"gzip\")\n\n        public val FormUrlEncoded: ContentType =\n            ContentType(\"application\", \"x-www-form-urlencoded\")\n\n        public val Pdf: ContentType = ContentType(\"application\", \"pdf\")\n        public val ProtoBuf: ContentType = ContentType(\"application\", \"protobuf\")\n        public val Wasm: ContentType = ContentType(\"application\", \"wasm\")\n        public val ProblemJson: ContentType = ContentType(\"application\", \"problem+json\")\n        public val ProblemXml: ContentType = ContentType(\"application\", \"problem+xml\")\n    }\n\n    /**\n     * Provides a list of standard subtypes of an `audio` content type.\n     */\n    @Suppress(\"KDocMissingDocumentation\", \"unused\")\n    public object Audio {\n        public val Any: ContentType = ContentType(\"audio\", \"*\")\n        public val MP4: ContentType = ContentType(\"audio\", \"mp4\")\n        public val MPEG: ContentType = ContentType(\"audio\", \"mpeg\")\n        public val OGG: ContentType = ContentType(\"audio\", \"ogg\")\n    }\n\n    /**\n     * Provides a list of standard subtypes of an `image` content type.\n     */\n    @Suppress(\"KDocMissingDocumentation\", \"unused\")\n    public object Image {\n        public val Any: ContentType = ContentType(\"image\", \"*\")\n        public val GIF: ContentType = ContentType(\"image\", \"gif\")\n        public val JPEG: ContentType = ContentType(\"image\", \"jpeg\")\n        public val PNG: ContentType = ContentType(\"image\", \"png\")\n        public val SVG: ContentType = ContentType(\"image\", \"svg+xml\")\n        public val XIcon: ContentType = ContentType(\"image\", \"x-icon\")\n    }\n\n    /**\n     * Provides a list of standard subtypes of a `message` content type.\n     */\n    @Suppress(\"KDocMissingDocumentation\", \"unused\")\n    public object Message {\n        public val Any: ContentType = ContentType(\"message\", \"*\")\n        public val Http: ContentType = ContentType(\"message\", \"http\")\n    }\n\n    /**\n     * Provides a list of standard subtypes of a `multipart` content type.\n     */\n    @Suppress(\"KDocMissingDocumentation\", \"unused\")\n    public object MultiPart {\n        public val Any: ContentType = ContentType(\"multipart\", \"*\")\n        public val Mixed: ContentType = ContentType(\"multipart\", \"mixed\")\n        public val Alternative: ContentType = ContentType(\"multipart\", \"alternative\")\n        public val Related: ContentType = ContentType(\"multipart\", \"related\")\n        public val FormData: ContentType = ContentType(\"multipart\", \"form-data\")\n        public val Signed: ContentType = ContentType(\"multipart\", \"signed\")\n        public val Encrypted: ContentType = ContentType(\"multipart\", \"encrypted\")\n        public val ByteRanges: ContentType = ContentType(\"multipart\", \"byteranges\")\n    }\n\n    /**\n     * Provides a list of standard subtypes of a `text` content type.\n     */\n    @Suppress(\"KDocMissingDocumentation\", \"unused\")\n    public object Text {\n        public val Any: ContentType = ContentType(\"text\", \"*\")\n        public val Plain: ContentType = ContentType(\"text\", \"plain\")\n        public val CSS: ContentType = ContentType(\"text\", \"css\")\n        public val CSV: ContentType = ContentType(\"text\", \"csv\")\n        public val Html: ContentType = ContentType(\"text\", \"html\")\n        public val JavaScript: ContentType = ContentType(\"text\", \"javascript\")\n        public val VCard: ContentType = ContentType(\"text\", \"vcard\")\n        public val Xml: ContentType = ContentType(\"text\", \"xml\")\n        public val EventStream: ContentType = ContentType(\"text\", \"event-stream\")\n    }\n\n    /**\n     * Provides a list of standard subtypes of a `video` content type.\n     */\n    @Suppress(\"KDocMissingDocumentation\", \"unused\")\n    public object Video {\n        public val Any: ContentType = ContentType(\"video\", \"*\")\n        public val MPEG: ContentType = ContentType(\"video\", \"mpeg\")\n        public val MP4: ContentType = ContentType(\"video\", \"mp4\")\n        public val OGG: ContentType = ContentType(\"video\", \"ogg\")\n        public val QuickTime: ContentType = ContentType(\"video\", \"quicktime\")\n    }\n}\n\n/**\n * Exception thrown when a content type string is malformed.\n */\npublic class BadContentTypeFormatException(value: String) : Exception(\"Bad Content-Type format: $value\")\n\n/**\n * Creates a copy of `this` type with the added charset parameter with [charset] value.\n */\npublic fun ContentType.withCharset(charset: Charset): ContentType = withParameter(\"charset\", charset.name)\n\n/**\n * Extracts a [Charset] value from the given `Content-Type`, `Content-Disposition` or similar header value.\n */\npublic fun HeaderValueWithParameters.charset(): Charset? = parameter(\"charset\")?.let {\n    try {\n        Charset.forName(it)\n    } catch (exception: IllegalArgumentException) {\n        null\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http\n\nimport io.ktor.util.*\nimport io.ktor.util.date.*\nimport kotlin.jvm.*\nimport kotlin.native.concurrent.*\n\n/**\n * Represents a cookie with name, content and a set of settings such as expiration, visibility and security.\n * A cookie with neither [expires] nor [maxAge] is a session cookie.\n *\n * @property name\n * @property value\n * @property encoding - cookie encoding type [CookieEncoding]\n * @property maxAge number of seconds to keep cookie\n * @property expires date when it expires\n * @property domain for which it is set\n * @property path for which it is set\n * @property secure send it via secure connection only\n * @property httpOnly only transfer cookie over HTTP, no access from JavaScript\n * @property extensions additional cookie extensions\n */\npublic data class Cookie(\n    val name: String,\n    val value: String,\n    val encoding: CookieEncoding = CookieEncoding.URI_ENCODING,\n    @get:JvmName(\"getMaxAgeInt\")\n    val maxAge: Int = 0,\n    val expires: GMTDate? = null,\n    val domain: String? = null,\n    val path: String? = null,\n    val secure: Boolean = false,\n    val httpOnly: Boolean = false,\n    val extensions: Map<String, String?> = emptyMap()\n) {\n    @Suppress(\"unused\", \"KDocMissingDocumentation\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun getMaxAge(): Int = maxAge\n}\n\n/**\n * Cooke encoding strategy\n */\npublic enum class CookieEncoding {\n    /**\n     * No encoding (could be dangerous)\n     */\n    RAW,\n\n    /**\n     * Double quotes with slash-escaping\n     */\n    DQUOTES,\n\n    /**\n     * URI encoding\n     */\n    URI_ENCODING,\n\n    /**\n     * BASE64 encoding\n     */\n    BASE64_ENCODING\n}\n\n@SharedImmutable\nprivate val loweredPartNames = setOf(\"max-age\", \"expires\", \"domain\", \"path\", \"secure\", \"httponly\", \"\\$x-enc\")\n\n/**\n * Parse server's `Set-Cookie` header value\n */\npublic fun parseServerSetCookieHeader(cookiesHeader: String): Cookie {\n    val asMap = parseClientCookiesHeader(cookiesHeader, false)\n    val first = asMap.entries.first { !it.key.startsWith(\"$\") }\n    val encoding = asMap[\"\\$x-enc\"]?.let { CookieEncoding.valueOf(it) } ?: CookieEncoding.RAW\n    val loweredMap = asMap.mapKeys { it.key.toLowerCasePreservingASCIIRules() }\n\n    return Cookie(\n        name = first.key,\n        value = decodeCookieValue(first.value, encoding),\n        encoding = encoding,\n        maxAge = loweredMap[\"max-age\"]?.toIntClamping() ?: 0,\n        expires = loweredMap[\"expires\"]?.fromCookieToGmtDate(),\n        domain = loweredMap[\"domain\"],\n        path = loweredMap[\"path\"],\n        secure = \"secure\" in loweredMap,\n        httpOnly = \"httponly\" in loweredMap,\n        extensions = asMap.filterKeys {\n            it.toLowerCasePreservingASCIIRules() !in loweredPartNames && it != first.key\n        }\n    )\n}\n\n@ThreadLocal\nprivate val clientCookieHeaderPattern = \"\"\"(^|;)\\s*([^()<>@;:/\\\\\"\\[\\]\\?=\\{\\}\\s]+)\\s*(=\\s*(\"[^\"]*\"|[^;]*))?\"\"\".toRegex()\n\n/**\n * Parse client's `Cookie` header value\n */\npublic fun parseClientCookiesHeader(cookiesHeader: String, skipEscaped: Boolean = true): Map<String, String> =\n    clientCookieHeaderPattern.findAll(cookiesHeader)\n        .map { (it.groups[2]?.value ?: \"\") to (it.groups[4]?.value ?: \"\") }\n        .filter { !skipEscaped || !it.first.startsWith(\"$\") }\n        .map { cookie ->\n            if (cookie.second.startsWith(\"\\\"\") && cookie.second.endsWith(\"\\\"\")) {\n                cookie.copy(second = cookie.second.removeSurrounding(\"\\\"\"))\n            } else {\n                cookie\n            }\n        }\n        .toMap()\n\n/**\n * Format `Set-Cookie` header value\n */\npublic fun renderSetCookieHeader(cookie: Cookie): String = with(cookie) {\n    renderSetCookieHeader(\n        name,\n        value,\n        encoding,\n        maxAge,\n        expires,\n        domain,\n        path,\n        secure,\n        httpOnly,\n        extensions\n    )\n}\n\n/**\n * Format `Cookie` header value\n */\npublic fun renderCookieHeader(cookie: Cookie): String = with(cookie) {\n    \"$name=${encodeCookieValue(value, encoding)}\"\n}\n\n/**\n * Format `Set-Cookie` header value\n */\npublic fun renderSetCookieHeader(\n    name: String,\n    value: String,\n    encoding: CookieEncoding = CookieEncoding.URI_ENCODING,\n    maxAge: Int = 0,\n    expires: GMTDate? = null,\n    domain: String? = null,\n    path: String? = null,\n    secure: Boolean = false,\n    httpOnly: Boolean = false,\n    extensions: Map<String, String?> = emptyMap(),\n    includeEncoding: Boolean = true\n): String = (\n    listOf(\n        cookiePart(name.assertCookieName(), value, encoding),\n        cookiePartUnencoded(\"Max-Age\", if (maxAge > 0) maxAge else null),\n        cookiePartUnencoded(\"Expires\", expires?.toHttpDate()),\n        cookiePart(\"Domain\", domain, CookieEncoding.RAW),\n        cookiePart(\"Path\", path, CookieEncoding.RAW),\n\n        cookiePartFlag(\"Secure\", secure),\n        cookiePartFlag(\"HttpOnly\", httpOnly)\n    ) + extensions.map { cookiePartExt(it.key.assertCookieName(), it.value, encoding) } +\n        if (includeEncoding) cookiePartExt(\"\\$x-enc\", encoding.name, CookieEncoding.RAW) else \"\"\n    ).filter { it.isNotEmpty() }\n    .joinToString(\"; \")\n\n/**\n * Encode cookie value using the specified [encoding]\n */\npublic fun encodeCookieValue(value: String, encoding: CookieEncoding): String = when (encoding) {\n    CookieEncoding.RAW -> when {\n        value.any { it.shouldEscapeInCookies() } ->\n            throw IllegalArgumentException(\n                \"The cookie value contains characters that cannot be encoded in RAW format. \" +\n                    \" Consider URL_ENCODING mode\"\n            )\n        else -> value\n    }\n    CookieEncoding.DQUOTES -> when {\n        value.contains('\"') -> throw IllegalArgumentException(\n            \"The cookie value contains characters that cannot be encoded in DQUOTES format. \" +\n                \"Consider URL_ENCODING mode\"\n        )\n        value.any { it.shouldEscapeInCookies() } -> \"\\\"$value\\\"\"\n        else -> value\n    }\n    CookieEncoding.BASE64_ENCODING -> value.encodeBase64()\n    CookieEncoding.URI_ENCODING -> value.encodeURLQueryComponent(encodeFull = true, spaceToPlus = true)\n}\n\n/**\n * Decode cookie value using the specified [encoding]\n */\npublic fun decodeCookieValue(encodedValue: String, encoding: CookieEncoding): String = when (encoding) {\n    CookieEncoding.RAW, CookieEncoding.DQUOTES -> when {\n        encodedValue.trimStart().startsWith(\"\\\"\") && encodedValue.trimEnd().endsWith(\"\\\"\") ->\n            encodedValue.trim().removeSurrounding(\"\\\"\")\n        else -> encodedValue\n    }\n    CookieEncoding.URI_ENCODING -> encodedValue.decodeURLQueryComponent(plusIsSpace = true)\n    CookieEncoding.BASE64_ENCODING -> encodedValue.decodeBase64String()\n}\n\nprivate fun String.assertCookieName() = when {\n    any { it.shouldEscapeInCookies() } -> throw IllegalArgumentException(\"Cookie name is not valid: $this\")\n    else -> this\n}\n\n@SharedImmutable\nprivate val cookieCharsShouldBeEscaped = setOf(';', ',', '\"')\n\nprivate fun Char.shouldEscapeInCookies() = isWhitespace() || this < ' ' || this in cookieCharsShouldBeEscaped\n\n@Suppress(\"NOTHING_TO_INLINE\")\nprivate inline fun cookiePart(name: String, value: Any?, encoding: CookieEncoding) =\n    if (value != null) \"$name=${encodeCookieValue(value.toString(), encoding)}\" else \"\"\n\n@Suppress(\"NOTHING_TO_INLINE\")\nprivate inline fun cookiePartUnencoded(name: String, value: Any?) =\n    if (value != null) \"$name=$value\" else \"\"\n\n@Suppress(\"NOTHING_TO_INLINE\")\nprivate inline fun cookiePartFlag(name: String, value: Boolean) =\n    if (value) name else \"\"\n\n@Suppress(\"NOTHING_TO_INLINE\")\nprivate inline fun cookiePartExt(name: String, value: String?, encoding: CookieEncoding) =\n    if (value == null) cookiePartFlag(name, true) else cookiePart(name, value, encoding)\n\nprivate fun String.toIntClamping(): Int = toLong().coerceIn(0L, Int.MAX_VALUE.toLong()).toInt()\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http\n\nimport io.ktor.util.*\n\n/**\n * Represents HTTP headers as a map from case-insensitive names to collection of [String] values\n */\npublic interface Headers : StringValues {\n    public companion object {\n        /**\n         * Empty [Headers] instance\n         */\n        @Suppress(\"DEPRECATION_ERROR\")\n        public val Empty: Headers = EmptyHeaders\n\n        /**\n         * Builds a [Headers] instance with the given [builder] function\n         * @param builder specifies a function to build a map\n         */\n        public inline fun build(builder: HeadersBuilder.() -> Unit): Headers = HeadersBuilder().apply(builder).build()\n    }\n}\n\n@Suppress(\"KDocMissingDocumentation\")\npublic class HeadersBuilder(size: Int = 8) : StringValuesBuilder(true, size) {\n    override fun build(): Headers {\n        require(!built) { \"HeadersBuilder can only build a single Headers instance\" }\n        built = true\n        return HeadersImpl(values)\n    }\n\n    override fun validateName(name: String) {\n        super.validateName(name)\n        HttpHeaders.checkHeaderName(name)\n    }\n\n    override fun validateValue(value: String) {\n        super.validateValue(value)\n        HttpHeaders.checkHeaderValue(value)\n    }\n}\n\n@Suppress(\"KDocMissingDocumentation\")\n@Deprecated(\n    \"Empty headers is internal\",\n    replaceWith = ReplaceWith(\"Headers.Empty\"),\n    level = DeprecationLevel.ERROR\n)\npublic object EmptyHeaders : Headers {\n    override val caseInsensitiveName: Boolean get() = true\n    override fun getAll(name: String): List<String>? = null\n    override fun names(): Set<String> = emptySet()\n    override fun entries(): Set<Map.Entry<String, List<String>>> = emptySet()\n    override fun isEmpty(): Boolean = true\n    override fun toString(): String = \"Headers ${entries()}\"\n}\n\n/**\n * Returns empty headers\n */\npublic fun headersOf(): Headers = Headers.Empty\n\n/**\n * Returns [Headers] instance containing only one header with the specified [name] and [value]\n */\npublic fun headersOf(name: String, value: String): Headers = HeadersSingleImpl(name, listOf(value))\n\n/**\n * Returns [Headers] instance containing only one header with the specified [name] and [values]\n */\npublic fun headersOf(name: String, values: List<String>): Headers = HeadersSingleImpl(name, values)\n\n/**\n * Returns [Headers] instance from [pairs]\n */\npublic fun headersOf(vararg pairs: Pair<String, List<String>>): Headers = HeadersImpl(pairs.asList().toMap())\n\n@InternalAPI\n@Suppress(\"KDocMissingDocumentation\")\npublic class HeadersImpl(\n    values: Map<String, List<String>> = emptyMap()\n) : Headers, StringValuesImpl(true, values) {\n    override fun toString(): String = \"Headers ${entries()}\"\n}\n\n@InternalAPI\n@Suppress(\"KDocMissingDocumentation\")\npublic class HeadersSingleImpl(\n    name: String,\n    values: List<String>\n) : Headers, StringValuesSingleImpl(true, name, values) {\n    override fun toString(): String = \"Headers ${entries()}\"\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http\n\nimport io.ktor.util.*\n\n/**\n * Represents a single value parameter\n * @property name of parameter\n * @property value of parameter\n */\npublic data class HeaderValueParam(val name: String, val value: String) {\n    override fun equals(other: Any?): Boolean {\n        return other is HeaderValueParam &&\n            other.name.equals(name, ignoreCase = true) &&\n            other.value.equals(value, ignoreCase = true)\n    }\n\n    override fun hashCode(): Int {\n        var result = name.toLowerCase().hashCode()\n        result += 31 * result + value.toLowerCase().hashCode()\n        return result\n    }\n}\n\n/**\n * Represents a header value. Similar to [HeaderValueWithParameters]\n * @property value\n * @property params for this value (could be empty)\n */\npublic data class HeaderValue(val value: String, val params: List<HeaderValueParam> = listOf()) {\n    /**\n     * Value's quality according to `q` parameter or `1.0` if missing or invalid\n     */\n    val quality: Double =\n        params.firstOrNull { it.name == \"q\" }?.value?.toDoubleOrNull()?.takeIf { it in 0.0..1.0 } ?: 1.0\n}\n\n/**\n * Parse header value and sort multiple values according to qualities\n */\npublic fun parseAndSortHeader(header: String?): List<HeaderValue> =\n    parseHeaderValue(header).sortedByDescending { it.quality }\n\n/**\n * Parse `Content-Type` header values and sort them by quality and asterisks quantity\n */\npublic fun parseAndSortContentTypeHeader(header: String?): List<HeaderValue> = parseHeaderValue(header).sortedWith(\n    compareByDescending<HeaderValue> { it.quality }.thenBy {\n        val contentType = ContentType.parse(it.value)\n        var asterisks = 0\n        if (contentType.contentType == \"*\") {\n            asterisks += 2\n        }\n        if (contentType.contentSubtype == \"*\") {\n            asterisks++\n        }\n        asterisks\n    }.thenByDescending { it.params.size }\n)\n\n/**\n * Parse header value respecting multi-values\n */\npublic fun parseHeaderValue(text: String?): List<HeaderValue> {\n    return parseHeaderValue(text, false)\n}\n\n/**\n * Parse header value respecting multi-values\n * @param parametersOnly if no header value itself, only parameters\n */\npublic fun parseHeaderValue(text: String?, parametersOnly: Boolean): List<HeaderValue> {\n    if (text == null) {\n        return emptyList()\n    }\n\n    var position = 0\n    val items = lazy(LazyThreadSafetyMode.NONE) { arrayListOf<HeaderValue>() }\n    while (position <= text.lastIndex) {\n        position = parseHeaderValueItem(text, position, items, parametersOnly)\n    }\n    return items.valueOrEmpty()\n}\n\n/**\n * Construct a list of [HeaderValueParam] from an iterable of pairs\n */\npublic fun Iterable<Pair<String, String>>.toHeaderParamsList(): List<HeaderValueParam> =\n    map { HeaderValueParam(it.first, it.second) }\n\nprivate fun <T> Lazy<List<T>>.valueOrEmpty(): List<T> = if (isInitialized()) value else emptyList()\nprivate fun String.subtrim(start: Int, end: Int): String {\n    return substring(start, end).trim()\n}\n\nprivate fun parseHeaderValueItem(\n    text: String,\n    start: Int,\n    items: Lazy<ArrayList<HeaderValue>>,\n    parametersOnly: Boolean\n): Int {\n    var position = start\n    val parameters = lazy(LazyThreadSafetyMode.NONE) { arrayListOf<HeaderValueParam>() }\n    var valueEnd: Int? = if (parametersOnly) position else null\n\n    while (position <= text.lastIndex) {\n        when (text[position]) {\n            ',' -> {\n                items.value.add(HeaderValue(text.subtrim(start, valueEnd ?: position), parameters.valueOrEmpty()))\n                return position + 1\n            }\n            ';' -> {\n                if (valueEnd == null) valueEnd = position\n                position = parseHeaderValueParameter(text, position + 1, parameters)\n            }\n            else -> {\n                position = if (parametersOnly) {\n                    parseHeaderValueParameter(text, position, parameters)\n                } else {\n                    position + 1\n                }\n            }\n        }\n    }\n\n    items.value.add(HeaderValue(text.subtrim(start, valueEnd ?: position), parameters.valueOrEmpty()))\n    return position\n}\n\nprivate fun parseHeaderValueParameter(text: String, start: Int, parameters: Lazy<ArrayList<HeaderValueParam>>): Int {\n    fun addParam(text: String, start: Int, end: Int, value: String) {\n        val name = text.subtrim(start, end)\n        if (name.isEmpty()) {\n            return\n        }\n\n        parameters.value.add(HeaderValueParam(name, value))\n    }\n\n    var position = start\n    while (position <= text.lastIndex) {\n        when (text[position]) {\n            '=' -> {\n                val (paramEnd, paramValue) = parseHeaderValueParameterValue(text, position + 1)\n                addParam(text, start, position, paramValue)\n                return paramEnd\n            }\n            ';', ',' -> {\n                addParam(text, start, position, \"\")\n                return position\n            }\n            else -> position++\n        }\n    }\n\n    addParam(text, start, position, \"\")\n    return position\n}\n\nprivate fun parseHeaderValueParameterValue(value: String, start: Int): Pair<Int, String> {\n    if (value.length == start) {\n        return start to \"\"\n    }\n\n    var position = start\n    if (value[start] == '\"') {\n        return parseHeaderValueParameterValueQuoted(value, position + 1)\n    }\n\n    while (position <= value.lastIndex) {\n        when (value[position]) {\n            ';', ',' -> return position to value.subtrim(start, position)\n            else -> position++\n        }\n    }\n    return position to value.subtrim(start, position)\n}\n\nprivate fun parseHeaderValueParameterValueQuoted(value: String, start: Int): Pair<Int, String> {\n    var position = start\n    val builder = StringBuilder()\n    loop@ while (position <= value.lastIndex) {\n        val currentChar = value[position]\n\n        when {\n            currentChar == '\"' && value.nextIsSemicolonOrEnd(position) -> {\n                return position + 1 to builder.toString()\n            }\n            currentChar == '\\\\' && position < value.lastIndex - 2 -> {\n                builder.append(value[position + 1])\n                position += 2\n                continue@loop\n            }\n        }\n\n        builder.append(currentChar)\n        position++\n    }\n\n    // The value is unquoted here\n    return position to '\"' + builder.toString()\n}\n\nprivate fun String.nextIsSemicolonOrEnd(start: Int): Boolean {\n    var position = start + 1\n    loop@ while (position < length && get(position) == ' ') {\n        position += 1\n    }\n\n    return position == length || get(position) == ';'\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http\n\nimport io.ktor.util.*\n\n@Suppress(\"unused\", \"KDocMissingDocumentation\", \"PublicApiImplicitType\", \"MayBeConstant\")\npublic object HttpHeaders {\n    // Permanently registered standard HTTP headers\n    // The list is taken from http://www.iana.org/assignments/message-headers/message-headers.xml#perm-headers\n\n    public val Accept: String = \"Accept\"\n    public val AcceptCharset: String = \"Accept-Charset\"\n    public val AcceptEncoding: String = \"Accept-Encoding\"\n    public val AcceptLanguage: String = \"Accept-Language\"\n    public val AcceptRanges: String = \"Accept-Ranges\"\n    public val Age: String = \"Age\"\n    public val Allow: String = \"Allow\"\n\n    // Application-Layer Protocol Negotiation, HTTP/2\n    public val ALPN: String = \"ALPN\"\n    public val AuthenticationInfo: String = \"Authentication-Info\"\n    public val Authorization: String = \"Authorization\"\n    public val CacheControl: String = \"Cache-Control\"\n    public val Connection: String = \"Connection\"\n    public val ContentDisposition: String = \"Content-Disposition\"\n    public val ContentEncoding: String = \"Content-Encoding\"\n    public val ContentLanguage: String = \"Content-Language\"\n    public val ContentLength: String = \"Content-Length\"\n    public val ContentLocation: String = \"Content-Location\"\n    public val ContentRange: String = \"Content-Range\"\n    public val ContentType: String = \"Content-Type\"\n    public val Cookie: String = \"Cookie\"\n\n    // WebDAV Search\n    public val DASL: String = \"DASL\"\n    public val Date: String = \"Date\"\n\n    // WebDAV\n    public val DAV: String = \"DAV\"\n    public val Depth: String = \"Depth\"\n\n    public val Destination: String = \"Destination\"\n    public val ETag: String = \"ETag\"\n    public val Expect: String = \"Expect\"\n    public val Expires: String = \"Expires\"\n    public val From: String = \"From\"\n    public val Forwarded: String = \"Forwarded\"\n    public val Host: String = \"Host\"\n    public val HTTP2Settings: String = \"HTTP2-Settings\"\n    public val If: String = \"If\"\n    public val IfMatch: String = \"If-Match\"\n    public val IfModifiedSince: String = \"If-Modified-Since\"\n    public val IfNoneMatch: String = \"If-None-Match\"\n    public val IfRange: String = \"If-Range\"\n    public val IfScheduleTagMatch: String = \"If-Schedule-Tag-Match\"\n    public val IfUnmodifiedSince: String = \"If-Unmodified-Since\"\n    public val LastModified: String = \"Last-Modified\"\n    public val Location: String = \"Location\"\n    public val LockToken: String = \"Lock-Token\"\n    public val Link: String = \"Link\"\n    public val MaxForwards: String = \"Max-Forwards\"\n    public val MIMEVersion: String = \"MIME-Version\"\n    public val OrderingType: String = \"Ordering-Type\"\n    public val Origin: String = \"Origin\"\n    public val Overwrite: String = \"Overwrite\"\n    public val Position: String = \"Position\"\n    public val Pragma: String = \"Pragma\"\n    public val Prefer: String = \"Prefer\"\n    public val PreferenceApplied: String = \"Preference-Applied\"\n    public val ProxyAuthenticate: String = \"Proxy-Authenticate\"\n    public val ProxyAuthenticationInfo: String = \"Proxy-Authentication-Info\"\n    public val ProxyAuthorization: String = \"Proxy-Authorization\"\n    public val PublicKeyPins: String = \"Public-Key-Pins\"\n    public val PublicKeyPinsReportOnly: String = \"Public-Key-Pins-Report-Only\"\n    public val Range: String = \"Range\"\n    public val Referrer: String = \"Referer\"\n    public val RetryAfter: String = \"Retry-After\"\n    public val ScheduleReply: String = \"Schedule-Reply\"\n    public val ScheduleTag: String = \"Schedule-Tag\"\n    public val SecWebSocketAccept: String = \"Sec-WebSocket-Accept\"\n    public val SecWebSocketExtensions: String = \"Sec-WebSocket-Extensions\"\n    public val SecWebSocketKey: String = \"Sec-WebSocket-Key\"\n    public val SecWebSocketProtocol: String = \"Sec-WebSocket-Protocol\"\n    public val SecWebSocketVersion: String = \"Sec-WebSocket-Version\"\n    public val Server: String = \"Server\"\n    public val SetCookie: String = \"Set-Cookie\"\n\n    // Atom Publishing\n    public val SLUG: String = \"SLUG\"\n    public val StrictTransportSecurity: String = \"Strict-Transport-Security\"\n    public val TE: String = \"TE\"\n    public val Timeout: String = \"Timeout\"\n    public val Trailer: String = \"Trailer\"\n    public val TransferEncoding: String = \"Transfer-Encoding\"\n    public val Upgrade: String = \"Upgrade\"\n    public val UserAgent: String = \"User-Agent\"\n    public val Vary: String = \"Vary\"\n    public val Via: String = \"Via\"\n    public val Warning: String = \"Warning\"\n    public val WWWAuthenticate: String = \"WWW-Authenticate\"\n\n    // CORS\n    public val AccessControlAllowOrigin: String = \"Access-Control-Allow-Origin\"\n    public val AccessControlAllowMethods: String = \"Access-Control-Allow-Methods\"\n    public val AccessControlAllowCredentials: String = \"Access-Control-Allow-Credentials\"\n    public val AccessControlAllowHeaders: String = \"Access-Control-Allow-Headers\"\n\n    public val AccessControlRequestMethod: String = \"Access-Control-Request-Method\"\n    public val AccessControlRequestHeaders: String = \"Access-Control-Request-Headers\"\n    public val AccessControlExposeHeaders: String = \"Access-Control-Expose-Headers\"\n    public val AccessControlMaxAge: String = \"Access-Control-Max-Age\"\n\n    // Unofficial de-facto headers\n    public val XHttpMethodOverride: String = \"X-Http-Method-Override\"\n    public val XForwardedHost: String = \"X-Forwarded-Host\"\n    public val XForwardedServer: String = \"X-Forwarded-Server\"\n    public val XForwardedProto: String = \"X-Forwarded-Proto\"\n    public val XForwardedFor: String = \"X-Forwarded-For\"\n\n    @PublicAPICandidate(\"2.0.0\")\n    internal val XForwardedPort: String = \"X-Forwarded-Port\"\n\n    public val XRequestId: String = \"X-Request-ID\"\n    public val XCorrelationId: String = \"X-Correlation-ID\"\n    public val XTotalCount: String = \"X-Total-Count\"\n\n    /**\n     * Check if [header] is unsafe. Header is unsafe if listed in [UnsafeHeadersList]\n     */\n    public fun isUnsafe(header: String): Boolean = UnsafeHeadersArray.any { it.equals(header, ignoreCase = true) }\n\n    private val UnsafeHeadersArray: Array<String> = arrayOf(ContentLength, ContentType, TransferEncoding, Upgrade)\n\n    @Deprecated(\"Use UnsafeHeadersList instead.\", replaceWith = ReplaceWith(\"HttpHeaders.UnsafeHeadersList\"))\n    public val UnsafeHeaders: Array<String>\n        get() = UnsafeHeadersArray.copyOf()\n\n    /**\n     * A list of header names that are not safe to use unless it is low-level engine implementation.\n     */\n    public val UnsafeHeadersList: List<String> = UnsafeHeadersArray.asList()\n\n    /**\n     * Validates header [name] throwing [IllegalHeaderNameException] when the name is not valid.\n     */\n    public fun checkHeaderName(name: String) {\n        name.forEachIndexed { index, ch ->\n            if (ch <= ' ' || isDelimiter(ch)) {\n                throw IllegalHeaderNameException(name, index)\n            }\n        }\n    }\n\n    /**\n     * Validates header [value] throwing [IllegalHeaderValueException] when the value is not valid.\n     */\n    public fun checkHeaderValue(value: String) {\n        value.forEachIndexed { index, ch ->\n            if (ch == ' ' || ch == '\\u0009') return@forEachIndexed\n            if (ch < ' ') {\n                throw IllegalHeaderValueException(value, index)\n            }\n        }\n    }\n}\n\n/**\n * Thrown when an attempt to set unsafe header detected. A header is unsafe if listed in [HttpHeaders.UnsafeHeadersList].\n */\npublic class UnsafeHeaderException(header: String) : IllegalArgumentException(\n    \"Header(s) $header are controlled by the engine and \" +\n        \"cannot be set explicitly\"\n)\n\n/**\n * Thrown when an illegal header name was used.\n * A header name should only consist from visible characters\n * without delimiters \"double quote\" and the following characters: `(),/:;<=>?@[\\]{}`.\n * @property headerName that was tried to use\n * @property position at which validation failed\n */\npublic class IllegalHeaderNameException(public val headerName: String, public val position: Int) :\n    IllegalArgumentException(\n        \"Header name '$headerName' contains illegal character '${headerName[position]}'\" +\n            \" (code ${(headerName[position].toInt() and 0xff)})\"\n    )\n\n/**\n * Thrown when an illegal header value was used.\n * A header value should only consist from visible characters, spaces and/or HTAB (0x09).\n * @property headerValue that was tried to use\n * @property position at which validation failed\n */\npublic class IllegalHeaderValueException(public val headerValue: String, public val position: Int) :\n    IllegalArgumentException(\n        \"Header value '$headerValue' contains illegal character '${headerValue[position]}'\" +\n            \" (code ${(headerValue[position].toInt() and 0xff)})\"\n    )\n\nprivate fun isDelimiter(ch: Char): Boolean = ch in \"\\\"(),/:;<=>?@[\\\\]{}\"\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\n@file:Suppress(\"unused\")\n\npackage io.ktor.http\n\nimport io.ktor.utils.io.charsets.*\n\n/**\n * Set `Content-Type` header.\n */\npublic fun HttpMessageBuilder.contentType(type: ContentType): Unit =\n    headers.set(HttpHeaders.ContentType, type.toString())\n\n@Deprecated(\n    \"Content-Length is controlled by underlying engine. Don't specify it explicitly.\",\n    level = DeprecationLevel.ERROR\n)\n@Suppress(\"KDocMissingDocumentation\", \"unused\", \"PublicApiImplicitType\", \"DeprecatedCallableAddReplaceWith\")\npublic fun HttpMessageBuilder.contentLength(length: Int): Unit =\n    headers.set(HttpHeaders.ContentLength, length.toString())\n\n@Deprecated(\"Use content with particular content type and charset instead\", level = DeprecationLevel.ERROR)\n@Suppress(\"KDocMissingDocumentation\", \"unused\", \"PublicApiImplicitType\", \"DeprecatedCallableAddReplaceWith\")\npublic fun HttpMessageBuilder.charset(charset: Charset): Unit? =\n    contentType()?.let { contentType(it.withCharset(charset)) }\n\n/**\n * Append `Max-Age` header value.\n */\npublic fun HttpMessageBuilder.maxAge(seconds: Int): Unit = headers.append(HttpHeaders.CacheControl, \"max-age=$seconds\")\n\n/**\n * Set `If-None-Match` header value.\n */\npublic fun HttpMessageBuilder.ifNoneMatch(value: String): Unit = headers.set(HttpHeaders.IfNoneMatch, value)\n\n/**\n * Set `User-Agent` header value.\n */\npublic fun HttpMessageBuilder.userAgent(content: String): Unit = headers.set(HttpHeaders.UserAgent, content)\n\n/**\n * Parse `Content-Type` header value.\n */\npublic fun HttpMessageBuilder.contentType(): ContentType? =\n    headers[HttpHeaders.ContentType]?.let { ContentType.parse(it) }\n\n/**\n * Parse charset from `Content-Type` header value.\n */\npublic fun HttpMessageBuilder.charset(): Charset? = contentType()?.charset()\n\n/**\n * Parse `E-Tag` header value.\n */\npublic fun HttpMessageBuilder.etag(): String? = headers[HttpHeaders.ETag]\n\n/**\n * Parse `Vary` header value.\n */\npublic fun HttpMessageBuilder.vary(): List<String>? = headers[HttpHeaders.Vary]?.split(\",\")?.map { it.trim() }\n\n/**\n * Parse `Content-Length` header value.\n */\npublic fun HttpMessageBuilder.contentLength(): Long? = headers[HttpHeaders.ContentLength]?.toLong()\n\n/**\n * Parse `Content-Type` header value.\n */\npublic fun HttpMessage.contentType(): ContentType? = headers[HttpHeaders.ContentType]?.let { ContentType.parse(it) }\n\n/**\n * Parse charset from `Content-Type` header value.\n */\npublic fun HttpMessage.charset(): Charset? = contentType()?.charset()\n\n/**\n * Parse `E-Tag` header value.\n */\npublic fun HttpMessage.etag(): String? = headers[HttpHeaders.ETag]\n\n/**\n * Parse `Vary` header value.\n */\npublic fun HttpMessage.vary(): List<String>? = headers[HttpHeaders.Vary]?.split(\",\")?.map { it.trim() }\n\n/**\n * Parse `Content-Length` header value.\n */\npublic fun HttpMessage.contentLength(): Long? = headers[HttpHeaders.ContentLength]?.toLong()\n\n/**\n * Parse `Set-Cookie` header value.\n */\npublic fun HttpMessage.setCookie(): List<Cookie> = headers.getAll(HttpHeaders.SetCookie)\n    ?.flatMap { it.splitSetCookieHeader() }\n    ?.map { parseServerSetCookieHeader(it) }\n    ?: emptyList()\n\n/**\n * Parse `Set-Cookie` header value.\n */\npublic fun HttpMessageBuilder.cookies(): List<Cookie> =\n    headers.getAll(HttpHeaders.SetCookie)?.map { parseServerSetCookieHeader(it) } ?: emptyList()\n\n/**\n * Parse `CacheControl` header.\n */\npublic fun HttpMessage.cacheControl(): List<HeaderValue> = headers[HttpHeaders.CacheControl]?.let {\n    parseHeaderValue(it)\n} ?: emptyList()\n\ninternal fun String.splitSetCookieHeader(): List<String> {\n    var comma = indexOf(',')\n\n    if (comma == -1) {\n        return listOf(this)\n    }\n\n    val result = mutableListOf<String>()\n    var current = 0\n\n    var equals = indexOf('=', comma)\n    var semicolon = indexOf(';', comma)\n    while (current < length && comma > 0) {\n        if (equals < comma) {\n            equals = indexOf('=', comma)\n        }\n\n        var nextComma = indexOf(',', comma + 1)\n        while (nextComma >= 0 && nextComma < equals) {\n            comma = nextComma\n            nextComma = indexOf(',', nextComma + 1)\n        }\n\n        if (semicolon < comma) {\n            semicolon = indexOf(';', comma)\n        }\n\n        // No more keys remaining.\n        if (equals < 0) {\n            result += substring(current)\n            return result\n        }\n\n        // No ';' between ',' and '=' => We're on a header border.\n        if (semicolon == -1 || semicolon > equals) {\n            result += substring(current, comma)\n            current = comma + 1\n            // Update comma index at the end of loop.\n        }\n\n        // ',' in value, skip it and find next.\n        comma = nextComma\n    }\n\n    // Add last chunk if no more ',' available.\n    if (current < length) {\n        result += substring(current)\n    }\n\n    return result\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http\n\n/**\n * Represents an HTTP protocol version.\n * @property name specifies name of the protocol, e.g. \"HTTP\".\n * @property major specifies protocol major version.\n * @property minor specifies protocol minor version.\n */\npublic data class HttpProtocolVersion(val name: String, val major: Int, val minor: Int) {\n    @Suppress(\"PublicApiImplicitType\")\n    public companion object {\n        /**\n         * HTTP/2.0 version.\n         */\n        public val HTTP_2_0: HttpProtocolVersion = HttpProtocolVersion(\"HTTP\", 2, 0)\n\n        /**\n         * HTTP/1.1 version.\n         */\n        public val HTTP_1_1: HttpProtocolVersion = HttpProtocolVersion(\"HTTP\", 1, 1)\n\n        /**\n         * HTTP/1.0 version.\n         */\n        public val HTTP_1_0: HttpProtocolVersion = HttpProtocolVersion(\"HTTP\", 1, 0)\n\n        /**\n         * SPDY/3.0 version.\n         */\n        public val SPDY_3: HttpProtocolVersion = HttpProtocolVersion(\"SPDY\", 3, 0)\n\n        /**\n         * QUIC/1.0 version.\n         */\n        public val QUIC: HttpProtocolVersion = HttpProtocolVersion(\"QUIC\", 1, 0)\n\n        /**\n         * Creates an instance of [HttpProtocolVersion] from the given parameters.\n         */\n        public fun fromValue(name: String, major: Int, minor: Int): HttpProtocolVersion = when {\n            name == \"HTTP\" && major == 1 && minor == 1 -> HTTP_1_1\n            name == \"HTTP\" && major == 2 && minor == 0 -> HTTP_2_0\n            else -> HttpProtocolVersion(name, major, minor)\n        }\n\n        /**\n         * Create an instance of [HttpProtocolVersion] from http string representation.\n         */\n        public fun parse(value: CharSequence): HttpProtocolVersion {\n            /**\n             * Format: protocol/major.minor\n             */\n            val (protocol, major, minor) = value.split(\"/\", \".\").also {\n                check(it.size == 3) {\n                    \"Failed to parse HttpProtocolVersion. Expected format: protocol/major.minor, but actual: $value\"\n                }\n            }\n\n            return fromValue(protocol, major.toInt(), minor.toInt())\n        }\n    }\n\n    override fun toString(): String = \"$name/$major.$minor\"\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http\n\n/**\n * Represents an HTTP status code and description.\n * @param value is a numeric code.\n * @param description is free form description of a status.\n */\n@Suppress(\"unused\")\npublic data class HttpStatusCode(val value: Int, val description: String) {\n    override fun toString(): String = \"$value $description\"\n\n    override fun equals(other: Any?): Boolean = other is HttpStatusCode && other.value == value\n\n    override fun hashCode(): Int = value.hashCode()\n\n    /**\n     * Returns a copy of `this` code with a description changed to [value].\n     */\n    public fun description(value: String): HttpStatusCode = copy(description = value)\n\n    @Suppress(\"KDocMissingDocumentation\", \"PublicApiImplicitType\")\n    public companion object {\n        // =============================================================================================================\n        // Disclaimer\n        // Adding a new status code here please remember [allStatusCodes] as well\n        //\n\n        public val Continue: HttpStatusCode = HttpStatusCode(100, \"Continue\")\n        public val SwitchingProtocols: HttpStatusCode = HttpStatusCode(101, \"Switching Protocols\")\n        public val Processing: HttpStatusCode = HttpStatusCode(102, \"Processing\")\n\n        public val OK: HttpStatusCode = HttpStatusCode(200, \"OK\")\n        public val Created: HttpStatusCode = HttpStatusCode(201, \"Created\")\n        public val Accepted: HttpStatusCode = HttpStatusCode(202, \"Accepted\")\n\n        public val NonAuthoritativeInformation: HttpStatusCode =\n            HttpStatusCode(203, \"Non-Authoritative Information\")\n\n        public val NoContent: HttpStatusCode = HttpStatusCode(204, \"No Content\")\n        public val ResetContent: HttpStatusCode = HttpStatusCode(205, \"Reset Content\")\n        public val PartialContent: HttpStatusCode = HttpStatusCode(206, \"Partial Content\")\n        public val MultiStatus: HttpStatusCode = HttpStatusCode(207, \"Multi-Status\")\n\n        public val MultipleChoices: HttpStatusCode = HttpStatusCode(300, \"Multiple Choices\")\n        public val MovedPermanently: HttpStatusCode = HttpStatusCode(301, \"Moved Permanently\")\n        public val Found: HttpStatusCode = HttpStatusCode(302, \"Found\")\n        public val SeeOther: HttpStatusCode = HttpStatusCode(303, \"See Other\")\n        public val NotModified: HttpStatusCode = HttpStatusCode(304, \"Not Modified\")\n        public val UseProxy: HttpStatusCode = HttpStatusCode(305, \"Use Proxy\")\n        public val SwitchProxy: HttpStatusCode = HttpStatusCode(306, \"Switch Proxy\")\n        public val TemporaryRedirect: HttpStatusCode = HttpStatusCode(307, \"Temporary Redirect\")\n        public val PermanentRedirect: HttpStatusCode = HttpStatusCode(308, \"Permanent Redirect\")\n\n        public val BadRequest: HttpStatusCode = HttpStatusCode(400, \"Bad Request\")\n        public val Unauthorized: HttpStatusCode = HttpStatusCode(401, \"Unauthorized\")\n        public val PaymentRequired: HttpStatusCode = HttpStatusCode(402, \"Payment Required\")\n        public val Forbidden: HttpStatusCode = HttpStatusCode(403, \"Forbidden\")\n        public val NotFound: HttpStatusCode = HttpStatusCode(404, \"Not Found\")\n        public val MethodNotAllowed: HttpStatusCode = HttpStatusCode(405, \"Method Not Allowed\")\n        public val NotAcceptable: HttpStatusCode = HttpStatusCode(406, \"Not Acceptable\")\n\n        public val ProxyAuthenticationRequired: HttpStatusCode =\n            HttpStatusCode(407, \"Proxy Authentication Required\")\n\n        public val RequestTimeout: HttpStatusCode = HttpStatusCode(408, \"Request Timeout\")\n        public val Conflict: HttpStatusCode = HttpStatusCode(409, \"Conflict\")\n        public val Gone: HttpStatusCode = HttpStatusCode(410, \"Gone\")\n        public val LengthRequired: HttpStatusCode = HttpStatusCode(411, \"Length Required\")\n        public val PreconditionFailed: HttpStatusCode = HttpStatusCode(412, \"Precondition Failed\")\n        public val PayloadTooLarge: HttpStatusCode = HttpStatusCode(413, \"Payload Too Large\")\n        public val RequestURITooLong: HttpStatusCode = HttpStatusCode(414, \"Request-URI Too Long\")\n\n        public val UnsupportedMediaType: HttpStatusCode = HttpStatusCode(415, \"Unsupported Media Type\")\n\n        public val RequestedRangeNotSatisfiable: HttpStatusCode =\n            HttpStatusCode(416, \"Requested Range Not Satisfiable\")\n\n        public val ExpectationFailed: HttpStatusCode = HttpStatusCode(417, \"Expectation Failed\")\n        public val UnprocessableEntity: HttpStatusCode = HttpStatusCode(422, \"Unprocessable Entity\")\n        public val Locked: HttpStatusCode = HttpStatusCode(423, \"Locked\")\n        public val FailedDependency: HttpStatusCode = HttpStatusCode(424, \"Failed Dependency\")\n        public val UpgradeRequired: HttpStatusCode = HttpStatusCode(426, \"Upgrade Required\")\n        public val TooManyRequests: HttpStatusCode = HttpStatusCode(429, \"Too Many Requests\")\n\n        public val RequestHeaderFieldTooLarge: HttpStatusCode =\n            HttpStatusCode(431, \"Request Header Fields Too Large\")\n\n        public val InternalServerError: HttpStatusCode = HttpStatusCode(500, \"Internal Server Error\")\n        public val NotImplemented: HttpStatusCode = HttpStatusCode(501, \"Not Implemented\")\n        public val BadGateway: HttpStatusCode = HttpStatusCode(502, \"Bad Gateway\")\n        public val ServiceUnavailable: HttpStatusCode = HttpStatusCode(503, \"Service Unavailable\")\n        public val GatewayTimeout: HttpStatusCode = HttpStatusCode(504, \"Gateway Timeout\")\n\n        public val VersionNotSupported: HttpStatusCode =\n            HttpStatusCode(505, \"HTTP Version Not Supported\")\n\n        public val VariantAlsoNegotiates: HttpStatusCode = HttpStatusCode(506, \"Variant Also Negotiates\")\n        public val InsufficientStorage: HttpStatusCode = HttpStatusCode(507, \"Insufficient Storage\")\n\n        /**\n         * All known status codes\n         */\n        public val allStatusCodes: List<HttpStatusCode> = allStatusCodes()\n\n        private val byValue: Array<HttpStatusCode?> = Array(1000) { idx ->\n            allStatusCodes.firstOrNull { it.value == idx }\n        }\n\n        /**\n         * Creates an instance of [HttpStatusCode] with the given numeric value.\n         */\n        public fun fromValue(value: Int): HttpStatusCode {\n            val knownStatus = if (value in 1 until 1000) byValue[value] else null\n            return knownStatus ?: HttpStatusCode(value, \"Unknown Status Code\")\n        }\n    }\n}\n\n@Suppress(\"UNUSED\", \"KDocMissingDocumentation\")\n@Deprecated(\n    \"Use ExpectationFailed instead\",\n    ReplaceWith(\"ExpectationFailed\", \"io.ktor.http.HttpStatusCode.Companion.ExpectationFailed\"),\n    level = DeprecationLevel.ERROR\n)\npublic inline val HttpStatusCode.Companion.ExceptionFailed: HttpStatusCode\n    get() = ExpectationFailed\n\ninternal fun allStatusCodes(): List<HttpStatusCode> = listOf(\n    HttpStatusCode.Continue,\n    HttpStatusCode.SwitchingProtocols,\n    HttpStatusCode.Processing,\n    HttpStatusCode.OK,\n    HttpStatusCode.Created,\n    HttpStatusCode.Accepted,\n    HttpStatusCode.NonAuthoritativeInformation,\n    HttpStatusCode.NoContent,\n    HttpStatusCode.ResetContent,\n    HttpStatusCode.PartialContent,\n    HttpStatusCode.MultiStatus,\n    HttpStatusCode.MultipleChoices,\n    HttpStatusCode.MovedPermanently,\n    HttpStatusCode.Found,\n    HttpStatusCode.SeeOther,\n    HttpStatusCode.NotModified,\n    HttpStatusCode.UseProxy,\n    HttpStatusCode.SwitchProxy,\n    HttpStatusCode.TemporaryRedirect,\n    HttpStatusCode.PermanentRedirect,\n    HttpStatusCode.BadRequest,\n    HttpStatusCode.Unauthorized,\n    HttpStatusCode.PaymentRequired,\n    HttpStatusCode.Forbidden,\n    HttpStatusCode.NotFound,\n    HttpStatusCode.MethodNotAllowed,\n    HttpStatusCode.NotAcceptable,\n    HttpStatusCode.ProxyAuthenticationRequired,\n    HttpStatusCode.RequestTimeout,\n    HttpStatusCode.Conflict,\n    HttpStatusCode.Gone,\n    HttpStatusCode.LengthRequired,\n    HttpStatusCode.PreconditionFailed,\n    HttpStatusCode.PayloadTooLarge,\n    HttpStatusCode.RequestURITooLong,\n    HttpStatusCode.UnsupportedMediaType,\n    HttpStatusCode.RequestedRangeNotSatisfiable,\n    HttpStatusCode.ExpectationFailed,\n    HttpStatusCode.UnprocessableEntity,\n    HttpStatusCode.Locked,\n    HttpStatusCode.FailedDependency,\n    HttpStatusCode.UpgradeRequired,\n    HttpStatusCode.TooManyRequests,\n    HttpStatusCode.RequestHeaderFieldTooLarge,\n    HttpStatusCode.InternalServerError,\n    HttpStatusCode.NotImplemented,\n    HttpStatusCode.BadGateway,\n    HttpStatusCode.ServiceUnavailable,\n    HttpStatusCode.GatewayTimeout,\n    HttpStatusCode.VersionNotSupported,\n    HttpStatusCode.VariantAlsoNegotiates,\n    HttpStatusCode.InsufficientStorage\n)\n\n/**\n * Checks if a given status code is a success code according to HTTP standards.\n *\n * Codes from 200 to 299 are considered to be successful.\n */\npublic fun HttpStatusCode.isSuccess(): Boolean = value in (200 until 300)\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http\n\nimport io.ktor.utils.io.charsets.*\n\n/**\n * Options for URL Encoding.\n * Keys and values are encoded only when [encodeKey] and [encodeValue] are `true` respectively.\n */\npublic enum class UrlEncodingOption(internal val encodeKey: Boolean, internal val encodeValue: Boolean) {\n    DEFAULT(true, true),\n    KEY_ONLY(true, false),\n    VALUE_ONLY(false, true),\n    NO_ENCODING(false, false)\n}\n\n/**\n * Parse URL query parameters. Shouldn't be used for urlencoded forms because of `+` character.\n */\npublic fun String.parseUrlEncodedParameters(defaultEncoding: Charset = Charsets.UTF_8, limit: Int = 1000): Parameters {\n    val parameters: List<Pair<String, String>> =\n        split(\"&\", limit = limit).map { it.substringBefore(\"=\") to it.substringAfter(\"=\", \"\") }\n    val encoding: String =\n        parameters.firstOrNull { it.first == \"_charset_\" }?.second ?: defaultEncoding.name\n\n    val charset = Charset.forName(encoding)\n    return Parameters.build {\n        parameters.forEach { (key, value) ->\n            append(\n                key.decodeURLQueryComponent(charset = charset),\n                value.decodeURLQueryComponent(charset = charset)\n            )\n        }\n    }\n}\n\n/**\n * Encode form parameters from a list of pairs\n */\n@Deprecated(\"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic fun List<Pair<String, String?>>.formUrlEncode(): String = formUrlEncode(UrlEncodingOption.DEFAULT)\n\n/**\n * Encode form parameters from a list of pairs\n */\npublic fun List<Pair<String, String?>>.formUrlEncode(option: UrlEncodingOption = UrlEncodingOption.DEFAULT): String =\n    buildString { formUrlEncodeTo(this, option) }\n\n/**\n * Encode form parameters from a list of pairs to the specified [out] appendable\n */\n@Suppress(\"unused\")\n@Deprecated(\"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic fun List<Pair<String, String?>>.formUrlEncodeTo(out: Appendable): Unit =\n    formUrlEncodeTo(out, UrlEncodingOption.DEFAULT)\n\n/**\n * Encode form parameters from a list of pairs to the specified [out] appendable by using [option]\n */\npublic fun List<Pair<String, String?>>.formUrlEncodeTo(\n    out: Appendable,\n    option: UrlEncodingOption = UrlEncodingOption.DEFAULT\n) {\n    joinTo(out, \"&\") {\n        val key = if (option.encodeKey) it.first.encodeURLParameter(spaceToPlus = true) else it.first\n        if (it.second == null) {\n            key\n        } else {\n            val nonNullValue = it.second.toString()\n            val value = if (option.encodeValue) nonNullValue.encodeURLParameterValue() else nonNullValue\n            \"$key=$value\"\n        }\n    }\n}\n\n/**\n * Encode form parameters\n */\npublic fun Parameters.formUrlEncode(): String = entries()\n    .flatMap { e -> e.value.map { e.key to it } }\n    .formUrlEncode(urlEncodingOption)\n\n/**\n * Encode form parameters to the specified [out] appendable\n */\npublic fun Parameters.formUrlEncodeTo(out: Appendable) {\n    entries().formUrlEncodeTo(out, urlEncodingOption)\n}\n\ninternal fun ParametersBuilder.formUrlEncodeTo(out: Appendable) {\n    entries().formUrlEncodeTo(out, urlEncodingOption)\n}\n\n@Suppress(\"unused\")\n@Deprecated(\"Binary compatibility\", level = DeprecationLevel.HIDDEN)\ninternal fun Set<Map.Entry<String, List<String>>>.formUrlEncodeTo(out: Appendable) =\n    formUrlEncodeTo(out, UrlEncodingOption.DEFAULT)\n\ninternal fun Set<Map.Entry<String, List<String>>>.formUrlEncodeTo(\n    out: Appendable,\n    option: UrlEncodingOption = UrlEncodingOption.DEFAULT\n) {\n    flatMap { (key, value) ->\n        if (value.isEmpty()) listOf(key to null) else value.map { key to it }\n    }.formUrlEncodeTo(out, option)\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http\n\nimport io.ktor.util.*\n\n/**\n * Represents HTTP parameters as a map from case-insensitive names to collection of [String] values\n */\npublic interface Parameters : StringValues {\n    /**\n     * Returns a [UrlEncodingOption] instance\n     */\n    public val urlEncodingOption: UrlEncodingOption\n        get() = UrlEncodingOption.DEFAULT\n\n    public companion object {\n        /**\n         * Empty [Parameters] instance\n         */\n        @Suppress(\"DEPRECATION_ERROR\")\n        public val Empty: Parameters = EmptyParameters\n\n        /**\n         * Builds a [Parameters] instance with the given [builder] function\n         * @param builder specifies a function to build a map\n         */\n        public inline fun build(builder: ParametersBuilder.() -> Unit): Parameters =\n            ParametersBuilder().apply(builder).build()\n    }\n}\n\n@Suppress(\"KDocMissingDocumentation\")\npublic class ParametersBuilder(\n    size: Int = 8,\n    public var urlEncodingOption: UrlEncodingOption = UrlEncodingOption.DEFAULT\n) : StringValuesBuilder(true, size) {\n\n    @Deprecated(\"Binary compatibility\", level = DeprecationLevel.HIDDEN)\n    public constructor(size: Int = 8) : this(size, UrlEncodingOption.DEFAULT)\n\n    override fun build(): Parameters {\n        require(!built) { \"ParametersBuilder can only build a single Parameters instance\" }\n        built = true\n        return ParametersImpl(values, urlEncodingOption)\n    }\n}\n\n@Suppress(\"KDocMissingDocumentation\")\n@Deprecated(\n    \"Empty parameters is internal\",\n    replaceWith = ReplaceWith(\"Parameters.Empty\"),\n    level = DeprecationLevel.ERROR\n)\npublic object EmptyParameters : Parameters {\n    override val caseInsensitiveName: Boolean get() = true\n    override fun getAll(name: String): List<String>? = null\n    override fun names(): Set<String> = emptySet()\n    override fun entries(): Set<Map.Entry<String, List<String>>> = emptySet()\n    override fun isEmpty(): Boolean = true\n    override fun toString(): String = \"Parameters ${entries()}\"\n\n    override fun equals(other: Any?): Boolean = other is Parameters && other.isEmpty()\n}\n\n/**\n * Returns an empty parameters instance\n */\npublic fun parametersOf(): Parameters = Parameters.Empty\n\n/**\n * Creates a parameters instance containing only single pair\n */\npublic fun parametersOf(name: String, value: String): Parameters = ParametersSingleImpl(name, listOf(value))\n\n/**\n * Creates a parameters instance containing only single pair of [name] with multiple [values]\n */\npublic fun parametersOf(name: String, values: List<String>): Parameters = ParametersSingleImpl(name, values)\n\n/**\n * Creates a parameters instance from the specified [pairs]\n */\npublic fun parametersOf(vararg pairs: Pair<String, List<String>>): Parameters = ParametersImpl(pairs.asList().toMap())\n\n@Suppress(\"KDocMissingDocumentation\")\n@InternalAPI\npublic class ParametersImpl(\n    values: Map<String, List<String>> = emptyMap(),\n    override val urlEncodingOption: UrlEncodingOption = UrlEncodingOption.DEFAULT\n) : Parameters, StringValuesImpl(true, values) {\n\n    @Deprecated(\"Binary compatibility\", level = DeprecationLevel.HIDDEN)\n    public constructor(values: Map<String, List<String>> = emptyMap()) : this(values, UrlEncodingOption.DEFAULT)\n\n    override fun toString(): String = \"Parameters ${entries()}\"\n}\n\n@Suppress(\"KDocMissingDocumentation\")\n@InternalAPI\npublic class ParametersSingleImpl(name: String, values: List<String>) : Parameters,\n    StringValuesSingleImpl(true, name, values) {\n    override fun toString(): String = \"Parameters ${entries()}\"\n}\n\n/**\n * Plus operator function that creates a new parameters instance from the original one concatenating with [other]\n */\npublic operator fun Parameters.plus(other: Parameters): Parameters = when {\n    caseInsensitiveName == other.caseInsensitiveName -> when {\n        this.isEmpty() -> other\n        other.isEmpty() -> this\n        else -> Parameters.build { appendAll(this@plus); appendAll(other) }\n    }\n    else -> {\n        throw IllegalArgumentException(\n            \"Cannot concatenate Parameters with case-sensitive and case-insensitive names\"\n        )\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http\n\n/**\n * Represents a `Link` header value as per RFC 5988\n */\npublic class LinkHeader(\n    uri: String,\n    params: List<HeaderValueParam>\n) : HeaderValueWithParameters(\"<$uri>\", params) {\n\n    @Suppress(\"unused\")\n    public constructor(uri: String, rel: String) : this(uri, listOf(HeaderValueParam(Parameters.Rel, rel)))\n\n    public constructor(uri: String, vararg rel: String) : this(\n        uri,\n        listOf(HeaderValueParam(Parameters.Rel, rel.joinToString(\" \")))\n    )\n\n    @Suppress(\"unused\")\n    public constructor(\n        uri: String,\n        rel: List<String>,\n        type: ContentType\n    ) : this(\n        uri,\n        listOf(\n            HeaderValueParam(Parameters.Rel, rel.joinToString(\" \")),\n            HeaderValueParam(Parameters.Type, type.toString())\n        )\n    )\n\n    /**\n     * Link URI part\n     */\n    public val uri: String\n        get() = content.removePrefix(\"<\").removeSuffix(\">\")\n\n    /**\n     * Known Link header parameters\n     */\n    @Suppress(\"unused\", \"KDocMissingDocumentation\", \"PublicApiImplicitType\")\n    public object Parameters {\n        public const val Rel: String = \"rel\"\n        public const val Anchor: String = \"anchor\"\n        public const val Rev: String = \"Rev\"\n        public const val HrefLang: String = \"hreflang\"\n        public const val Media: String = \"media\"\n        public const val Title: String = \"title\"\n        public const val Type: String = \"type\"\n    }\n\n    /**\n     * Known rel parameter values\n     */\n    @Suppress(\"unused\", \"KDocMissingDocumentation\", \"PublicApiImplicitType\")\n    public object Rel {\n        public const val Stylesheet: String = \"stylesheet\"\n\n        public const val Prefetch: String = \"prefetch\"\n        public const val DnsPrefetch: String = \"dns-prefetch\"\n        public const val PreConnect: String = \"preconnect\"\n        public const val PreLoad: String = \"preload\"\n        public const val PreRender: String = \"prerender\"\n        public const val Next: String = \"next\"\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http\n\nimport io.ktor.http.parsing.*\nimport io.ktor.http.parsing.regex.*\nimport kotlin.native.concurrent.*\n\n/**\n * Check if [host] is IPv4 or IPv6 address.\n */\npublic fun hostIsIp(host: String): Boolean = IP_PARSER.match(host)\n\n@SharedImmutable\nprivate val IPv4address = digits then \".\" then digits then \".\" then digits then \".\" then digits\n\n@SharedImmutable\nprivate val IPv6address = \"[\" then atLeastOne(hex or \":\") then \"]\"\n\n@SharedImmutable\nprivate val IP_PARSER = (IPv4address or IPv6address).buildRegexParser()\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http\n\n/**\n * Parse query string withing starting at the specified [startIndex] but up to [limit] pairs\n */\npublic fun parseQueryString(query: String, startIndex: Int = 0, limit: Int = 1000): Parameters {\n    return if (startIndex > query.lastIndex) {\n        Parameters.Empty\n    } else {\n        Parameters.build { parse(query, startIndex, limit) }\n    }\n}\n\n/**\n * Parse query string withing starting at the specified [startIndex] but up to [limit] pairs\n */\npublic fun parseQueryStringTo(\n    parametersBuilder: ParametersBuilder,\n    query: String,\n    startIndex: Int = 0,\n    limit: Int = 1000\n) {\n    if (startIndex > query.lastIndex) {\n        return\n    }\n    parametersBuilder.parse(query, startIndex, limit)\n}\n\nprivate fun ParametersBuilder.parse(query: String, startIndex: Int, limit: Int) {\n    var count = 0\n    var nameIndex = startIndex\n    var equalIndex = -1\n    for (index in startIndex..query.lastIndex) {\n        if (count == limit) {\n            return\n        }\n        when (query[index]) {\n            '&' -> {\n                appendParam(query, nameIndex, equalIndex, index)\n                nameIndex = index + 1\n                equalIndex = -1\n                count++\n            }\n            '=' -> {\n                if (equalIndex == -1) {\n                    equalIndex = index\n                }\n            }\n        }\n    }\n    if (count == limit) {\n        return\n    }\n    appendParam(query, nameIndex, equalIndex, query.length)\n}\n\nprivate fun ParametersBuilder.appendParam(query: String, nameIndex: Int, equalIndex: Int, endIndex: Int) {\n    if (equalIndex == -1) {\n        val spaceNameIndex = trimStart(nameIndex, endIndex, query)\n        val spaceEndIndex = trimEnd(spaceNameIndex, endIndex, query)\n\n        if (spaceEndIndex > spaceNameIndex) {\n            val name = when {\n                urlEncodingOption.encodeKey -> query.decodeURLQueryComponent(spaceNameIndex, spaceEndIndex)\n                else -> query.substring(spaceNameIndex, spaceEndIndex)\n            }\n            appendAll(name, emptyList())\n        }\n    } else {\n        val spaceNameIndex = trimStart(nameIndex, equalIndex, query)\n        val spaceEqualIndex = trimEnd(spaceNameIndex, equalIndex, query)\n        if (spaceEqualIndex > spaceNameIndex) {\n            val name = when {\n                urlEncodingOption.encodeKey -> query.decodeURLQueryComponent(spaceNameIndex, spaceEqualIndex)\n                else -> query.substring(spaceNameIndex, spaceEqualIndex)\n            }\n\n            val spaceValueIndex = trimStart(equalIndex + 1, endIndex, query)\n            val spaceEndIndex = trimEnd(spaceValueIndex, endIndex, query)\n            val value = when {\n                urlEncodingOption.encodeValue ->\n                    query.decodeURLQueryComponent(spaceValueIndex, spaceEndIndex, plusIsSpace = true)\n                else -> query.substring(spaceValueIndex, spaceEndIndex)\n            }\n            append(name, value)\n        }\n    }\n}\n\nprivate fun trimEnd(start: Int, end: Int, text: CharSequence): Int {\n    var spaceIndex = end\n    while (spaceIndex > start && text[spaceIndex - 1].isWhitespace()) spaceIndex--\n    return spaceIndex\n}\n\nprivate fun trimStart(start: Int, end: Int, query: CharSequence): Int {\n    var spaceIndex = start\n    while (spaceIndex < end && query[spaceIndex].isWhitespace()) spaceIndex++\n    return spaceIndex\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http\n\nimport io.ktor.util.*\nimport kotlin.math.*\n\n/**\n * Possible content range units: bytes and none\n * @property unitToken Lower-case unit name\n */\npublic enum class RangeUnits(public val unitToken: String) {\n    /**\n     * Range unit `bytes`\n     */\n    Bytes(\"bytes\"),\n\n    /**\n     * Range unit `none`\n     */\n    None(\"none\");\n}\n\n/**\n * Represents a `Range` header's particular range\n */\npublic sealed class ContentRange {\n    /**\n     * Represents a `Content-Range` bounded from both sides\n     * @property from index from which the content should begin\n     * @property to the last index the content should end at (inclusive)\n     */\n    public data class Bounded(val from: Long, val to: Long) : ContentRange() {\n        override fun toString(): String = \"$from-$to\"\n    }\n\n    /**\n     * Represents a `Content-Range` bounded at the beginning (skip first bytes, show tail)\n     * @property from index from which the content should begin\n     */\n    public data class TailFrom(val from: Long) : ContentRange() {\n        override fun toString(): String = \"$from-\"\n    }\n\n    /**\n     * Represents a `Content-Range` bounded by tail size\n     * @property lastCount number of tail bytes\n     */\n    public data class Suffix(val lastCount: Long) : ContentRange() {\n        override fun toString(): String = \"-$lastCount\"\n    }\n}\n\n/**\n * Parse `Range` header value\n */\npublic fun parseRangesSpecifier(rangeSpec: String): RangesSpecifier? {\n    try {\n        val (unit, allRangesString) = rangeSpec.chomp(\"=\") { return null }\n        val allRanges = allRangesString.split(',').map {\n            if (it.startsWith(\"-\")) {\n                ContentRange.Suffix(it.removePrefix(\"-\").toLong())\n            } else {\n                val (from, to) = it.chomp(\"-\") { \"\" to \"\" }\n                when {\n                    to.isNotEmpty() -> ContentRange.Bounded(from.toLong(), to.toLong())\n                    else -> ContentRange.TailFrom(from.toLong())\n                }\n            }\n        }\n\n        if (allRanges.isEmpty() || unit.isEmpty()) {\n            return null\n        }\n\n        val spec = RangesSpecifier(unit, allRanges)\n        return if (spec.isValid()) spec else null\n    } catch (e: Throwable) {\n        return null // according to the specification we should ignore syntactically incorrect headers\n    }\n}\n\ninternal fun List<ContentRange>.toLongRanges(contentLength: Long) = map {\n    when (it) {\n        is ContentRange.Bounded -> it.from..it.to.coerceAtMost(contentLength - 1)\n        is ContentRange.TailFrom -> it.from until contentLength\n        is ContentRange.Suffix -> (contentLength - it.lastCount).coerceAtLeast(0L) until contentLength\n    }\n}.filterNot { it.isEmpty() }\n\n// O (N^2 + N ln (N) + N)\ninternal fun List<LongRange>.mergeRangesKeepOrder(): List<LongRange> {\n    val sortedMerged = sortedBy { it.start }.fold(ArrayList<LongRange>(size)) { acc, range ->\n        when {\n            acc.isEmpty() -> acc.add(range)\n            acc.last().endInclusive < range.start - 1 -> acc.add(range)\n            else -> {\n                val last = acc.last()\n                acc[acc.lastIndex] = last.start..max(last.endInclusive, range.endInclusive)\n            }\n        }\n        acc\n    }\n    val result = arrayOfNulls<LongRange>(size)\n\n    for (range in sortedMerged) {\n        for (i in indices) {\n            if (this[i] in range) {\n                result[i] = range\n                break\n            }\n        }\n    }\n\n    return result.filterNotNull()\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http\n\n/**\n * Select default port value from protocol.\n */\npublic const val DEFAULT_PORT: Int = 0\n\n/**\n * A URL builder with all mutable components\n *\n * @property protocol URL protocol (scheme)\n * @property host name without port (domain)\n * @property port port number\n * @property user username part (optional)\n * @property password password part (optional)\n * @property encodedPath encoded URL path without query\n * @property parameters URL query parameters\n * @property fragment URL fragment (anchor name)\n * @property trailingQuery keep a trailing question character even if there are no query parameters\n */\npublic class URLBuilder(\n    public var protocol: URLProtocol = URLProtocol.HTTP,\n    public var host: String = \"localhost\",\n    public var port: Int = DEFAULT_PORT,\n    public var user: String? = null,\n    public var password: String? = null,\n    public var encodedPath: String = \"/\",\n    public val parameters: ParametersBuilder = ParametersBuilder(),\n    public var fragment: String = \"\",\n    public var trailingQuery: Boolean = false\n) {\n    init {\n        originHost?.let { takeFrom(it) }\n\n        if (encodedPath.isEmpty()) {\n            encodedPath = \"/\"\n        }\n    }\n\n    /**\n     * Encode [components] to [encodedPath]\n     */\n    public fun path(vararg components: String): URLBuilder {\n        path(components.asList())\n\n        return this\n    }\n\n    /**\n     * Encode [components] to [encodedPath]\n     */\n    public fun path(components: List<String>): URLBuilder {\n        encodedPath = components.joinToString(\"/\", prefix = \"/\") { it.encodeURLPath() }\n\n        return this\n    }\n\n    private fun <A : Appendable> appendTo(out: A): A {\n        out.append(protocol.name)\n\n        when (protocol.name) {\n            \"file\" -> {\n                out.appendFile(host, encodedPath)\n                return out\n            }\n            \"mailto\" -> {\n                out.appendMailto(userAndPassword, encodedPath)\n                return out\n            }\n        }\n\n        out.append(\"://\")\n        out.append(authority)\n\n        out.appendUrlFullPath(encodedPath, parameters, trailingQuery)\n\n        if (fragment.isNotEmpty()) {\n            out.append('#')\n            out.append(fragment.encodeURLQueryComponent())\n        }\n\n        return out\n    }\n\n    /**\n     * Build a URL string\n     */\n    // note: 256 should fit 99.5% of all urls according to http://www.supermind.org/blog/740/average-length-of-a-url-part-2\n    public fun buildString(): String = appendTo(StringBuilder(256)).toString()\n\n    /**\n     * Build a [Url] instance (everything is copied to a new instance)\n     */\n    public fun build(): Url = Url(\n        protocol, host, port, encodedPath, parameters.build(), fragment, user, password, trailingQuery\n    )\n\n    // Required to write external extension function\n    public companion object\n}\n\n/**\n * Hostname of current origin.\n *\n * It uses \"localhost\" for all platforms except js.\n */\ninternal expect val URLBuilder.Companion.originHost: String?\n\n/**\n * Create a copy of this builder. Modifications in a copy is not reflected in the original instance and vise-versa.\n */\npublic fun URLBuilder.clone(): URLBuilder = URLBuilder().takeFrom(this)\n\n/**\n * Represents an immutable URL\n *\n * @property protocol\n * @property host name without port (domain)\n * @property port the specified port or protocol default port\n * @property specifiedPort port number that was specified to override protocol's default\n * @property encodedPath encoded path without query string\n * @property parameters URL query parameters\n * @property fragment URL fragment (anchor name)\n * @property user username part of URL\n * @property password password part of URL\n * @property trailingQuery keep trailing question character even if there are no query parameters\n */\npublic data class Url(\n    val protocol: URLProtocol,\n    val host: String,\n    val specifiedPort: Int,\n    val encodedPath: String,\n    val parameters: Parameters,\n    val fragment: String,\n    val user: String?,\n    val password: String?,\n    val trailingQuery: Boolean\n) {\n    init {\n        require(\n            specifiedPort in 0..65535 ||\n                specifiedPort == DEFAULT_PORT\n        ) { \"port must be between 0 and 65535, or $DEFAULT_PORT if not set\" }\n    }\n\n    val port: Int get() = specifiedPort.takeUnless { it == DEFAULT_PORT } ?: protocol.defaultPort\n\n    override fun toString(): String = buildString {\n        append(protocol.name)\n\n        when (protocol.name) {\n            \"file\" -> {\n                appendFile(host, encodedPath)\n                return@buildString\n            }\n            \"mailto\" -> {\n                val userValue = user ?: error(\"User can't be empty.\")\n                appendMailto(userValue, host)\n                return@buildString\n            }\n        }\n\n        append(\"://\")\n        append(authority)\n        append(fullPath)\n\n        if (fragment.isNotEmpty()) {\n            append('#')\n            append(fragment)\n        }\n    }\n\n    public companion object\n}\n\nprivate fun Appendable.appendMailto(user: String, host: String) {\n    append(\":\")\n    append(user.encodeURLParameter())\n    append('@')\n    append(host)\n}\n\nprivate fun Appendable.appendFile(host: String, encodedPath: String) {\n    append(\"://\")\n    append(host)\n    append(encodedPath)\n}\n\ninternal val Url.userAndPassword: String\n    get() = buildString {\n        appendUserAndPassword(user, password)\n    }\n\ninternal val URLBuilder.userAndPassword: String\n    get() = buildString {\n        appendUserAndPassword(user, password)\n    }\n\nprivate fun StringBuilder.appendUserAndPassword(user: String?, password: String?) {\n    user ?: return\n    append(user.encodeURLParameter())\n\n    if (password != null) {\n        append(':')\n        append(password.encodeURLParameter())\n    }\n\n    append(\"@\")\n}\n\n/**\n * [Url] authority.\n */\npublic val Url.authority: String\n    get() = buildString {\n        append(userAndPassword)\n\n        if (specifiedPort == DEFAULT_PORT) {\n            append(host)\n        } else {\n            append(hostWithPort)\n        }\n    }\n\n/**\n * [URLBuilder] authority.\n */\npublic val URLBuilder.authority: String\n    get() = buildString {\n        append(userAndPassword)\n        append(host)\n\n        if (port != DEFAULT_PORT && port != protocol.defaultPort) {\n            append(\":\")\n            append(port.toString())\n        }\n    }\n\n/**\n * Adds [components] to current [encodedPath]\n */\npublic fun URLBuilder.pathComponents(components: List<String>): URLBuilder {\n    var paths = components\n        .map { part -> part.dropWhile { it == '/' }.dropLastWhile { it == '/' }.encodeURLQueryComponent() }\n        .filter { it.isNotEmpty() }\n        .joinToString(\"/\")\n\n    // make sure that there's a slash separator at the end of current path\n    if (!encodedPath.endsWith('/')) {\n        paths = \"/$paths\"\n    }\n    encodedPath += paths\n\n    return this\n}\n\n/**\n * Adds [components] to current [encodedPath]\n */\npublic fun URLBuilder.pathComponents(vararg components: String): URLBuilder {\n    return pathComponents(components.toList())\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http\n\nimport io.ktor.util.*\n\n/**\n * Take url parts from [urlString]\n * throws [URLParserException]\n */\npublic fun URLBuilder.takeFrom(urlString: String): URLBuilder {\n    return try {\n        takeFromUnsafe(urlString)\n    } catch (cause: Throwable) {\n        throw URLParserException(urlString, cause)\n    }\n}\n\n/**\n * Thrown when failed to parse URL\n */\npublic class URLParserException(urlString: String, cause: Throwable) : IllegalStateException(\n    \"Fail to parse url: $urlString\",\n    cause\n)\n\ninternal fun URLBuilder.takeFromUnsafe(urlString: String): URLBuilder {\n    var startIndex = urlString.indexOfFirst { !it.isWhitespace() }\n    val endIndex = urlString.indexOfLast { !it.isWhitespace() } + 1\n\n    val schemeLength = findScheme(urlString, startIndex, endIndex)\n    if (schemeLength > 0) {\n        val scheme = urlString.substring(startIndex, startIndex + schemeLength)\n\n        protocol = URLProtocol.createOrDefault(scheme)\n        startIndex += schemeLength + 1\n    }\n\n    // Auth & Host\n    val slashCount = count(urlString, startIndex, endIndex, '/')\n    startIndex += slashCount\n\n    if (protocol.name == \"file\") {\n        parseFile(urlString, startIndex, endIndex, slashCount)\n        return this\n    }\n\n    if (protocol.name == \"mailto\") {\n        require(slashCount == 0)\n        parseMailto(urlString, startIndex, endIndex)\n        return this\n    }\n\n    if (slashCount >= 2) {\n        loop@ while (true) {\n            val delimiter = urlString.indexOfAny(\"@/\\\\?#\".toCharArray(), startIndex).takeIf { it > 0 } ?: endIndex\n\n            if (delimiter < endIndex && urlString[delimiter] == '@') {\n                // user and password check\n                val passwordIndex = urlString.indexOfColonInHostPort(startIndex, delimiter)\n                if (passwordIndex != -1) {\n                    user = urlString.substring(startIndex, passwordIndex).decodeURLPart()\n                    password = urlString.substring(passwordIndex + 1, delimiter).decodeURLPart()\n                } else {\n                    user = urlString.substring(startIndex, delimiter).decodeURLPart()\n                }\n                startIndex = delimiter + 1\n            } else {\n                fillHost(urlString, startIndex, delimiter)\n                startIndex = delimiter\n                break@loop\n            }\n        }\n    }\n\n    // Path\n    if (startIndex >= endIndex) {\n        encodedPath = if (urlString[endIndex - 1] == '/') \"/\" else \"\"\n        return this\n    }\n\n    encodedPath = if (slashCount == 0) {\n        // Relative path\n        val lastSlashIndex = encodedPath.lastIndexOf('/')\n\n        if (lastSlashIndex != encodedPath.length - 1) {\n            // Current path does not end in slash, get rid of last path segment.\n            if (lastSlashIndex != -1) {\n                encodedPath.substring(0, lastSlashIndex + 1)\n            } else {\n                \"/\"\n            }\n        } else {\n            // keep the whole path\n            encodedPath\n        }\n    } else {\n        // overwrite the path\n        \"\"\n    }\n\n    val pathEnd = urlString.indexOfAny(\"?#\".toCharArray(), startIndex).takeIf { it > 0 } ?: endIndex\n    val rawPath = urlString.substring(startIndex, pathEnd)\n\n    encodedPath += rawPath.encodeURLPath()\n    startIndex = pathEnd\n\n    // Query\n    if (startIndex < endIndex && urlString[startIndex] == '?') {\n        startIndex = parseQuery(urlString, startIndex, endIndex)\n    }\n\n    // Fragment\n    parseFragment(urlString, startIndex, endIndex)\n    return this\n}\n\nprivate fun URLBuilder.parseFile(urlString: String, startIndex: Int, endIndex: Int, slashCount: Int) {\n    when (slashCount) {\n        2 -> {\n            val nextSlash = urlString.indexOf('/', startIndex)\n            if (nextSlash == -1 || nextSlash == endIndex) {\n                host = urlString.substring(startIndex, endIndex)\n                return\n            }\n\n            host = urlString.substring(startIndex, nextSlash)\n            encodedPath = urlString.substring(nextSlash, endIndex)\n        }\n        3 -> {\n            host = \"\"\n            encodedPath = \"/\" + urlString.substring(startIndex, endIndex)\n        }\n        else -> throw IllegalArgumentException(\"Invalid file url: $urlString\")\n    }\n}\n\nprivate fun URLBuilder.parseMailto(urlString: String, startIndex: Int, endIndex: Int) {\n    val delimiter = urlString.indexOf(\"@\", startIndex)\n    if (delimiter == -1) {\n        throw IllegalArgumentException(\"Invalid mailto url: $urlString, it should contain '@'.\")\n    }\n\n    user = urlString.substring(startIndex, delimiter).decodeURLPart()\n    host = urlString.substring(delimiter + 1, endIndex)\n}\n\nprivate fun URLBuilder.parseQuery(urlString: String, startIndex: Int, endIndex: Int): Int {\n    if (startIndex + 1 == endIndex) {\n        trailingQuery = true\n        return endIndex\n    }\n\n    val fragmentStart = urlString.indexOf('#', startIndex + 1).takeIf { it > 0 } ?: endIndex\n\n    parseQueryStringTo(parameters, urlString.substring(startIndex + 1, fragmentStart))\n\n    return fragmentStart\n}\n\nprivate fun URLBuilder.parseFragment(urlString: String, startIndex: Int, endIndex: Int) {\n    if (startIndex < endIndex && urlString[startIndex] == '#') {\n        fragment = urlString.substring(startIndex + 1, endIndex)\n    }\n}\n\nprivate fun URLBuilder.fillHost(urlString: String, startIndex: Int, endIndex: Int) {\n    val colonIndex = urlString.indexOfColonInHostPort(startIndex, endIndex).takeIf { it > 0 } ?: endIndex\n\n    host = urlString.substring(startIndex, colonIndex)\n\n    if (colonIndex + 1 < endIndex) {\n        port = urlString.substring(colonIndex + 1, endIndex).toInt()\n    } else {\n        port = DEFAULT_PORT\n    }\n}\n\n/**\n * Finds scheme in the given [urlString]. If there is no scheme found the function returns -1. If the scheme contains\n * illegal characters an [IllegalArgumentException] will be thrown. If the scheme is present and it doesn't contain\n * illegal characters the function returns the length of the scheme.\n */\nprivate fun findScheme(urlString: String, startIndex: Int, endIndex: Int): Int {\n    var current = startIndex\n\n    // Incorrect scheme position is used to identify the first position at which the character is not allowed in the\n    // scheme or the part of the scheme. This number is reported in the exception message.\n    var incorrectSchemePosition = -1\n    val firstChar = urlString[current]\n    if (firstChar !in 'a'..'z' && firstChar !in 'A'..'Z') {\n        incorrectSchemePosition = current\n    }\n\n    while (current < endIndex) {\n        val char = urlString[current]\n\n        // Character ':' means the end of the scheme and at this point the length of the scheme should be returned or\n        // the exception should be thrown in case the scheme contains illegal characters.\n        if (char == ':') {\n            if (incorrectSchemePosition != -1) {\n                throw IllegalArgumentException(\"Illegal character in scheme at position $incorrectSchemePosition\")\n            }\n\n            return current - startIndex\n        }\n\n        // If character '/' or '?' or '#' found this is not a scheme.\n        if (char == '/' || char == '?' || char == '#') return -1\n\n        // Update incorrect scheme position is current char is illegal.\n        if (incorrectSchemePosition == -1 &&\n            char !in 'a'..'z' &&\n            char !in 'A'..'Z' &&\n            char !in '0'..'9' &&\n            char != '.' &&\n            char != '+' &&\n            char != '-'\n        ) {\n            incorrectSchemePosition = current\n        }\n\n        ++current\n    }\n\n    return -1\n}\n\nprivate fun count(urlString: String, startIndex: Int, endIndex: Int, char: Char): Int {\n    var result = 0\n    while (startIndex + result < endIndex) {\n        if (urlString[startIndex + result] != char) break\n        result++\n    }\n\n    return result\n}\n\nprivate fun String.indexOfColonInHostPort(startIndex: Int, endIndex: Int): Int {\n    var skip = false\n    for (index in startIndex until endIndex) {\n        when (this[index]) {\n            '[' -> skip = true\n            ']' -> skip = false\n            ':' -> if (!skip) return index\n        }\n    }\n\n    return -1\n}\n\nprivate fun Char.isLetter(): Boolean = toLowerCase() in 'a'..'z'\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http\n\nimport io.ktor.util.*\n\n/**\n * Represents URL protocol\n * @property name of protocol (schema)\n * @property defaultPort default port for protocol or `-1` if not known\n */\npublic data class URLProtocol(val name: String, val defaultPort: Int) {\n    init {\n        require(name.all { it.isLowerCase() }) { \"All characters should be lower case\" }\n    }\n\n    @Suppress(\"PublicApiImplicitType\")\n    public companion object {\n        /**\n         * HTTP with port 80\n         */\n        public val HTTP: URLProtocol = URLProtocol(\"http\", 80)\n\n        /**\n         * secure HTTPS with port 443\n         */\n        public val HTTPS: URLProtocol = URLProtocol(\"https\", 443)\n\n        /**\n         * Web socket over HTTP on port 80\n         */\n        public val WS: URLProtocol = URLProtocol(\"ws\", 80)\n\n        /**\n         * Web socket over secure HTTPS on port 443\n         */\n        public val WSS: URLProtocol = URLProtocol(\"wss\", 443)\n\n        /**\n         * Socks proxy url protocol.\n         */\n        public val SOCKS: URLProtocol = URLProtocol(\"socks\", 1080)\n\n        /**\n         * Protocols by names map\n         */\n        public val byName: Map<String, URLProtocol> = listOf(HTTP, HTTPS, WS, WSS, SOCKS).associateBy { it.name }\n\n        /**\n         * Create an instance by [name] or use already existing instance\n         */\n        public fun createOrDefault(name: String): URLProtocol = name.toLowerCasePreservingASCIIRules().let {\n            byName[it] ?: URLProtocol(it, DEFAULT_PORT)\n        }\n    }\n}\n\n/**\n * Check if the protocol is websocket\n */\npublic fun URLProtocol.isWebsocket(): Boolean = name == \"ws\" || name == \"wss\"\n\n/**\n * Check if the protocol is secure\n */\npublic fun URLProtocol.isSecure(): Boolean = name == \"https\" || name == \"wss\"\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http\n\nimport io.ktor.util.*\n\n/**\n * Construct [Url] from [urlString].\n */\n@Suppress(\"FunctionName\")\npublic fun Url(urlString: String): Url = URLBuilder(urlString).build()\n\n/**\n * Construct [Url] from [builder] without building origin.\n */\n@Suppress(\"FunctionName\")\npublic fun Url(builder: URLBuilder): Url = URLBuilder().takeFrom(builder).build()\n\n/**\n * Construct [URLBuilder] from [urlString].\n */\n@Suppress(\"FunctionName\")\npublic fun URLBuilder(urlString: String): URLBuilder = URLBuilder().takeFrom(urlString)\n\n/**\n * Construct [URLBuilder] from [url].\n */\n@Suppress(\"FunctionName\")\npublic fun URLBuilder(url: Url): URLBuilder = URLBuilder().takeFrom(url)\n\n/**\n * Construct [URLBuilder] from [builder].\n */\n@Suppress(\"FunctionName\")\npublic fun URLBuilder(builder: URLBuilder): URLBuilder = URLBuilder().takeFrom(builder)\n\n/**\n * Take components from another [url] builder\n */\npublic fun URLBuilder.takeFrom(url: URLBuilder): URLBuilder {\n    protocol = url.protocol\n    host = url.host\n    port = url.port\n    encodedPath = url.encodedPath\n    user = url.user\n    password = url.password\n    parameters.appendAll(url.parameters)\n    parameters.urlEncodingOption = url.parameters.urlEncodingOption\n    fragment = url.fragment\n    trailingQuery = url.trailingQuery\n\n    return this\n}\n\n/**\n * Take components from another [url]\n */\npublic fun URLBuilder.takeFrom(url: Url): URLBuilder {\n    protocol = url.protocol\n    host = url.host\n    port = url.specifiedPort\n    encodedPath = url.encodedPath\n    user = url.user\n    password = url.password\n    parameters.appendAll(url.parameters)\n    parameters.urlEncodingOption = url.parameters.urlEncodingOption\n    fragment = url.fragment\n    trailingQuery = url.trailingQuery\n\n    return this\n}\n\n/**\n * Full encoded path with query string but without domain, port and schema\n */\npublic val Url.fullPath: String\n    get() = buildString { appendUrlFullPath(encodedPath, parameters, trailingQuery) }\n\n/**\n * Host:port pair, not normalized so port is always specified even if the port is schema's default\n */\npublic val Url.hostWithPort: String get() = \"$host:$port\"\n\ninternal fun Appendable.appendUrlFullPath(\n    encodedPath: String,\n    queryParameters: Parameters,\n    trailingQuery: Boolean\n) {\n    if (encodedPath.isNotBlank() && !encodedPath.startsWith(\"/\")) {\n        append('/')\n    }\n\n    append(encodedPath)\n\n    if (!queryParameters.isEmpty() || trailingQuery) {\n        append(\"?\")\n    }\n\n    queryParameters.formUrlEncodeTo(this)\n}\n\ninternal fun Appendable.appendUrlFullPath(\n    encodedPath: String,\n    queryParameters: ParametersBuilder,\n    trailingQuery: Boolean\n) {\n    if (encodedPath.isNotBlank() && !encodedPath.startsWith(\"/\")) {\n        append('/')\n    }\n\n    append(encodedPath)\n\n    if (!queryParameters.isEmpty() || trailingQuery) {\n        append(\"?\")\n    }\n\n    queryParameters.formUrlEncodeTo(this)\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http.auth\n\n/**\n * Describes how a header should be encoded.\n */\npublic enum class HeaderValueEncoding {\n    /**\n     * The header will be quoted only when required.\n     */\n    QUOTED_WHEN_REQUIRED,\n\n    /**\n     * The header will be quoted always.\n     */\n    QUOTED_ALWAYS,\n\n    /**\n     * The header will be URI-encoded as described in the RFC-3986:\n     *\n     * see https://tools.ietf.org/html/rfc3986#page-12\n     */\n    URI_ENCODE\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http.auth\n\nimport io.ktor.http.*\nimport io.ktor.http.parsing.*\nimport io.ktor.util.*\nimport io.ktor.utils.io.charsets.*\nimport kotlin.native.concurrent.*\n\n@ThreadLocal\nprivate val TOKEN_EXTRA = setOf('!', '#', '$', '%', '&', '\\'', '*', '+', '-', '.', '^', '_', '`', '|', '~')\n\n@ThreadLocal\nprivate val TOKEN68_EXTRA = setOf('-', '.', '_', '~', '+', '/')\n\n@ThreadLocal\nprivate val token68Pattern = \"[a-zA-Z0-9\\\\-._~+/]+=*\".toRegex()\n\n@ThreadLocal\nprivate val escapeRegex: Regex = \"\\\\\\\\.\".toRegex()\n\n/**\n * Parses an authorization header [headerValue] into a [HttpAuthHeader].\n * @return [HttpAuthHeader] or `null` if argument string is blank.\n * @throws [ParseException] on invalid header\n */\npublic fun parseAuthorizationHeader(headerValue: String): HttpAuthHeader? {\n    var index = 0\n    index = headerValue.skipSpaces(index)\n\n    var tokenStartIndex = index\n    while (index < headerValue.length && headerValue[index].isToken()) {\n        index++\n    }\n\n    // Auth scheme\n    val authScheme = headerValue.substring(tokenStartIndex until index)\n    index = headerValue.skipSpaces(index)\n    tokenStartIndex = index\n\n    if (authScheme.isBlank()) {\n        return null\n    }\n\n    if (headerValue.length == index) {\n        return HttpAuthHeader.Parameterized(authScheme, emptyList())\n    }\n\n    val token68 = matchToken68(headerValue, index)\n    if (token68 != null) {\n        return HttpAuthHeader.Single(authScheme, token68)\n    }\n\n    val parameters = matchParameters(headerValue, tokenStartIndex)\n    return HttpAuthHeader.Parameterized(authScheme, parameters)\n}\n\nprivate fun matchParameters(headerValue: String, startIndex: Int): Map<String, String> {\n    val result = mutableMapOf<String, String>()\n\n    var index = startIndex\n    while (index > 0 && index < headerValue.length) {\n        index = matchParameter(headerValue, index, result)\n        index = headerValue.skipDelimiter(index, ',')\n    }\n\n    return result\n}\n\nprivate fun matchParameter(headerValue: String, startIndex: Int, parameters: MutableMap<String, String>): Int {\n    val keyStart = headerValue.skipSpaces(startIndex)\n    var index = keyStart\n\n    // Take key\n    while (index < headerValue.length && headerValue[index].isToken()) {\n        index++\n    }\n\n    val key = headerValue.substring(keyStart until index)\n\n    // Take '='\n    index = headerValue.skipSpaces(index)\n    if (index >= headerValue.length || headerValue[index] != '=') {\n        throw ParseException(\"Expected `=` after parameter key '$key': $headerValue\")\n    }\n\n    index++\n    index = headerValue.skipSpaces(index)\n\n    // Take value\n    var quoted = false\n    var valueStart = index\n\n    if (headerValue[index] == '\"') {\n        quoted = true\n        index++\n        valueStart = index\n\n        var escaped = false\n        while (index < headerValue.length) {\n            if (headerValue[index] == '\"' && !escaped) break\n            escaped = !escaped && headerValue[index] == '\\\\'\n\n            index++\n        }\n\n        if (index == headerValue.length) {\n            throw ParseException(\"Expected closing quote'\\\"' in parameter: $headerValue \")\n        }\n    } else {\n        while (index < headerValue.length && headerValue[index] != ' ' && headerValue[index] != ',') {\n            index++\n        }\n    }\n\n    val value = headerValue.substring(valueStart until index)\n    parameters[key] = if (quoted) value.unescaped() else value\n\n    if (quoted) index++\n    return index\n}\n\nprivate fun matchToken68(headerValue: String, startIndex: Int): String? {\n    var index = startIndex\n\n    while (index < headerValue.length && headerValue[index].isToken68()) {\n        index++\n    }\n\n    while (index < headerValue.length && headerValue[index] == '=') {\n        index++\n    }\n\n    val onlySpaceRemaining = (index until headerValue.length).all { headerValue[it] == ' ' }\n    if (onlySpaceRemaining) {\n        return headerValue.substring(startIndex until index)\n    }\n\n    return null\n}\n\n/**\n * Describes an authentication header with a mandatory [authScheme] that usually is a standard [AuthScheme].\n *\n * This can be of type [HttpAuthHeader.Single] or [HttpAuthHeader.Parameterized].\n *\n * @property authScheme auth scheme, usually one of [AuthScheme]\n */\npublic sealed class HttpAuthHeader(public val authScheme: String) {\n    init {\n        if (!authScheme.matches(token68Pattern)) {\n            throw ParseException(\"Invalid authScheme value: it should be token, but instead it is $authScheme\")\n        }\n    }\n\n    /**\n     * Describes an authentication header that is represented by a single [blob].\n     * @property blob contains single token 68, should consist from digits, letters and one of the following: `-._~+/`\n     */\n    public class Single(authScheme: String, public val blob: String) : HttpAuthHeader(authScheme) {\n        init {\n            if (!blob.matches(token68Pattern)) {\n                throw ParseException(\"Invalid blob value: it should be token68, but instead it is $blob\")\n            }\n        }\n\n        override fun render(): String = \"$authScheme $blob\"\n        override fun render(encoding: HeaderValueEncoding): String = render()\n\n        override fun equals(other: Any?): Boolean {\n            if (other !is Single) return false\n            return other.authScheme.equals(authScheme, ignoreCase = true) &&\n                other.blob.equals(blob, ignoreCase = true)\n        }\n\n        override fun hashCode(): Int {\n            return Hash.combine(authScheme.toLowerCase(), blob.toLowerCase())\n        }\n    }\n\n    /**\n     * Describes a parameterized authentication header that is represented by a set of [parameters] encoded with [encoding].\n     * @property parameters a list of auth parameters\n     * @property encoding parameters encoding method, one of [HeaderValueEncoding]\n     */\n    public class Parameterized(\n        authScheme: String,\n        public val parameters: List<HeaderValueParam>,\n        public val encoding: HeaderValueEncoding = HeaderValueEncoding.QUOTED_WHEN_REQUIRED\n    ) : HttpAuthHeader(authScheme) {\n        public constructor(\n            authScheme: String,\n            parameters: Map<String, String>,\n            encoding: HeaderValueEncoding = HeaderValueEncoding.QUOTED_WHEN_REQUIRED\n        ) : this(authScheme, parameters.entries.map { HeaderValueParam(it.key, it.value) }, encoding)\n\n        init {\n            parameters.forEach {\n                if (!it.name.matches(token68Pattern)) {\n                    throw ParseException(\"parameter name should be a token but it is ${it.name}\")\n                }\n            }\n        }\n\n        /**\n         * Copies this [Parameterized] appending a new parameter [name] [value].\n         */\n        public fun withParameter(name: String, value: String): Parameterized =\n            Parameterized(authScheme, this.parameters + HeaderValueParam(name, value), encoding)\n\n        /**\n         * Copies this [Parameterized] replacing parameters with [name] assigning new [value]\n         * or appending if no such parameters found.\n         * If there were several pairs they will be reduced into a single pair\n         * at position of first occurrence discarding following pairs with this [name].\n         */\n        public fun withReplacedParameter(name: String, value: String): Parameterized {\n            val firstIndex = parameters.indexOfFirst { it.name == name }\n            if (firstIndex == -1) return withParameter(name, value)\n\n            var replaced = false\n            val newParameters = parameters.mapNotNull {\n                when {\n                    it.name != name -> it\n                    !replaced -> {\n                        replaced = true\n                        HeaderValueParam(name, value)\n                    }\n                    else -> null\n                }\n            }\n\n            return Parameterized(authScheme, newParameters, encoding)\n        }\n\n        override fun render(encoding: HeaderValueEncoding): String =\n            parameters.joinToString(\", \", prefix = \"$authScheme \") { \"${it.name}=${it.value.encode(encoding)}\" }\n\n        /**\n         * Tries to extract the first value of a parameter [name]. Returns null when not found.\n         */\n        public fun parameter(name: String): String? = parameters.firstOrNull { it.name == name }?.value\n\n        private fun String.encode(encoding: HeaderValueEncoding) = when (encoding) {\n            HeaderValueEncoding.QUOTED_WHEN_REQUIRED -> escapeIfNeeded()\n            HeaderValueEncoding.QUOTED_ALWAYS -> quote()\n            HeaderValueEncoding.URI_ENCODE -> encodeURLParameter()\n        }\n\n        override fun render(): String = render(encoding)\n\n        override fun equals(other: Any?): Boolean {\n            if (other !is Parameterized) return false\n            return other.authScheme.equals(authScheme, ignoreCase = true) &&\n                other.parameters == parameters\n        }\n\n        override fun hashCode(): Int {\n            return Hash.combine(authScheme.toLowerCase(), parameters)\n        }\n    }\n\n    /**\n     * Encodes the header with a specified [encoding].\n     */\n    public abstract fun render(encoding: HeaderValueEncoding): String\n\n    /**\n     * Encodes the header with the default [HeaderValueEncoding] for this header.\n     */\n    public abstract fun render(): String\n\n    /**\n     * Encodes the header with the default [HeaderValueEncoding] for this header.\n     */\n    override fun toString(): String {\n        return render()\n    }\n\n    public companion object {\n        /**\n         * Generates an [AuthScheme.Basic] challenge as a [HttpAuthHeader].\n         */\n        public fun basicAuthChallenge(realm: String, charset: Charset?): Parameterized = Parameterized(\n            AuthScheme.Basic,\n            LinkedHashMap<String, String>().apply {\n                put(Parameters.Realm, realm)\n                if (charset != null) {\n                    put(Parameters.Charset, charset.name)\n                }\n            }\n        )\n\n        /**\n         * Generates an [AuthScheme.Digest] challenge as a [HttpAuthHeader].\n         */\n        public fun digestAuthChallenge(\n            realm: String,\n            nonce: String = generateNonce(),\n            domain: List<String> = emptyList(),\n            opaque: String? = null,\n            stale: Boolean? = null,\n            algorithm: String = \"MD5\"\n        ): Parameterized = Parameterized(\n            AuthScheme.Digest,\n            linkedMapOf<String, String>().apply {\n                put(\"realm\", realm)\n                put(\"nonce\", nonce)\n                if (domain.isNotEmpty()) {\n                    put(\"domain\", domain.joinToString(\" \"))\n                }\n                if (opaque != null) {\n                    put(\"opaque\", opaque)\n                }\n                if (stale != null) {\n                    put(\"stale\", stale.toString())\n                }\n                put(\"algorithm\", algorithm)\n            },\n            HeaderValueEncoding.QUOTED_ALWAYS\n        )\n    }\n\n    /**\n     * Standard parameters for [Parameterized] [HttpAuthHeader].\n     */\n    @Suppress(\"KDocMissingDocumentation\", \"PublicApiImplicitType\")\n    public object Parameters {\n        public const val Realm: String = \"realm\"\n        public const val Charset: String = \"charset\"\n\n        public const val OAuthCallback: String = \"oauth_callback\"\n        public const val OAuthConsumerKey: String = \"oauth_consumer_key\"\n        public const val OAuthNonce: String = \"oauth_nonce\"\n        public const val OAuthToken: String = \"oauth_token\"\n        public const val OAuthTokenSecret: String = \"oauth_token_secret\"\n        public const val OAuthVerifier: String = \"oauth_verifier\"\n        public const val OAuthSignatureMethod: String = \"oauth_signature_method\"\n        public const val OAuthTimestamp: String = \"oauth_timestamp\"\n        public const val OAuthVersion: String = \"oauth_version\"\n        public const val OAuthSignature: String = \"oauth_signature\"\n        public const val OAuthCallbackConfirmed: String = \"oauth_callback_confirmed\"\n    }\n}\n\nprivate fun String.unescaped() = replace(escapeRegex) { it.value.takeLast(1) }\n\nprivate fun String.skipDelimiter(startIndex: Int, delimiter: Char): Int {\n    var index = skipSpaces(startIndex)\n\n    while (index < length && this[index] != delimiter) {\n        index++\n    }\n\n    if (index == length) return -1\n    index++\n\n    return skipSpaces(index)\n}\n\nprivate fun String.skipSpaces(startIndex: Int): Int {\n    var index = startIndex\n    while (index < length && (this[index] == ' ')) {\n        index++\n    }\n\n    return index\n}\n\nprivate fun Char.isToken68(): Boolean = (this in 'a'..'z') || (this in 'A'..'Z') || isDigit() || this in TOKEN68_EXTRA\n\nprivate fun Char.isToken(): Boolean = (this in 'a'..'z') || (this in 'A'..'Z') || isDigit() || this in TOKEN_EXTRA\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http.content\n\nimport io.ktor.http.*\nimport io.ktor.http.content.PartData.*\nimport io.ktor.utils.io.core.*\n\n/**\n * Represents a multipart/form-data entry. Could be a [FormItem] or [FileItem]\n * @property dispose to be invoked when this part is no longed needed\n * @property headers of this part, could be inaccurate on some engines\n */\npublic sealed class PartData(public val dispose: () -> Unit, public val headers: Headers) {\n    /**\n     * Represents a multipart form item\n     * @property value of this field\n     */\n    public class FormItem(public val value: String, dispose: () -> Unit, partHeaders: Headers) :\n        PartData(dispose, partHeaders)\n\n    /**\n     * Represents a file item\n     * @property provider of content bytes\n     */\n    public class FileItem(\n        public val provider: () -> Input,\n        dispose: () -> Unit,\n        partHeaders: Headers\n    ) : PartData(dispose, partHeaders) {\n        /**\n         * Original file name if present\n         */\n        public val originalFileName: String? = contentDisposition?.parameter(ContentDisposition.Parameters.FileName)\n    }\n\n    /**\n     * Represents a binary item\n     * @property provider of content bytes\n     */\n    public class BinaryItem(\n        public val provider: () -> Input,\n        dispose: () -> Unit,\n        partHeaders: Headers\n    ) : PartData(dispose, partHeaders)\n\n    /**\n     * Parsed `Content-Disposition` header or `null` if missing\n     */\n    public val contentDisposition: ContentDisposition? by lazy(LazyThreadSafetyMode.NONE) {\n        headers[HttpHeaders.ContentDisposition]?.let { ContentDisposition.parse(it) }\n    }\n\n    /**\n     * Parsed `Content-Type` header or `null` if missing\n     */\n    public val contentType: ContentType? by lazy(LazyThreadSafetyMode.NONE) {\n        headers[HttpHeaders.ContentType]?.let {\n            ContentType.parse(\n                it\n            )\n        }\n    }\n\n    /**\n     * Optional part name based on `Content-Disposition` header\n     */\n    public val name: String? get() = contentDisposition?.name\n\n    @Suppress(\"KDocMissingDocumentation\", \"unused\")\n    @Deprecated(\n        \"Use name property instead\",\n        ReplaceWith(\"name\"),\n        level = DeprecationLevel.ERROR\n    )\n    public val partName: String?\n        get() = name\n\n    @Suppress(\"KDocMissingDocumentation\", \"unused\")\n    @Deprecated(\n        \"Use headers property instead\",\n        ReplaceWith(\"headers\"),\n        level = DeprecationLevel.ERROR\n    )\n    public val partHeaders: Headers\n        get() = headers\n}\n\n/**\n * Represents a multipart data stream that could be received from a call\n */\npublic interface MultiPartData {\n    /**\n     * Reads next part data or `null` if end of multipart stream encountered\n     */\n    public suspend fun readPart(): PartData?\n\n    /**\n     * An empty multipart data stream\n     */\n    public object Empty : MultiPartData {\n        override suspend fun readPart(): PartData? {\n            return null\n        }\n    }\n}\n\n/**\n * Parse multipart data stream and invoke [partHandler] for each [PartData] encountered\n * @param partHandler to be invoked for every part item\n */\npublic suspend fun MultiPartData.forEachPart(partHandler: suspend (PartData) -> Unit) {\n    while (true) {\n        val part = readPart() ?: break\n        partHandler(part)\n    }\n}\n\n/**\n * Parse multipart data stream and put all parts into a list\n * @return a list of part data\n */\npublic suspend fun MultiPartData.readAllParts(): List<PartData> {\n    var part = readPart() ?: return emptyList()\n    val parts = ArrayList<PartData>()\n    parts.add(part)\n\n    do {\n        part = readPart() ?: break\n        parts.add(part)\n    } while (true)\n\n    return parts\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http.content\n\nimport io.ktor.http.*\nimport io.ktor.util.*\nimport io.ktor.utils.io.*\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\n/**\n * Information about the content to be sent to the peer, recognized by a client or server engine\n */\npublic sealed class OutgoingContent {\n    /**\n     * Specifies [ContentType] for this resource.\n     */\n    public open val contentType: ContentType? get() = null\n\n    /**\n     * Specifies content length in bytes for this resource.\n     *\n     * If null, the resources will be sent as `Transfer-Encoding: chunked`\n     */\n    public open val contentLength: Long? get() = null\n\n    /**\n     * Status code to set when sending this content\n     */\n    public open val status: HttpStatusCode?\n        get() = null\n\n    /**\n     * Headers to set when sending this content\n     */\n    public open val headers: Headers\n        get() = Headers.Empty\n\n    private var extensionProperties: Attributes? = null\n\n    /**\n     * Gets an extension property for this content\n     */\n    public open fun <T : Any> getProperty(key: AttributeKey<T>): T? = extensionProperties?.getOrNull(key)\n\n    /**\n     * Sets an extension property for this content\n     */\n    public open fun <T : Any> setProperty(key: AttributeKey<T>, value: T?) {\n        when {\n            value == null && extensionProperties == null -> return\n            value == null -> extensionProperties?.remove(key)\n            else -> (extensionProperties ?: Attributes()).also { extensionProperties = it }.put(key, value)\n        }\n    }\n\n    /**\n     * Variant of a [OutgoingContent] without a payload\n     */\n    public abstract class NoContent : OutgoingContent()\n\n    /**\n     * Variant of a [OutgoingContent] with payload read from [ByteReadChannel]\n     *\n     */\n    public abstract class ReadChannelContent : OutgoingContent() {\n        /**\n         * Provides [ByteReadChannel] for the content\n         */\n        public abstract fun readFrom(): ByteReadChannel\n\n        /**\n         * Provides [ByteReadChannel] for the given range of the content\n         */\n        public open fun readFrom(range: LongRange): ByteReadChannel = if (range.isEmpty()) {\n            ByteReadChannel.Empty\n        } else {\n            GlobalScope.writer(Dispatchers.Unconfined, autoFlush = true) {\n                val source = readFrom()\n                source.discard(range.start)\n                val limit = range.endInclusive - range.start + 1\n                source.copyTo(channel, limit)\n            }.channel\n        }\n    }\n\n    /**\n     * Variant of a [OutgoingContent] with payload written to [ByteWriteChannel]\n     */\n    public abstract class WriteChannelContent : OutgoingContent() {\n        /**\n         * Receives [channel] provided by the engine and writes all data to it\n         */\n        public abstract suspend fun writeTo(channel: ByteWriteChannel)\n    }\n\n    /**\n     * Variant of a [OutgoingContent] with payload represented as [ByteArray]\n     */\n    public abstract class ByteArrayContent : OutgoingContent() {\n        /**\n         * Provides [ByteArray] which engine will send to peer\n         */\n        public abstract fun bytes(): ByteArray\n    }\n\n    /**\n     * Variant of a [OutgoingContent] for upgrading an HTTP connection\n     */\n    public abstract class ProtocolUpgrade : OutgoingContent() {\n        final override val status: HttpStatusCode?\n            get() = HttpStatusCode.SwitchingProtocols\n\n        /**\n         * Upgrades an HTTP connection\n         * @param input is a [ByteReadChannel] for an upgraded connection\n         * @param output is a [ByteWriteChannel] for an upgraded connection\n         * @param engineContext is a [CoroutineContext] to execute non-blocking code, such as parsing or processing\n         * @param userContext is a [CoroutineContext] to execute user-provided callbacks or code potentially blocking\n         */\n        public abstract suspend fun upgrade(\n            input: ByteReadChannel,\n            output: ByteWriteChannel,\n            engineContext: CoroutineContext,\n            userContext: CoroutineContext\n        ): Job\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http.parsing\n\ninternal fun Grammar.printDebug(offset: Int = 0): Unit = when (this) {\n    is StringGrammar -> printlnWithOffset(offset, \"STRING[${Regex.escape(value)}]\")\n    is RawGrammar -> printlnWithOffset(offset, \"STRING[$value]\")\n    is NamedGrammar -> {\n        printlnWithOffset(offset, \"NAMED[$name]\")\n        grammar.printDebug(offset + 2)\n    }\n    is SequenceGrammar -> {\n        printlnWithOffset(offset, \"SEQUENCE\")\n        grammars.forEach { it.printDebug(offset + 2) }\n    }\n    is OrGrammar -> {\n        printlnWithOffset(offset, \"OR\")\n        grammars.forEach { it.printDebug(offset + 2) }\n    }\n    is MaybeGrammar -> {\n        printlnWithOffset(offset, \"MAYBE\")\n        grammar.printDebug(offset + 2)\n    }\n    is ManyGrammar -> {\n        printlnWithOffset(offset, \"MANY\")\n        grammar.printDebug(offset + 2)\n    }\n    is AtLeastOne -> {\n        printlnWithOffset(offset, \"MANY_NOT_EMPTY\")\n        grammar.printDebug(offset + 2)\n    }\n    is AnyOfGrammar -> printlnWithOffset(offset, \"ANY_OF[${Regex.escape(value)}]\")\n    is RangeGrammar -> printlnWithOffset(offset, \"RANGE[$from-$to]\")\n}\n\nprivate fun printlnWithOffset(offset: Int, node: Any) {\n    println(\"${\" \".repeat(offset)}${offset / 2}: $node\")\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http.parsing\n\ninternal class GrammarBuilder {\n    private val grammars = mutableListOf<Grammar>()\n\n    infix fun then(grammar: Grammar): GrammarBuilder {\n        grammars += grammar\n        return this\n    }\n\n    infix fun then(value: String): GrammarBuilder {\n        grammars += StringGrammar(value)\n        return this\n    }\n\n    operator fun (() -> Grammar).unaryPlus() {\n        grammars += this()\n    }\n\n    operator fun Grammar.unaryPlus() {\n        grammars += this\n    }\n\n    operator fun String.unaryPlus() {\n        grammars += StringGrammar(this)\n    }\n\n    public fun build(): Grammar = if (grammars.size == 1) grammars.first() else SequenceGrammar(grammars)\n}\n\ninternal fun grammar(block: GrammarBuilder.() -> Unit): Grammar = GrammarBuilder().apply(block).build()\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http.parsing\n\ninternal sealed class Grammar\n\ninternal interface ComplexGrammar {\n    val grammars: List<Grammar>\n}\n\ninternal interface SimpleGrammar {\n    val grammar: Grammar\n}\n\ninternal class StringGrammar(val value: String) : Grammar()\ninternal class AnyOfGrammar(val value: String) : Grammar()\ninternal class RangeGrammar(val from: Char, val to: Char) : Grammar()\ninternal class RawGrammar(val value: String) : Grammar()\n\ninternal class NamedGrammar(val name: String, val grammar: Grammar) : Grammar()\n\ninternal class MaybeGrammar(override val grammar: Grammar) : Grammar(), SimpleGrammar\ninternal class ManyGrammar(override val grammar: Grammar) : Grammar(), SimpleGrammar\ninternal class AtLeastOne(override val grammar: Grammar) : Grammar(), SimpleGrammar\n\ninternal class SequenceGrammar(sourceGrammars: List<Grammar>) : Grammar(), ComplexGrammar {\n    override val grammars: List<Grammar> = sourceGrammars.flatten<SequenceGrammar>()\n}\n\ninternal class OrGrammar(sourceGrammars: List<Grammar>) : Grammar(), ComplexGrammar {\n    override val grammars: List<Grammar> = sourceGrammars.flatten<OrGrammar>()\n}\n\ninternal fun maybe(grammar: Grammar): Grammar = MaybeGrammar(grammar)\ninternal fun maybe(value: String): Grammar = MaybeGrammar(StringGrammar(value))\ninternal fun maybe(block: GrammarBuilder.() -> Unit): () -> Grammar = { maybe(GrammarBuilder().apply(block).build()) }\n\ninternal infix fun String.then(grammar: Grammar): Grammar = StringGrammar(this) then grammar\ninternal infix fun Grammar.then(grammar: Grammar): Grammar = SequenceGrammar(listOf(this, grammar))\ninternal infix fun Grammar.then(value: String): Grammar = this then StringGrammar(value)\n\ninternal infix fun Grammar.or(grammar: Grammar): Grammar = OrGrammar(listOf(this, grammar))\ninternal infix fun Grammar.or(value: String): Grammar = this or StringGrammar(value)\ninternal infix fun String.or(grammar: Grammar): Grammar = StringGrammar(this) or grammar\n\ninternal fun many(grammar: Grammar): Grammar = ManyGrammar(grammar)\ninternal fun atLeastOne(grammar: Grammar): Grammar = AtLeastOne(grammar)\n\ninternal fun Grammar.named(name: String): Grammar = NamedGrammar(name, this)\n\ninternal fun anyOf(value: String): Grammar = AnyOfGrammar(value)\ninternal infix fun Char.to(other: Char): Grammar = RangeGrammar(this, other)\n\ninternal inline fun <reified T : ComplexGrammar> List<Grammar>.flatten(): List<Grammar> {\n    val result = mutableListOf<Grammar>()\n    forEach {\n        if (it is T) result += it.grammars else result += it\n    }\n    return result\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http.parsing.regex\n\nimport io.ktor.http.parsing.*\n\ninternal fun Grammar.buildRegexParser(): Parser {\n    val groups = mutableMapOf<String, MutableList<Int>>()\n    val expression = toRegex(groups).regex\n\n    return RegexParser(Regex(expression), groups)\n}\n\nprivate class GrammarRegex(\n    regexRaw: String,\n    groupsCountRaw: Int = 0,\n    group: Boolean = false\n) {\n    val regex = if (group) \"($regexRaw)\" else regexRaw\n    val groupsCount = if (group) groupsCountRaw + 1 else groupsCountRaw\n}\n\nprivate fun Grammar.toRegex(\n    groups: MutableMap<String, MutableList<Int>>,\n    offset: Int = 1,\n    shouldGroup: Boolean = false\n): GrammarRegex = when (this) {\n    is StringGrammar -> GrammarRegex(Regex.escape(value))\n    is RawGrammar -> GrammarRegex(value)\n    is NamedGrammar -> {\n        val nested = grammar.toRegex(groups, offset + 1)\n        groups.add(name, offset)\n        GrammarRegex(nested.regex, nested.groupsCount, group = true)\n    }\n    is ComplexGrammar -> {\n        val expression = StringBuilder()\n\n        var currentOffset = if (shouldGroup) offset + 1 else offset\n        grammars.forEachIndexed { index, grammar ->\n            val current = grammar.toRegex(groups, currentOffset, shouldGroup = true)\n\n            if (index != 0 && this is OrGrammar) expression.append(\"|\")\n            expression.append(current.regex)\n            currentOffset += current.groupsCount\n        }\n\n        val groupsCount = if (shouldGroup) currentOffset - offset - 1 else currentOffset - offset\n        GrammarRegex(expression.toString(), groupsCount, shouldGroup)\n    }\n    is SimpleGrammar -> {\n        val operator = when (this) {\n            is MaybeGrammar -> '?'\n            is ManyGrammar -> '*'\n            is AtLeastOne -> '+'\n            else -> error(\"Unsupported simple grammar element: $this\")\n        }\n\n        val nested = grammar.toRegex(groups, offset, shouldGroup = true)\n        GrammarRegex(\"${nested.regex}$operator\", nested.groupsCount)\n    }\n    is AnyOfGrammar -> GrammarRegex(\"[${Regex.escape(value)}]\")\n    is RangeGrammar -> GrammarRegex(\"[$from-$to]\")\n    else -> error(\"Unsupported grammar element: $this\")\n}\n\nprivate fun MutableMap<String, MutableList<Int>>.add(key: String, value: Int) {\n    if (!contains(key)) this[key] = mutableListOf()\n    this[key]!! += value\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http.websocket\n\nimport io.ktor.util.*\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.*\n\nprivate const val WEBSOCKET_SERVER_ACCEPT_TAIL = \"258EAFA5-E914-47DA-95CA-C5AB0DC85B11\"\n\n/**\n * Calculates `Sec-WebSocket-Accept` header value\n */\npublic fun websocketServerAccept(nonce: String): String =\n    sha1(\"${nonce.trim()}$WEBSOCKET_SERVER_ACCEPT_TAIL\".toByteArray(Charset.forName(\"ISO_8859_1\"))).encodeBase64()\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http\n\nimport io.ktor.util.*\nimport kotlinx.browser.*\n\n/**\n * Hostname of current origin.\n *\n * It uses \"localhost\" for all platforms except js.\n */\ninternal actual val URLBuilder.Companion.originHost: String?\n    get() = if (PlatformUtils.IS_BROWSER) {\n        window.location.origin\n    } else null\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http.auth\n\n/**\n * Contains the standard auth schemes.\n */\npublic object AuthScheme {\n    /**\n     * Basic Authentication described in the RFC-7617\n     *\n     * ```\n     * response = base64(\"$user:$password\")\n     * ```\n     *\n     * see https://tools.ietf.org/html/rfc7617)\n     */\n    public const val Basic: String = \"Basic\"\n\n    /**\n     * Digest Authentication described in the RFC-2069:\n     *\n     * ```\n     * HA1 = MD5(\"$username:$realm:$password\") // What's usually stored\n     * HA2 = MD5(\"$method:$digestURI\")\n     * response = MD5(\"$HA1:$nonce:$HA2\") // The client and the server sends and checks this.\n     * ```\n     *\n     * see https://tools.ietf.org/html/rfc2069\n     */\n    public const val Digest: String = \"Digest\"\n\n    /**\n     * Described in the RFC-4599:\n     *\n     * see https://www.ietf.org/rfc/rfc4559.txt\n     */\n    public const val Negotiate: String = \"Negotiate\"\n\n    /**\n     * OAuth Authentication described in the RFC-6749:\n     *\n     * see https://tools.ietf.org/html/rfc6749\n     */\n    public const val OAuth: String = \"OAuth\"\n\n    /**\n     * Bearer Authentication described in the RFC-6749:\n     *\n     * see https://tools.ietf.org/html/rfc6750\n     */\n    public const val Bearer: String = \"Bearer\"\n\n    @Suppress(\"KDocMissingDocumentation\", \"unused\")\n    @Deprecated(\"Compatibility\", level = DeprecationLevel.HIDDEN)\n    public fun getBasic(): String = Basic\n\n    @Suppress(\"KDocMissingDocumentation\", \"unused\")\n    @Deprecated(\"Compatibility\", level = DeprecationLevel.HIDDEN)\n    public fun getDigest(): String = Digest\n\n    @Suppress(\"KDocMissingDocumentation\", \"unused\")\n    @Deprecated(\"Compatibility\", level = DeprecationLevel.HIDDEN)\n    public fun getNegotiate(): String = Negotiate\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http.content\n\nimport io.ktor.http.*\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.*\n\n/**\n * Represents a text content that could be sent\n * @property text to be sent\n */\npublic class TextContent(\n    public val text: String,\n    override val contentType: ContentType,\n    override val status: HttpStatusCode? = null\n) : OutgoingContent.ByteArrayContent() {\n    private val bytes = text.toByteArray(contentType.charset() ?: Charsets.UTF_8)\n\n    override val contentLength: Long\n        get() = bytes.size.toLong()\n\n    override fun bytes(): ByteArray = bytes\n\n    override fun toString(): String = \"TextContent[$contentType] \\\"${text.take(30)}\\\"\"\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http\n\nimport io.ktor.util.*\nimport io.ktor.util.date.*\nimport kotlin.native.concurrent.*\n\n@SharedImmutable\nprivate val HTTP_DATE_FORMATS = listOf(\n    \"***, dd MMM YYYY hh:mm:ss zzz\",\n    \"****, dd-MMM-YYYY hh:mm:ss zzz\",\n    \"*** MMM d hh:mm:ss YYYY\",\n    \"***, dd-MMM-YYYY hh:mm:ss zzz\",\n    \"***, dd-MMM-YYYY hh-mm-ss zzz\",\n    \"***, dd MMM YYYY hh:mm:ss zzz\",\n    \"*** dd-MMM-YYYY hh:mm:ss zzz\",\n    \"*** dd MMM YYYY hh:mm:ss zzz\",\n    \"*** dd-MMM-YYYY hh-mm-ss zzz\",\n    \"***,dd-MMM-YYYY hh:mm:ss zzz\",\n    \"*** MMM d YYYY hh:mm:ss zzz\"\n)\n\n/**\n * Convert valid http date [String] to [GMTDate] trying various http date formats from [HTTP_DATE_FORMATS]\n *\n * Note that only GMT(UTC) date is valid http date.\n */\npublic fun String.fromHttpToGmtDate(): GMTDate = with(trim()) {\n    for (format in HTTP_DATE_FORMATS) {\n        try {\n            val parser = GMTDateParser(format)\n            return parser.parse(this@fromHttpToGmtDate)\n        } catch (_: InvalidDateStringException) {\n        }\n    }\n\n    error(\"Failed to parse date: $this\")\n}\n\n/**\n * Convert valid cookie date [String] to [GMTDate] trying first the RFC6265 standard, falling back on [fromHttpToGmtDate]\n *\n * @see [fromHttpToGmtDate]\n */\npublic fun String.fromCookieToGmtDate(): GMTDate = with(trim()) {\n    try {\n        val parser = CookieDateParser()\n        return parser.parse(this@with)\n    } catch (_: InvalidCookieDateException) {\n    }\n\n    return fromHttpToGmtDate()\n}\n\n/**\n * Convert [GMTDate] to valid http date [String]\n */\npublic fun GMTDate.toHttpDate(): String = buildString {\n    append(\"${dayOfWeek.value}, \")\n    append(\"${dayOfMonth.padZero(2)} \")\n    append(\"${month.value} \")\n    append(year.padZero(4))\n    append(\" ${hours.padZero(2)}:${minutes.padZero(2)}:${seconds.padZero(2)} \")\n    append(\"GMT\")\n}\n\nprivate fun Int.padZero(length: Int): String = toString().padStart(length, '0')\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http\n\nimport io.ktor.util.*\nimport io.ktor.utils.io.charsets.*\nimport kotlin.native.concurrent.*\n\n/**\n * Default [ContentType] for [extension]\n */\npublic fun ContentType.Companion.defaultForFileExtension(extension: String): ContentType =\n    ContentType.fromFileExtension(extension).selectDefault()\n\n/**\n * Default [ContentType] for file [path]\n */\npublic fun ContentType.Companion.defaultForFilePath(path: String): ContentType =\n    ContentType.fromFilePath(path).selectDefault()\n\n/**\n * Recommended content types by file [path]\n */\npublic fun ContentType.Companion.fromFilePath(path: String): List<ContentType> {\n    val slashIndex = path.lastIndexOfAny(\"/\\\\\".toCharArray())\n    val index = path.indexOf('.', startIndex = slashIndex + 1)\n    if (index == -1) {\n        return emptyList()\n    }\n    return fromFileExtension(path.substring(index + 1))\n}\n\n/**\n * Recommended content type by file name extension\n */\npublic fun ContentType.Companion.fromFileExtension(ext: String): List<ContentType> {\n    var current = ext.removePrefix(\".\").toLowerCasePreservingASCIIRules()\n    while (current.isNotEmpty()) {\n        val type = contentTypesByExtensions[current]\n        if (type != null) {\n            return type\n        }\n        current = current.substringAfter(\".\", \"\")\n    }\n\n    return emptyList()\n}\n\n/**\n * Recommended file name extensions for this content type\n */\npublic fun ContentType.fileExtensions(): List<String> = extensionsByContentType[this]\n    ?: extensionsByContentType[this.withoutParameters()]\n    ?: emptyList()\n\n@ThreadLocal\nprivate val contentTypesByExtensions: Map<String, List<ContentType>> by lazy {\n    caseInsensitiveMap<List<ContentType>>().apply { putAll(mimes.asSequence().groupByPairs()) }\n}\n\n@ThreadLocal\nprivate val extensionsByContentType: Map<ContentType, List<String>> by lazy {\n    mimes.asSequence().map { (first, second) -> second to first }.groupByPairs()\n}\n\ninternal fun List<ContentType>.selectDefault(): ContentType {\n    val contentType = firstOrNull() ?: ContentType.Application.OctetStream\n    return when {\n        contentType.contentType == \"text\" && contentType.charset() == null -> contentType.withCharset(Charsets.UTF_8)\n        else -> contentType\n    }\n}\n\ninternal fun <A, B> Sequence<Pair<A, B>>.groupByPairs() = groupBy { it.first }\n    .mapValues { e -> e.value.map { it.second } }\n\ninternal fun String.toContentType() = try {\n    ContentType.parse(this)\n} catch (e: Throwable) {\n    throw IllegalArgumentException(\"Failed to parse $this\", e)\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http\n\nimport io.ktor.util.*\nimport kotlin.native.concurrent.*\n\nprivate val rawMimes: String\n    get() = \"\"\"\n.123,application/vnd.lotus-1-2-3\n.3dmf,x-world/x-3dmf\n.3dml,text/vnd.in3d.3dml\n.3dm,x-world/x-3dmf\n.3g2,video/3gpp2\n.3gp,video/3gpp\n.7z,application/x-7z-compressed\n.aab,application/x-authorware-bin\n.aac,audio/aac\n.aam,application/x-authorware-map\n.a,application/octet-stream\n.aas,application/x-authorware-seg\n.abc,text/vnd.abc\n.abw,application/x-abiword\n.ac,application/pkix-attr-cert\n.acc,application/vnd.americandynamics.acc\n.ace,application/x-ace-compressed\n.acgi,text/html\n.acu,application/vnd.acucobol\n.adp,audio/adpcm\n.aep,application/vnd.audiograph\n.afl,video/animaflex\n.afp,application/vnd.ibm.modcap\n.ahead,application/vnd.ahead.space\n.ai,application/postscript\n.aif,audio/aiff\n.aifc,audio/aiff\n.aiff,audio/aiff\n.aim,application/x-aim\n.aip,text/x-audiosoft-intra\n.air,application/vnd.adobe.air-application-installer-package+zip\n.ait,application/vnd.dvb.ait\n.ami,application/vnd.amiga.ami\n.ani,application/x-navi-animation\n.aos,application/x-nokia-9000-communicator-add-on-software\n.apk,application/vnd.android.package-archive\n.application,application/x-ms-application\n,application/pgp-encrypted\n.apr,application/vnd.lotus-approach\n.aps,application/mime\n.arc,application/octet-stream\n.arj,application/arj\n.arj,application/octet-stream\n.art,image/x-jg\n.asf,video/x-ms-asf\n.asm,text/x-asm\n.aso,application/vnd.accpac.simply.aso\n.asp,text/asp\n.asx,application/x-mplayer2\n.asx,video/x-ms-asf\n.asx,video/x-ms-asf-plugin\n.atc,application/vnd.acucorp\n.atomcat,application/atomcat+xml\n.atomsvc,application/atomsvc+xml\n.atom,application/atom+xml\n.atx,application/vnd.antix.game-component\n.au,audio/basic\n.au,audio/x-au\n.avi,video/avi\n.avi,video/msvideo\n.avi,video/x-msvideo\n.avs,video/avs-video\n.aw,application/applixware\n.azf,application/vnd.airzip.filesecure.azf\n.azs,application/vnd.airzip.filesecure.azs\n.azw,application/vnd.amazon.ebook\n.bcpio,application/x-bcpio\n.bdf,application/x-font-bdf\n.bdm,application/vnd.syncml.dm+wbxml\n.bed,application/vnd.realvnc.bed\n.bh2,application/vnd.fujitsu.oasysprs\n.bin,application/macbinary\n.bin,application/mac-binary\n.bin,application/octet-stream\n.bin,application/x-binary\n.bin,application/x-macbinary\n.bmi,application/vnd.bmi\n.bm,image/bmp\n.bmp,image/bmp\n.bmp,image/x-windows-bmp\n.boo,application/book\n.book,application/book\n.box,application/vnd.previewsystems.box\n.boz,application/x-bzip2\n.bsh,application/x-bsh\n.btif,image/prs.btif\n.bz2,application/x-bzip2\n.bz,application/x-bzip\n.c11amc,application/vnd.cluetrust.cartomobile-config\n.c11amz,application/vnd.cluetrust.cartomobile-config-pkg\n.c4g,application/vnd.clonk.c4group\n.cab,application/vnd.ms-cab-compressed\n.car,application/vnd.curl.car\n.cat,application/vnd.ms-pki.seccat\n.ccad,application/clariscad\n.cco,application/x-cocoa\n.cc,text/plain\n.cc,text/x-c\n.ccxml,application/ccxml+xml,\n.cdbcmsg,application/vnd.contact.cmsg\n.cdf,application/cdf\n.cdf,application/x-cdf\n.cdf,application/x-netcdf\n.cdkey,application/vnd.mediastation.cdkey\n.cdmia,application/cdmi-capability\n.cdmic,application/cdmi-container\n.cdmid,application/cdmi-domain\n.cdmio,application/cdmi-object\n.cdmiq,application/cdmi-queue\n.cdx,chemical/x-cdx\n.cdxml,application/vnd.chemdraw+xml\n.cdy,application/vnd.cinderella\n.cer,application/pkix-cert\n.cgm,image/cgm\n.cha,application/x-chat\n.chat,application/x-chat\n.chm,application/vnd.ms-htmlhelp\n.chrt,application/vnd.kde.kchart\n.cif,chemical/x-cif\n.cii,application/vnd.anser-web-certificate-issue-initiation\n.cil,application/vnd.ms-artgalry\n.cla,application/vnd.claymore\n.class,application/java\n.class,application/java-byte-code\n.class,application/java-vm\n.class,application/x-java-class\n.clkk,application/vnd.crick.clicker.keyboard\n.clkp,application/vnd.crick.clicker.palette\n.clkt,application/vnd.crick.clicker.template\n.clkw,application/vnd.crick.clicker.wordbank\n.clkx,application/vnd.crick.clicker\n.clp,application/x-msclip\n.cmc,application/vnd.cosmocaller\n.cmdf,chemical/x-cmdf\n.cml,chemical/x-cml\n.cmp,application/vnd.yellowriver-custom-menu\n.cmx,image/x-cmx\n.cod,application/vnd.rim.cod\n.com,application/octet-stream\n.com,text/plain\n.conf,text/plain\n.cpio,application/x-cpio\n.cpp,text/x-c\n.cpt,application/mac-compactpro\n.cpt,application/x-compactpro\n.cpt,application/x-cpt\n.crd,application/x-mscardfile\n.crl,application/pkcs-crl\n.crl,application/pkix-crl\n.crt,application/pkix-cert\n.crt,application/x-x509-ca-cert\n.crt,application/x-x509-user-cert\n.cryptonote,application/vnd.rig.cryptonote\n.csh,application/x-csh\n.csh,text/x-script.csh\n.csml,chemical/x-csml\n.csp,application/vnd.commonspace\n.css,text/css\n.csv,text/csv\n.c,text/plain\n.c++,text/plain\n.c,text/x-c\n.cu,application/cu-seeme\n.curl,text/vnd.curl\n.cww,application/prs.cww\n.cxx,text/plain\n.dat,binary/octet-stream\n.dae,model/vnd.collada+xml\n.daf,application/vnd.mobius.daf\n.davmount,application/davmount+xml\n.dcr,application/x-director\n.dcurl,text/vnd.curl.dcurl\n.dd2,application/vnd.oma.dd2+xml\n.ddd,application/vnd.fujixerox.ddd\n.deb,application/x-debian-package\n.deepv,application/x-deepv\n.def,text/plain\n.der,application/x-x509-ca-cert\n.dfac,application/vnd.dreamfactory\n.dif,video/x-dv\n.dir,application/x-director\n.dis,application/vnd.mobius.dis\n.djvu,image/vnd.djvu\n.dl,video/dl\n.dl,video/x-dl\n.dna,application/vnd.dna\n.doc,application/msword\n.docm,application/vnd.ms-word.document.macroenabled.12\n.docx,application/vnd.openxmlformats-officedocument.wordprocessingml.document\n.dot,application/msword\n.dotm,application/vnd.ms-word.template.macroenabled.12\n.dotx,application/vnd.openxmlformats-officedocument.wordprocessingml.template\n.dp,application/commonground\n.dp,application/vnd.osgi.dp\n.dpg,application/vnd.dpgraph\n.dra,audio/vnd.dra\n.drw,application/drafting\n.dsc,text/prs.lines.tag\n.dssc,application/dssc+der\n.dtb,application/x-dtbook+xml\n.dtd,application/xml-dtd\n.dts,audio/vnd.dts\n.dtshd,audio/vnd.dts.hd\n.dump,application/octet-stream\n.dvi,application/x-dvi\n.dv,video/x-dv\n.dwf,model/vnd.dwf\n.dwg,application/acad\n.dwg,image/vnd.dwg\n.dwg,image/x-dwg\n.dxf,application/dxf\n.dxf,image/vnd.dwg\n.dxf,image/vnd.dxf\n.dxf,image/x-dwg\n.dxp,application/vnd.spotfire.dxp\n.dxr,application/x-director\n.ecelp4800,audio/vnd.nuera.ecelp4800\n.ecelp7470,audio/vnd.nuera.ecelp7470\n.ecelp9600,audio/vnd.nuera.ecelp9600\n.edm,application/vnd.novadigm.edm\n.edx,application/vnd.novadigm.edx\n.efif,application/vnd.picsel\n.ei6,application/vnd.pg.osasli\n.elc,application/x-elc\n.el,text/x-script.elisp\n.eml,message/rfc822\n.emma,application/emma+xml\n.env,application/x-envoy\n.eol,audio/vnd.digital-winds\n.eot,application/vnd.ms-fontobject\n.eps,application/postscript\n.epub,application/epub+zip\n.es3,application/vnd.eszigno3+xml\n.es,application/ecmascript\n.es,application/x-esrehber\n.esf,application/vnd.epson.esf\n.etx,text/x-setext\n.evy,application/envoy\n.evy,application/x-envoy\n.exe,application/octet-stream\n.exe,application/x-msdownload\n.exi,application/exi\n.ext,application/vnd.novadigm.ext\n.ez2,application/vnd.ezpix-album\n.ez3,application/vnd.ezpix-package\n.f4v,video/x-f4v\n.f77,text/x-fortran\n.f90,text/plain\n.f90,text/x-fortran\n.fbs,image/vnd.fastbidsheet\n.fcs,application/vnd.isac.fcs\n.fdf,application/vnd.fdf\n.fe_launch,application/vnd.denovo.fcselayout-link\n.fg5,application/vnd.fujitsu.oasysgp\n.fh,image/x-freehand\n.fif,application/fractals\n.fif,image/fif\n.fig,application/x-xfig\n.fli,video/fli\n.fli,video/x-fli\n.flo,application/vnd.micrografx.flo\n.flo,image/florian\n.flv,video/x-flv\n.flw,application/vnd.kde.kivio\n.flx,text/vnd.fmi.flexstor\n.fly,text/vnd.fly\n.fm,application/vnd.framemaker\n.fmf,video/x-atomic3d-feature\n.fnc,application/vnd.frogans.fnc\n.for,text/plain\n.for,text/x-fortran\n.fpx,image/vnd.fpx\n.fpx,image/vnd.net-fpx\n.frl,application/freeloader\n.fsc,application/vnd.fsc.weblaunch\n.fst,image/vnd.fst\n.ftc,application/vnd.fluxtime.clip\n.f,text/plain\n.f,text/x-fortran\n.fti,application/vnd.anser-web-funds-transfer-initiation\n.funk,audio/make\n.fvt,video/vnd.fvt\n.fxp,application/vnd.adobe.fxp\n.fzs,application/vnd.fuzzysheet\n.g2w,application/vnd.geoplan\n.g3,image/g3fax\n.g3w,application/vnd.geospace\n.gac,application/vnd.groove-account\n.gdl,model/vnd.gdl\n.geo,application/vnd.dynageo\n.gex,application/vnd.geometry-explorer\n.ggb,application/vnd.geogebra.file\n.ggt,application/vnd.geogebra.tool\n.ghf,application/vnd.groove-help\n.gif,image/gif\n.gim,application/vnd.groove-identity-message\n.gl,video/gl\n.gl,video/x-gl\n.gmx,application/vnd.gmx\n.gnumeric,application/x-gnumeric\n.gph,application/vnd.flographit\n.gqf,application/vnd.grafeq\n.gram,application/srgs\n.grv,application/vnd.groove-injector\n.grxml,application/srgs+xml\n.gsd,audio/x-gsm\n.gsf,application/x-font-ghostscript\n.gsm,audio/x-gsm\n.gsp,application/x-gsp\n.gss,application/x-gss\n.gtar,application/x-gtar\n.g,text/plain\n.gtm,application/vnd.groove-tool-message\n.gtw,model/vnd.gtw\n.gv,text/vnd.graphviz\n.gxt,application/vnd.geonext\n.gz,application/x-compressed\n.gz,application/x-gzip\n.gzip,application/x-gzip\n.gzip,multipart/x-gzip\n.h261,video/h261\n.h263,video/h263\n.h264,video/h264\n.hal,application/vnd.hal+xml\n.hbci,application/vnd.hbci\n.hdf,application/x-hdf\n.help,application/x-helpfile\n.hgl,application/vnd.hp-hpgl\n.hh,text/plain\n.hh,text/x-h\n.hlb,text/x-script\n.hlp,application/hlp\n.hlp,application/winhlp\n.hlp,application/x-helpfile\n.hlp,application/x-winhelp\n.hpg,application/vnd.hp-hpgl\n.hpgl,application/vnd.hp-hpgl\n.hpid,application/vnd.hp-hpid\n.hps,application/vnd.hp-hps\n.hqx,application/binhex\n.hqx,application/binhex4\n.hqx,application/mac-binhex\n.hqx,application/mac-binhex40\n.hqx,application/x-binhex40\n.hqx,application/x-mac-binhex40\n.hta,application/hta\n.htc,text/x-component\n.h,text/plain\n.h,text/x-h\n.htke,application/vnd.kenameaapp\n.htmls,text/html\n.html,text/html\n.htm,text/html\n.htt,text/webviewhtml\n.htx,text/html\n.hvd,application/vnd.yamaha.hv-dic\n.hvp,application/vnd.yamaha.hv-voice\n.hvs,application/vnd.yamaha.hv-script\n.i2g,application/vnd.intergeo\n.icc,application/vnd.iccprofile\n.ice,x-conference/x-cooltalk\n.ico,image/x-icon\n.ics,text/calendar\n.idc,text/plain\n.ief,image/ief\n.iefs,image/ief\n.iff,application/iff\n.ifm,application/vnd.shana.informed.formdata\n.iges,application/iges\n.iges,model/iges\n.igl,application/vnd.igloader\n.igm,application/vnd.insors.igm\n.igs,application/iges\n.igs,model/iges\n.igx,application/vnd.micrografx.igx\n.iif,application/vnd.shana.informed.interchange\n.ima,application/x-ima\n.imap,application/x-httpd-imap\n.imp,application/vnd.accpac.simply.imp\n.ims,application/vnd.ms-ims\n.inf,application/inf\n.ins,application/x-internett-signup\n.ip,application/x-ip2\n.ipfix,application/ipfix\n.ipk,application/vnd.shana.informed.package\n.irm,application/vnd.ibm.rights-management\n.irp,application/vnd.irepository.package+xml\n.isu,video/x-isvideo\n.it,audio/it\n.itp,application/vnd.shana.informed.formtemplate\n.iv,application/x-inventor\n.ivp,application/vnd.immervision-ivp\n.ivr,i-world/i-vrml\n.ivu,application/vnd.immervision-ivu\n.ivy,application/x-livescreen\n.jad,text/vnd.sun.j2me.app-descriptor\n.jam,application/vnd.jam\n.jam,audio/x-jam\n.jar,application/java-archive\n.java,text/plain\n.java,text/x-java-source\n.jav,text/plain\n.jav,text/x-java-source\n.jcm,application/x-java-commerce\n.jfif,image/jpeg\n.jfif,image/pjpeg\n.jfif-tbnl,image/jpeg\n.jisp,application/vnd.jisp\n.jlt,application/vnd.hp-jlyt\n.jnlp,application/x-java-jnlp-file\n.joda,application/vnd.joost.joda-archive\n.jpeg,image/jpeg\n.jpe,image/jpeg\n.jpg,image/jpeg\n.jpgv,video/jpeg\n.jpm,video/jpm\n.jps,image/x-jps\n.js,application/javascript\n.json,application/json\n.jut,image/jutvision\n.kar,audio/midi\n.karbon,application/vnd.kde.karbon\n.kar,music/x-karaoke\n.key,application/pgp-keys\n.keychain,application/octet-stream\n.kfo,application/vnd.kde.kformula\n.kia,application/vnd.kidspiration\n.kml,application/vnd.google-earth.kml+xml\n.kmz,application/vnd.google-earth.kmz\n.kne,application/vnd.kinar\n.kon,application/vnd.kde.kontour\n.kpr,application/vnd.kde.kpresenter\n.ksh,application/x-ksh\n.ksh,text/x-script.ksh\n.ksp,application/vnd.kde.kspread\n.ktx,image/ktx\n.ktz,application/vnd.kahootz\n.kwd,application/vnd.kde.kword\n.la,audio/nspaudio\n.la,audio/x-nspaudio\n.lam,audio/x-liveaudio\n.lasxml,application/vnd.las.las+xml\n.latex,application/x-latex\n.lbd,application/vnd.llamagraphics.life-balance.desktop\n.lbe,application/vnd.llamagraphics.life-balance.exchange+xml\n.les,application/vnd.hhe.lesson-player\n.lha,application/lha\n.lha,application/x-lha\n.link66,application/vnd.route66.link66+xml\n.list,text/plain\n.lma,audio/nspaudio\n.lma,audio/x-nspaudio\n.log,text/plain\n.lrm,application/vnd.ms-lrm\n.lsp,application/x-lisp\n.lsp,text/x-script.lisp\n.lst,text/plain\n.lsx,text/x-la-asf\n.ltf,application/vnd.frogans.ltf\n.ltx,application/x-latex\n.lvp,audio/vnd.lucent.voice\n.lwp,application/vnd.lotus-wordpro\n.lzh,application/octet-stream\n.lzh,application/x-lzh\n.lzx,application/lzx\n.lzx,application/octet-stream\n.lzx,application/x-lzx\n.m1v,video/mpeg\n.m21,application/mp21\n.m2a,audio/mpeg\n.m2v,video/mpeg\n.m3u8,application/vnd.apple.mpegurl\n.m3u,audio/x-mpegurl\n.m4a,audio/mp4\n.m4v,video/mp4\n.ma,application/mathematica\n.mads,application/mads+xml\n.mag,application/vnd.ecowin.chart\n.man,application/x-troff-man\n.map,application/x-navimap\n.mar,text/plain\n.mathml,application/mathml+xml\n.mbd,application/mbedlet\n.mbk,application/vnd.mobius.mbk\n.mbox,application/mbox\n.mc1,application/vnd.medcalcdata\n.mc${'$'},application/x-magic-cap-package-1.0\n.mcd,application/mcad\n.mcd,application/vnd.mcd\n.mcd,application/x-mathcad\n.mcf,image/vasa\n.mcf,text/mcf\n.mcp,application/netmc\n.mcurl,text/vnd.curl.mcurl\n.mdb,application/x-msaccess\n.mdi,image/vnd.ms-modi\n.me,application/x-troff-me\n.meta4,application/metalink4+xml\n.mets,application/mets+xml\n.mfm,application/vnd.mfmp\n.mgp,application/vnd.osgeo.mapguide.package\n.mgz,application/vnd.proteus.magazine\n.mht,message/rfc822\n.mhtml,message/rfc822\n.mid,application/x-midi\n.mid,audio/midi\n.mid,audio/x-mid\n.midi,application/x-midi\n.midi,audio/midi\n.midi,audio/x-mid\n.midi,audio/x-midi\n.midi,music/crescendo\n.midi,x-music/x-midi\n.mid,music/crescendo\n.mid,x-music/x-midi\n.mif,application/vnd.mif\n.mif,application/x-frame\n.mif,application/x-mif\n.mime,message/rfc822\n.mime,www/mime\n.mj2,video/mj2\n.mjf,audio/x-vnd.audioexplosion.mjuicemediafile\n.mjpg,video/x-motion-jpeg\n.mkv,video/x-matroska\n.mkv,audio/x-matroska\n.mlp,application/vnd.dolby.mlp\n.mm,application/base64\n.mm,application/x-meme\n.mmd,application/vnd.chipnuts.karaoke-mmd\n.mme,application/base64\n.mmf,application/vnd.smaf\n.mmr,image/vnd.fujixerox.edmics-mmr\n.mny,application/x-msmoney\n.mod,audio/mod\n.mod,audio/x-mod\n.mods,application/mods+xml\n.moov,video/quicktime\n.movie,video/x-sgi-movie\n.mov,video/quicktime\n.mp2,audio/mpeg\n.mp2,audio/x-mpeg\n.mp2,video/mpeg\n.mp2,video/x-mpeg\n.mp2,video/x-mpeq2a\n.mp3,audio/mpeg\n.mp3,audio/mpeg3\n.mp4a,audio/mp4\n.mp4,video/mp4\n.mp4,application/mp4\n.mpa,audio/mpeg\n.mpc,application/vnd.mophun.certificate\n.mpc,application/x-project\n.mpeg,video/mpeg\n.mpe,video/mpeg\n.mpga,audio/mpeg\n.mpg,video/mpeg\n.mpg,audio/mpeg\n.mpkg,application/vnd.apple.installer+xml\n.mpm,application/vnd.blueice.multipass\n.mpn,application/vnd.mophun.application\n.mpp,application/vnd.ms-project\n.mpt,application/x-project\n.mpv,application/x-project\n.mpx,application/x-project\n.mpy,application/vnd.ibm.minipay\n.mqy,application/vnd.mobius.mqy\n.mrc,application/marc\n.mrcx,application/marcxml+xml\n.ms,application/x-troff-ms\n.mscml,application/mediaservercontrol+xml\n.mseq,application/vnd.mseq\n.msf,application/vnd.epson.msf\n.msg,application/vnd.ms-outlook\n.msh,model/mesh\n.msl,application/vnd.mobius.msl\n.msty,application/vnd.muvee.style\n.m,text/plain\n.m,text/x-m\n.mts,model/vnd.mts\n.mus,application/vnd.musician\n.musicxml,application/vnd.recordare.musicxml+xml\n.mvb,application/x-msmediaview\n.mv,video/x-sgi-movie\n.mwf,application/vnd.mfer\n.mxf,application/mxf\n.mxl,application/vnd.recordare.musicxml\n.mxml,application/xv+xml\n.mxs,application/vnd.triscape.mxs\n.mxu,video/vnd.mpegurl\n.my,audio/make\n.mzz,application/x-vnd.audioexplosion.mzz\n.n3,text/n3\nN/A,application/andrew-inset\n.nap,image/naplps\n.naplps,image/naplps\n.nbp,application/vnd.wolfram.player\n.nc,application/x-netcdf\n.ncm,application/vnd.nokia.configuration-message\n.ncx,application/x-dtbncx+xml\n.n-gage,application/vnd.nokia.n-gage.symbian.install\n.ngdat,application/vnd.nokia.n-gage.data\n.niff,image/x-niff\n.nif,image/x-niff\n.nix,application/x-mix-transfer\n.nlu,application/vnd.neurolanguage.nlu\n.nml,application/vnd.enliven\n.nnd,application/vnd.noblenet-directory\n.nns,application/vnd.noblenet-sealer\n.nnw,application/vnd.noblenet-web\n.npx,image/vnd.net-fpx\n.nsc,application/x-conference\n.nsf,application/vnd.lotus-notes\n.nvd,application/x-navidoc\n.oa2,application/vnd.fujitsu.oasys2\n.oa3,application/vnd.fujitsu.oasys3\n.o,application/octet-stream\n.oas,application/vnd.fujitsu.oasys\n.obd,application/x-msbinder\n.oda,application/oda\n.odb,application/vnd.oasis.opendocument.database\n.odc,application/vnd.oasis.opendocument.chart\n.odf,application/vnd.oasis.opendocument.formula\n.odft,application/vnd.oasis.opendocument.formula-template\n.odg,application/vnd.oasis.opendocument.graphics\n.odi,application/vnd.oasis.opendocument.image\n.odm,application/vnd.oasis.opendocument.text-master\n.odp,application/vnd.oasis.opendocument.presentation\n.ods,application/vnd.oasis.opendocument.spreadsheet\n.odt,application/vnd.oasis.opendocument.text\n.oga,audio/ogg\n.ogg,audio/ogg\n.ogv,video/ogg\n.ogx,application/ogg\n.omc,application/x-omc\n.omcd,application/x-omcdatamaker\n.omcr,application/x-omcregerator\n.onetoc,application/onenote\n.opf,application/oebps-package+xml\n.org,application/vnd.lotus-organizer\n.osf,application/vnd.yamaha.openscoreformat\n.osfpvg,application/vnd.yamaha.openscoreformat.osfpvg+xml\n.otc,application/vnd.oasis.opendocument.chart-template\n.otf,application/x-font-otf\n.otg,application/vnd.oasis.opendocument.graphics-template\n.oth,application/vnd.oasis.opendocument.text-web\n.oti,application/vnd.oasis.opendocument.image-template\n.otp,application/vnd.oasis.opendocument.presentation-template\n.ots,application/vnd.oasis.opendocument.spreadsheet-template\n.ott,application/vnd.oasis.opendocument.text-template\n.oxt,application/vnd.openofficeorg.extension\n.p10,application/pkcs10\n.p12,application/pkcs-12\n.p7a,application/x-pkcs7-signature\n.p7b,application/x-pkcs7-certificates\n.p7c,application/pkcs7-mime\n.p7m,application/pkcs7-mime\n.p7r,application/x-pkcs7-certreqresp\n.p7s,application/pkcs7-signature\n.p8,application/pkcs8\n.pages,application/vnd.apple.pages\n.part,application/pro_eng\n.par,text/plain-bas\n.pas,text/pascal\n.paw,application/vnd.pawaafile\n.pbd,application/vnd.powerbuilder6\n.pbm,image/x-portable-bitmap\n.pcf,application/x-font-pcf\n.pcl,application/vnd.hp-pcl\n.pcl,application/x-pcl\n.pclxl,application/vnd.hp-pclxl\n.pct,image/x-pict\n.pcurl,application/vnd.curl.pcurl\n.pcx,image/x-pcx\n.pdb,application/vnd.palm\n.pdb,chemical/x-pdb\n.pdf,application/pdf\n.pem,application/x-pem-file\n.pfa,application/x-font-type1\n.pfr,application/font-tdpfr\n.pfunk,audio/make\n.pfunk,audio/make.my.funk\n.pfx,application/x-pkcs12\n.pgm,image/x-portable-graymap\n.pgn,application/x-chess-pgn\n.pgp,application/pgp-signature\n.pic,image/pict\n.pict,image/pict\n.pkg,application/x-newton-compatible-pkg\n.pki,application/pkixcmp\n.pkipath,application/pkix-pkipath\n.pko,application/vnd.ms-pki.pko\n.plb,application/vnd.3gpp.pic-bw-large\n.plc,application/vnd.mobius.plc\n.plf,application/vnd.pocketlearn\n.pls,application/pls+xml\n.pl,text/plain\n.pl,text/x-script.perl\n.plx,application/x-pixclscript\n.pm4,application/x-pagemaker\n.pm5,application/x-pagemaker\n.pm,image/x-xpixmap\n.pml,application/vnd.ctc-posml\n.pm,text/x-script.perl-module\n.png,image/png\n.pnm,application/x-portable-anymap\n.pnm,image/x-portable-anymap\n.portpkg,application/vnd.macports.portpkg\n.pot,application/mspowerpoint\n.pot,application/vnd.ms-powerpoint\n.potm,application/vnd.ms-powerpoint.template.macroenabled.12\n.potx,application/vnd.openxmlformats-officedocument.presentationml.template\n.pov,model/x-pov\n.ppa,application/vnd.ms-powerpoint\n.ppam,application/vnd.ms-powerpoint.addin.macroenabled.12\n.ppd,application/vnd.cups-ppd\n.ppm,image/x-portable-pixmap\n.pps,application/mspowerpoint\n.pps,application/vnd.ms-powerpoint\n.ppsm,application/vnd.ms-powerpoint.slideshow.macroenabled.12\n.ppsx,application/vnd.openxmlformats-officedocument.presentationml.slideshow\n.ppt,application/mspowerpoint\n.ppt,application/powerpoint\n.ppt,application/vnd.ms-powerpoint\n.ppt,application/x-mspowerpoint\n.pptm,application/vnd.ms-powerpoint.presentation.macroenabled.12\n.pptx,application/vnd.openxmlformats-officedocument.presentationml.presentation\n.ppz,application/mspowerpoint\n.prc,application/x-mobipocket-ebook\n.pre,application/vnd.lotus-freelance\n.pre,application/x-freelance\n.prf,application/pics-rules\n.prt,application/pro_eng\n.ps,application/postscript\n.psb,application/vnd.3gpp.pic-bw-small\n.psd,application/octet-stream\n.psd,image/vnd.adobe.photoshop\n.psf,application/x-font-linux-psf\n.pskcxml,application/pskc+xml\n.p,text/x-pascal\n.ptid,application/vnd.pvi.ptid1\n.pub,application/x-mspublisher\n.pvb,application/vnd.3gpp.pic-bw-var\n.pvu,paleovu/x-pv\n.pwn,application/vnd.3m.post-it-notes\n.pwz,application/vnd.ms-powerpoint\n.pya,audio/vnd.ms-playready.media.pya\n.pyc,application/x-bytecode.python\n.py,text/x-script.python\n.pyv,video/vnd.ms-playready.media.pyv\n.qam,application/vnd.epson.quickanime\n.qbo,application/vnd.intu.qbo\n.qcp,audio/vnd.qcelp\n.qd3d,x-world/x-3dmf\n.qd3,x-world/x-3dmf\n.qfx,application/vnd.intu.qfx\n.qif,image/x-quicktime\n.qps,application/vnd.publishare-delta-tree\n.qtc,video/x-qtc\n.qtif,image/x-quicktime\n.qti,image/x-quicktime\n.qt,video/quicktime\n.qxd,application/vnd.quark.quarkxpress\n.ra,audio/x-pn-realaudio\n.ra,audio/x-pn-realaudio-plugin\n.ra,audio/x-realaudio\n.ram,audio/x-pn-realaudio\n.rar,application/x-rar-compressed\n.ras,application/x-cmu-raster\n.ras,image/cmu-raster\n.ras,image/x-cmu-raster\n.rast,image/cmu-raster\n.rcprofile,application/vnd.ipunplugged.rcprofile\n.rdf,application/rdf+xml\n.rdz,application/vnd.data-vision.rdz\n.rep,application/vnd.businessobjects\n.res,application/x-dtbresource+xml\n.rexx,text/x-script.rexx\n.rf,image/vnd.rn-realflash\n.rgb,image/x-rgb\n.rif,application/reginfo+xml\n.rip,audio/vnd.rip\n.rl,application/resource-lists+xml\n.rlc,image/vnd.fujixerox.edmics-rlc\n.rld,application/resource-lists-diff+xml\n.rm,application/vnd.rn-realmedia\n.rm,audio/x-pn-realaudio\n.rmi,audio/mid\n.rmm,audio/x-pn-realaudio\n.rmp,audio/x-pn-realaudio\n.rmp,audio/x-pn-realaudio-plugin\n.rms,application/vnd.jcp.javame.midlet-rms\n.rnc,application/relax-ng-compact-syntax\n.rng,application/ringing-tones\n.rng,application/vnd.nokia.ringing-tone\n.rnx,application/vnd.rn-realplayer\n.roff,application/x-troff\n.rp9,application/vnd.cloanto.rp9\n.rp,image/vnd.rn-realpix\n.rpm,audio/x-pn-realaudio-plugin\n.rpm,application/x-rpm\n.rpss,application/vnd.nokia.radio-presets\n.rpst,application/vnd.nokia.radio-preset\n.rq,application/sparql-query\n.rs,application/rls-services+xml\n.rsd,application/rsd+xml\n.rss,application/rss+xml\n.rtf,application/rtf\n.rtf,text/rtf\n.rt,text/richtext\n.rt,text/vnd.rn-realtext\n.rtx,application/rtf\n.rtx,text/richtext\n.rv,video/vnd.rn-realvideo\n.s3m,audio/s3m\n.saf,application/vnd.yamaha.smaf-audio\n.saveme,application/octet-stream\n.sbk,application/x-tbook\n.sbml,application/sbml+xml\n.sc,application/vnd.ibm.secure-container\n.scd,application/x-msschedule\n.scm,application/vnd.lotus-screencam\n.scm,application/x-lotusscreencam\n.scm,text/x-script.guile\n.scm,text/x-script.scheme\n.scm,video/x-scm\n.scq,application/scvp-cv-request\n.scs,application/scvp-cv-response\n.scurl,text/vnd.curl.scurl\n.sda,application/vnd.stardivision.draw\n.sdc,application/vnd.stardivision.calc\n.sdd,application/vnd.stardivision.impress\n.sdf,application/octet-stream\n.sdkm,application/vnd.solent.sdkm+xml\n.sdml,text/plain\n.sdp,application/sdp\n.sdp,application/x-sdp\n.sdr,application/sounder\n.sdw,application/vnd.stardivision.writer\n.sea,application/sea\n.sea,application/x-sea\n.see,application/vnd.seemail\n.seed,application/vnd.fdsn.seed\n.sema,application/vnd.sema\n.semd,application/vnd.semd\n.semf,application/vnd.semf\n.ser,application/java-serialized-object\n.set,application/set\n.setpay,application/set-payment-initiation\n.setreg,application/set-registration-initiation\n.sfd-hdstx,application/vnd.hydrostatix.sof-data\n.sfs,application/vnd.spotfire.sfs\n.sgl,application/vnd.stardivision.writer-global\n.sgml,text/sgml\n.sgml,text/x-sgml\n.sgm,text/sgml\n.sgm,text/x-sgml\n.sh,application/x-bsh\n.sh,application/x-sh\n.sh,application/x-shar\n.shar,application/x-bsh\n.shar,application/x-shar\n.shf,application/shf+xml\n.sh,text/x-script.sh\n.shtml,text/html\n.shtml,text/x-server-parsed-html\n.sid,audio/x-psid\n.sis,application/vnd.symbian.install\n.sit,application/x-sit\n.sit,application/x-stuffit\n.sitx,application/x-stuffitx\n.skd,application/x-koan\n.skm,application/x-koan\n.skp,application/vnd.koan\n.skp,application/x-koan\n.skt,application/x-koan\n.sl,application/x-seelogo\n.sldm,application/vnd.ms-powerpoint.slide.macroenabled.12\n.sldx,application/vnd.openxmlformats-officedocument.presentationml.slide\n.slt,application/vnd.epson.salt\n.sm,application/vnd.stepmania.stepchart\n.smf,application/vnd.stardivision.math\n.smi,application/smil\n.smi,application/smil+xml\n.smil,application/smil\n.snd,audio/basic\n.snd,audio/x-adpcm\n.snf,application/x-font-snf\n.sol,application/solids\n.spc,application/x-pkcs7-certificates\n.spc,text/x-speech\n.spf,application/vnd.yamaha.smaf-phrase\n.spl,application/futuresplash\n.spl,application/x-futuresplash\n.spot,text/vnd.in3d.spot\n.spp,application/scvp-vp-response\n.spq,application/scvp-vp-request\n.spr,application/x-sprite\n.sprite,application/x-sprite\n.src,application/x-wais-source\n.srt,text/srt\n.sru,application/sru+xml\n.srx,application/sparql-results+xml\n.sse,application/vnd.kodak-descriptor\n.ssf,application/vnd.epson.ssf\n.ssi,text/x-server-parsed-html\n.ssm,application/streamingmedia\n.ssml,application/ssml+xml\n.sst,application/vnd.ms-pki.certstore\n.st,application/vnd.sailingtracker.track\n.stc,application/vnd.sun.xml.calc.template\n.std,application/vnd.sun.xml.draw.template\n.step,application/step\n.s,text/x-asm\n.stf,application/vnd.wt.stf\n.sti,application/vnd.sun.xml.impress.template\n.stk,application/hyperstudio\n.stl,application/sla\n.stl,application/vnd.ms-pki.stl\n.stl,application/x-navistyle\n.stp,application/step\n.str,application/vnd.pg.format\n.stw,application/vnd.sun.xml.writer.template\n.sub,image/vnd.dvb.subtitle\n.sus,application/vnd.sus-calendar\n.sv4cpio,application/x-sv4cpio\n.sv4crc,application/x-sv4crc\n.svc,application/vnd.dvb.service\n.svd,application/vnd.svd\n.svf,image/vnd.dwg\n.svf,image/x-dwg\n.svg,image/svg+xml\n.svr,application/x-world\n.svr,x-world/x-svr\n.swf,application/x-shockwave-flash\n.swi,application/vnd.aristanetworks.swi\n.sxc,application/vnd.sun.xml.calc\n.sxd,application/vnd.sun.xml.draw\n.sxg,application/vnd.sun.xml.writer.global\n.sxi,application/vnd.sun.xml.impress\n.sxm,application/vnd.sun.xml.math\n.sxw,application/vnd.sun.xml.writer\n.talk,text/x-speech\n.tao,application/vnd.tao.intent-module-archive\n.t,application/x-troff\n.tar,application/x-tar\n.tbk,application/toolbook\n.tbk,application/x-tbook\n.tcap,application/vnd.3gpp2.tcap\n.tcl,application/x-tcl\n.tcl,text/x-script.tcl\n.tcsh,text/x-script.tcsh\n.teacher,application/vnd.smart.teacher\n.tei,application/tei+xml\n.tex,application/x-tex\n.texi,application/x-texinfo\n.texinfo,application/x-texinfo\n.text,text/plain\n.tfi,application/thraud+xml\n.tfm,application/x-tex-tfm\n.tgz,application/gnutar\n.tgz,application/x-compressed\n.thmx,application/vnd.ms-officetheme\n.tiff,image/tiff\n.tif,image/tiff\n.tmo,application/vnd.tmobile-livetv\n.torrent,application/x-bittorrent\n.tpl,application/vnd.groove-tool-template\n.tpt,application/vnd.trid.tpt\n.tra,application/vnd.trueapp\n.tr,application/x-troff\n.trm,application/x-msterminal\n.tsd,application/timestamped-data\n.tsi,audio/tsp-audio\n.tsp,application/dsptype\n.tsp,audio/tsplayer\n.tsv,text/tab-separated-values\n.t,text/troff\n.ttf,application/x-font-ttf\n.ttl,text/turtle\n.turbot,image/florian\n.twd,application/vnd.simtech-mindmapper\n.txd,application/vnd.genomatix.tuxedo\n.txf,application/vnd.mobius.txf\n.txt,text/plain\n.ufd,application/vnd.ufdl\n.uil,text/x-uil\n.umj,application/vnd.umajin\n.unis,text/uri-list\n.uni,text/uri-list\n.unityweb,application/vnd.unity\n.unv,application/i-deas\n.uoml,application/vnd.uoml+xml\n.uris,text/uri-list\n.uri,text/uri-list\n.ustar,application/x-ustar\n.ustar,multipart/x-ustar\n.utz,application/vnd.uiq.theme\n.uu,application/octet-stream\n.uue,text/x-uuencode\n.uu,text/x-uuencode\n.uva,audio/vnd.dece.audio\n.uvh,video/vnd.dece.hd\n.uvi,image/vnd.dece.graphic\n.uvm,video/vnd.dece.mobile\n.uvp,video/vnd.dece.pd\n.uvs,video/vnd.dece.sd\n.uvu,video/vnd.uvvu.mp4\n.uvv,video/vnd.dece.video\n.vcd,application/x-cdlink\n.vcf,text/x-vcard\n.vcg,application/vnd.groove-vcard\n.vcs,text/x-vcalendar\n.vcx,application/vnd.vcx\n.vda,application/vda\n.vdo,video/vdo\n.vew,application/groupwise\n.vis,application/vnd.visionary\n.vivo,video/vivo\n.vivo,video/vnd.vivo\n.viv,video/vivo\n.viv,video/vnd.vivo\n.vmd,application/vocaltec-media-desc\n.vmf,application/vocaltec-media-file\n.vob,video/dvd\n.voc,audio/voc\n.voc,audio/x-voc\n.vos,video/vosaic\n.vox,audio/voxware\n.vqe,audio/x-twinvq-plugin\n.vqf,audio/x-twinvq\n.vql,audio/x-twinvq-plugin\n.vrml,application/x-vrml\n.vrml,model/vrml\n.vrml,x-world/x-vrml\n.vrt,x-world/x-vrt\n.vsd,application/vnd.visio\n.vsd,application/x-visio\n.vsf,application/vnd.vsf\n.vst,application/x-visio\n.vsw,application/x-visio\n.vtt,text/vtt\n.vtu,model/vnd.vtu\n.vxml,application/voicexml+xml\n.w60,application/wordperfect6.0\n.w61,application/wordperfect6.1\n.w6w,application/msword\n.wad,application/x-doom\n.war,application/zip\n.wasm,application/wasm\n.wav,audio/wav\n.wax,audio/x-ms-wax\n.wb1,application/x-qpro\n.wbmp,image/vnd.wap.wbmp\n.wbs,application/vnd.criticaltools.wbs+xml\n.wbxml,application/vnd.wap.wbxml\n.weba,audio/webm\n.web,application/vnd.xara\n.webm,video/webm\n.webp,image/webp\n.wg,application/vnd.pmi.widget\n.wgt,application/widget\n.wiz,application/msword\n.wk1,application/x-123\n.wma,audio/x-ms-wma\n.wmd,application/x-ms-wmd\n.wmf,application/x-msmetafile\n.wmf,windows/metafile\n.wmlc,application/vnd.wap.wmlc\n.wmlsc,application/vnd.wap.wmlscriptc\n.wmls,text/vnd.wap.wmlscript\n.wml,text/vnd.wap.wml\n.wm,video/x-ms-wm\n.wmv,video/x-ms-wmv\n.wmx,video/x-ms-wmx\n.wmz,application/x-ms-wmz\n.woff,application/x-font-woff\n.word,application/msword\n.wp5,application/wordperfect\n.wp5,application/wordperfect6.0\n.wp6,application/wordperfect\n.wp,application/wordperfect\n.wpd,application/vnd.wordperfect\n.wpd,application/wordperfect\n.wpd,application/x-wpwin\n.wpl,application/vnd.ms-wpl\n.wps,application/vnd.ms-works\n.wq1,application/x-lotus\n.wqd,application/vnd.wqd\n.wri,application/mswrite\n.wri,application/x-mswrite\n.wri,application/x-wri\n.wrl,application/x-world\n.wrl,model/vrml\n.wrl,x-world/x-vrml\n.wrz,model/vrml\n.wrz,x-world/x-vrml\n.wsc,text/scriplet\n.wsdl,application/wsdl+xml\n.wspolicy,application/wspolicy+xml\n.wsrc,application/x-wais-source\n.wtb,application/vnd.webturbo\n.wtk,application/x-wintalk\n.wvx,video/x-ms-wvx\n.x3d,application/vnd.hzn-3d-crossword\n.xap,application/x-silverlight-app\n.xar,application/vnd.xara\n.xbap,application/x-ms-xbap\n.xbd,application/vnd.fujixerox.docuworks.binder\n.xbm,image/xbm\n.xbm,image/x-xbitmap\n.xbm,image/x-xbm\n.xdf,application/xcap-diff+xml\n.xdm,application/vnd.syncml.dm+xml\n.xdp,application/vnd.adobe.xdp+xml\n.xdr,video/x-amt-demorun\n.xdssc,application/dssc+xml\n.xdw,application/vnd.fujixerox.docuworks\n.xenc,application/xenc+xml\n.xer,application/patch-ops-error+xml\n.xfdf,application/vnd.adobe.xfdf\n.xfdl,application/vnd.xfdl\n.xgz,xgl/drawing\n.xhtml,application/xhtml+xml\n.xif,image/vnd.xiff\n.xla,application/excel\n.xla,application/x-excel\n.xla,application/x-msexcel\n.xlam,application/vnd.ms-excel.addin.macroenabled.12\n.xl,application/excel\n.xlb,application/excel\n.xlb,application/vnd.ms-excel\n.xlb,application/x-excel\n.xlc,application/excel\n.xlc,application/vnd.ms-excel\n.xlc,application/x-excel\n.xld,application/excel\n.xld,application/x-excel\n.xlk,application/excel\n.xlk,application/x-excel\n.xll,application/excel\n.xll,application/vnd.ms-excel\n.xll,application/x-excel\n.xlm,application/excel\n.xlm,application/vnd.ms-excel\n.xlm,application/x-excel\n.xls,application/excel\n.xls,application/vnd.ms-excel\n.xls,application/x-excel\n.xls,application/x-msexcel\n.xlsb,application/vnd.ms-excel.sheet.binary.macroenabled.12\n.xlsm,application/vnd.ms-excel.sheet.macroenabled.12\n.xlsx,application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\n.xlt,application/excel\n.xlt,application/x-excel\n.xltm,application/vnd.ms-excel.template.macroenabled.12\n.xltx,application/vnd.openxmlformats-officedocument.spreadsheetml.template\n.xlv,application/excel\n.xlv,application/x-excel\n.xlw,application/excel\n.xlw,application/vnd.ms-excel\n.xlw,application/x-excel\n.xlw,application/x-msexcel\n.xm,audio/xm\n.xml,application/xml\n.xml,text/xml\n.xmz,xgl/movie\n.xo,application/vnd.olpc-sugar\n.xop,application/xop+xml\n.xpi,application/x-xpinstall\n.xpix,application/x-vnd.ls-xpix\n.xpm,image/xpm\n.xpm,image/x-xpixmap\n.x-png,image/png\n.xpr,application/vnd.is-xpr\n.xps,application/vnd.ms-xpsdocument\n.xpw,application/vnd.intercon.formnet\n.xslt,application/xslt+xml\n.xsm,application/vnd.syncml+xml\n.xspf,application/xspf+xml\n.xsr,video/x-amt-showrun\n.xul,application/vnd.mozilla.xul+xml\n.xwd,image/x-xwd\n.xwd,image/x-xwindowdump\n.xyz,chemical/x-pdb\n.xyz,chemical/x-xyz\n.xz,application/x-xz\n.yaml,text/yaml\n.yang,application/yang\n.yin,application/yin+xml\n.z,application/x-compress\n.z,application/x-compressed\n.zaz,application/vnd.zzazz.deck+xml\n.zip,application/zip\n.zip,application/x-compressed\n.zip,application/x-zip-compressed\n.zip,multipart/x-zip\n.zir,application/vnd.zul\n.zmm,application/vnd.handheld-entertainment+xml\n.zoo,application/octet-stream\n.zsh,text/x-script.zsh\n\"\"\"\n\ninternal fun loadMimes(): List<Pair<String, ContentType>> {\n    return rawMimes.lineSequence().mapNotNull {\n        val line = it.trim()\n        if (line.isEmpty()) return@mapNotNull null\n\n        val index = line.indexOf(',')\n        val extension = line.substring(0, index)\n        val mime = line.substring(index + 1)\n\n        extension.removePrefix(\".\").toLowerCasePreservingASCIIRules() to mime.toContentType()\n    }.toList()\n}\n\n@ThreadLocal\ninternal val mimes: List<Pair<String, ContentType>> by lazy { loadMimes() }\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.http.content\n\nimport io.ktor.http.*\nimport io.ktor.util.*\nimport io.ktor.util.date.*\n\n/**\n * Specifies caching properties for an [OutgoingContent] such as Cache-Control or Expires\n * @property cacheControl header\n * @property expires header\n */\npublic data class CachingOptions(val cacheControl: CacheControl? = null, val expires: GMTDate? = null)\n\n/**\n * Specifies a key for CacheControl extension property for [OutgoingContent]\n */\npublic val CachingProperty: AttributeKey<CachingOptions> = AttributeKey<CachingOptions>(\"Caching\")\n\n/**\n * Gets or sets [CacheControl] instance as an extension property on this content\n */\npublic var OutgoingContent.caching: CachingOptions?\n    get() = getProperty(CachingProperty)\n    set(value) = setProperty(CachingProperty, value)\n","package io.ktor.utils.io\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.internal.*\nimport io.ktor.utils.io.pool.*\nimport kotlinx.atomicfu.locks.*\nimport kotlin.math.*\n\n@Deprecated(\"This is going to become internal. Use ByteReadChannel receiver instead.\", level = DeprecationLevel.ERROR)\npublic suspend fun ByteChannelSequentialBase.joinTo(dst: ByteChannelSequentialBase, closeOnEnd: Boolean) {\n    return joinToImpl(dst, closeOnEnd)\n}\n\n@Deprecated(\"This is going to become internal. Use ByteReadChannel receiver instead.\", level = DeprecationLevel.ERROR)\npublic suspend fun ByteChannelSequentialBase.copyTo(\n    dst: ByteChannelSequentialBase,\n    limit: Long = Long.MAX_VALUE\n): Long {\n    return copyToSequentialImpl(dst, limit)\n}\n\nprivate const val EXPECTED_CAPACITY: Long = 4088L\n\n/**\n * Sequential (non-concurrent) byte channel implementation\n */\n@Suppress(\"OverridingDeprecatedMember\")\n@DangerousInternalIoApi\npublic abstract class ByteChannelSequentialBase(\n    initial: IoBuffer,\n    override val autoFlush: Boolean,\n    pool: ObjectPool<ChunkBuffer> = ChunkBuffer.Pool\n) : ByteChannel, ByteReadChannel, ByteWriteChannel, SuspendableReadSession, HasReadSession, HasWriteSession {\n\n    @Suppress(\"unused\", \"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public constructor(initial: IoBuffer, autoFlush: Boolean) : this(initial, autoFlush, ChunkBuffer.Pool)\n\n    private val state = ByteChannelSequentialBaseSharedState()\n\n    protected var closed: Boolean\n        get() = state.closed\n        set(value) {\n            state.closed = value\n        }\n\n    protected val writable: BytePacketBuilder = BytePacketBuilder(0, pool)\n    protected val readable: ByteReadPacket = ByteReadPacket(initial, pool)\n\n    private val slot = AwaitingSlot()\n\n    @Suppress(\"NOTHING_TO_INLINE\")\n    private inline fun totalPending(): Int = availableForRead + writable.size\n\n    private val flushSize: Int get() = flushBuffer.size\n\n    override val availableForRead: Int\n        get() = flushSize + readable.remaining.toInt()\n\n    override val availableForWrite: Int\n        get() = maxOf(0, EXPECTED_CAPACITY.toInt() - totalPending())\n\n    @Deprecated(\n        \"Setting byte order is no longer supported. Read/write in big endian and use reverseByteOrder() extensions.\",\n        level = DeprecationLevel.ERROR\n    )\n    override var readByteOrder: ByteOrder\n        get() = state.readByteOrder\n        set(value) {\n            state.readByteOrder = value\n        }\n\n    @Deprecated(\n        \"Setting byte order is no longer supported. Read/write in big endian and use reverseByteOrder() extensions.\",\n        level = DeprecationLevel.ERROR\n    )\n    override var writeByteOrder: ByteOrder\n        get() = state.writeByteOrder\n        set(value) {\n            state.writeByteOrder = value\n        }\n\n    override val isClosedForRead: Boolean\n        get() = closed && readable.isEmpty && flushSize == 0 && writable.isEmpty\n\n    override val isClosedForWrite: Boolean\n        get() = closed\n\n    private var _totalBytesRead: Long\n        get() = state.totalBytesRead\n        set(value) {\n            state.totalBytesRead = value\n        }\n\n    override val totalBytesRead: Long get() = state.totalBytesRead\n\n    private var _totalBytesWritten: Long\n        get() = state.totalBytesWritten\n        set(value) {\n            state.totalBytesWritten = value\n        }\n\n    override val totalBytesWritten: Long get() = state.totalBytesWritten\n\n    final override var closedCause: Throwable?\n        get() = state.closedCause\n        private set(value) {\n            state.closedCause = value\n        }\n\n    private val flushMutex = SynchronizedObject()\n    private val flushBuffer: BytePacketBuilder = BytePacketBuilder()\n\n    internal suspend fun awaitAtLeastNBytesAvailableForWrite(count: Int) {\n        while (availableForWrite < count && !closed) {\n            if (!flushImpl()) {\n                slot.sleep()\n            }\n        }\n    }\n\n    internal suspend fun awaitAtLeastNBytesAvailableForRead(count: Int) {\n        while (availableForRead < count && !closed) {\n            slot.sleep()\n        }\n    }\n\n    override fun flush() {\n        flushImpl()\n    }\n\n    private fun flushImpl(): Boolean {\n        if (writable.isEmpty) {\n            return false\n        }\n\n        flushWrittenBytes()\n        slot.resume()\n        return true\n    }\n\n    /**\n     * Send bytes to thread-safe storage.\n     *\n     * This method is writer-only safe.\n     */\n    private fun flushWrittenBytes() {\n        synchronized(flushMutex) {\n            val buffer = writable.stealAll()!!\n            flushBuffer.writeChunkBuffer(buffer)\n        }\n    }\n\n    /**\n     * Take flushed bytes before read.\n     *\n     * This method is reader-only safe.\n     */\n    protected fun prepareFlushedBytes() {\n        synchronized(flushMutex) {\n            readable.unsafeAppend(flushBuffer)\n        }\n    }\n\n    private fun ensureNotClosed() {\n        if (closed) {\n            throw closedCause ?: ClosedWriteChannelException(\"Channel is already closed\")\n        }\n    }\n\n    private fun ensureNotFailed() {\n        closedCause?.let { throw it }\n    }\n\n    private fun ensureNotFailed(closeable: BytePacketBuilder) {\n        closedCause?.let { cause ->\n            closeable.release()\n            throw cause\n        }\n    }\n\n    override suspend fun writeByte(b: Byte) {\n        awaitAtLeastNBytesAvailableForWrite(1)\n        writable.writeByte(b)\n        afterWrite(1)\n    }\n\n    private inline fun <T : Any> reverseWrite(value: () -> T, reversed: () -> T): T {\n        @Suppress(\"DEPRECATION_ERROR\")\n        return if (writeByteOrder == ByteOrder.BIG_ENDIAN) {\n            value()\n        } else {\n            reversed()\n        }\n    }\n\n    override suspend fun writeShort(s: Short) {\n        awaitAtLeastNBytesAvailableForWrite(2)\n        writable.writeShort(reverseWrite({ s }, { s.reverseByteOrder() }))\n        afterWrite(2)\n    }\n\n    override suspend fun writeInt(i: Int) {\n        awaitAtLeastNBytesAvailableForWrite(4)\n        writable.writeInt(reverseWrite({ i }, { i.reverseByteOrder() }))\n        afterWrite(4)\n    }\n\n    override suspend fun writeLong(l: Long) {\n        awaitAtLeastNBytesAvailableForWrite(8)\n        writable.writeLong(reverseWrite({ l }, { l.reverseByteOrder() }))\n        afterWrite(8)\n    }\n\n    override suspend fun writeFloat(f: Float) {\n        awaitAtLeastNBytesAvailableForWrite(4)\n        writable.writeFloat(reverseWrite({ f }, { f.reverseByteOrder() }))\n        afterWrite(4)\n    }\n\n    override suspend fun writeDouble(d: Double) {\n        awaitAtLeastNBytesAvailableForWrite(8)\n        writable.writeDouble(reverseWrite({ d }, { d.reverseByteOrder() }))\n        afterWrite(8)\n    }\n\n    override suspend fun writePacket(packet: ByteReadPacket) {\n        awaitAtLeastNBytesAvailableForWrite(1)\n        val size = packet.remaining.toInt()\n        writable.writePacket(packet)\n        afterWrite(size)\n    }\n\n    override suspend fun writeFully(src: IoBuffer) {\n        writeFully(src as Buffer)\n    }\n\n    override suspend fun writeFully(src: Buffer) {\n        awaitAtLeastNBytesAvailableForWrite(1)\n        val count = src.readRemaining\n        writable.writeFully(src)\n        afterWrite(count)\n    }\n\n    override suspend fun writeFully(src: ByteArray, offset: Int, length: Int) {\n        var currentIndex = offset\n        val endIndex = offset + length\n\n        while (currentIndex < endIndex) {\n            awaitAtLeastNBytesAvailableForWrite(1)\n\n            val bytesCount = min(availableForWrite, endIndex - currentIndex)\n            writable.writeFully(src, currentIndex, bytesCount)\n\n            currentIndex += bytesCount\n            afterWrite(bytesCount)\n        }\n    }\n\n    override suspend fun writeFully(memory: Memory, startIndex: Int, endIndex: Int) {\n        var currentIndex = startIndex\n\n        while (currentIndex < endIndex) {\n            awaitAtLeastNBytesAvailableForWrite(1)\n\n            val bytesCount = min(availableForWrite, endIndex - currentIndex)\n            writable.writeFully(memory, currentIndex, bytesCount)\n\n            currentIndex += bytesCount\n            afterWrite(bytesCount)\n        }\n    }\n\n    override suspend fun writeAvailable(src: IoBuffer): Int {\n        val srcRemaining = src.readRemaining\n        if (srcRemaining == 0) return 0\n        val size = minOf(srcRemaining, availableForWrite)\n\n        return if (size == 0) writeAvailableSuspend(src)\n        else {\n            writable.writeFully(src, size)\n            afterWrite(size)\n            size\n        }\n    }\n\n    override suspend fun writeAvailable(src: ByteArray, offset: Int, length: Int): Int {\n        if (length == 0) return 0\n        val size = minOf(length, availableForWrite)\n\n        return if (size == 0) writeAvailableSuspend(src, offset, length)\n        else {\n            writable.writeFully(src, offset, size)\n            afterWrite(size)\n            size\n        }\n    }\n\n    @ExperimentalIoApi\n    @Suppress(\"DEPRECATION\")\n    override suspend fun writeSuspendSession(visitor: suspend WriterSuspendSession.() -> Unit) {\n        val session = beginWriteSession()\n        visitor(session)\n    }\n\n    @Suppress(\"DEPRECATION\")\n    override fun beginWriteSession(): WriterSuspendSession {\n        return object : WriterSuspendSession {\n            override fun request(min: Int): IoBuffer? {\n                if (availableForWrite == 0) return null\n                return writable.prepareWriteHead(min) as IoBuffer\n            }\n\n            override fun written(n: Int) {\n                writable.afterHeadWrite()\n                afterWrite(n)\n            }\n\n            override fun flush() {\n                this@ByteChannelSequentialBase.flush()\n            }\n\n            override suspend fun tryAwait(n: Int) {\n                if (availableForWrite < n) {\n                    awaitAtLeastNBytesAvailableForWrite(n)\n                }\n            }\n        }\n    }\n\n    override fun endWriteSession(written: Int) {\n        writable.afterHeadWrite()\n        afterWrite(written)\n    }\n\n    override suspend fun readByte(): Byte {\n        return if (readable.isNotEmpty) {\n            readable.readByte().also { afterRead(1) }\n        } else {\n            readByteSlow()\n        }\n    }\n\n    private fun checkClosed(remaining: Int, closeable: BytePacketBuilder? = null) {\n        closedCause?.let {\n            closeable?.close()\n            throw it\n        }\n        if (closed && availableForRead < remaining) {\n            closeable?.close()\n            throw EOFException(\"$remaining bytes required but EOF reached\")\n        }\n    }\n\n    private suspend fun readByteSlow(): Byte {\n        do {\n            awaitSuspend(1)\n\n            if (readable.isNotEmpty) return readable.readByte().also { afterRead(1) }\n            checkClosed(1)\n        } while (true)\n    }\n\n    override suspend fun readShort(): Short {\n        return if (readable.hasBytes(2)) {\n            readable.readShort().reverseRead().also { afterRead(2) }\n        } else {\n            readShortSlow()\n        }\n    }\n\n    private suspend fun readShortSlow(): Short {\n        readNSlow(2) { return readable.readShort().reverseRead().also { afterRead(2) } }\n    }\n\n    @Deprecated(\"Consider providing consumed count of bytes\", level = DeprecationLevel.ERROR)\n    protected fun afterRead() {\n        afterRead(0)\n    }\n\n    protected fun afterRead(count: Int) {\n        _totalBytesRead += count\n        slot.resume()\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\", \"DEPRECATION_ERROR\")\n    private inline fun Short.reverseRead(): Short = when {\n        readByteOrder == ByteOrder.BIG_ENDIAN -> this\n        else -> this.reverseByteOrder()\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\", \"DEPRECATION_ERROR\")\n    private inline fun Int.reverseRead(): Int = when {\n        readByteOrder == ByteOrder.BIG_ENDIAN -> this\n        else -> this.reverseByteOrder()\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\", \"DEPRECATION_ERROR\")\n    private inline fun Long.reverseRead(): Long = when {\n        readByteOrder == ByteOrder.BIG_ENDIAN -> this\n        else -> this.reverseByteOrder()\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\", \"DEPRECATION_ERROR\")\n    private inline fun Float.reverseRead(): Float = when {\n        readByteOrder == ByteOrder.BIG_ENDIAN -> this\n        else -> this.reverseByteOrder()\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\", \"DEPRECATION_ERROR\")\n    private inline fun Double.reverseRead(): Double = when {\n        readByteOrder == ByteOrder.BIG_ENDIAN -> this\n        else -> this.reverseByteOrder()\n    }\n\n    override suspend fun readInt(): Int {\n        return if (readable.hasBytes(4)) {\n            readable.readInt().reverseRead().also { afterRead(4) }\n        } else {\n            readIntSlow()\n        }\n    }\n\n    private suspend fun readIntSlow(): Int {\n        readNSlow(4) {\n            return readable.readInt().reverseRead().also { afterRead(4) }\n        }\n    }\n\n    override suspend fun readLong(): Long {\n        return if (readable.hasBytes(8)) {\n            readable.readLong().reverseRead().also { afterRead(8) }\n        } else {\n            readLongSlow()\n        }\n    }\n\n    private suspend fun readLongSlow(): Long {\n        readNSlow(8) {\n            return readable.readLong().reverseRead().also { afterRead(8) }\n        }\n    }\n\n    override suspend fun readFloat(): Float = if (readable.hasBytes(4)) {\n        readable.readFloat().reverseRead().also { afterRead(4) }\n    } else {\n        readFloatSlow()\n    }\n\n    private suspend fun readFloatSlow(): Float {\n        readNSlow(4) {\n            return readable.readFloat().reverseRead().also { afterRead(4) }\n        }\n    }\n\n    override suspend fun readDouble(): Double = if (readable.hasBytes(8)) {\n        readable.readDouble().reverseRead().also { afterRead(8) }\n    } else {\n        readDoubleSlow()\n    }\n\n    private suspend fun readDoubleSlow(): Double {\n        readNSlow(8) {\n            return readable.readDouble().reverseRead().also { afterRead(8) }\n        }\n    }\n\n    override suspend fun readRemaining(limit: Long, headerSizeHint: Int): ByteReadPacket {\n        ensureNotFailed()\n\n        val builder = BytePacketBuilder(headerSizeHint)\n\n        val size = minOf(limit, readable.remaining)\n        builder.writePacket(readable, size)\n        val remaining = limit - builder.size\n\n        return if (remaining == 0L || isClosedForRead) {\n            afterRead(remaining.toInt())\n            ensureNotFailed(builder)\n            builder.build()\n        } else {\n            readRemainingSuspend(builder, limit)\n        }\n    }\n\n    private suspend fun readRemainingSuspend(builder: BytePacketBuilder, limit: Long): ByteReadPacket {\n        while (builder.size < limit) {\n            val partLimit = minOf(limit - builder.size, readable.remaining)\n            builder.writePacket(readable, partLimit)\n            afterRead(partLimit.toInt())\n            ensureNotFailed(builder)\n\n            if (isClosedForRead || builder.size == limit.toInt()) {\n                break\n            }\n\n            awaitSuspend(1)\n        }\n\n        ensureNotFailed(builder)\n        return builder.build()\n    }\n\n    override suspend fun readPacket(size: Int, headerSizeHint: Int): ByteReadPacket {\n        checkClosed(size)\n\n        val builder = BytePacketBuilder(headerSizeHint)\n\n        var remaining = size\n        val partSize = minOf(remaining.toLong(), readable.remaining).toInt()\n        remaining -= partSize\n        builder.writePacket(readable, partSize)\n        afterRead(partSize)\n        checkClosed(remaining, builder)\n\n        return if (remaining > 0) readPacketSuspend(builder, remaining)\n        else builder.build()\n    }\n\n    private suspend fun readPacketSuspend(builder: BytePacketBuilder, size: Int): ByteReadPacket {\n        var remaining = size\n        while (remaining > 0) {\n            val partSize = minOf(remaining.toLong(), readable.remaining).toInt()\n            remaining -= partSize\n            builder.writePacket(readable, partSize)\n            afterRead(partSize)\n            checkClosed(remaining, builder)\n\n            if (remaining > 0) {\n                awaitSuspend(1)\n            }\n        }\n\n        checkClosed(remaining, builder)\n        return builder.build()\n    }\n\n    protected fun readAvailableClosed(): Int {\n        closedCause?.let { throw it }\n\n        if (availableForRead > 0) {\n            prepareFlushedBytes()\n        }\n\n        return -1\n    }\n\n    override suspend fun readAvailable(dst: IoBuffer): Int = readAvailable(dst as Buffer)\n\n    internal suspend fun readAvailable(dst: Buffer): Int {\n        closedCause?.let { throw it }\n        if (closed && availableForRead == 0) return -1\n\n        if (dst.writeRemaining == 0) return 0\n\n        if (availableForRead == 0) {\n            awaitSuspend(1)\n        }\n\n        if (!readable.canRead()) {\n            prepareFlushedBytes()\n        }\n\n        val size = minOf(dst.writeRemaining.toLong(), readable.remaining).toInt()\n        readable.readFully(dst, size)\n        afterRead(size)\n        return size\n    }\n\n    override suspend fun readFully(dst: IoBuffer, n: Int) {\n        readFully(dst as Buffer, n)\n    }\n\n    private suspend fun readFully(dst: Buffer, n: Int) {\n        require(n <= dst.writeRemaining) { \"Not enough space in the destination buffer to write $n bytes\" }\n        require(n >= 0) { \"n shouldn't be negative\" }\n\n        return when {\n            closedCause != null -> throw closedCause!!\n            readable.remaining >= n -> readable.readFully(dst, n).also { afterRead(n) }\n            closed -> throw EOFException(\n                \"Channel is closed and not enough bytes available: required $n but $availableForRead available\"\n            )\n            else -> readFullySuspend(dst, n)\n        }\n    }\n\n    private suspend fun readFullySuspend(dst: Buffer, n: Int) {\n        awaitSuspend(n)\n        return readFully(dst, n)\n    }\n\n    override suspend fun readAvailable(dst: ByteArray, offset: Int, length: Int): Int {\n        closedCause?.let { throw it }\n        if (closed && availableForRead == 0) return -1\n\n        if (length == 0) return 0\n\n        if (availableForRead == 0) {\n            awaitSuspend(1)\n        }\n\n        if (!readable.canRead()) {\n            prepareFlushedBytes()\n        }\n\n        val size = minOf(length.toLong(), readable.remaining).toInt()\n        readable.readFully(dst, offset, size)\n        afterRead(size)\n        return size\n    }\n\n    override suspend fun readFully(dst: ByteArray, offset: Int, length: Int) {\n        val rc = readAvailable(dst, offset, length)\n        if (rc == length) return\n        if (rc == -1) throw EOFException(\"Unexpected end of stream\")\n\n        return readFullySuspend(dst, offset + rc, length - rc)\n    }\n\n    private suspend fun readFullySuspend(dst: ByteArray, offset: Int, length: Int) {\n        var written = 0\n\n        while (written < length) {\n            val rc = readAvailable(dst, offset + written, length - written)\n            if (rc == -1) throw EOFException(\"Unexpected end of stream\")\n            written += rc\n        }\n    }\n\n    override suspend fun readBoolean(): Boolean {\n        return if (readable.canRead()) (readable.readByte() == 1.toByte()).also { afterRead(1) }\n        else readBooleanSlow()\n    }\n\n    private suspend fun readBooleanSlow(): Boolean {\n        awaitSuspend(1)\n        checkClosed(1)\n        return readBoolean()\n    }\n\n    private var lastReadAvailable: Int\n        get() = state.lastReadAvailable\n        set(value) {\n            state.lastReadAvailable = value\n        }\n\n    private var lastReadView: ChunkBuffer\n        get() = state.lastReadView\n        set(value) {\n            state.lastReadView = value\n        }\n\n    private fun completeReading() {\n        val remaining = lastReadView.readRemaining\n        val delta = lastReadAvailable - remaining\n        if (lastReadView !== Buffer.Empty) {\n            readable.completeReadHead(lastReadView)\n        }\n        if (delta > 0) {\n            afterRead(delta)\n        }\n        lastReadAvailable = 0\n        lastReadView = ChunkBuffer.Empty\n    }\n\n    override suspend fun await(atLeast: Int): Boolean {\n        require(atLeast >= 0) { \"atLeast parameter shouldn't be negative: $atLeast\" }\n        require(atLeast <= EXPECTED_CAPACITY) {\n            \"atLeast parameter shouldn't be larger than max buffer size of $EXPECTED_CAPACITY: $atLeast\"\n        }\n\n        completeReading()\n\n        if (atLeast == 0) return !isClosedForRead\n        if (readable.remaining >= atLeast) return true\n\n        return awaitSuspend(atLeast)\n    }\n\n    internal suspend fun awaitInternalAtLeast1(): Boolean = if (readable.isNotEmpty) {\n        true\n    } else {\n        awaitSuspend(1)\n    }\n\n    protected suspend fun awaitSuspend(atLeast: Int): Boolean {\n        require(atLeast >= 0)\n\n        awaitAtLeastNBytesAvailableForRead(atLeast)\n        prepareFlushedBytes()\n\n        closedCause?.let { throw it }\n        return !isClosedForRead && availableForRead >= atLeast\n    }\n\n    override fun discard(n: Int): Int {\n        closedCause?.let { throw it }\n\n        if (n == 0) {\n            return 0\n        }\n\n        return readable.discard(n).also {\n            afterRead(n)\n            requestNextView(1)\n        }\n    }\n\n    override fun request(atLeast: Int): IoBuffer? {\n        closedCause?.let { throw it }\n\n        completeReading()\n\n        return requestNextView(atLeast)\n    }\n\n    private fun requestNextView(atLeast: Int): IoBuffer? {\n        if (readable.isEmpty) {\n            prepareFlushedBytes()\n        }\n\n        val view = readable.prepareReadHead(atLeast) as IoBuffer?\n\n        if (view == null) {\n            lastReadView = ChunkBuffer.Empty\n            lastReadAvailable = 0\n        } else {\n            lastReadView = view\n            lastReadAvailable = view.readRemaining\n        }\n\n        return view\n    }\n\n    override suspend fun discard(max: Long): Long {\n        val discarded = readable.discard(max)\n\n        return if (discarded == max || isClosedForRead) {\n            ensureNotFailed()\n            return discarded\n        } else {\n            discardSuspend(max, discarded)\n        }\n    }\n\n    private suspend fun discardSuspend(max: Long, discarded0: Long): Long {\n        var discarded = discarded0\n\n        do {\n            if (!await(1)) break\n            discarded += readable.discard(max - discarded)\n        } while (discarded < max && !isClosedForRead)\n\n        ensureNotFailed()\n\n        return discarded\n    }\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Use read instead.\")\n    override fun readSession(consumer: ReadSession.() -> Unit) {\n        try {\n            consumer(this)\n        } finally {\n            completeReading()\n        }\n    }\n\n    override fun startReadSession(): SuspendableReadSession = this\n\n    override fun endReadSession() {\n        completeReading()\n    }\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Use read instead.\")\n    override suspend fun readSuspendableSession(consumer: suspend SuspendableReadSession.() -> Unit) {\n        try {\n            consumer(this)\n        } finally {\n            completeReading()\n        }\n    }\n\n    override suspend fun <A : Appendable> readUTF8LineTo(out: A, limit: Int): Boolean {\n        if (isClosedForRead) {\n            val cause = closedCause\n            if (cause != null) {\n                throw cause\n            }\n\n            return false\n        }\n\n        @OptIn(DangerousInternalIoApi::class)\n        return decodeUTF8LineLoopSuspend(out, limit) { size ->\n            afterRead(size)\n            if (await(size)) readable\n            else null\n        }\n    }\n\n    override suspend fun readUTF8Line(limit: Int): String? {\n        val sb = StringBuilder()\n        if (!readUTF8LineTo(sb, limit)) {\n            return null\n        }\n\n        return sb.toString()\n    }\n\n    override fun cancel(cause: Throwable?): Boolean {\n        if (closedCause != null || closed) {\n            return false\n        }\n\n        return close(cause ?: io.ktor.utils.io.CancellationException(\"Channel cancelled\"))\n    }\n\n    override fun close(cause: Throwable?): Boolean {\n        if (closed || closedCause != null) return false\n        closedCause = cause\n        closed = true\n        if (cause != null) {\n            readable.release()\n            writable.release()\n            flushBuffer.release()\n        } else {\n            flush()\n        }\n\n        slot.cancel(cause)\n        return true\n    }\n\n    internal fun transferTo(dst: ByteChannelSequentialBase, limit: Long): Long {\n        val size = readable.remaining\n        return if (size <= limit) {\n            dst.writable.writePacket(readable)\n            dst.afterWrite(size.toInt())\n            afterRead(size.toInt())\n            size\n        } else {\n            0\n        }\n    }\n\n    private suspend inline fun readNSlow(n: Int, block: () -> Nothing): Nothing {\n        do {\n            awaitSuspend(n)\n\n            if (readable.hasBytes(n)) block()\n            checkClosed(n)\n        } while (true)\n    }\n\n    @Suppress(\"DEPRECATION\")\n    private suspend fun writeAvailableSuspend(src: IoBuffer): Int {\n        awaitAtLeastNBytesAvailableForWrite(1)\n        return writeAvailable(src)\n    }\n\n    private suspend fun writeAvailableSuspend(src: ByteArray, offset: Int, length: Int): Int {\n        awaitAtLeastNBytesAvailableForWrite(1)\n        return writeAvailable(src, offset, length)\n    }\n\n    @Deprecated(\"Consider providing written count of bytes\", level = DeprecationLevel.ERROR)\n    protected fun afterWrite() {\n        afterWrite(0)\n    }\n\n    protected fun afterWrite(count: Int) {\n        _totalBytesWritten += count\n\n        if (closed) {\n            writable.release()\n            ensureNotClosed()\n        }\n        if (autoFlush || availableForWrite == 0) {\n            flush()\n        }\n    }\n\n    override suspend fun awaitFreeSpace() {\n        flush()\n        awaitAtLeastNBytesAvailableForWrite(1)\n        ensureNotClosed()\n    }\n\n    final override suspend fun peekTo(\n        destination: Memory,\n        destinationOffset: Long,\n        offset: Long,\n        min: Long,\n        max: Long\n    ): Long {\n        var bytesCopied = 0L\n\n        @Suppress(\"DEPRECATION\")\n        readSuspendableSession {\n            val desiredSize = (min + offset).coerceAtMost(EXPECTED_CAPACITY).toInt()\n\n            await(desiredSize)\n\n            val buffer = request(1) ?: IoBuffer.Empty\n            if (buffer.readRemaining > offset) {\n                bytesCopied = minOf(buffer.readRemaining.toLong() - offset, max, destination.size - destinationOffset)\n                buffer.memory.copyTo(destination, offset, bytesCopied, destinationOffset)\n            }\n        }\n\n        return bytesCopied\n    }\n}\n","package io.ktor.utils.io.charsets\n\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.core.internal.*\n\npublic expect abstract class Charset {\n    @ExperimentalIoApi\n    public abstract fun newEncoder(): CharsetEncoder\n\n    @ExperimentalIoApi\n    public abstract fun newDecoder(): CharsetDecoder\n\n    public companion object {\n        public fun forName(name: String): Charset\n    }\n}\n\npublic expect val Charset.name: String\n\n// ----------------------------- ENCODER -------------------------------------------------------------------------------\n@ExperimentalIoApi\npublic expect abstract class CharsetEncoder\n\npublic expect val CharsetEncoder.charset: Charset\n\n@Deprecated(\n    \"Use writeText on Output instead.\",\n    ReplaceWith(\"dst.writeText(input, fromIndex, toIndex, charset)\", \"io.ktor.utils.io.core.writeText\")\n)\npublic fun CharsetEncoder.encode(input: CharSequence, fromIndex: Int, toIndex: Int, dst: Output) {\n    encodeToImpl(dst, input, fromIndex, toIndex)\n}\n\n@ExperimentalIoApi\npublic expect fun CharsetEncoder.encodeToByteArray(\n    input: CharSequence,\n    fromIndex: Int = 0,\n    toIndex: Int = input.length\n): ByteArray\n\n@Deprecated(\n    \"Internal API. Will be hidden in future releases. Use encodeToByteArray instead.\",\n    replaceWith = ReplaceWith(\"encodeToByteArray(input, fromIndex, toIndex)\")\n)\npublic fun CharsetEncoder.encodeToByteArrayImpl(\n    input: CharSequence,\n    fromIndex: Int = 0,\n    toIndex: Int = input.length\n): ByteArray {\n    return encodeToByteArray(input, fromIndex, toIndex)\n}\n\n@ExperimentalIoApi\npublic expect fun CharsetEncoder.encodeUTF8(input: ByteReadPacket, dst: Output)\n\n@ExperimentalIoApi\npublic fun CharsetEncoder.encode(\n    input: CharSequence,\n    fromIndex: Int = 0,\n    toIndex: Int = input.length\n): ByteReadPacket = buildPacket {\n    encodeToImpl(this, input, fromIndex, toIndex)\n}\n\n@ExperimentalIoApi\npublic fun CharsetEncoder.encodeUTF8(input: ByteReadPacket): ByteReadPacket = buildPacket {\n    encodeUTF8(input, this)\n}\n\n@ExperimentalIoApi\npublic fun CharsetEncoder.encode(input: CharArray, fromIndex: Int, toIndex: Int, dst: Output) {\n    var start = fromIndex\n\n    if (start >= toIndex) return\n    dst.writeWhileSize(1) { view: Buffer ->\n        val rc = encodeArrayImpl(input, start, toIndex, view)\n        check(rc >= 0)\n        start += rc\n\n        when {\n            start >= toIndex -> 0\n            rc == 0 -> 8\n            else -> 1\n        }\n    }\n\n    encodeCompleteImpl(dst)\n}\n\n// ----------------------------- DECODER -------------------------------------------------------------------------------\n\n@ExperimentalIoApi\npublic expect abstract class CharsetDecoder\n\n/**\n * Decoder's charset it is created for.\n */\npublic expect val CharsetDecoder.charset: Charset\n\n@ExperimentalIoApi\npublic fun CharsetDecoder.decode(input: Input, max: Int = Int.MAX_VALUE): String =\n    buildString(minOf(max.toLong(), input.sizeEstimate()).toInt()) {\n        decode(input, this, max)\n    }\n\n@ExperimentalIoApi\npublic expect fun CharsetDecoder.decode(input: Input, dst: Appendable, max: Int): Int\n\n@ExperimentalIoApi\npublic expect fun CharsetDecoder.decodeExactBytes(input: Input, inputLength: Int): String\n\n// ----------------------------- REGISTRY ------------------------------------------------------------------------------\npublic expect object Charsets {\n    public val UTF_8: Charset\n    public val ISO_8859_1: Charset\n}\n\npublic expect open class MalformedInputException(message: String) : Throwable\n\npublic class TooLongLineException(message: String) : MalformedInputException(message)\n\n// ----------------------------- INTERNALS -----------------------------------------------------------------------------\n\ninternal fun CharsetEncoder.encodeArrayImpl(input: CharArray, fromIndex: Int, toIndex: Int, dst: Buffer): Int {\n    val length = toIndex - fromIndex\n    return encodeImpl(CharArraySequence(input, fromIndex, length), 0, length, dst)\n}\n\ninternal expect fun CharsetEncoder.encodeImpl(input: CharSequence, fromIndex: Int, toIndex: Int, dst: Buffer): Int\n\ninternal expect fun CharsetEncoder.encodeComplete(dst: Buffer): Boolean\n\ninternal expect fun CharsetDecoder.decodeBuffer(\n    input: Buffer,\n    out: Appendable,\n    lastBuffer: Boolean,\n    max: Int = Int.MAX_VALUE\n): Int\n\ninternal fun CharsetEncoder.encodeToByteArrayImpl1(\n    input: CharSequence,\n    fromIndex: Int = 0,\n    toIndex: Int = input.length\n): ByteArray {\n    var start = fromIndex\n    if (start >= toIndex) return EmptyByteArray\n    val single = ChunkBuffer.Pool.borrow()\n\n    try {\n        val rc = encodeImpl(input, start, toIndex, single)\n        start += rc\n        if (start == toIndex) {\n            val result = ByteArray(single.readRemaining)\n            single.readFully(result)\n            return result\n        }\n\n        return buildPacket {\n            appendSingleChunk(single.duplicate())\n            encodeToImpl(this, input, start, toIndex)\n        }.readBytes()\n    } finally {\n        single.release(ChunkBuffer.Pool)\n    }\n}\n\ninternal fun Input.sizeEstimate(): Long = when (this) {\n    is ByteReadPacket -> remaining\n    is AbstractInput -> maxOf(remaining, 16)\n    else -> 16\n}\n\nprivate fun CharsetEncoder.encodeCompleteImpl(dst: Output): Int {\n    var size = 1\n    var bytesWritten = 0\n\n    dst.writeWhile { view ->\n        val before = view.writeRemaining\n        if (encodeComplete(view)) {\n            size = 0\n        } else {\n            size++\n        }\n        bytesWritten += before - view.writeRemaining\n        size > 0\n    }\n\n    return bytesWritten\n}\n\ninternal fun CharsetEncoder.encodeToImpl(\n    destination: Output,\n    input: CharSequence,\n    fromIndex: Int,\n    toIndex: Int\n): Int {\n    var start = fromIndex\n    if (start >= toIndex) return 0\n\n    var bytesWritten = 0\n\n    destination.writeWhileSize(1) { view: Buffer ->\n        val before = view.writeRemaining\n        val rc = encodeImpl(input, start, toIndex, view)\n        check(rc >= 0)\n        start += rc\n        bytesWritten += before - view.writeRemaining\n\n        when {\n            start >= toIndex -> 0\n            rc == 0 -> 8\n            else -> 1\n        }\n    }\n\n    bytesWritten += encodeCompleteImpl(destination)\n    return bytesWritten\n}\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.bits\n\nimport io.ktor.utils.io.core.internal.*\n\npublic actual inline fun Memory.loadShortAt(offset: Int): Short = view.getInt16(offset, false)\n\npublic actual inline fun Memory.loadShortAt(offset: Long): Short = loadShortAt(offset.toIntOrFail(\"offset\"))\n\npublic actual inline fun Memory.loadIntAt(offset: Int): Int = view.getInt32(offset, false)\n\npublic actual inline fun Memory.loadIntAt(offset: Long): Int = loadIntAt(offset.toIntOrFail(\"offset\"))\n\npublic actual inline fun Memory.loadLongAt(offset: Int): Long =\n    (view.getUint32(offset, false).toLong() shl 32) or\n        view.getUint32(offset + 4, false).toLong()\n\npublic actual inline fun Memory.loadLongAt(offset: Long): Long = loadLongAt(offset.toIntOrFail(\"offset\"))\n\npublic actual inline fun Memory.loadFloatAt(offset: Int): Float = view.getFloat32(offset, false)\n\npublic actual inline fun Memory.loadFloatAt(offset: Long): Float = loadFloatAt(offset.toIntOrFail(\"offset\"))\n\npublic actual inline fun Memory.loadDoubleAt(offset: Int): Double = view.getFloat64(offset, false)\n\npublic actual inline fun Memory.loadDoubleAt(offset: Long): Double = loadDoubleAt(offset.toIntOrFail(\"offset\"))\n\n/**\n * Write regular signed 32bit integer in the network byte order (Big Endian)\n */\npublic actual inline fun Memory.storeIntAt(offset: Int, value: Int) {\n    view.setInt32(offset, value, littleEndian = false)\n}\n\n/**\n * Write regular signed 32bit integer in the network byte order (Big Endian)\n */\npublic actual inline fun Memory.storeIntAt(offset: Long, value: Int) {\n    view.setInt32(offset.toIntOrFail(\"offset\"), value, littleEndian = false)\n}\n\n/**\n * Write short signed 16bit integer in the network byte order (Big Endian)\n */\npublic actual inline fun Memory.storeShortAt(offset: Int, value: Short) {\n    view.setInt16(offset, value, littleEndian = false)\n}\n\n/**\n * Write short signed 16bit integer in the network byte order (Big Endian)\n */\npublic actual inline fun Memory.storeShortAt(offset: Long, value: Short) {\n    view.setInt16(offset.toIntOrFail(\"offset\"), value, littleEndian = false)\n}\n\n/**\n * Write short signed 64bit integer in the network byte order (Big Endian)\n */\npublic actual inline fun Memory.storeLongAt(offset: Int, value: Long) {\n    view.setInt32(offset, (value shr 32).toInt(), littleEndian = false)\n    view.setInt32(offset + 4, (value and 0xffffffffL).toInt(), littleEndian = false)\n}\n\n/**\n * Write short signed 64bit integer in the network byte order (Big Endian)\n */\npublic actual inline fun Memory.storeLongAt(offset: Long, value: Long) {\n    storeLongAt(offset.toIntOrFail(\"offset\"), value)\n}\n\n/**\n * Write short signed 32bit floating point number in the network byte order (Big Endian)\n */\npublic actual inline fun Memory.storeFloatAt(offset: Int, value: Float) {\n    view.setFloat32(offset, value, littleEndian = false)\n}\n\n/**\n * Write short signed 32bit floating point number in the network byte order (Big Endian)\n */\npublic actual inline fun Memory.storeFloatAt(offset: Long, value: Float) {\n    view.setFloat32(offset.toIntOrFail(\"offset\"), value, littleEndian = false)\n}\n\n/**\n * Write short signed 64bit floating point number in the network byte order (Big Endian)\n */\npublic actual inline fun Memory.storeDoubleAt(offset: Int, value: Double) {\n    view.setFloat64(offset, value, littleEndian = false)\n}\n\n/**\n * Write short signed 64bit floating point number in the network byte order (Big Endian)\n */\npublic actual inline fun Memory.storeDoubleAt(offset: Long, value: Double) {\n    view.setFloat64(offset.toIntOrFail(\"offset\"), value, littleEndian = false)\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.Memory\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readFully(dst: ByteArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyBytesTemplate(offset, length) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }.requireNoRemaining()\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readFully(dst: ShortArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyTemplate(offset, length, 2) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }.requireNoRemaining()\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readFully(dst: IntArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyTemplate(offset, length, 4) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }.requireNoRemaining()\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readFully(dst: LongArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyTemplate(offset, length, 8) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }.requireNoRemaining()\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readFully(dst: FloatArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyTemplate(offset, length, 4) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }.requireNoRemaining()\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readFully(dst: DoubleArray, offset: Int = 0, length: Int = dst.size - offset) {\n    readFullyTemplate(offset, length, 8) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }.requireNoRemaining()\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readFully(dst: Buffer, length: Int = dst.writeRemaining) {\n    readFullyBytesTemplate(0, length) { src, _, count ->\n        src.readFully(dst, count)\n    }.requireNoRemaining()\n}\n\npublic fun Input.readFully(destination: Memory, destinationOffset: Int, length: Int) {\n    readFully(destination, destinationOffset.toLong(), length.toLong())\n}\n\npublic fun Input.readFully(destination: Memory, destinationOffset: Long, length: Long) {\n    if (readAvailable(destination, destinationOffset, length) != length) {\n        prematureEndOfStream(length)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readAvailable(dst: ByteArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return length - readFullyBytesTemplate(offset, length) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readAvailable(dst: ShortArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return length - readFullyTemplate(offset, length, 2) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readAvailable(dst: IntArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return length - readFullyTemplate(offset, length, 4) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readAvailable(dst: LongArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return length - readFullyTemplate(offset, length, 8) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readAvailable(dst: FloatArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return length - readFullyTemplate(offset, length, 4) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readAvailable(dst: DoubleArray, offset: Int = 0, length: Int = dst.size - offset): Int {\n    return length - readFullyTemplate(offset, length, 8) { src, dstOffset, count ->\n        src.readFully(dst, dstOffset, count)\n    }\n}\n\npublic fun Input.readAvailable(dst: Buffer, length: Int = dst.writeRemaining): Int {\n    return length - readFullyBytesTemplate(0, length) { src, _, count ->\n        src.readFully(dst, count)\n    }\n}\n\npublic fun Input.readAvailable(destination: Memory, destinationOffset: Int, length: Int): Int {\n    return readAvailable(destination, destinationOffset.toLong(), length.toLong()).toInt()\n}\n\npublic fun Input.readAvailable(destination: Memory, destinationOffset: Long, length: Long): Long {\n    val remaining = readFullyBytesTemplate(destinationOffset, length) { src, srcOffset, dstOffset, count ->\n        src.copyTo(destination, srcOffset, count.toLong(), dstOffset)\n    }\n    val result = length - remaining\n    return when {\n        result == 0L && endOfInput -> -1\n        else -> result\n    }\n}\n\n/**\n * @return number of bytes remaining or 0 if all [length] bytes were copied\n */\nprivate inline fun Input.readFullyBytesTemplate(\n    initialDstOffset: Int,\n    length: Int,\n    readBlock: (src: Buffer, dstOffset: Int, count: Int) -> Unit\n): Int {\n    var remaining = length\n    var dstOffset = initialDstOffset\n\n    takeWhile { buffer ->\n        val count = minOf(remaining, buffer.readRemaining)\n        readBlock(buffer, dstOffset, count)\n        remaining -= count\n        dstOffset += count\n\n        remaining > 0\n    }\n\n    return remaining\n}\n\n/**\n * @return number of bytes remaining or 0 if all [length] bytes were copied\n */\nprivate inline fun Input.readFullyBytesTemplate(\n    initialDstOffset: Long,\n    length: Long,\n    readBlock: (src: Memory, srcOffset: Long, dstOffset: Long, count: Int) -> Unit\n): Long {\n    var remaining = length\n    var dstOffset = initialDstOffset\n\n    takeWhile { buffer ->\n        val count = minOf(remaining, buffer.readRemaining.toLong()).toInt()\n        readBlock(buffer.memory, buffer.readPosition.toLong(), dstOffset, count)\n        buffer.discardExact(count)\n        remaining -= count\n        dstOffset += count\n\n        remaining > 0\n    }\n\n    return remaining\n}\n\n/**\n * @return number of elements remaining or 0 if all [length] elements were copied\n */\nprivate inline fun Input.readFullyTemplate(\n    offset: Int,\n    length: Int,\n    componentSize: Int,\n    readBlock: (src: Buffer, dstOffset: Int, count: Int) -> Unit\n): Int {\n    var remaining = length\n    var dstOffset = offset\n\n    takeWhileSize { buffer ->\n        val count = minOf(remaining, buffer.readRemaining / componentSize)\n        readBlock(buffer, dstOffset, count)\n        remaining -= count\n        dstOffset += count\n\n        when {\n            remaining > 0 -> componentSize\n            else -> 0\n        }\n    }\n\n    return remaining\n}\n\n@Suppress(\"NOTHING_TO_INLINE\")\nprivate inline fun Int.requireNoRemaining() {\n    if (this > 0) {\n        prematureEndOfStream(this)\n    }\n}\n","/*\n * Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.utils.io.core.internal\n\nimport kotlin.contracts.*\n\n@PublishedApi\ninternal inline fun require(condition: Boolean, crossinline message: () -> String) {\n    contract {\n        returns() implies condition\n    }\n\n    if (!condition) {\n        val m = object : RequireFailureCapture() {\n            override fun doFail(): Nothing {\n                throw IllegalArgumentException(message())\n            }\n        }\n        m.doFail()\n    }\n}\n\n@PublishedApi\ninternal abstract class RequireFailureCapture {\n    abstract fun doFail(): Nothing\n}\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.concurrent.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.errors.EOFException\nimport kotlin.contracts.*\n\n/**\n * Represents a buffer with read and write positions.\n *\n * Concurrent unsafe: the same memory could be shared between different instances of [Buffer] however you can't\n * read/write using the same [Buffer] instance from different threads.\n */\n@DangerousInternalIoApi\npublic open class Buffer(public val memory: Memory) {\n    private val bufferState: BufferSharedState = BufferSharedState(memory.size32)\n\n    /**\n     * Current read position. It is always non-negative and will never run ahead of the [writePosition].\n     * It is usually greater or equal to [startGap] reservation.\n     * This position is affected by [discard], [rewind], [resetForRead], [resetForWrite], [reserveStartGap]\n     * and [reserveEndGap].\n     */\n    public var readPosition: Int\n        get() = bufferState.readPosition\n        private set(value) {\n            bufferState.readPosition = value\n        }\n\n    /**\n     * Current write position. It is always non-negative and will never run ahead of the [limit].\n     * It is always greater or equal to the [readPosition].\n     * * This position is affected by [resetForRead], [resetForWrite], [reserveStartGap]\n     * and [reserveEndGap].\n     */\n    public var writePosition: Int\n        get() = bufferState.writePosition\n        private set(value) {\n            bufferState.writePosition = value\n        }\n\n    /**\n     * Start gap is a reserved space in the beginning. The reserved space is usually used to write a packet length\n     * in the case when it's not known before the packet constructed.\n     */\n    public var startGap: Int\n        get() = bufferState.startGap\n        private set(value) {\n            bufferState.startGap = value\n        }\n\n    /**\n     * Write position limit. No bytes could be written ahead of this limit. When the limit is less than the [capacity]\n     * then this means that there are reserved bytes in the end ([endGap]). Such a reserved space in the end could be used\n     * to write size, hash and so on. Also it is useful when several buffers are connected into a chain and some\n     * primitive value (e.g. `kotlin.Int`) is separated into two chunks so bytes from the second chain could be copied\n     * to the reserved space of the first chunk and then the whole value could be read at once.\n     */\n    public var limit: Int\n        get() = bufferState.limit\n        private set(value) {\n            bufferState.limit = value\n        }\n\n    /**\n     * Number of bytes reserved in the end.\n     */\n    public inline val endGap: Int get() = capacity - limit\n\n    /**\n     * Buffer's capacity (including reserved [startGap] and [endGap]). Value for released buffer is unspecified.\n     */\n    public val capacity: Int = memory.size32\n\n    /**\n     * Number of bytes available for reading.\n     */\n    public inline val readRemaining: Int get() = writePosition - readPosition\n\n    /**\n     * Size of the free space available for writing in bytes.\n     */\n    public inline val writeRemaining: Int get() = limit - writePosition\n\n    /**\n     * User data: could be a session, connection or anything useful\n     */\n    @Deprecated(\"Will be removed. Inherit Buffer and add required fields instead.\")\n    @ExperimentalIoApi\n    public var attachment: Any?\n        get() = bufferState.attachment\n        set(value) {\n            bufferState.attachment = value\n        }\n\n    /**\n     * Discard [count] readable bytes.\n     *\n     * @throws EOFException if [count] is bigger than available bytes.\n     */\n    public fun discardExact(count: Int = readRemaining) {\n        if (count == 0) return\n\n        val newReadPosition = readPosition + count\n        if (count < 0 || newReadPosition > writePosition) {\n            discardFailed(count, readRemaining)\n        }\n        readPosition = newReadPosition\n    }\n\n    @Deprecated(\"Use discardExact instead.\", level = DeprecationLevel.ERROR)\n    public fun discard(count: Int): Int {\n        val size = minOf(count, readRemaining)\n        discardExact(size)\n        return size\n    }\n\n    @Deprecated(\"Use discardExact instead.\", level = DeprecationLevel.ERROR)\n    public final fun discard(count: Long): Long {\n        val size = minOf(count, readRemaining.toLong()).toInt()\n        discardExact(size)\n        return size.toLong()\n    }\n\n    @DangerousInternalIoApi\n    public fun commitWritten(count: Int) {\n        val newWritePosition = writePosition + count\n        if (count < 0 || newWritePosition > limit) {\n            commitWrittenFailed(count, writeRemaining)\n        }\n        writePosition = newWritePosition\n    }\n\n    /**\n     * @return `true` if there is free space\n     */\n    @PublishedApi\n    internal fun commitWrittenUntilIndex(position: Int): Boolean {\n        val limit = limit\n        if (position < writePosition) {\n            commitWrittenFailed(position - writePosition, writeRemaining)\n        }\n        if (position >= limit) {\n            if (position == limit) {\n                writePosition = position\n                return false\n            }\n            commitWrittenFailed(position - writePosition, writeRemaining)\n        }\n\n        writePosition = position\n        return true\n    }\n\n    internal fun discardUntilIndex(position: Int) {\n        if (position < 0 || position > writePosition) {\n            discardFailed(position - readPosition, readRemaining)\n        }\n\n        if (readPosition != position) {\n            readPosition = position\n        }\n    }\n\n    /**\n     * Rewind [readPosition] backward to make [count] bytes available for reading again.\n     * @throws IllegalArgumentException when [count] is too big and not enough bytes available before the [readPosition]\n     */\n    public fun rewind(count: Int = readPosition - startGap) {\n        val newReadPosition = readPosition - count\n        if (newReadPosition < startGap) {\n            rewindFailed(count, readPosition - startGap)\n        }\n        readPosition = newReadPosition\n    }\n\n    /**\n     * Reserve [startGap] bytes in the beginning.\n     * May move [readPosition] and [writePosition] if no bytes available for reading.\n     */\n    public fun reserveStartGap(startGap: Int) {\n        require(startGap >= 0) { \"startGap shouldn't be negative: $startGap\" }\n\n        if (readPosition >= startGap) {\n            this.startGap = startGap\n            return\n        }\n\n        if (readPosition == writePosition) {\n            if (startGap > limit) {\n                startGapReservationFailedDueToLimit(startGap)\n            }\n\n            this.writePosition = startGap\n            this.readPosition = startGap\n            this.startGap = startGap\n            return\n        }\n\n        startGapReservationFailed(startGap)\n    }\n\n    /**\n     * Reserve [endGap] bytes in the end.\n     * Could move [readPosition] and [writePosition] to reserve space but only when no bytes were written or\n     * all written bytes are marked as consumed (were read or discarded).\n     */\n    public fun reserveEndGap(endGap: Int) {\n        require(endGap >= 0) { \"endGap shouldn't be negative: $endGap\" }\n\n        val newLimit = capacity - endGap\n        if (newLimit >= writePosition) {\n            limit = newLimit\n            return\n        }\n\n        if (newLimit < 0) {\n            endGapReservationFailedDueToCapacity(endGap)\n        }\n        if (newLimit < startGap) {\n            endGapReservationFailedDueToStartGap(endGap)\n        }\n\n        if (readPosition == writePosition) {\n            limit = newLimit\n            readPosition = newLimit\n            writePosition = newLimit\n            return\n        }\n\n        endGapReservationFailedDueToContent(endGap)\n    }\n\n    /**\n     * Marks the whole buffer available for read and no for write\n     */\n    public fun resetForRead() {\n        startGap = 0\n        readPosition = 0\n\n        val capacity = capacity\n        writePosition = capacity\n    }\n\n    /**\n     * Marks all capacity writable except the start gap reserved before. The end gap reservation is discarded.\n     */\n    public fun resetForWrite() {\n        resetForWrite(capacity - startGap)\n    }\n\n    /**\n     * Marks up to [limit] bytes of the buffer available for write and no bytes for read.\n     * It does respect [startGap] already reserved. All extra bytes after the specified [limit]\n     * are considered as [endGap].\n     */\n    public fun resetForWrite(limit: Int) {\n        val startGap = startGap\n        readPosition = startGap\n        writePosition = startGap\n        this.limit = limit\n    }\n\n    /**\n     * Forget start/end gap reservations.\n     */\n    internal fun releaseGaps() {\n        releaseStartGap(0)\n        releaseEndGap()\n    }\n\n    internal fun releaseEndGap() {\n        limit = capacity\n    }\n\n    internal fun releaseStartGap(newReadPosition: Int) {\n        require(newReadPosition >= 0) { \"newReadPosition shouldn't be negative: $newReadPosition\" }\n        require(newReadPosition <= readPosition) {\n            \"newReadPosition shouldn't be ahead of the read position: $newReadPosition > $readPosition\"\n        }\n\n        readPosition = newReadPosition\n        if (startGap > newReadPosition) {\n            startGap = newReadPosition\n        }\n    }\n\n    protected open fun duplicateTo(copy: Buffer) {\n        copy.limit = limit\n        copy.startGap = startGap\n        copy.readPosition = readPosition\n        copy.writePosition = writePosition\n    }\n\n    /**\n     * Create a new [Buffer] instance pointing to the same memory and having the same positions.\n     */\n    public open fun duplicate(): Buffer = Buffer(memory).apply {\n        duplicateTo(this)\n    }\n\n    /**\n     * Peek the next unsigned byte or return `-1` if no more bytes available for reading. No bytes will be marked\n     * as consumed in any case.\n     * @return an unsigned byte or `-1` if not even a byte is available for reading.\n     * @see tryReadByte\n     * @see readByte\n     */\n    public fun tryPeekByte(): Int {\n        val readPosition = readPosition\n        if (readPosition == writePosition) return -1\n        return memory[readPosition].toInt() and 0xff\n    }\n\n    /**\n     * Read the next unsigned byte or return `-1` if no more bytes available for reading. The returned byte is marked\n     * as consumed.\n     * @return an unsigned byte or `-1` if not even a byte is available for reading.\n     * @see tryPeekByte\n     * @see readByte\n     */\n    public fun tryReadByte(): Int {\n        val readPosition = readPosition\n        if (readPosition == writePosition) return -1\n        this.readPosition = readPosition + 1\n        return memory[readPosition].toInt() and 0xff\n    }\n\n    /**\n     * Read the next byte or fail with [EOFException] if it's not available. The returned byte is marked\n     * as consumed.\n     * @throws EOFException when not even a byte is available for reading.\n     * @see tryPeekByte\n     * @see tryReadByte\n     */\n    public fun readByte(): Byte {\n        val readPosition = readPosition\n        if (readPosition == writePosition) {\n            throw EOFException(\"No readable bytes available.\")\n        }\n        this.readPosition = readPosition + 1\n        return memory[readPosition]\n    }\n\n    /**\n     * Write a byte [value] at [writePosition] (incremented when written successfully).\n     * @throws InsufficientSpaceException when no free space in the buffer.\n     */\n    public fun writeByte(value: Byte) {\n        val writePosition = writePosition\n        if (writePosition == limit) {\n            throw InsufficientSpaceException(\"No free space in the buffer to write a byte\")\n        }\n        memory[writePosition] = value\n        this.writePosition = writePosition + 1\n    }\n\n    /**\n     * Clear buffer's state: read/write positions, gaps and so on. Byte content is not cleaned-up.\n     */\n    public open fun reset() {\n        releaseGaps()\n        resetForWrite()\n    }\n\n    override fun toString(): String {\n        return \"Buffer($readRemaining used, $writeRemaining free, ${startGap + endGap} reserved of $capacity)\"\n    }\n\n    public companion object {\n        /**\n         * Number of bytes usually reserved in the end of chunk\n         * when several instances of [io.ktor.utils.io.core.internal.ChunkBuffer] are connected into a chain (usually inside of [ByteReadPacket]\n         * or [BytePacketBuilder])\n         */\n        @DangerousInternalIoApi\n        public const val ReservedSize: Int = 8\n\n        /**\n         * The empty buffer singleton: it has zero capacity for read and write.\n         */\n        @Suppress(\"DEPRECATION\")\n        public val Empty: Buffer get() = IoBuffer.Empty\n    }\n}\n\n/**\n * @return `true` if there are available bytes to be read\n */\npublic inline fun Buffer.canRead(): Boolean = writePosition > readPosition\n\n/**\n * @return `true` if there is free room to for write\n */\npublic inline fun Buffer.canWrite(): Boolean = limit > writePosition\n\n/**\n * Apply [block] of code with buffer's memory providing read range indices. The returned value of [block] lambda should\n * return number of bytes to be marked as consumed.\n * No read/write functions on this buffer should be called inside of [block] otherwise an undefined behaviour may occur\n * including data damage.\n */\n@DangerousInternalIoApi\npublic inline fun Buffer.read(block: (memory: Memory, start: Int, endExclusive: Int) -> Int): Int {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val rc = block(memory, readPosition, writePosition)\n    discardExact(rc)\n    return rc\n}\n\n/**\n * Apply [block] of code with buffer's memory providing write range indices. The returned value of [block] lambda should\n * return number of bytes were written.\n * o read/write functions on this buffer should be called inside of [block] otherwise an undefined behaviour may occur\n * including data damage.\n */\n@DangerousInternalIoApi\npublic inline fun Buffer.write(block: (memory: Memory, start: Int, endExclusive: Int) -> Int): Int {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val rc = block(memory, writePosition, limit)\n    commitWritten(rc)\n    return rc\n}\n\ninternal fun discardFailed(count: Int, readRemaining: Int): Nothing {\n    throw EOFException(\"Unable to discard $count bytes: only $readRemaining available for reading\")\n}\n\ninternal fun commitWrittenFailed(count: Int, writeRemaining: Int): Nothing {\n    throw EOFException(\"Unable to discard $count bytes: only $writeRemaining available for writing\")\n}\n\ninternal fun rewindFailed(count: Int, rewindRemaining: Int): Nothing {\n    throw IllegalArgumentException(\"Unable to rewind $count bytes: only $rewindRemaining could be rewinded\")\n}\n\ninternal fun Buffer.startGapReservationFailedDueToLimit(startGap: Int): Nothing {\n    if (startGap > capacity) {\n        throw IllegalArgumentException(\"Start gap $startGap is bigger than the capacity $capacity\")\n    }\n\n    throw IllegalStateException(\n        \"Unable to reserve $startGap start gap: there are already $endGap bytes reserved in the end\"\n    )\n}\n\ninternal fun Buffer.startGapReservationFailed(startGap: Int): Nothing {\n    throw IllegalStateException(\n        \"Unable to reserve $startGap start gap: \" +\n            \"there are already $readRemaining content bytes starting at offset $readPosition\"\n    )\n}\n\ninternal fun Buffer.endGapReservationFailedDueToCapacity(endGap: Int) {\n    throw IllegalArgumentException(\"End gap $endGap is too big: capacity is $capacity\")\n}\n\ninternal fun Buffer.endGapReservationFailedDueToStartGap(endGap: Int) {\n    throw IllegalArgumentException(\n        \"End gap $endGap is too big: there are already $startGap bytes reserved in the beginning\"\n    )\n}\n\ninternal fun Buffer.endGapReservationFailedDueToContent(endGap: Int) {\n    throw IllegalArgumentException(\n        \"Unable to reserve end gap $endGap:\" +\n            \" there are already $readRemaining content bytes at offset $readPosition\"\n    )\n}\n\ninternal fun Buffer.restoreStartGap(size: Int) {\n    releaseStartGap(readPosition - size)\n}\n\n@ExperimentalIoApi\npublic class InsufficientSpaceException(message: String = \"Not enough free space\") : Exception(message) {\n    public constructor(\n        size: Int,\n        availableSpace: Int\n    ) : this(\"Not enough free space to write $size bytes, available $availableSpace bytes.\")\n\n    public constructor(\n        name: String,\n        size: Int,\n        availableSpace: Int\n    ) : this(\"Not enough free space to write $name of $size bytes, available $availableSpace bytes.\")\n\n    public constructor(\n        size: Long,\n        availableSpace: Long\n    ) : this(\"Not enough free space to write $size bytes, available $availableSpace bytes.\")\n}\n","package io.ktor.utils.io\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.*\n\n/**\n * Channel for asynchronous reading of sequences of bytes.\n * This is a **single-reader channel**.\n *\n * Operations on this channel cannot be invoked concurrently.\n */\npublic expect interface ByteReadChannel {\n    /**\n     * Returns number of bytes that can be read without suspension. Read operations do no suspend and return\n     * immediately when this number is at least the number of bytes requested for read.\n     */\n    public val availableForRead: Int\n\n    /**\n     * Returns `true` if the channel is closed and no remaining bytes are available for read.\n     * It implies that [availableForRead] is zero.\n     */\n    public val isClosedForRead: Boolean\n\n    public val isClosedForWrite: Boolean\n\n    /**\n     * A closure causes exception or `null` if closed successfully or not yet closed\n     */\n    public val closedCause: Throwable?\n\n    /**\n     * Byte order that is used for multi-byte read operations\n     * (such as [readShort], [readInt], [readLong], [readFloat], and [readDouble]).\n     */\n    @Deprecated(\n        \"Setting byte order is no longer supported. Read/write in big endian and use reverseByteOrder() extensions.\",\n        level = DeprecationLevel.ERROR\n    )\n    public var readByteOrder: ByteOrder\n\n    /**\n     * Number of bytes read from the channel.\n     * It is not guaranteed to be atomic so could be updated in the middle of long-running read operation.\n     */\n    public val totalBytesRead: Long\n\n    /**\n     * Reads all available bytes to [dst] buffer and returns immediately or suspends if no bytes available\n     * @return number of bytes were read or `-1` if the channel has been closed\n     */\n    public suspend fun readAvailable(dst: ByteArray, offset: Int, length: Int): Int\n    public suspend fun readAvailable(dst: IoBuffer): Int\n\n    /**\n     * Reads all [length] bytes to [dst] buffer or fails if channel has been closed.\n     * Suspends if not enough bytes available.\n     */\n    public suspend fun readFully(dst: ByteArray, offset: Int, length: Int)\n    public suspend fun readFully(dst: IoBuffer, n: Int)\n\n    /**\n     * Reads the specified amount of bytes and makes a byte packet from them. Fails if channel has been closed\n     * and not enough bytes available. Accepts [headerSizeHint] to be provided, see [BytePacketBuilder].\n     */\n    public suspend fun readPacket(size: Int, headerSizeHint: Int): ByteReadPacket\n\n    /**\n     * Reads up to [limit] bytes and makes a byte packet or until end of stream encountered.\n     * Accepts [headerSizeHint] to be provided, see [BytePacketBuilder].\n     */\n    public suspend fun readRemaining(limit: Long, headerSizeHint: Int): ByteReadPacket\n\n    /**\n     * Reads a long number (suspending if not enough bytes available) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    public suspend fun readLong(): Long\n\n    /**\n     * Reads an int number (suspending if not enough bytes available) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    public suspend fun readInt(): Int\n\n    /**\n     * Reads a short number (suspending if not enough bytes available) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    public suspend fun readShort(): Short\n\n    /**\n     * Reads a byte (suspending if no bytes available yet) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    public suspend fun readByte(): Byte\n\n    /**\n     * Reads a boolean value (suspending if no bytes available yet) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    public suspend fun readBoolean(): Boolean\n\n    /**\n     * Reads double number (suspending if not enough bytes available) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    public suspend fun readDouble(): Double\n\n    /**\n     * Reads float number (suspending if not enough bytes available) or fails if channel has been closed\n     * and not enough bytes.\n     */\n    public suspend fun readFloat(): Float\n\n    /**\n     * Starts non-suspendable read session. After channel preparation [consumer] lambda will be invoked immediately\n     * event if there are no bytes available for read yet.\n     */\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Use read { } instead.\")\n    public fun readSession(consumer: ReadSession.() -> Unit)\n\n    /**\n     * Starts a suspendable read session. After channel preparation [consumer] lambda will be invoked immediately\n     * even if there are no bytes available for read yet. [consumer] lambda could suspend as much as needed.\n     */\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Use read { } instead.\")\n    public suspend fun readSuspendableSession(consumer: suspend SuspendableReadSession.() -> Unit)\n\n    /**\n     * Reads a line of UTF-8 characters to the specified [out] buffer up to [limit] characters.\n     * Supports both CR-LF and LF line endings. No line ending characters will be appended to [out] buffer.\n     * Throws an exception if the specified [limit] has been exceeded.\n     *\n     * @return `true` if line has been read (possibly empty) or `false` if channel has been closed\n     * and no characters were read.\n     */\n    public suspend fun <A : Appendable> readUTF8LineTo(out: A, limit: Int): Boolean\n\n    /**\n     * Reads a line of UTF-8 characters up to [limit] characters.\n     * Supports both CR-LF and LF line endings.\n     * Throws an exception if the specified [limit] has been exceeded.\n     *\n     * @return a line string with no line endings or `null` of channel has been closed\n     * and no characters were read.\n     */\n    public suspend fun readUTF8Line(limit: Int): String?\n\n    /**\n     * Close channel with optional [cause] cancellation. Unlike [ByteWriteChannel.close] that could close channel\n     * normally, cancel does always close with error so any operations on this channel will always fail\n     * and all suspensions will be resumed with exception.\n     *\n     * Please note that if the channel has been provided by [reader] or [writer] then the corresponding owning\n     * coroutine will be cancelled as well\n     *\n     * @see ByteWriteChannel.close\n     */\n    public fun cancel(cause: Throwable?): Boolean\n\n    /**\n     * Discard up to [max] bytes\n     *\n     * @return number of bytes were discarded\n     */\n    public suspend fun discard(max: Long): Long\n\n    /**\n     * Try to copy at least [min] but up to [max] bytes to the specified [destination] buffer from this input\n     * skipping [offset] bytes. If there are not enough bytes available to provide [min] bytes after skipping [offset]\n     * bytes then it will trigger the underlying source reading first and after that will\n     * simply copy available bytes even if EOF encountered so [min] is not a requirement but a desired number of bytes.\n     * It is safe to specify [max] greater than the destination free space.\n     * `min` shouldn't be bigger than the [destination] free space.\n     * This function could trigger the underlying source suspending reading.\n     * It is allowed to specify too big [offset] so in this case this function will always return `0` after prefetching\n     * all underlying bytes but note that it may lead to significant memory consumption.\n     * This function usually copy more bytes than [min] (unless `max = min`) but it is not guaranteed.\n     * When `0` is returned with `offset = 0` then it makes sense to check [isClosedForRead].\n     *\n     * @param destination to write bytes\n     * @param offset to skip input\n     * @param min bytes to be copied, shouldn't be greater than the buffer free space. Could be `0`.\n     * @param max bytes to be copied even if there are more bytes buffered, could be [Int.MAX_VALUE].\n     * @return number of bytes copied to the [destination] possibly `0`\n     */\n    public suspend fun peekTo(\n        destination: Memory,\n        destinationOffset: Long,\n        offset: Long = 0,\n        min: Long = 1,\n        max: Long = Long.MAX_VALUE\n    ): Long\n\n    public companion object {\n        public val Empty: ByteReadChannel\n    }\n}\n\n/**\n * Reads the specified amount of bytes and makes a byte packet from them. Fails if channel has been closed\n * and not enough bytes available.\n */\npublic suspend fun ByteReadChannel.readPacket(size: Int): ByteReadPacket = readPacket(size, 0)\n\n/**\n * Reads up to [limit] bytes and makes a byte packet or until end of stream encountered.\n */\npublic suspend fun ByteReadChannel.readRemaining(limit: Long): ByteReadPacket = readRemaining(limit, 0)\n\n/**\n * Reads all remaining bytes and makes a byte packet\n */\npublic suspend fun ByteReadChannel.readRemaining(): ByteReadPacket = readRemaining(Long.MAX_VALUE, 0)\n\npublic suspend fun ByteReadChannel.readFully(dst: IoBuffer) {\n    readFully(dst, dst.writeRemaining)\n}\n\npublic suspend fun ByteReadChannel.readUTF8LineTo(out: Appendable): Boolean {\n    return readUTF8LineTo(out, Int.MAX_VALUE)\n}\n\npublic suspend fun ByteReadChannel.readUTF8Line(): String? {\n    return readUTF8Line(Int.MAX_VALUE)\n}\n\npublic fun ByteReadChannel.cancel(): Boolean = cancel(null)\n\n/**\n * Discards all bytes in the channel and suspends until end of stream.\n */\npublic suspend fun ByteReadChannel.discard(): Long = discard(Long.MAX_VALUE)\n\n/**\n * Discards exactly [n] bytes or fails if not enough bytes in the channel\n */\npublic suspend inline fun ByteReadChannel.discardExact(n: Long) {\n    if (discard(n) != n) throw EOFException(\"Unable to discard $n bytes\")\n}\n\npublic suspend fun ByteReadChannel.readAvailable(dst: ByteArray): Int = readAvailable(dst, 0, dst.size)\n\npublic suspend fun ByteReadChannel.readFully(dst: ByteArray): Unit = readFully(dst, 0, dst.size)\n\npublic expect suspend fun ByteReadChannel.joinTo(dst: ByteWriteChannel, closeOnEnd: Boolean)\n\n/**\n * Reads bytes from receiver channel and writes them to [dst] channel.\n * Closes [dst] channel if fails to read or write with cause exception.\n * @return a number of copied bytes\n */\npublic suspend fun ByteReadChannel.copyTo(dst: ByteWriteChannel): Long = copyTo(dst, limit = Long.MAX_VALUE)\n\n/**\n * Reads up to [limit] bytes from receiver channel and writes them to [dst] channel.\n * Closes [dst] channel if fails to read or write with cause exception.\n * @return a number of copied bytes\n */\npublic expect suspend fun ByteReadChannel.copyTo(dst: ByteWriteChannel, limit: Long): Long\n\n/**\n * Reads all the bytes from receiver channel and writes them to [dst] channel and then closes it.\n * Closes [dst] channel if fails to read or write with cause exception.\n * @return a number of copied bytes\n */\npublic suspend fun ByteReadChannel.copyAndClose(dst: ByteWriteChannel, limit: Long = Long.MAX_VALUE): Long {\n    val count = copyTo(dst, limit)\n    dst.close()\n    return count\n}\n","package io.ktor.utils.io\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.*\n\n/**\n * Channel for asynchronous writing of sequences of bytes.\n * This is a **single-writer channel**.\n *\n * Operations on this channel cannot be invoked concurrently, unless explicitly specified otherwise\n * in description. Exceptions are [close] and [flush].\n */\npublic expect interface ByteWriteChannel {\n    /**\n     * Returns number of bytes that can be written without suspension. Write operations do no suspend and return\n     * immediately when this number is at least the number of bytes requested for write.\n     */\n    public val availableForWrite: Int\n\n    /**\n     * Returns `true` is channel has been closed and attempting to write to the channel will cause an exception.\n     */\n    public val isClosedForWrite: Boolean\n\n    /**\n     * Returns `true` if channel flushes automatically all pending bytes after every write function call.\n     * If `false` then flush only happens at manual [flush] invocation or when the buffer is full.\n     */\n    public val autoFlush: Boolean\n\n    /**\n     * Byte order that is used for multi-byte write operations\n     * (such as [writeShort], [writeInt], [writeLong], [writeFloat], and [writeDouble]).\n     */\n    @Deprecated(\n        \"Setting byte order is no longer supported. Read/write in big endian and use reverseByteOrder() extensions.\",\n        level = DeprecationLevel.ERROR\n    )\n    public var writeByteOrder: ByteOrder\n\n    /**\n     * Number of bytes written to the channel.\n     * It is not guaranteed to be atomic so could be updated in the middle of write operation.\n     */\n    public val totalBytesWritten: Long\n\n    /**\n     * A closure causes exception or `null` if closed successfully or not yet closed\n     */\n    public val closedCause: Throwable?\n\n    /**\n     * Writes as much as possible and only suspends if buffer is full\n     */\n    public suspend fun writeAvailable(src: ByteArray, offset: Int, length: Int): Int\n\n    public suspend fun writeAvailable(src: IoBuffer): Int\n\n    /**\n     * Writes all [src] bytes and suspends until all bytes written. Causes flush if buffer filled up or when [autoFlush]\n     * Crashes if channel get closed while writing.\n     */\n    public suspend fun writeFully(src: ByteArray, offset: Int, length: Int)\n\n    public suspend fun writeFully(src: IoBuffer)\n\n    public suspend fun writeFully(src: Buffer)\n\n    public suspend fun writeFully(memory: Memory, startIndex: Int, endIndex: Int)\n\n    @Deprecated(\"Use write { } instead.\")\n    @ExperimentalIoApi\n    public suspend fun writeSuspendSession(visitor: suspend WriterSuspendSession.() -> Unit)\n\n    /**\n     * Writes a [packet] fully or fails if channel get closed before the whole packet has been written\n     */\n    public suspend fun writePacket(packet: ByteReadPacket)\n\n    /**\n     * Writes long number and suspends until written.\n     * Crashes if channel get closed while writing.\n     */\n    public suspend fun writeLong(l: Long)\n\n    /**\n     * Writes int number and suspends until written.\n     * Crashes if channel get closed while writing.\n     */\n    public suspend fun writeInt(i: Int)\n\n    /**\n     * Writes short number and suspends until written.\n     * Crashes if channel get closed while writing.\n     */\n    public suspend fun writeShort(s: Short)\n\n    /**\n     * Writes byte and suspends until written.\n     * Crashes if channel get closed while writing.\n     */\n    public suspend fun writeByte(b: Byte)\n\n    /**\n     * Writes double number and suspends until written.\n     * Crashes if channel get closed while writing.\n     */\n    public suspend fun writeDouble(d: Double)\n\n    /**\n     * Writes float number and suspends until written.\n     * Crashes if channel get closed while writing.\n     */\n    public suspend fun writeFloat(f: Float)\n\n    /**\n     * Invokes [block] when at least 1 byte is available for write.\n     */\n    @ExperimentalIoApi\n    public suspend fun awaitFreeSpace()\n\n    /**\n     * Closes this channel with an optional exceptional [cause].\n     * It flushes all pending write bytes (via [flush]).\n     * This is an idempotent operation -- repeated invocations of this function have no effect and return `false`.\n     *\n     * A channel that was closed without a [cause], is considered to be _closed normally_.\n     * A channel that was closed with non-null [cause] is called a _failed channel_. Attempts to read or\n     * write on a failed channel throw this cause exception.\n     *\n     * After invocation of this operation [isClosedForWrite] starts returning `true` and\n     * all subsequent write operations throw [ClosedWriteChannelException] or the specified [cause].\n     * However, [isClosedForRead][ByteReadChannel.isClosedForRead] on the side of [ByteReadChannel]\n     * starts returning `true` only after all written bytes have been read.\n     *\n     * Please note that if the channel has been closed with cause and it has been provided by [reader] or [writer]\n     * coroutine then the corresponding coroutine will be cancelled with [cause]. If no [cause] provided then no\n     * cancellation will be propagated.\n     */\n    public fun close(cause: Throwable?): Boolean\n\n    /**\n     * Flushes all pending write bytes making them available for read.\n     *\n     * This function is thread-safe and can be invoked in any thread at any time.\n     * It does nothing when invoked on a closed channel.\n     */\n    public fun flush()\n}\n\npublic suspend fun ByteWriteChannel.writeAvailable(src: ByteArray): Int = writeAvailable(src, 0, src.size)\npublic suspend fun ByteWriteChannel.writeFully(src: ByteArray): Unit = writeFully(src, 0, src.size)\n\npublic suspend fun ByteWriteChannel.writeShort(s: Int) {\n    return writeShort((s and 0xffff).toShort())\n}\n\npublic suspend fun ByteWriteChannel.writeShort(s: Int, byteOrder: ByteOrder) {\n    return writeShort((s and 0xffff).toShort(), byteOrder)\n}\n\npublic suspend fun ByteWriteChannel.writeByte(b: Int) {\n    return writeByte((b and 0xff).toByte())\n}\n\npublic suspend fun ByteWriteChannel.writeInt(i: Long) {\n    return writeInt(i.toInt())\n}\n\npublic suspend fun ByteWriteChannel.writeInt(i: Long, byteOrder: ByteOrder) {\n    return writeInt(i.toInt(), byteOrder)\n}\n\n/**\n * Closes this channel with no failure (successfully)\n */\npublic fun ByteWriteChannel.close(): Boolean = close(null)\n\npublic suspend fun ByteWriteChannel.writeStringUtf8(s: CharSequence) {\n    val packet = buildPacket {\n        writeStringUtf8(s)\n    }\n\n    return writePacket(packet)\n}\n\n/*\nTODO\npublic suspend fun ByteWriteChannel.writeStringUtf8(s: CharBuffer) {\n    val packet = buildPacket {\n        writeStringUtf8(s)\n    }\n\n    return writePacket(packet)\n}*/\n\npublic suspend fun ByteWriteChannel.writeStringUtf8(s: String) {\n    val packet = buildPacket {\n        writeText(s)\n    }\n\n    return writePacket(packet)\n}\n\npublic suspend fun ByteWriteChannel.writeBoolean(b: Boolean) {\n    return writeByte(if (b) 1 else 0)\n}\n\n/**\n * Writes UTF16 character\n */\npublic suspend fun ByteWriteChannel.writeChar(ch: Char) {\n    return writeShort(ch.toInt())\n}\n\npublic suspend inline fun ByteWriteChannel.writePacket(headerSizeHint: Int = 0, builder: BytePacketBuilder.() -> Unit) {\n    return writePacket(buildPacket(headerSizeHint, builder))\n}\n\npublic suspend fun ByteWriteChannel.writePacketSuspend(builder: suspend BytePacketBuilder.() -> Unit) {\n    return writePacket(buildPacket { builder() })\n}\n\n/**\n * Indicates attempt to write on [isClosedForWrite][ByteWriteChannel.isClosedForWrite] channel\n * that was closed without a cause. A _failed_ channel rethrows the original [close][ByteWriteChannel.close] cause\n * exception on send attempts.\n */\npublic class ClosedWriteChannelException(message: String?) : CancellationException(message)\n","package io.ktor.utils.io\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.*\n\npublic suspend inline fun ByteReadChannel.readShort(byteOrder: ByteOrder): Short {\n    return readShort().reverseIfNeeded(byteOrder) { reverseByteOrder() }\n}\n\npublic suspend inline fun ByteReadChannel.readInt(byteOrder: ByteOrder): Int {\n    return readInt().reverseIfNeeded(byteOrder) { reverseByteOrder() }\n}\n\npublic suspend inline fun ByteReadChannel.readLong(byteOrder: ByteOrder): Long {\n    return readLong().reverseIfNeeded(byteOrder) { reverseByteOrder() }\n}\n\npublic suspend inline fun ByteReadChannel.readFloat(byteOrder: ByteOrder): Float {\n    return readFloat().reverseIfNeeded(byteOrder) { reverseByteOrder() }\n}\n\npublic suspend inline fun ByteReadChannel.readDouble(byteOrder: ByteOrder): Double {\n    return readDouble().reverseIfNeeded(byteOrder) { reverseByteOrder() }\n}\n\npublic suspend inline fun ByteReadChannel.readShortLittleEndian(): Short {\n    return toLittleEndian(readShort()) { reverseByteOrder() }\n}\n\npublic suspend inline fun ByteReadChannel.readIntLittleEndian(): Int {\n    return toLittleEndian(readInt()) { reverseByteOrder() }\n}\n\npublic suspend inline fun ByteReadChannel.readLongLittleEndian(): Long {\n    return toLittleEndian(readLong()) { reverseByteOrder() }\n}\n\npublic suspend inline fun ByteReadChannel.readFloatLittleEndian(): Float {\n    return toLittleEndian(readFloat()) { reverseByteOrder() }\n}\n\npublic suspend inline fun ByteReadChannel.readDoubleLittleEndian(): Double {\n    return toLittleEndian(readDouble()) { reverseByteOrder() }\n}\n\npublic suspend fun ByteWriteChannel.writeShort(value: Short, byteOrder: ByteOrder) {\n    writeShort(value.reverseIfNeeded(byteOrder) { reverseByteOrder() })\n}\n\npublic suspend fun ByteWriteChannel.writeInt(value: Int, byteOrder: ByteOrder) {\n    writeInt(value.reverseIfNeeded(byteOrder) { reverseByteOrder() })\n}\n\npublic suspend fun ByteWriteChannel.writeLong(value: Long, byteOrder: ByteOrder) {\n    writeLong(value.reverseIfNeeded(byteOrder) { reverseByteOrder() })\n}\n\npublic suspend fun ByteWriteChannel.writeFloat(value: Float, byteOrder: ByteOrder) {\n    writeFloat(value.reverseIfNeeded(byteOrder) { reverseByteOrder() })\n}\n\npublic suspend fun ByteWriteChannel.writeDouble(value: Double, byteOrder: ByteOrder) {\n    writeDouble(value.reverseIfNeeded(byteOrder) { reverseByteOrder() })\n}\n\npublic suspend fun ByteWriteChannel.writeShortLittleEndian(value: Short) {\n    writeShort(toLittleEndian(value) { reverseByteOrder() })\n}\n\npublic suspend fun ByteWriteChannel.writeIntLittleEndian(value: Int) {\n    writeInt(toLittleEndian(value) { reverseByteOrder() })\n}\n\npublic suspend fun ByteWriteChannel.writeLongLittleEndian(value: Long) {\n    writeLong(toLittleEndian(value) { reverseByteOrder() })\n}\n\npublic suspend fun ByteWriteChannel.writeFloatLittleEndian(value: Float) {\n    writeFloat(toLittleEndian(value) { reverseByteOrder() })\n}\n\npublic suspend fun ByteWriteChannel.writeDoubleLittleEndian(value: Double) {\n    writeDouble(toLittleEndian(value) { reverseByteOrder() })\n}\n\n@PublishedApi\n@Suppress(\"DEPRECATION_ERROR\")\ninternal inline fun <T> ByteReadChannel.toLittleEndian(value: T, reverseBlock: T.() -> T): T {\n    return when (readByteOrder) {\n        ByteOrder.LITTLE_ENDIAN -> value\n        else -> value.reverseBlock()\n    }\n}\n\n@Suppress(\"DEPRECATION_ERROR\")\nprivate inline fun <T> ByteWriteChannel.toLittleEndian(value: T, reverseBlock: T.() -> T): T {\n    return when (writeByteOrder) {\n        ByteOrder.LITTLE_ENDIAN -> value\n        else -> value.reverseBlock()\n    }\n}\n\n@PublishedApi\ninternal inline fun <T> T.reverseIfNeeded(byteOrder: ByteOrder, reverseBlock: T.() -> T): T {\n    return when (byteOrder) {\n        ByteOrder.BIG_ENDIAN -> this\n        else -> reverseBlock()\n    }\n}\n","package io.ktor.utils.io\n\nimport io.ktor.utils.io.bits.Memory\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.core.internal.ChunkBuffer\n\n/**\n * Await for [desiredSpace] will be available for write and invoke [block] function providing [Memory] instance and\n * the corresponding range suitable for wiring in the memory. The block function should return number of bytes were\n * written, possibly 0.\n *\n * Similar to [ByteReadChannel.read], this function may invoke block function with lesser memory range when the\n * specified [desiredSpace] is bigger that the buffer's capacity\n * or when it is impossible to represent all [desiredSpace] bytes as a single memory range\n * due to internal implementation reasons.\n */\n@ExperimentalIoApi\npublic suspend inline fun ByteWriteChannel.write(\n    desiredSpace: Int = 1,\n    block: (freeSpace: Memory, startOffset: Long, endExclusive: Long) -> Int\n): Int {\n    val buffer = requestWriteBuffer(desiredSpace) ?: Buffer.Empty\n    var bytesWritten = 0\n    try {\n        bytesWritten = block(buffer.memory, buffer.writePosition.toLong(), buffer.limit.toLong())\n        buffer.commitWritten(bytesWritten)\n        return bytesWritten\n    } finally {\n        completeWriting(buffer, bytesWritten)\n    }\n}\n\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Use writeMemory instead.\")\npublic interface WriterSession {\n    public fun request(min: Int): IoBuffer?\n    public fun written(n: Int)\n    public fun flush()\n}\n\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Use writeMemory instead.\")\npublic interface WriterSuspendSession : WriterSession {\n    public suspend fun tryAwait(n: Int)\n}\n\n@Suppress(\"DEPRECATION\")\ninternal interface HasWriteSession {\n    public fun beginWriteSession(): WriterSuspendSession?\n    public fun endWriteSession(written: Int)\n}\n\n@PublishedApi\ninternal suspend fun ByteWriteChannel.requestWriteBuffer(desiredSpace: Int): Buffer? {\n    val session = writeSessionFor()\n    if (session != null) {\n        val buffer = session.request(desiredSpace)\n        if (buffer != null) {\n            return buffer\n        }\n\n        return writeBufferSuspend(session, desiredSpace)\n    }\n\n    return writeBufferFallback()\n}\n\n@PublishedApi\ninternal suspend fun ByteWriteChannel.completeWriting(buffer: Buffer, written: Int) {\n    if (this is HasWriteSession) {\n        endWriteSession(written)\n        return\n    }\n\n    return completeWritingFallback(buffer)\n}\n\n@Suppress(\"DEPRECATION\")\nprivate suspend fun ByteWriteChannel.completeWritingFallback(buffer: Buffer) {\n    if (buffer is IoBuffer) {\n        writeFully(buffer)\n        buffer.release(IoBuffer.Pool)\n        return\n    }\n\n    throw UnsupportedOperationException(\"Only IoBuffer instance is supported.\")\n}\n\n@Suppress(\"DEPRECATION\")\nprivate suspend fun writeBufferSuspend(session: WriterSuspendSession, desiredSpace: Int): Buffer? {\n    session.tryAwait(desiredSpace)\n    return session.request(desiredSpace) ?: session.request(1)\n}\n\nprivate fun writeBufferFallback(): Buffer? {\n    return ChunkBuffer.Pool.borrow().also { it.resetForWrite(); it.reserveEndGap(Buffer.ReservedSize) }\n}\n\n@Suppress(\"DEPRECATION\", \"NOTHING_TO_INLINE\")\nprivate inline fun ByteWriteChannel.writeSessionFor(): WriterSuspendSession? = when {\n    this is HasWriteSession -> beginWriteSession()\n    else -> null\n}\n","package io.ktor.utils.io.core.internal\n\n@PublishedApi\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun Long.toIntOrFail(name: String): Int {\n    if (this >= Int.MAX_VALUE) failLongToIntConversion(this, name)\n    return toInt()\n}\n\n@PublishedApi\ninternal fun failLongToIntConversion(value: Long, name: String): Nothing =\n    throw IllegalArgumentException(\"Long value $value of $name doesn't fit into 32-bit integer\")\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.bits\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset].\n */\npublic inline fun Memory.loadByteArray(\n    offset: Int,\n    destination: ByteArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    copyTo(destination, offset, count, destinationOffset)\n}\n\n/**\n * Copies unsigned shorts integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic inline fun Memory.loadByteArray(\n    offset: Long,\n    destination: ByteArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    copyTo(destination, offset, count, destinationOffset)\n}\n\n/**\n * Copies unsigned shorts integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic inline fun Memory.loadUByteArray(\n    offset: Int,\n    destination: UByteArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    copyTo(destination.asByteArray(), offset, count, destinationOffset)\n}\n\n/**\n * Copies unsigned shorts integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic inline fun Memory.loadUByteArray(\n    offset: Long,\n    destination: UByteArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    copyTo(destination.asByteArray(), offset, count, destinationOffset)\n}\n\n/**\n * Copies short integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic expect fun Memory.loadShortArray(\n    offset: Int,\n    destination: ShortArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies short integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic expect fun Memory.loadShortArray(\n    offset: Long,\n    destination: ShortArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies unsigned shorts integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic inline fun Memory.loadUShortArray(\n    offset: Int,\n    destination: UShortArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    loadShortArray(offset, destination.asShortArray(), destinationOffset, count)\n}\n\n/**\n * Copies unsigned shorts integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic inline fun Memory.loadUShortArray(\n    offset: Long,\n    destination: UShortArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    loadShortArray(offset, destination.asShortArray(), destinationOffset, count)\n}\n\n/**\n * Copies regular integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic expect fun Memory.loadIntArray(\n    offset: Int,\n    destination: IntArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies regular integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic expect fun Memory.loadIntArray(\n    offset: Long,\n    destination: IntArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies unsigned integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic inline fun Memory.loadUIntArray(\n    offset: Int,\n    destination: UIntArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    loadIntArray(offset, destination.asIntArray(), destinationOffset, count)\n}\n\n/**\n * Copies unsigned integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic inline fun Memory.loadUIntArray(\n    offset: Long,\n    destination: UIntArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    loadIntArray(offset, destination.asIntArray(), destinationOffset, count)\n}\n\n/**\n * Copies long integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic expect fun Memory.loadLongArray(\n    offset: Int,\n    destination: LongArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies long integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic expect fun Memory.loadLongArray(\n    offset: Long,\n    destination: LongArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies unsigned long integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic inline fun Memory.loadULongArray(\n    offset: Int,\n    destination: ULongArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    loadLongArray(offset, destination.asLongArray(), destinationOffset, count)\n}\n\n/**\n * Copies unsigned long integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic inline fun Memory.loadULongArray(\n    offset: Long,\n    destination: ULongArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n) {\n    loadLongArray(offset, destination.asLongArray(), destinationOffset, count)\n}\n\n/**\n * Copies floating point numbers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic expect fun Memory.loadFloatArray(\n    offset: Int,\n    destination: FloatArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies floating point numbers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic expect fun Memory.loadFloatArray(\n    offset: Long,\n    destination: FloatArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies floating point numbers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic expect fun Memory.loadDoubleArray(\n    offset: Int,\n    destination: DoubleArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies floating point numbers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic expect fun Memory.loadDoubleArray(\n    offset: Long,\n    destination: DoubleArray,\n    destinationOffset: Int = 0,\n    count: Int = destination.size - destinationOffset\n)\n\n/**\n * Copies unsigned shorts integers from the [source] array at [sourceOffset] to this memory at the specified [offset].\n * @param sourceOffset items\n */\npublic inline fun Memory.storeByteArray(\n    offset: Int,\n    source: ByteArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    source.useMemory(sourceOffset, count) { sourceMemory ->\n        sourceMemory.copyTo(this, 0, count, offset)\n    }\n}\n\n/**\n * Copies unsigned shorts integers from the [source] array at [sourceOffset] to this memory at the specified [offset].\n * @param sourceOffset items\n */\npublic inline fun Memory.storeByteArray(\n    offset: Long,\n    source: ByteArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    source.useMemory(sourceOffset, count) { sourceMemory ->\n        sourceMemory.copyTo(this, 0L, count.toLong(), offset)\n    }\n}\n\n/**\n * Copies unsigned shorts integers from the [source] array at [sourceOffset] to this memory at the specified [offset].\n * @param sourceOffset items\n */\npublic inline fun Memory.storeUByteArray(\n    offset: Int,\n    source: UByteArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    storeByteArray(offset, source.asByteArray(), sourceOffset, count)\n}\n\n/**\n * Copies unsigned shorts integers from the [source] array at [sourceOffset] to this memory at the specified [offset].\n * @param sourceOffset items\n */\npublic inline fun Memory.storeUByteArray(\n    offset: Long,\n    source: UByteArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    storeByteArray(offset, source.asByteArray(), sourceOffset, count)\n}\n\n/**\n * Copies short integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic expect fun Memory.storeShortArray(\n    offset: Int,\n    source: ShortArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies short integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic expect fun Memory.storeShortArray(\n    offset: Long,\n    source: ShortArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies unsigned shorts integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic inline fun Memory.storeUShortArray(\n    offset: Int,\n    source: UShortArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    storeShortArray(offset, source.asShortArray(), sourceOffset, count)\n}\n\n/**\n * Copies unsigned shorts integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic inline fun Memory.storeUShortArray(\n    offset: Long,\n    source: UShortArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    storeShortArray(offset, source.asShortArray(), sourceOffset, count)\n}\n\n/**\n * Copies regular integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic expect fun Memory.storeIntArray(\n    offset: Int,\n    source: IntArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies regular integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic expect fun Memory.storeIntArray(\n    offset: Long,\n    source: IntArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies unsigned integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic inline fun Memory.storeUIntArray(\n    offset: Int,\n    source: UIntArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    storeIntArray(offset, source.asIntArray(), sourceOffset, count)\n}\n\n/**\n * Copies unsigned integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic inline fun Memory.storeUIntArray(\n    offset: Long,\n    source: UIntArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    storeIntArray(offset, source.asIntArray(), sourceOffset, count)\n}\n\n/**\n * Copies long integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic expect fun Memory.storeLongArray(\n    offset: Int,\n    source: LongArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies long integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic expect fun Memory.storeLongArray(\n    offset: Long,\n    source: LongArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies unsigned long integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic inline fun Memory.storeULongArray(\n    offset: Int,\n    source: ULongArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    storeLongArray(offset, source.asLongArray(), sourceOffset, count)\n}\n\n/**\n * Copies unsigned long integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic inline fun Memory.storeULongArray(\n    offset: Long,\n    source: ULongArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n) {\n    storeLongArray(offset, source.asLongArray(), sourceOffset, count)\n}\n\n/**\n * Copies floating point numbers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic expect fun Memory.storeFloatArray(\n    offset: Int,\n    source: FloatArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies floating point numbers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic expect fun Memory.storeFloatArray(\n    offset: Long,\n    source: FloatArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies floating point numbers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic expect fun Memory.storeDoubleArray(\n    offset: Int,\n    source: DoubleArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n\n/**\n * Copies floating point numbers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic expect fun Memory.storeDoubleArray(\n    offset: Long,\n    source: DoubleArray,\n    sourceOffset: Int = 0,\n    count: Int = source.size - sourceOffset\n)\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"UArraysKt\")\n@file:kotlin.jvm.JvmPackageName(\"kotlin.collections.unsigned\")\n\npackage kotlin.collections\n\n//\n// NOTE: THIS FILE IS AUTO-GENERATED by the GenerateStandardLib.kt\n// See: https://github.com/JetBrains/kotlin/tree/master/libraries/stdlib\n//\n\nimport kotlin.random.*\nimport kotlin.ranges.contains\nimport kotlin.ranges.reversed\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component1(): UInt {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component1(): ULong {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component1(): UByte {\n    return get(0)\n}\n\n/**\n * Returns 1st *element* from the array.\n * \n * If the size of this array is less than 1, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component1(): UShort {\n    return get(0)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component2(): UInt {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component2(): ULong {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component2(): UByte {\n    return get(1)\n}\n\n/**\n * Returns 2nd *element* from the array.\n * \n * If the size of this array is less than 2, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component2(): UShort {\n    return get(1)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component3(): UInt {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component3(): ULong {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component3(): UByte {\n    return get(2)\n}\n\n/**\n * Returns 3rd *element* from the array.\n * \n * If the size of this array is less than 3, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component3(): UShort {\n    return get(2)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component4(): UInt {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component4(): ULong {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component4(): UByte {\n    return get(3)\n}\n\n/**\n * Returns 4th *element* from the array.\n * \n * If the size of this array is less than 4, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component4(): UShort {\n    return get(3)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.component5(): UInt {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.component5(): ULong {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.component5(): UByte {\n    return get(4)\n}\n\n/**\n * Returns 5th *element* from the array.\n * \n * If the size of this array is less than 5, throws an [IndexOutOfBoundsException] except in Kotlin/JS\n * where the behavior is unspecified.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.component5(): UShort {\n    return get(4)\n}\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UIntArray.elementAt(index: Int): UInt\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun ULongArray.elementAt(index: Int): ULong\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UByteArray.elementAt(index: Int): UByte\n\n/**\n * Returns an element at the given [index] or throws an [IndexOutOfBoundsException] if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAt\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UShortArray.elementAt(index: Int): UShort\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.elementAtOrElse(index: Int, defaultValue: (Int) -> UInt): UInt {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.elementAtOrElse(index: Int, defaultValue: (Int) -> ULong): ULong {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.elementAtOrElse(index: Int, defaultValue: (Int) -> UByte): UByte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrElse\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.elementAtOrElse(index: Int, defaultValue: (Int) -> UShort): UShort {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.elementAtOrNull(index: Int): UInt? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.elementAtOrNull(index: Int): ULong? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.elementAtOrNull(index: Int): UByte? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.elementAtOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.elementAtOrNull(index: Int): UShort? {\n    return this.getOrNull(index)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.find(predicate: (UInt) -> Boolean): UInt? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.find(predicate: (ULong) -> Boolean): ULong? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.find(predicate: (UByte) -> Boolean): UByte? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.find(predicate: (UShort) -> Boolean): UShort? {\n    return firstOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.findLast(predicate: (UInt) -> Boolean): UInt? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.findLast(predicate: (ULong) -> Boolean): ULong? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.findLast(predicate: (UByte) -> Boolean): UByte? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.find\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.findLast(predicate: (UShort) -> Boolean): UShort? {\n    return lastOrNull(predicate)\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.first(): UInt {\n    return storage.first().toUInt()\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.first(): ULong {\n    return storage.first().toULong()\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.first(): UByte {\n    return storage.first().toUByte()\n}\n\n/**\n * Returns first element.\n * @throws [NoSuchElementException] if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.first(): UShort {\n    return storage.first().toUShort()\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.first(predicate: (UInt) -> Boolean): UInt {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.first(predicate: (ULong) -> Boolean): ULong {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.first(predicate: (UByte) -> Boolean): UByte {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element matching the given [predicate].\n * @throws [NoSuchElementException] if no such element is found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.first(predicate: (UShort) -> Boolean): UShort {\n    for (element in this) if (predicate(element)) return element\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.firstOrNull(): UInt? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.firstOrNull(): ULong? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.firstOrNull(): UByte? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element, or `null` if the array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.firstOrNull(): UShort? {\n    return if (isEmpty()) null else this[0]\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.firstOrNull(predicate: (UInt) -> Boolean): UInt? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.firstOrNull(predicate: (ULong) -> Boolean): ULong? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.firstOrNull(predicate: (UByte) -> Boolean): UByte? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns the first element matching the given [predicate], or `null` if element was not found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.firstOrNull(predicate: (UShort) -> Boolean): UShort? {\n    for (element in this) if (predicate(element)) return element\n    return null\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.getOrElse(index: Int, defaultValue: (Int) -> UInt): UInt {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.getOrElse(index: Int, defaultValue: (Int) -> ULong): ULong {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.getOrElse(index: Int, defaultValue: (Int) -> UByte): UByte {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or the result of calling the [defaultValue] function if the [index] is out of bounds of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.getOrElse(index: Int, defaultValue: (Int) -> UShort): UShort {\n    return if (index >= 0 && index <= lastIndex) get(index) else defaultValue(index)\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.getOrNull(index: Int): UInt? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.getOrNull(index: Int): ULong? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.getOrNull(index: Int): UByte? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns an element at the given [index] or `null` if the [index] is out of bounds of this array.\n * \n * @sample samples.collections.Collections.Elements.getOrNull\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.getOrNull(index: Int): UShort? {\n    return if (index >= 0 && index <= lastIndex) get(index) else null\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.indexOf(element: UInt): Int {\n    return storage.indexOf(element.toInt())\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.indexOf(element: ULong): Int {\n    return storage.indexOf(element.toLong())\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.indexOf(element: UByte): Int {\n    return storage.indexOf(element.toByte())\n}\n\n/**\n * Returns first index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.indexOf(element: UShort): Int {\n    return storage.indexOf(element.toShort())\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.indexOfFirst(predicate: (UInt) -> Boolean): Int {\n    return storage.indexOfFirst { predicate(it.toUInt()) }\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.indexOfFirst(predicate: (ULong) -> Boolean): Int {\n    return storage.indexOfFirst { predicate(it.toULong()) }\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.indexOfFirst(predicate: (UByte) -> Boolean): Int {\n    return storage.indexOfFirst { predicate(it.toUByte()) }\n}\n\n/**\n * Returns index of the first element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.indexOfFirst(predicate: (UShort) -> Boolean): Int {\n    return storage.indexOfFirst { predicate(it.toUShort()) }\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.indexOfLast(predicate: (UInt) -> Boolean): Int {\n    return storage.indexOfLast { predicate(it.toUInt()) }\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.indexOfLast(predicate: (ULong) -> Boolean): Int {\n    return storage.indexOfLast { predicate(it.toULong()) }\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.indexOfLast(predicate: (UByte) -> Boolean): Int {\n    return storage.indexOfLast { predicate(it.toUByte()) }\n}\n\n/**\n * Returns index of the last element matching the given [predicate], or -1 if the array does not contain such element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.indexOfLast(predicate: (UShort) -> Boolean): Int {\n    return storage.indexOfLast { predicate(it.toUShort()) }\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.last(): UInt {\n    return storage.last().toUInt()\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.last(): ULong {\n    return storage.last().toULong()\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.last(): UByte {\n    return storage.last().toUByte()\n}\n\n/**\n * Returns the last element.\n * \n * @throws NoSuchElementException if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.last(): UShort {\n    return storage.last().toUShort()\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.last(predicate: (UInt) -> Boolean): UInt {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.last(predicate: (ULong) -> Boolean): ULong {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.last(predicate: (UByte) -> Boolean): UByte {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns the last element matching the given [predicate].\n * \n * @throws NoSuchElementException if no such element is found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.last(predicate: (UShort) -> Boolean): UShort {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.lastIndexOf(element: UInt): Int {\n    return storage.lastIndexOf(element.toInt())\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.lastIndexOf(element: ULong): Int {\n    return storage.lastIndexOf(element.toLong())\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.lastIndexOf(element: UByte): Int {\n    return storage.lastIndexOf(element.toByte())\n}\n\n/**\n * Returns last index of [element], or -1 if the array does not contain element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.lastIndexOf(element: UShort): Int {\n    return storage.lastIndexOf(element.toShort())\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.lastOrNull(): UInt? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.lastOrNull(): ULong? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.lastOrNull(): UByte? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element, or `null` if the array is empty.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.lastOrNull(): UShort? {\n    return if (isEmpty()) null else this[size - 1]\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.lastOrNull(predicate: (UInt) -> Boolean): UInt? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.lastOrNull(predicate: (ULong) -> Boolean): ULong? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.lastOrNull(predicate: (UByte) -> Boolean): UByte? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns the last element matching the given [predicate], or `null` if no such element was found.\n * \n * @sample samples.collections.Collections.Elements.last\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.lastOrNull(predicate: (UShort) -> Boolean): UShort? {\n    for (index in this.indices.reversed()) {\n        val element = this[index]\n        if (predicate(element)) return element\n    }\n    return null\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.random(): UInt {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.random(): ULong {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.random(): UByte {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.random(): UShort {\n    return random(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.random(random: Random): UInt {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.random(random: Random): ULong {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.random(random: Random): UByte {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness.\n * \n * @throws NoSuchElementException if this array is empty.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.random(random: Random): UShort {\n    if (isEmpty())\n        throw NoSuchElementException(\"Array is empty.\")\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.randomOrNull(): UInt? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.randomOrNull(): ULong? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.randomOrNull(): UByte? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.randomOrNull(): UShort? {\n    return randomOrNull(Random)\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun UIntArray.randomOrNull(random: Random): UInt? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun ULongArray.randomOrNull(random: Random): ULong? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun UByteArray.randomOrNull(random: Random): UByte? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns a random element from this array using the specified source of randomness, or `null` if this array is empty.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\npublic fun UShortArray.randomOrNull(random: Random): UShort? {\n    if (isEmpty())\n        return null\n    return get(random.nextInt(size))\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.single(): UInt {\n    return storage.single().toUInt()\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.single(): ULong {\n    return storage.single().toULong()\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.single(): UByte {\n    return storage.single().toUByte()\n}\n\n/**\n * Returns the single element, or throws an exception if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.single(): UShort {\n    return storage.single().toUShort()\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.single(predicate: (UInt) -> Boolean): UInt {\n    var single: UInt? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as UInt\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.single(predicate: (ULong) -> Boolean): ULong {\n    var single: ULong? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as ULong\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.single(predicate: (UByte) -> Boolean): UByte {\n    var single: UByte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as UByte\n}\n\n/**\n * Returns the single element matching the given [predicate], or throws exception if there is no or more than one matching element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.single(predicate: (UShort) -> Boolean): UShort {\n    var single: UShort? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) throw IllegalArgumentException(\"Array contains more than one matching element.\")\n            single = element\n            found = true\n        }\n    }\n    if (!found) throw NoSuchElementException(\"Array contains no element matching the predicate.\")\n    @Suppress(\"UNCHECKED_CAST\")\n    return single as UShort\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.singleOrNull(): UInt? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.singleOrNull(): ULong? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.singleOrNull(): UByte? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns single element, or `null` if the array is empty or has more than one element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.singleOrNull(): UShort? {\n    return if (size == 1) this[0] else null\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.singleOrNull(predicate: (UInt) -> Boolean): UInt? {\n    var single: UInt? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.singleOrNull(predicate: (ULong) -> Boolean): ULong? {\n    var single: ULong? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.singleOrNull(predicate: (UByte) -> Boolean): UByte? {\n    var single: UByte? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns the single element matching the given [predicate], or `null` if element was not found or more than one element was found.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.singleOrNull(predicate: (UShort) -> Boolean): UShort? {\n    var single: UShort? = null\n    var found = false\n    for (element in this) {\n        if (predicate(element)) {\n            if (found) return null\n            single = element\n            found = true\n        }\n    }\n    if (!found) return null\n    return single\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.drop(n: Int): List<UInt> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.drop(n: Int): List<ULong> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.drop(n: Int): List<UByte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.drop(n: Int): List<UShort> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return takeLast((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.dropLast(n: Int): List<UInt> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.dropLast(n: Int): List<ULong> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.dropLast(n: Int): List<UByte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.dropLast(n: Int): List<UShort> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    return take((size - n).coerceAtLeast(0))\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.dropLastWhile(predicate: (UInt) -> Boolean): List<UInt> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.dropLastWhile(predicate: (ULong) -> Boolean): List<ULong> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.dropLastWhile(predicate: (UByte) -> Boolean): List<UByte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except last elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.dropLastWhile(predicate: (UShort) -> Boolean): List<UShort> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return take(index + 1)\n        }\n    }\n    return emptyList()\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.dropWhile(predicate: (UInt) -> Boolean): List<UInt> {\n    var yielding = false\n    val list = ArrayList<UInt>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.dropWhile(predicate: (ULong) -> Boolean): List<ULong> {\n    var yielding = false\n    val list = ArrayList<ULong>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.dropWhile(predicate: (UByte) -> Boolean): List<UByte> {\n    var yielding = false\n    val list = ArrayList<UByte>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing all elements except first elements that satisfy the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.drop\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.dropWhile(predicate: (UShort) -> Boolean): List<UShort> {\n    var yielding = false\n    val list = ArrayList<UShort>()\n    for (item in this)\n        if (yielding)\n            list.add(item)\n        else if (!predicate(item)) {\n            list.add(item)\n            yielding = true\n        }\n    return list\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.filter(predicate: (UInt) -> Boolean): List<UInt> {\n    return filterTo(ArrayList<UInt>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.filter(predicate: (ULong) -> Boolean): List<ULong> {\n    return filterTo(ArrayList<ULong>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.filter(predicate: (UByte) -> Boolean): List<UByte> {\n    return filterTo(ArrayList<UByte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.filter(predicate: (UShort) -> Boolean): List<UShort> {\n    return filterTo(ArrayList<UShort>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.filterIndexed(predicate: (index: Int, UInt) -> Boolean): List<UInt> {\n    return filterIndexedTo(ArrayList<UInt>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.filterIndexed(predicate: (index: Int, ULong) -> Boolean): List<ULong> {\n    return filterIndexedTo(ArrayList<ULong>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.filterIndexed(predicate: (index: Int, UByte) -> Boolean): List<UByte> {\n    return filterIndexedTo(ArrayList<UByte>(), predicate)\n}\n\n/**\n * Returns a list containing only elements matching the given [predicate].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexed\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.filterIndexed(predicate: (index: Int, UShort) -> Boolean): List<UShort> {\n    return filterIndexedTo(ArrayList<UShort>(), predicate)\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UInt>> UIntArray.filterIndexedTo(destination: C, predicate: (index: Int, UInt) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in ULong>> ULongArray.filterIndexedTo(destination: C, predicate: (index: Int, ULong) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UByte>> UByteArray.filterIndexedTo(destination: C, predicate: (index: Int, UByte) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * @param [predicate] function that takes the index of an element and the element itself\n * and returns the result of predicate evaluation on the element.\n * \n * @sample samples.collections.Collections.Filtering.filterIndexedTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UShort>> UShortArray.filterIndexedTo(destination: C, predicate: (index: Int, UShort) -> Boolean): C {\n    forEachIndexed { index, element ->\n        if (predicate(index, element)) destination.add(element)\n    }\n    return destination\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.filterNot(predicate: (UInt) -> Boolean): List<UInt> {\n    return filterNotTo(ArrayList<UInt>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.filterNot(predicate: (ULong) -> Boolean): List<ULong> {\n    return filterNotTo(ArrayList<ULong>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.filterNot(predicate: (UByte) -> Boolean): List<UByte> {\n    return filterNotTo(ArrayList<UByte>(), predicate)\n}\n\n/**\n * Returns a list containing all elements not matching the given [predicate].\n * \n * @sample samples.collections.Collections.Filtering.filter\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.filterNot(predicate: (UShort) -> Boolean): List<UShort> {\n    return filterNotTo(ArrayList<UShort>(), predicate)\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UInt>> UIntArray.filterNotTo(destination: C, predicate: (UInt) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in ULong>> ULongArray.filterNotTo(destination: C, predicate: (ULong) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UByte>> UByteArray.filterNotTo(destination: C, predicate: (UByte) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements not matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UShort>> UShortArray.filterNotTo(destination: C, predicate: (UShort) -> Boolean): C {\n    for (element in this) if (!predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UInt>> UIntArray.filterTo(destination: C, predicate: (UInt) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in ULong>> ULongArray.filterTo(destination: C, predicate: (ULong) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UByte>> UByteArray.filterTo(destination: C, predicate: (UByte) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Appends all elements matching the given [predicate] to the given [destination].\n * \n * @sample samples.collections.Collections.Filtering.filterTo\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <C : MutableCollection<in UShort>> UShortArray.filterTo(destination: C, predicate: (UShort) -> Boolean): C {\n    for (element in this) if (predicate(element)) destination.add(element)\n    return destination\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.slice(indices: IntRange): List<UInt> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.slice(indices: IntRange): List<ULong> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.slice(indices: IntRange): List<UByte> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.slice(indices: IntRange): List<UShort> {\n    if (indices.isEmpty()) return listOf()\n    return copyOfRange(indices.start, indices.endInclusive + 1).asList()\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.slice(indices: Iterable<Int>): List<UInt> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<UInt>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.slice(indices: Iterable<Int>): List<ULong> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<ULong>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.slice(indices: Iterable<Int>): List<UByte> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<UByte>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns a list containing elements at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.slice(indices: Iterable<Int>): List<UShort> {\n    val size = indices.collectionSizeOrDefault(10)\n    if (size == 0) return emptyList()\n    val list = ArrayList<UShort>(size)\n    for (index in indices) {\n        list.add(get(index))\n    }\n    return list\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sliceArray(indices: Collection<Int>): UIntArray {\n    return UIntArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sliceArray(indices: Collection<Int>): ULongArray {\n    return ULongArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sliceArray(indices: Collection<Int>): UByteArray {\n    return UByteArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements of this array at specified [indices].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sliceArray(indices: Collection<Int>): UShortArray {\n    return UShortArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sliceArray(indices: IntRange): UIntArray {\n    return UIntArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sliceArray(indices: IntRange): ULongArray {\n    return ULongArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sliceArray(indices: IntRange): UByteArray {\n    return UByteArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns an array containing elements at indices in the specified [indices] range.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sliceArray(indices: IntRange): UShortArray {\n    return UShortArray(storage.sliceArray(indices))\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.take(n: Int): List<UInt> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<UInt>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.take(n: Int): List<ULong> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<ULong>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.take(n: Int): List<UByte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<UByte>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing first [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.take(n: Int): List<UShort> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[0])\n    var count = 0\n    val list = ArrayList<UShort>(n)\n    for (item in this) {\n        list.add(item)\n        if (++count == n)\n            break\n    }\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.takeLast(n: Int): List<UInt> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<UInt>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.takeLast(n: Int): List<ULong> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<ULong>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.takeLast(n: Int): List<UByte> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<UByte>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last [n] elements.\n * \n * @throws IllegalArgumentException if [n] is negative.\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.takeLast(n: Int): List<UShort> {\n    require(n >= 0) { \"Requested element count $n is less than zero.\" }\n    if (n == 0) return emptyList()\n    val size = size\n    if (n >= size) return toList()\n    if (n == 1) return listOf(this[size - 1])\n    val list = ArrayList<UShort>(n)\n    for (index in size - n until size)\n        list.add(this[index])\n    return list\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.takeLastWhile(predicate: (UInt) -> Boolean): List<UInt> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.takeLastWhile(predicate: (ULong) -> Boolean): List<ULong> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.takeLastWhile(predicate: (UByte) -> Boolean): List<UByte> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing last elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.takeLastWhile(predicate: (UShort) -> Boolean): List<UShort> {\n    for (index in lastIndex downTo 0) {\n        if (!predicate(this[index])) {\n            return drop(index + 1)\n        }\n    }\n    return toList()\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.takeWhile(predicate: (UInt) -> Boolean): List<UInt> {\n    val list = ArrayList<UInt>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.takeWhile(predicate: (ULong) -> Boolean): List<ULong> {\n    val list = ArrayList<ULong>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.takeWhile(predicate: (UByte) -> Boolean): List<UByte> {\n    val list = ArrayList<UByte>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Returns a list containing first elements satisfying the given [predicate].\n * \n * @sample samples.collections.Collections.Transformations.take\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.takeWhile(predicate: (UShort) -> Boolean): List<UShort> {\n    val list = ArrayList<UShort>()\n    for (item in this) {\n        if (!predicate(item))\n            break\n        list.add(item)\n    }\n    return list\n}\n\n/**\n * Reverses elements in the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reverse(): Unit {\n    storage.reverse()\n}\n\n/**\n * Reverses elements in the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reverse(): Unit {\n    storage.reverse()\n}\n\n/**\n * Reverses elements in the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reverse(): Unit {\n    storage.reverse()\n}\n\n/**\n * Reverses elements in the array in-place.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reverse(): Unit {\n    storage.reverse()\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    storage.reverse(fromIndex, toIndex)\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    storage.reverse(fromIndex, toIndex)\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    storage.reverse(fromIndex, toIndex)\n}\n\n/**\n * Reverses elements of the array in the specified range in-place.\n * \n * @param fromIndex the start of the range (inclusive) to reverse.\n * @param toIndex the end of the range (exclusive) to reverse.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reverse(fromIndex: Int, toIndex: Int): Unit {\n    storage.reverse(fromIndex, toIndex)\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.reversed(): List<UInt> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.reversed(): List<ULong> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.reversed(): List<UByte> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns a list with elements in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.reversed(): List<UShort> {\n    if (isEmpty()) return emptyList()\n    val list = toMutableList()\n    list.reverse()\n    return list\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reversedArray(): UIntArray {\n    return UIntArray(storage.reversedArray())\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reversedArray(): ULongArray {\n    return ULongArray(storage.reversedArray())\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reversedArray(): UByteArray {\n    return UByteArray(storage.reversedArray())\n}\n\n/**\n * Returns an array with elements of this array in reversed order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reversedArray(): UShortArray {\n    return UShortArray(storage.reversedArray())\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.shuffle(): Unit {\n    shuffle(Random)\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Randomly shuffles elements in this array in-place using the specified [random] instance as the source of randomness.\n * \n * See: https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle#The_modern_algorithm\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.shuffle(random: Random): Unit {\n    for (i in lastIndex downTo 1) {\n        val j = random.nextInt(i + 1)\n        val copy = this[i]\n        this[i] = this[j]\n        this[j] = copy\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Sorts elements in the array in-place descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortDescending(): Unit {\n    if (size > 1) {\n        sort()\n        reverse()\n    }\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sorted(): List<UInt> {\n    return copyOf().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sorted(): List<ULong> {\n    return copyOf().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sorted(): List<UByte> {\n    return copyOf().apply { sort() }.asList()\n}\n\n/**\n * Returns a list of all elements sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sorted(): List<UShort> {\n    return copyOf().apply { sort() }.asList()\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortedArray(): UIntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortedArray(): ULongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortedArray(): UByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortedArray(): UShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sort() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortedArrayDescending(): UIntArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortedArrayDescending(): ULongArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortedArrayDescending(): UByteArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns an array with all elements of this array sorted descending according to their natural sort order.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortedArrayDescending(): UShortArray {\n    if (isEmpty()) return this\n    return this.copyOf().apply { sortDescending() }\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortedDescending(): List<UInt> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortedDescending(): List<ULong> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortedDescending(): List<UByte> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns a list of all elements sorted descending according to their natural sort order.\n * \n * The sort is _stable_. It means that equal elements preserve their order relative to each other after sorting.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortedDescending(): List<UShort> {\n    return copyOf().apply { sort() }.reversed()\n}\n\n/**\n * Returns an array of type [ByteArray], which is a view of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.asByteArray(): ByteArray {\n    return storage\n}\n\n/**\n * Returns an array of type [IntArray], which is a view of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.asIntArray(): IntArray {\n    return storage\n}\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UIntArray.asList(): List<UInt>\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun ULongArray.asList(): List<ULong>\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UByteArray.asList(): List<UByte>\n\n/**\n * Returns a [List] that wraps the original array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic expect fun UShortArray.asList(): List<UShort>\n\n/**\n * Returns an array of type [LongArray], which is a view of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.asLongArray(): LongArray {\n    return storage\n}\n\n/**\n * Returns an array of type [ShortArray], which is a view of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.asShortArray(): ShortArray {\n    return storage\n}\n\n/**\n * Returns an array of type [UByteArray], which is a view of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.asUByteArray(): UByteArray {\n    return UByteArray(this)\n}\n\n/**\n * Returns an array of type [UIntArray], which is a view of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.asUIntArray(): UIntArray {\n    return UIntArray(this)\n}\n\n/**\n * Returns an array of type [ULongArray], which is a view of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.asULongArray(): ULongArray {\n    return ULongArray(this)\n}\n\n/**\n * Returns an array of type [UShortArray], which is a view of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.asUShortArray(): UShortArray {\n    return UShortArray(this)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun UIntArray.contentEquals(other: UIntArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun ULongArray.contentEquals(other: ULongArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun UByteArray.contentEquals(other: UByteArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun UShortArray.contentEquals(other: UShortArray): Boolean {\n    return this.contentEquals(other)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun UIntArray?.contentEquals(other: UIntArray?): Boolean {\n    return this?.storage.contentEquals(other?.storage)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun ULongArray?.contentEquals(other: ULongArray?): Boolean {\n    return this?.storage.contentEquals(other?.storage)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun UByteArray?.contentEquals(other: UByteArray?): Boolean {\n    return this?.storage.contentEquals(other?.storage)\n}\n\n/**\n * Returns `true` if the two specified arrays are *structurally* equal to one another,\n * i.e. contain the same number of the same elements in the same order.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic infix fun UShortArray?.contentEquals(other: UShortArray?): Boolean {\n    return this?.storage.contentEquals(other?.storage)\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.contentHashCode(): Int {\n    return this.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray?.contentHashCode(): Int {\n    return this?.storage.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray?.contentHashCode(): Int {\n    return this?.storage.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray?.contentHashCode(): Int {\n    return this?.storage.contentHashCode()\n}\n\n/**\n * Returns a hash code based on the contents of this array as if it is [List].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray?.contentHashCode(): Int {\n    return this?.storage.contentHashCode()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@Deprecated(\"Use Kotlin compiler 1.4 to avoid deprecation warning.\")\n@SinceKotlin(\"1.3\")\n@DeprecatedSinceKotlin(hiddenSince = \"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.contentToString(): String {\n    return this.contentToString()\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray?.contentToString(): String {\n    return this?.joinToString(\", \", \"[\", \"]\") ?: \"null\"\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray?.contentToString(): String {\n    return this?.joinToString(\", \", \"[\", \"]\") ?: \"null\"\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray?.contentToString(): String {\n    return this?.joinToString(\", \", \"[\", \"]\") ?: \"null\"\n}\n\n/**\n * Returns a string representation of the contents of the specified array as if it is [List].\n * \n * @sample samples.collections.Arrays.ContentOperations.contentToString\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray?.contentToString(): String {\n    return this?.joinToString(\", \", \"[\", \"]\") ?: \"null\"\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.copyInto(destination: UIntArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): UIntArray {\n    storage.copyInto(destination.storage, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.copyInto(destination: ULongArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): ULongArray {\n    storage.copyInto(destination.storage, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.copyInto(destination: UByteArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): UByteArray {\n    storage.copyInto(destination.storage, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Copies this array or its subrange into the [destination] array and returns that array.\n * \n * It's allowed to pass the same array in the [destination] and even specify the subrange so that it overlaps with the destination range.\n * \n * @param destination the array to copy to.\n * @param destinationOffset the position in the [destination] array to copy to, 0 by default.\n * @param startIndex the beginning (inclusive) of the subrange to copy, 0 by default.\n * @param endIndex the end (exclusive) of the subrange to copy, size of this array by default.\n * \n * @throws IndexOutOfBoundsException or [IllegalArgumentException] when [startIndex] or [endIndex] is out of range of this array indices or when `startIndex > endIndex`.\n * @throws IndexOutOfBoundsException when the subrange doesn't fit into the [destination] array starting at the specified [destinationOffset],\n * or when that index is out of the [destination] array indices range.\n * \n * @return the [destination] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.copyInto(destination: UShortArray, destinationOffset: Int = 0, startIndex: Int = 0, endIndex: Int = size): UShortArray {\n    storage.copyInto(destination.storage, destinationOffset, startIndex, endIndex)\n    return destination\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.copyOf(): UIntArray {\n    return UIntArray(storage.copyOf())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.copyOf(): ULongArray {\n    return ULongArray(storage.copyOf())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.copyOf(): UByteArray {\n    return UByteArray(storage.copyOf())\n}\n\n/**\n * Returns new array which is a copy of the original array.\n * \n * @sample samples.collections.Arrays.CopyOfOperations.copyOf\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.copyOf(): UShortArray {\n    return UShortArray(storage.copyOf())\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.copyOf(newSize: Int): UIntArray {\n    return UIntArray(storage.copyOf(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.copyOf(newSize: Int): ULongArray {\n    return ULongArray(storage.copyOf(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.copyOf(newSize: Int): UByteArray {\n    return UByteArray(storage.copyOf(newSize))\n}\n\n/**\n * Returns new array which is a copy of the original array, resized to the given [newSize].\n * The copy is either truncated or padded at the end with zero values if necessary.\n * \n * - If [newSize] is less than the size of the original array, the copy array is truncated to the [newSize].\n * - If [newSize] is greater than the size of the original array, the extra elements in the copy array are filled with zero values.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.copyOf(newSize: Int): UShortArray {\n    return UShortArray(storage.copyOf(newSize))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.copyOfRange(fromIndex: Int, toIndex: Int): UIntArray {\n    return UIntArray(storage.copyOfRange(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.copyOfRange(fromIndex: Int, toIndex: Int): ULongArray {\n    return ULongArray(storage.copyOfRange(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.copyOfRange(fromIndex: Int, toIndex: Int): UByteArray {\n    return UByteArray(storage.copyOfRange(fromIndex, toIndex))\n}\n\n/**\n * Returns a new array which is a copy of the specified range of the original array.\n * \n * @param fromIndex the start of the range (inclusive) to copy.\n * @param toIndex the end of the range (exclusive) to copy.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.copyOfRange(fromIndex: Int, toIndex: Int): UShortArray {\n    return UShortArray(storage.copyOfRange(fromIndex, toIndex))\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.fill(element: UInt, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    storage.fill(element.toInt(), fromIndex, toIndex)\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.fill(element: ULong, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    storage.fill(element.toLong(), fromIndex, toIndex)\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.fill(element: UByte, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    storage.fill(element.toByte(), fromIndex, toIndex)\n}\n\n/**\n * Fills this array or its subrange with the specified [element] value.\n * \n * @param fromIndex the start of the range (inclusive) to fill, 0 by default.\n * @param toIndex the end of the range (exclusive) to fill, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.fill(element: UShort, fromIndex: Int = 0, toIndex: Int = size): Unit {\n    storage.fill(element.toShort(), fromIndex, toIndex)\n}\n\n/**\n * Returns the range of valid indices for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UIntArray.indices: IntRange\n    get() = storage.indices\n\n/**\n * Returns the range of valid indices for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val ULongArray.indices: IntRange\n    get() = storage.indices\n\n/**\n * Returns the range of valid indices for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UByteArray.indices: IntRange\n    get() = storage.indices\n\n/**\n * Returns the range of valid indices for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UShortArray.indices: IntRange\n    get() = storage.indices\n\n/**\n * Returns the last valid index for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UIntArray.lastIndex: Int\n    get() = storage.lastIndex\n\n/**\n * Returns the last valid index for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val ULongArray.lastIndex: Int\n    get() = storage.lastIndex\n\n/**\n * Returns the last valid index for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UByteArray.lastIndex: Int\n    get() = storage.lastIndex\n\n/**\n * Returns the last valid index for the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic inline val UShortArray.lastIndex: Int\n    get() = storage.lastIndex\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.plus(element: UInt): UIntArray {\n    return UIntArray(storage + element.toInt())\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.plus(element: ULong): ULongArray {\n    return ULongArray(storage + element.toLong())\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.plus(element: UByte): UByteArray {\n    return UByteArray(storage + element.toByte())\n}\n\n/**\n * Returns an array containing all elements of the original array and then the given [element].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.plus(element: UShort): UShortArray {\n    return UShortArray(storage + element.toShort())\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic operator fun UIntArray.plus(elements: Collection<UInt>): UIntArray {\n    var index = size\n    val result = storage.copyOf(size + elements.size)\n    for (element in elements) result[index++] = element.toInt()\n    return UIntArray(result)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic operator fun ULongArray.plus(elements: Collection<ULong>): ULongArray {\n    var index = size\n    val result = storage.copyOf(size + elements.size)\n    for (element in elements) result[index++] = element.toLong()\n    return ULongArray(result)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic operator fun UByteArray.plus(elements: Collection<UByte>): UByteArray {\n    var index = size\n    val result = storage.copyOf(size + elements.size)\n    for (element in elements) result[index++] = element.toByte()\n    return UByteArray(result)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] collection.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic operator fun UShortArray.plus(elements: Collection<UShort>): UShortArray {\n    var index = size\n    val result = storage.copyOf(size + elements.size)\n    for (element in elements) result[index++] = element.toShort()\n    return UShortArray(result)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UIntArray.plus(elements: UIntArray): UIntArray {\n    return UIntArray(storage + elements.storage)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun ULongArray.plus(elements: ULongArray): ULongArray {\n    return ULongArray(storage + elements.storage)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UByteArray.plus(elements: UByteArray): UByteArray {\n    return UByteArray(storage + elements.storage)\n}\n\n/**\n * Returns an array containing all elements of the original array and then all elements of the given [elements] array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline operator fun UShortArray.plus(elements: UShortArray): UShortArray {\n    return UShortArray(storage + elements.storage)\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sort(): Unit {\n    if (size > 1) sortArray(this, 0, size)\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sort(): Unit {\n    if (size > 1) sortArray(this, 0, size)\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sort(): Unit {\n    if (size > 1) sortArray(this, 0, size)\n}\n\n/**\n * Sorts the array in-place.\n * \n * @sample samples.collections.Arrays.Sorting.sortArray\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sort(): Unit {\n    if (size > 1) sortArray(this, 0, size)\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArray(this, fromIndex, toIndex)\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArray(this, fromIndex, toIndex)\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArray(this, fromIndex, toIndex)\n}\n\n/**\n * Sorts a range in the array in-place.\n * \n * @param fromIndex the start of the range (inclusive) to sort, 0 by default.\n * @param toIndex the end of the range (exclusive) to sort, size of this array by default.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n * \n * @sample samples.collections.Arrays.Sorting.sortRangeOfArray\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sort(fromIndex: Int = 0, toIndex: Int = size): Unit {\n    AbstractList.checkRangeIndexes(fromIndex, toIndex, size)\n    sortArray(this, fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Sorts elements of the array in the specified range in-place.\n * The elements are sorted descending according to their natural sort order.\n * \n * @param fromIndex the start of the range (inclusive) to sort.\n * @param toIndex the end of the range (exclusive) to sort.\n * \n * @throws IndexOutOfBoundsException if [fromIndex] is less than zero or [toIndex] is greater than the size of this array.\n * @throws IllegalArgumentException if [fromIndex] is greater than [toIndex].\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.sortDescending(fromIndex: Int, toIndex: Int): Unit {\n    sort(fromIndex, toIndex)\n    reverse(fromIndex, toIndex)\n}\n\n/**\n * Returns an array of type [ByteArray], which is a copy of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.toByteArray(): ByteArray {\n    return storage.copyOf()\n}\n\n/**\n * Returns an array of type [IntArray], which is a copy of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.toIntArray(): IntArray {\n    return storage.copyOf()\n}\n\n/**\n * Returns an array of type [LongArray], which is a copy of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.toLongArray(): LongArray {\n    return storage.copyOf()\n}\n\n/**\n * Returns an array of type [ShortArray], which is a copy of this array where each element is a signed reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.toShortArray(): ShortArray {\n    return storage.copyOf()\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.toTypedArray(): Array<UInt> {\n    return Array(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.toTypedArray(): Array<ULong> {\n    return Array(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.toTypedArray(): Array<UByte> {\n    return Array(size) { index -> this[index] }\n}\n\n/**\n * Returns a *typed* object array containing all of the elements of this primitive array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.toTypedArray(): Array<UShort> {\n    return Array(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of UByte containing all of the elements of this generic array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UByte>.toUByteArray(): UByteArray {\n    return UByteArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of type [UByteArray], which is a copy of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ByteArray.toUByteArray(): UByteArray {\n    return UByteArray(this.copyOf())\n}\n\n/**\n * Returns an array of UInt containing all of the elements of this generic array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UInt>.toUIntArray(): UIntArray {\n    return UIntArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of type [UIntArray], which is a copy of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun IntArray.toUIntArray(): UIntArray {\n    return UIntArray(this.copyOf())\n}\n\n/**\n * Returns an array of ULong containing all of the elements of this generic array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out ULong>.toULongArray(): ULongArray {\n    return ULongArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of type [ULongArray], which is a copy of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun LongArray.toULongArray(): ULongArray {\n    return ULongArray(this.copyOf())\n}\n\n/**\n * Returns an array of UShort containing all of the elements of this generic array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun Array<out UShort>.toUShortArray(): UShortArray {\n    return UShortArray(size) { index -> this[index] }\n}\n\n/**\n * Returns an array of type [UShortArray], which is a copy of this array where each element is an unsigned reinterpretation\n * of the corresponding element of this array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ShortArray.toUShortArray(): UShortArray {\n    return UShortArray(this.copyOf())\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UIntArray.associateWith(valueSelector: (UInt) -> V): Map<UInt, V> {\n    val result = LinkedHashMap<UInt, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> ULongArray.associateWith(valueSelector: (ULong) -> V): Map<ULong, V> {\n    val result = LinkedHashMap<ULong, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UByteArray.associateWith(valueSelector: (UByte) -> V): Map<UByte, V> {\n    val result = LinkedHashMap<UByte, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Returns a [Map] where keys are elements from the given array and values are\n * produced by the [valueSelector] function applied to each element.\n * \n * If any two elements are equal, the last one gets added to the map.\n * \n * The returned map preserves the entry iteration order of the original array.\n * \n * @sample samples.collections.Collections.Transformations.associateWith\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UShortArray.associateWith(valueSelector: (UShort) -> V): Map<UShort, V> {\n    val result = LinkedHashMap<UShort, V>(mapCapacity(size).coerceAtLeast(16))\n    return associateWithTo(result, valueSelector)\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in UInt, in V>> UIntArray.associateWithTo(destination: M, valueSelector: (UInt) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in ULong, in V>> ULongArray.associateWithTo(destination: M, valueSelector: (ULong) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in UByte, in V>> UByteArray.associateWithTo(destination: M, valueSelector: (UByte) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Populates and returns the [destination] mutable map with key-value pairs for each element of the given array,\n * where key is the element itself and value is provided by the [valueSelector] function applied to that key.\n * \n * If any two elements are equal, the last one overwrites the former value in the map.\n * \n * @sample samples.collections.Collections.Transformations.associateWithTo\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V, M : MutableMap<in UShort, in V>> UShortArray.associateWithTo(destination: M, valueSelector: (UShort) -> V): M {\n    for (element in this) {\n        destination.put(element, valueSelector(element))\n    }\n    return destination\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.flatMap(transform: (UInt) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.flatMap(transform: (ULong) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.flatMap(transform: (UByte) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element of original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMap\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.flatMap(transform: (UShort) -> Iterable<R>): List<R> {\n    return flatMapTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.flatMapIndexed(transform: (index: Int, UInt) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.flatMapIndexed(transform: (index: Int, ULong) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.flatMapIndexed(transform: (index: Int, UByte) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Returns a single list of all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array.\n * \n * @sample samples.collections.Collections.Transformations.flatMapIndexed\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.flatMapIndexed(transform: (index: Int, UShort) -> Iterable<R>): List<R> {\n    return flatMapIndexedTo(ArrayList<R>(), transform)\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UIntArray.flatMapIndexedTo(destination: C, transform: (index: Int, UInt) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ULongArray.flatMapIndexedTo(destination: C, transform: (index: Int, ULong) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UByteArray.flatMapIndexedTo(destination: C, transform: (index: Int, UByte) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element\n * and its index in the original array, to the given [destination].\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UShortArray.flatMapIndexedTo(destination: C, transform: (index: Int, UShort) -> Iterable<R>): C {\n    var index = 0\n    for (element in this) {\n        val list = transform(index++, element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UIntArray.flatMapTo(destination: C, transform: (UInt) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ULongArray.flatMapTo(destination: C, transform: (ULong) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UByteArray.flatMapTo(destination: C, transform: (UByte) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Appends all elements yielded from results of [transform] function being invoked on each element of original array, to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UShortArray.flatMapTo(destination: C, transform: (UShort) -> Iterable<R>): C {\n    for (element in this) {\n        val list = transform(element)\n        destination.addAll(list)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K> UIntArray.groupBy(keySelector: (UInt) -> K): Map<K, List<UInt>> {\n    return groupByTo(LinkedHashMap<K, MutableList<UInt>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K> ULongArray.groupBy(keySelector: (ULong) -> K): Map<K, List<ULong>> {\n    return groupByTo(LinkedHashMap<K, MutableList<ULong>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K> UByteArray.groupBy(keySelector: (UByte) -> K): Map<K, List<UByte>> {\n    return groupByTo(LinkedHashMap<K, MutableList<UByte>>(), keySelector)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and returns a map where each group key is associated with a list of corresponding elements.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K> UShortArray.groupBy(keySelector: (UShort) -> K): Map<K, List<UShort>> {\n    return groupByTo(LinkedHashMap<K, MutableList<UShort>>(), keySelector)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> UIntArray.groupBy(keySelector: (UInt) -> K, valueTransform: (UInt) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> ULongArray.groupBy(keySelector: (ULong) -> K, valueTransform: (ULong) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> UByteArray.groupBy(keySelector: (UByte) -> K, valueTransform: (UByte) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and returns a map where each group key is associated with a list of corresponding values.\n * \n * The returned map preserves the entry iteration order of the keys produced from the original array.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V> UShortArray.groupBy(keySelector: (UShort) -> K, valueTransform: (UShort) -> V): Map<K, List<V>> {\n    return groupByTo(LinkedHashMap<K, MutableList<V>>(), keySelector, valueTransform)\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, M : MutableMap<in K, MutableList<UInt>>> UIntArray.groupByTo(destination: M, keySelector: (UInt) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<UInt>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, M : MutableMap<in K, MutableList<ULong>>> ULongArray.groupByTo(destination: M, keySelector: (ULong) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<ULong>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, M : MutableMap<in K, MutableList<UByte>>> UByteArray.groupByTo(destination: M, keySelector: (UByte) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<UByte>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups elements of the original array by the key returned by the given [keySelector] function\n * applied to each element and puts to the [destination] map each group key associated with a list of corresponding elements.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupBy\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, M : MutableMap<in K, MutableList<UShort>>> UShortArray.groupByTo(destination: M, keySelector: (UShort) -> K): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<UShort>() }\n        list.add(element)\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> UIntArray.groupByTo(destination: M, keySelector: (UInt) -> K, valueTransform: (UInt) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> ULongArray.groupByTo(destination: M, keySelector: (ULong) -> K, valueTransform: (ULong) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> UByteArray.groupByTo(destination: M, keySelector: (UByte) -> K, valueTransform: (UByte) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Groups values returned by the [valueTransform] function applied to each element of the original array\n * by the key returned by the given [keySelector] function applied to the element\n * and puts to the [destination] map each group key associated with a list of corresponding values.\n * \n * @return The [destination] map.\n * \n * @sample samples.collections.Collections.Transformations.groupByKeysAndValues\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <K, V, M : MutableMap<in K, MutableList<V>>> UShortArray.groupByTo(destination: M, keySelector: (UShort) -> K, valueTransform: (UShort) -> V): M {\n    for (element in this) {\n        val key = keySelector(element)\n        val list = destination.getOrPut(key) { ArrayList<V>() }\n        list.add(valueTransform(element))\n    }\n    return destination\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.map(transform: (UInt) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.map(transform: (ULong) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.map(transform: (UByte) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element in the original array.\n * \n * @sample samples.collections.Collections.Transformations.map\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.map(transform: (UShort) -> R): List<R> {\n    return mapTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.mapIndexed(transform: (index: Int, UInt) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.mapIndexed(transform: (index: Int, ULong) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.mapIndexed(transform: (index: Int, UByte) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Returns a list containing the results of applying the given [transform] function\n * to each element and its index in the original array.\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.mapIndexed(transform: (index: Int, UShort) -> R): List<R> {\n    return mapIndexedTo(ArrayList<R>(size), transform)\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UIntArray.mapIndexedTo(destination: C, transform: (index: Int, UInt) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ULongArray.mapIndexedTo(destination: C, transform: (index: Int, ULong) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UByteArray.mapIndexedTo(destination: C, transform: (index: Int, UByte) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element and its index in the original array\n * and appends the results to the given [destination].\n * @param [transform] function that takes the index of an element and the element itself\n * and returns the result of the transform applied to the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UShortArray.mapIndexedTo(destination: C, transform: (index: Int, UShort) -> R): C {\n    var index = 0\n    for (item in this)\n        destination.add(transform(index++, item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UIntArray.mapTo(destination: C, transform: (UInt) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> ULongArray.mapTo(destination: C, transform: (ULong) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UByteArray.mapTo(destination: C, transform: (UByte) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Applies the given [transform] function to each element of the original array\n * and appends the results to the given [destination].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, C : MutableCollection<in R>> UShortArray.mapTo(destination: C, transform: (UShort) -> R): C {\n    for (item in this)\n        destination.add(transform(item))\n    return destination\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.withIndex(): Iterable<IndexedValue<UInt>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.withIndex(): Iterable<IndexedValue<ULong>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.withIndex(): Iterable<IndexedValue<UByte>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns a lazy [Iterable] that wraps each element of the original array\n * into an [IndexedValue] containing the index of that element and the element itself.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.withIndex(): Iterable<IndexedValue<UShort>> {\n    return IndexingIterable { iterator() }\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.all(predicate: (UInt) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.all(predicate: (ULong) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.all(predicate: (UByte) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if all elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.all\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.all(predicate: (UShort) -> Boolean): Boolean {\n    for (element in this) if (!predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.any(): Boolean {\n    return storage.any()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.any(): Boolean {\n    return storage.any()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.any(): Boolean {\n    return storage.any()\n}\n\n/**\n * Returns `true` if array has at least one element.\n * \n * @sample samples.collections.Collections.Aggregates.any\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.any(): Boolean {\n    return storage.any()\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.any(predicate: (UInt) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.any(predicate: (ULong) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.any(predicate: (UByte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns `true` if at least one element matches the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.anyWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.any(predicate: (UShort) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return true\n    return false\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.count(predicate: (UInt) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.count(predicate: (ULong) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.count(predicate: (UByte) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Returns the number of elements matching the given [predicate].\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.count(predicate: (UShort) -> Boolean): Int {\n    var count = 0\n    for (element in this) if (predicate(element)) ++count\n    return count\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.fold(initial: R, operation: (acc: R, UInt) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.fold(initial: R, operation: (acc: R, ULong) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.fold(initial: R, operation: (acc: R, UByte) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.fold(initial: R, operation: (acc: R, UShort) -> R): R {\n    var accumulator = initial\n    for (element in this) accumulator = operation(accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.foldIndexed(initial: R, operation: (index: Int, acc: R, UInt) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.foldIndexed(initial: R, operation: (index: Int, acc: R, ULong) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.foldIndexed(initial: R, operation: (index: Int, acc: R, UByte) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.foldIndexed(initial: R, operation: (index: Int, acc: R, UShort) -> R): R {\n    var index = 0\n    var accumulator = initial\n    for (element in this) accumulator = operation(index++, accumulator, element)\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.foldRight(initial: R, operation: (UInt, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.foldRight(initial: R, operation: (ULong, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.foldRight(initial: R, operation: (UByte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.foldRight(initial: R, operation: (UShort, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.foldRightIndexed(initial: R, operation: (index: Int, UInt, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.foldRightIndexed(initial: R, operation: (index: Int, ULong, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.foldRightIndexed(initial: R, operation: (index: Int, UByte, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with [initial] value and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns the specified [initial] value if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself\n * and current accumulator value, and calculates the next accumulator value.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.foldRightIndexed(initial: R, operation: (index: Int, UShort, acc: R) -> R): R {\n    var index = lastIndex\n    var accumulator = initial\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.forEach(action: (UInt) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.forEach(action: (ULong) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.forEach(action: (UByte) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.forEach(action: (UShort) -> Unit): Unit {\n    for (element in this) action(element)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.forEachIndexed(action: (index: Int, UInt) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.forEachIndexed(action: (index: Int, ULong) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.forEachIndexed(action: (index: Int, UByte) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.forEachIndexed(action: (index: Int, UShort) -> Unit): Unit {\n    var index = 0\n    for (item in this) action(index++, item)\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.max(): UInt? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.max(): ULong? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.max(): UByte? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxOrNull instead.\", ReplaceWith(\"this.maxOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.max(): UShort? {\n    return maxOrNull()\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.maxBy(selector: (UInt) -> R): UInt? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.maxBy(selector: (ULong) -> R): ULong? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.maxBy(selector: (UByte) -> R): UByte? {\n    return maxByOrNull(selector)\n}\n\n@Deprecated(\"Use maxByOrNull instead.\", ReplaceWith(\"this.maxByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.maxBy(selector: (UShort) -> R): UShort? {\n    return maxByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.maxByOrNull(selector: (UInt) -> R): UInt? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.maxByOrNull(selector: (ULong) -> R): ULong? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.maxByOrNull(selector: (UByte) -> R): UByte? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the first element yielding the largest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.maxByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.maxByOrNull(selector: (UShort) -> R): UShort? {\n    if (isEmpty()) return null\n    var maxElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return maxElem\n    var maxValue = selector(maxElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (maxValue < v) {\n            maxElem = e\n            maxValue = v\n        }\n    }\n    return maxElem\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.maxOf(selector: (UInt) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.maxOf(selector: (ULong) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.maxOf(selector: (UByte) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.maxOf(selector: (UShort) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.maxOf(selector: (UInt) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.maxOf(selector: (ULong) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.maxOf(selector: (UByte) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.maxOf(selector: (UShort) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.maxOf(selector: (UInt) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.maxOf(selector: (ULong) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.maxOf(selector: (UByte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.maxOf(selector: (UShort) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.maxOfOrNull(selector: (UInt) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.maxOfOrNull(selector: (ULong) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.maxOfOrNull(selector: (UByte) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.maxOfOrNull(selector: (UShort) -> Double): Double? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.maxOfOrNull(selector: (UInt) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.maxOfOrNull(selector: (ULong) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.maxOfOrNull(selector: (UByte) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.maxOfOrNull(selector: (UShort) -> Float): Float? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        maxValue = maxOf(maxValue, v)\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.maxOfOrNull(selector: (UInt) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.maxOfOrNull(selector: (ULong) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.maxOfOrNull(selector: (UByte) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.maxOfOrNull(selector: (UShort) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (maxValue < v) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.maxOfWith(comparator: Comparator<in R>, selector: (UInt) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.maxOfWith(comparator: Comparator<in R>, selector: (ULong) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.maxOfWith(comparator: Comparator<in R>, selector: (UByte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.maxOfWith(comparator: Comparator<in R>, selector: (UShort) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (UInt) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (ULong) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (UByte) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.maxOfWithOrNull(comparator: Comparator<in R>, selector: (UShort) -> R): R? {\n    if (isEmpty()) return null\n    var maxValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(maxValue, v) < 0) {\n            maxValue = v\n        }\n    }\n    return maxValue\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.maxOrNull(): UInt? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.maxOrNull(): ULong? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.maxOrNull(): UByte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n/**\n * Returns the largest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.maxOrNull(): UShort? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (max < e) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.maxWith(comparator: Comparator<in UInt>): UInt? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.maxWith(comparator: Comparator<in ULong>): ULong? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.maxWith(comparator: Comparator<in UByte>): UByte? {\n    return maxWithOrNull(comparator)\n}\n\n@Deprecated(\"Use maxWithOrNull instead.\", ReplaceWith(\"this.maxWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.maxWith(comparator: Comparator<in UShort>): UShort? {\n    return maxWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.maxWithOrNull(comparator: Comparator<in UInt>): UInt? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.maxWithOrNull(comparator: Comparator<in ULong>): ULong? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.maxWithOrNull(comparator: Comparator<in UByte>): UByte? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n/**\n * Returns the first element having the largest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.maxWithOrNull(comparator: Comparator<in UShort>): UShort? {\n    if (isEmpty()) return null\n    var max = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(max, e) < 0) max = e\n    }\n    return max\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.min(): UInt? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.min(): ULong? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.min(): UByte? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minOrNull instead.\", ReplaceWith(\"this.minOrNull()\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.min(): UShort? {\n    return minOrNull()\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.minBy(selector: (UInt) -> R): UInt? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.minBy(selector: (ULong) -> R): ULong? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.minBy(selector: (UByte) -> R): UByte? {\n    return minByOrNull(selector)\n}\n\n@Deprecated(\"Use minByOrNull instead.\", ReplaceWith(\"this.minByOrNull(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.minBy(selector: (UShort) -> R): UShort? {\n    return minByOrNull(selector)\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.minByOrNull(selector: (UInt) -> R): UInt? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.minByOrNull(selector: (ULong) -> R): ULong? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.minByOrNull(selector: (UByte) -> R): UByte? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the first element yielding the smallest value of the given function or `null` if there are no elements.\n * \n * @sample samples.collections.Collections.Aggregates.minByOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.minByOrNull(selector: (UShort) -> R): UShort? {\n    if (isEmpty()) return null\n    var minElem = this[0]\n    val lastIndex = this.lastIndex\n    if (lastIndex == 0) return minElem\n    var minValue = selector(minElem)\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        val v = selector(e)\n        if (minValue > v) {\n            minElem = e\n            minValue = v\n        }\n    }\n    return minElem\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.minOf(selector: (UInt) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.minOf(selector: (ULong) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.minOf(selector: (UByte) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.minOf(selector: (UShort) -> Double): Double {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.minOf(selector: (UInt) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.minOf(selector: (ULong) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.minOf(selector: (UByte) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.minOf(selector: (UShort) -> Float): Float {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.minOf(selector: (UInt) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.minOf(selector: (ULong) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.minOf(selector: (UByte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.minOf(selector: (UShort) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.minOfOrNull(selector: (UInt) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.minOfOrNull(selector: (ULong) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.minOfOrNull(selector: (UByte) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.minOfOrNull(selector: (UShort) -> Double): Double? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.minOfOrNull(selector: (UInt) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.minOfOrNull(selector: (ULong) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.minOfOrNull(selector: (UByte) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n * \n * If any of values produced by [selector] function is `NaN`, the returned result is `NaN`.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.minOfOrNull(selector: (UShort) -> Float): Float? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        minValue = minOf(minValue, v)\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UIntArray.minOfOrNull(selector: (UInt) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> ULongArray.minOfOrNull(selector: (ULong) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UByteArray.minOfOrNull(selector: (UByte) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value among all values produced by [selector] function\n * applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R : Comparable<R>> UShortArray.minOfOrNull(selector: (UShort) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (minValue > v) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.minOfWith(comparator: Comparator<in R>, selector: (UInt) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.minOfWith(comparator: Comparator<in R>, selector: (ULong) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.minOfWith(comparator: Comparator<in R>, selector: (UByte) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array.\n * \n * @throws NoSuchElementException if the array is empty.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.minOfWith(comparator: Comparator<in R>, selector: (UShort) -> R): R {\n    if (isEmpty()) throw NoSuchElementException()\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (UInt) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (ULong) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (UByte) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest value according to the provided [comparator]\n * among all values produced by [selector] function applied to each element in the array or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.minOfWithOrNull(comparator: Comparator<in R>, selector: (UShort) -> R): R? {\n    if (isEmpty()) return null\n    var minValue = selector(this[0])\n    for (i in 1..lastIndex) {\n        val v = selector(this[i])\n        if (comparator.compare(minValue, v) > 0) {\n            minValue = v\n        }\n    }\n    return minValue\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.minOrNull(): UInt? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.minOrNull(): ULong? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.minOrNull(): UByte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n/**\n * Returns the smallest element or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.minOrNull(): UShort? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (min > e) min = e\n    }\n    return min\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.minWith(comparator: Comparator<in UInt>): UInt? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.minWith(comparator: Comparator<in ULong>): ULong? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.minWith(comparator: Comparator<in UByte>): UByte? {\n    return minWithOrNull(comparator)\n}\n\n@Deprecated(\"Use minWithOrNull instead.\", ReplaceWith(\"this.minWithOrNull(comparator)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.4\", errorSince = \"1.5\", hiddenSince = \"1.6\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.minWith(comparator: Comparator<in UShort>): UShort? {\n    return minWithOrNull(comparator)\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UIntArray.minWithOrNull(comparator: Comparator<in UInt>): UInt? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun ULongArray.minWithOrNull(comparator: Comparator<in ULong>): ULong? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UByteArray.minWithOrNull(comparator: Comparator<in UByte>): UByte? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns the first element having the smallest value according to the provided [comparator] or `null` if there are no elements.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\npublic fun UShortArray.minWithOrNull(comparator: Comparator<in UShort>): UShort? {\n    if (isEmpty()) return null\n    var min = this[0]\n    for (i in 1..lastIndex) {\n        val e = this[i]\n        if (comparator.compare(min, e) > 0) min = e\n    }\n    return min\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if the array has no elements.\n * \n * @sample samples.collections.Collections.Aggregates.none\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.none(): Boolean {\n    return isEmpty()\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.none(predicate: (UInt) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.none(predicate: (ULong) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.none(predicate: (UByte) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Returns `true` if no elements match the given [predicate].\n * \n * @sample samples.collections.Collections.Aggregates.noneWithPredicate\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.none(predicate: (UShort) -> Boolean): Boolean {\n    for (element in this) if (predicate(element)) return false\n    return true\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.onEach(action: (UInt) -> Unit): UIntArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.onEach(action: (ULong) -> Unit): ULongArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.onEach(action: (UByte) -> Unit): UByteArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element and returns the array itself afterwards.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.onEach(action: (UShort) -> Unit): UShortArray {\n    return apply { for (element in this) action(element) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.onEachIndexed(action: (index: Int, UInt) -> Unit): UIntArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.onEachIndexed(action: (index: Int, ULong) -> Unit): ULongArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.onEachIndexed(action: (index: Int, UByte) -> Unit): UByteArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Performs the given [action] on each element, providing sequential index with the element,\n * and returns the array itself afterwards.\n * @param [action] function that takes the index of an element and the element itself\n * and performs the action on the element.\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.onEachIndexed(action: (index: Int, UShort) -> Unit): UShortArray {\n    return apply { forEachIndexed(action) }\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduce(operation: (acc: UInt, UInt) -> UInt): UInt {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduce(operation: (acc: ULong, ULong) -> ULong): ULong {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduce(operation: (acc: UByte, UByte) -> UByte): UByte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduce(operation: (acc: UShort, UShort) -> UShort): UShort {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceIndexed(operation: (index: Int, acc: UInt, UInt) -> UInt): UInt {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceIndexed(operation: (index: Int, acc: ULong, ULong) -> ULong): ULong {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceIndexed(operation: (index: Int, acc: UByte, UByte) -> UByte): UByte {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduce\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceIndexed(operation: (index: Int, acc: UShort, UShort) -> UShort): UShort {\n    if (isEmpty())\n        throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceIndexedOrNull(operation: (index: Int, acc: UInt, UInt) -> UInt): UInt? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceIndexedOrNull(operation: (index: Int, acc: ULong, ULong) -> ULong): ULong? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceIndexedOrNull(operation: (index: Int, acc: UByte, UByte) -> UByte): UByte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element with its index in the original array.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, current accumulator value and the element itself,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceIndexedOrNull(operation: (index: Int, acc: UShort, UShort) -> UShort): UShort? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(index, accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceOrNull(operation: (acc: UInt, UInt) -> UInt): UInt? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceOrNull(operation: (acc: ULong, ULong) -> ULong): ULong? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceOrNull(operation: (acc: UByte, UByte) -> UByte): UByte? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the first element and applying [operation] from left to right\n * to current accumulator value and each element.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes current accumulator value and an element,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceOrNull(operation: (acc: UShort, UShort) -> UShort): UShort? {\n    if (isEmpty())\n        return null\n    var accumulator = this[0]\n    for (index in 1..lastIndex) {\n        accumulator = operation(accumulator, this[index])\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceRight(operation: (UInt, acc: UInt) -> UInt): UInt {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceRight(operation: (ULong, acc: ULong) -> ULong): ULong {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceRight(operation: (UByte, acc: UByte) -> UByte): UByte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceRight(operation: (UShort, acc: UShort) -> UShort): UShort {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceRightIndexed(operation: (index: Int, UInt, acc: UInt) -> UInt): UInt {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceRightIndexed(operation: (index: Int, ULong, acc: ULong) -> ULong): ULong {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceRightIndexed(operation: (index: Int, UByte, acc: UByte) -> UByte): UByte {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Throws an exception if this array is empty. If the array can be empty in an expected way,\n * please use [reduceRightIndexedOrNull] instead. It returns `null` when its receiver is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRight\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceRightIndexed(operation: (index: Int, UShort, acc: UShort) -> UShort): UShort {\n    var index = lastIndex\n    if (index < 0) throw UnsupportedOperationException(\"Empty array can't be reduced.\")\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceRightIndexedOrNull(operation: (index: Int, UInt, acc: UInt) -> UInt): UInt? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceRightIndexedOrNull(operation: (index: Int, ULong, acc: ULong) -> ULong): ULong? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceRightIndexedOrNull(operation: (index: Int, UByte, acc: UByte) -> UByte): UByte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element with its index in the original array and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes the index of an element, the element itself and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceRightIndexedOrNull(operation: (index: Int, UShort, acc: UShort) -> UShort): UShort? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(index, get(index), accumulator)\n        --index\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.reduceRightOrNull(operation: (UInt, acc: UInt) -> UInt): UInt? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.reduceRightOrNull(operation: (ULong, acc: ULong) -> ULong): ULong? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.reduceRightOrNull(operation: (UByte, acc: UByte) -> UByte): UByte? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Accumulates value starting with the last element and applying [operation] from right to left\n * to each element and current accumulator value.\n * \n * Returns `null` if the array is empty.\n * \n * @param [operation] function that takes an element and current accumulator value,\n * and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.reduceRightOrNull\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.reduceRightOrNull(operation: (UShort, acc: UShort) -> UShort): UShort? {\n    var index = lastIndex\n    if (index < 0) return null\n    var accumulator = get(index--)\n    while (index >= 0) {\n        accumulator = operation(get(index--), accumulator)\n    }\n    return accumulator\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.runningFold(initial: R, operation: (acc: R, UInt) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.runningFold(initial: R, operation: (acc: R, ULong) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.runningFold(initial: R, operation: (acc: R, UByte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.runningFold(initial: R, operation: (acc: R, UShort) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (element in this) {\n        accumulator = operation(accumulator, element)\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, UInt) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, ULong) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, UByte) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningFold\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.runningFoldIndexed(initial: R, operation: (index: Int, acc: R, UShort) -> R): List<R> {\n    if (isEmpty()) return listOf(initial)\n    val result = ArrayList<R>(size + 1).apply { add(initial) }\n    var accumulator = initial\n    for (index in indices) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.runningReduce(operation: (acc: UInt, UInt) -> UInt): List<UInt> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<UInt>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.runningReduce(operation: (acc: ULong, ULong) -> ULong): List<ULong> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<ULong>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.runningReduce(operation: (acc: UByte, UByte) -> UByte): List<UByte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<UByte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.runningReduce(operation: (acc: UShort, UShort) -> UShort): List<UShort> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<UShort>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.runningReduceIndexed(operation: (index: Int, acc: UInt, UInt) -> UInt): List<UInt> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<UInt>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.runningReduceIndexed(operation: (index: Int, acc: ULong, ULong) -> ULong): List<ULong> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<ULong>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.runningReduceIndexed(operation: (index: Int, acc: UByte, UByte) -> UByte): List<UByte> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<UByte>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with the first element of this array.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.runningReduce\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.runningReduceIndexed(operation: (index: Int, acc: UShort, UShort) -> UShort): List<UShort> {\n    if (isEmpty()) return emptyList()\n    var accumulator = this[0]\n    val result = ArrayList<UShort>(size).apply { add(accumulator) }\n    for (index in 1 until size) {\n        accumulator = operation(index, accumulator, this[index])\n        result.add(accumulator)\n    }\n    return result\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.scan(initial: R, operation: (acc: R, UInt) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.scan(initial: R, operation: (acc: R, ULong) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.scan(initial: R, operation: (acc: R, UByte) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes current accumulator value and an element, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.scan(initial: R, operation: (acc: R, UShort) -> R): List<R> {\n    return runningFold(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> UIntArray.scanIndexed(initial: R, operation: (index: Int, acc: R, UInt) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> ULongArray.scanIndexed(initial: R, operation: (index: Int, acc: R, ULong) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> UByteArray.scanIndexed(initial: R, operation: (index: Int, acc: R, UByte) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns a list containing successive accumulation values generated by applying [operation] from left to right\n * to each element, its index in the original array and current accumulator value that starts with [initial] value.\n * \n * Note that `acc` value passed to [operation] function should not be mutated;\n * otherwise it would affect the previous value in resulting list.\n * \n * @param [operation] function that takes the index of an element, current accumulator value\n * and the element itself, and calculates the next accumulator value.\n * \n * @sample samples.collections.Collections.Aggregates.scan\n */\n@SinceKotlin(\"1.4\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalStdlibApi::class)\n@kotlin.internal.InlineOnly\npublic inline fun <R> UShortArray.scanIndexed(initial: R, operation: (index: Int, acc: R, UShort) -> R): List<R> {\n    return runningFoldIndexed(initial, operation)\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumBy(selector: (UInt) -> UInt): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumBy(selector: (ULong) -> UInt): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumBy(selector: (UByte) -> UInt): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumBy(selector: (UShort) -> UInt): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumByDouble(selector: (UInt) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumByDouble(selector: (ULong) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumByDouble(selector: (UByte) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@Deprecated(\"Use sumOf instead.\", ReplaceWith(\"this.sumOf(selector)\"))\n@DeprecatedSinceKotlin(warningSince = \"1.5\")\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumByDouble(selector: (UShort) -> Double): Double {\n    var sum: Double = 0.0\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumOf(selector: (UInt) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumOf(selector: (ULong) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumOf(selector: (UByte) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfDouble\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumOf(selector: (UShort) -> Double): Double {\n    var sum: Double = 0.toDouble()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumOf(selector: (UInt) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumOf(selector: (ULong) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumOf(selector: (UByte) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfInt\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumOf(selector: (UShort) -> Int): Int {\n    var sum: Int = 0.toInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumOf(selector: (UInt) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumOf(selector: (ULong) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumOf(selector: (UByte) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.4\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfLong\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumOf(selector: (UShort) -> Long): Long {\n    var sum: Long = 0.toLong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumOf(selector: (UInt) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumOf(selector: (ULong) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumOf(selector: (UByte) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumOf(selector: (UShort) -> UInt): UInt {\n    var sum: UInt = 0.toUInt()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sumOf(selector: (UInt) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sumOf(selector: (ULong) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sumOf(selector: (UByte) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all values produced by [selector] function applied to each element in the array.\n */\n@SinceKotlin(\"1.5\")\n@OptIn(kotlin.experimental.ExperimentalTypeInference::class)\n@OverloadResolutionByLambdaReturnType\n@Suppress(\"INAPPLICABLE_JVM_NAME\")\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@ExperimentalUnsignedTypes\n@WasExperimental(ExperimentalUnsignedTypes::class)\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sumOf(selector: (UShort) -> ULong): ULong {\n    var sum: ULong = 0.toULong()\n    for (element in this) {\n        sum += selector(element)\n    }\n    return sum\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UIntArray.zip(other: Array<out R>): List<Pair<UInt, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> ULongArray.zip(other: Array<out R>): List<Pair<ULong, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UByteArray.zip(other: Array<out R>): List<Pair<UByte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UShortArray.zip(other: Array<out R>): List<Pair<UShort, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UIntArray.zip(other: Array<out R>, transform: (a: UInt, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> ULongArray.zip(other: Array<out R>, transform: (a: ULong, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UByteArray.zip(other: Array<out R>, transform: (a: UByte, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UShortArray.zip(other: Array<out R>, transform: (a: UShort, b: R) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UIntArray.zip(other: Iterable<R>): List<Pair<UInt, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> ULongArray.zip(other: Iterable<R>): List<Pair<ULong, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UByteArray.zip(other: Iterable<R>): List<Pair<UByte, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` collection and [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun <R> UShortArray.zip(other: Iterable<R>): List<Pair<UShort, R>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UIntArray.zip(other: Iterable<R>, transform: (a: UInt, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> ULongArray.zip(other: Iterable<R>, transform: (a: ULong, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UByteArray.zip(other: Iterable<R>, transform: (a: UByte, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] collection with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <R, V> UShortArray.zip(other: Iterable<R>, transform: (a: UShort, b: R) -> V): List<V> {\n    val arraySize = size\n    val list = ArrayList<V>(minOf(other.collectionSizeOrDefault(10), arraySize))\n    var i = 0\n    for (element in other) {\n        if (i >= arraySize) break\n        list.add(transform(this[i++], element))\n    }\n    return list\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun UIntArray.zip(other: UIntArray): List<Pair<UInt, UInt>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun ULongArray.zip(other: ULongArray): List<Pair<ULong, ULong>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun UByteArray.zip(other: UByteArray): List<Pair<UByte, UByte>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of pairs built from the elements of `this` array and the [other] array with the same index.\n * The returned list has length of the shortest collection.\n * \n * @sample samples.collections.Iterables.Operations.zipIterable\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\npublic infix fun UShortArray.zip(other: UShortArray): List<Pair<UShort, UShort>> {\n    return zip(other) { t1, t2 -> t1 to t2 }\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UIntArray.zip(other: UIntArray, transform: (a: UInt, b: UInt) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> ULongArray.zip(other: ULongArray, transform: (a: ULong, b: ULong) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UByteArray.zip(other: UByteArray, transform: (a: UByte, b: UByte) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns a list of values built from the elements of `this` array and the [other] array with the same index\n * using the provided [transform] function applied to each pair of elements.\n * The returned list has length of the shortest array.\n * \n * @sample samples.collections.Iterables.Operations.zipIterableWithTransform\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun <V> UShortArray.zip(other: UShortArray, transform: (a: UShort, b: UShort) -> V): List<V> {\n    val size = minOf(size, other.size)\n    val list = ArrayList<V>(size)\n    for (i in 0 until size) {\n        list.add(transform(this[i], other[i]))\n    }\n    return list\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfUInt\")\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun Array<out UInt>.sum(): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfULong\")\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun Array<out ULong>.sum(): ULong {\n    var sum: ULong = 0uL\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfUByte\")\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun Array<out UByte>.sum(): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@kotlin.jvm.JvmName(\"sumOfUShort\")\n@SinceKotlin(\"1.5\")\n@WasExperimental(ExperimentalUnsignedTypes::class)\npublic fun Array<out UShort>.sum(): UInt {\n    var sum: UInt = 0u\n    for (element in this) {\n        sum += element\n    }\n    return sum\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UIntArray.sum(): UInt {\n    return storage.sum().toUInt()\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun ULongArray.sum(): ULong {\n    return storage.sum().toULong()\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UByteArray.sum(): UInt {\n    return sumOf { it.toUInt() }\n}\n\n/**\n * Returns the sum of all elements in the array.\n */\n@SinceKotlin(\"1.3\")\n@ExperimentalUnsignedTypes\n@kotlin.internal.InlineOnly\npublic inline fun UShortArray.sum(): UInt {\n    return sumOf { it.toUInt() }\n}\n\n","package io.ktor.utils.io.bits\n\nimport io.ktor.utils.io.core.internal.*\nimport org.khronos.webgl.*\nimport kotlin.contracts.*\n\n/**\n * Execute [block] of code providing a temporary instance of [Memory] view of this byte array range\n * starting at the specified [offset] and having the specified bytes [length].\n * By default, if neither [offset] nor [length] specified, the whole array is used.\n * An instance of [Memory] provided into the [block] should be never captured and used outside of lambda.\n */\npublic actual inline fun <R> ByteArray.useMemory(offset: Int, length: Int, block: (Memory) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n    return Memory.of(this, offset, length).let(block)\n}\n\n/**\n * Create [Memory] view for the specified [array] range starting at [offset] and the specified bytes [length].\n */\npublic fun Memory.Companion.of(array: ByteArray, offset: Int = 0, length: Int = array.size - offset): Memory {\n    @Suppress(\"UnsafeCastFromDynamic\")\n    val typedArray: Int8Array = array.asDynamic()\n    return Memory.of(typedArray, offset, length)\n}\n\n/**\n * Create [Memory] view for the specified [buffer] range starting at [offset] and the specified bytes [length].\n */\npublic fun Memory.Companion.of(buffer: ArrayBuffer, offset: Int = 0, length: Int = buffer.byteLength - offset): Memory {\n    return Memory(DataView(buffer, offset, length))\n}\n\n/**\n * Create [Memory] view for the specified [view].\n */\npublic fun Memory.Companion.of(view: DataView): Memory {\n    return Memory(view)\n}\n\n/**\n * Create [Memory] view for the specified [view] range starting at [offset] and the specified bytes [length].\n */\npublic fun Memory.Companion.of(view: ArrayBufferView, offset: Int = 0, length: Int = view.byteLength): Memory {\n    return Memory.of(view.buffer, view.byteOffset + offset, length)\n}\n\n@PublishedApi\ninternal actual object DefaultAllocator : Allocator {\n    override fun alloc(size: Int): Memory = Memory(DataView(ArrayBuffer(size)))\n    override fun alloc(size: Long): Memory = Memory(DataView(ArrayBuffer(size.toIntOrFail(\"size\"))))\n    override fun free(instance: Memory) {\n    }\n}\n","@file:Suppress(\"RedundantModalityModifier\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.pool.*\n\n/**\n * The default abstract base class implementing [Input] interface.\n * @see [AbstractInput.fill] and [AbstractInput.closeSource].\n */\n@Deprecated(\n    \"AbstractInput is deprecated and will be merged with Input in 2.0.0\",\n    ReplaceWith(\"Input\"),\n    DeprecationLevel.WARNING\n)\npublic abstract class AbstractInput(\n    head: ChunkBuffer = ChunkBuffer.Empty,\n    remaining: Long = head.remainingAll(),\n    public val pool: ObjectPool<ChunkBuffer> = ChunkBuffer.Pool\n) : Input {\n    private val state = AbstractInputSharedState(head, remaining)\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public constructor(\n        head: IoBuffer = IoBuffer.Empty,\n        remaining: Long = head.remainingAll(),\n        pool: ObjectPool<ChunkBuffer> = ChunkBuffer.Pool\n    ) : this(head as ChunkBuffer, remaining, pool)\n\n    /**\n     * Read the next bytes into the [destination] starting at [offset] at most [length] bytes.\n     * May block until at least one byte is available.\n     * Usually bypass all exceptions from the underlying source.\n     *\n     * @param offset in bytes where result should be written\n     * @param length should be at least one byte\n     *\n     * @return number of bytes were copied or `0` if EOF encountered\n     */\n    protected abstract fun fill(destination: Memory, offset: Int, length: Int): Int\n\n    /**\n     * Should close the underlying bytes source. Could do nothing or throw exceptions.\n     */\n    protected abstract fun closeSource()\n\n    /**\n     * Current head chunk reference\n     */\n    private final var _head: ChunkBuffer\n        get() = state.head\n        set(newHead) {\n            state.head = newHead\n            state.headMemory = newHead.memory\n            state.headPosition = newHead.readPosition\n            state.headEndExclusive = newHead.writePosition\n        }\n\n    @PublishedApi\n    @Suppress(\"CanBePrimaryConstructorProperty\")\n    internal var head: ChunkBuffer\n        get() = _head.also { it.discardUntilIndex(headPosition) }\n        @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.ERROR)\n        set(newHead) {\n            _head = newHead\n        }\n\n    @PublishedApi\n    internal final var headMemory: Memory\n        get() = state.headMemory\n        set(value) {\n            state.headMemory = value\n        }\n\n    @PublishedApi\n    internal final var headPosition: Int\n        get() = state.headPosition\n        set(value) {\n            state.headPosition = value\n        }\n\n    @PublishedApi\n    internal final var headEndExclusive: Int\n        get() = state.headEndExclusive\n        set(value) {\n            state.headEndExclusive = value\n        }\n\n    @PublishedApi\n    @Suppress(\"DEPRECATION_ERROR\")\n    internal final var headRemaining: Int\n        inline get() = headEndExclusive - headPosition\n        @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n        set(newRemaining) {\n            updateHeadRemaining(newRemaining)\n        }\n\n    private var tailRemaining: Long\n        get() = state.tailRemaining\n        set(newValue) {\n            require(newValue >= 0) { \"tailRemaining shouldn't be negative: $newValue\" }\n            state.tailRemaining = newValue\n        }\n\n    @Deprecated(\n        \"Not supported anymore. All operations are big endian by default.\",\n        level = DeprecationLevel.ERROR\n    )\n    final override var byteOrder: ByteOrder\n        get() = ByteOrder.BIG_ENDIAN\n        set(newOrder) {\n            if (newOrder != ByteOrder.BIG_ENDIAN) {\n                throw IllegalArgumentException(\"Only BIG_ENDIAN is supported.\")\n            }\n        }\n\n    internal final fun prefetch(min: Long): Boolean {\n        if (min <= 0) return true\n        val headRemaining = headRemaining\n        if (headRemaining >= min || headRemaining + tailRemaining >= min) return true\n\n        return doPrefetch(min)\n    }\n\n    final override fun peekTo(destination: Memory, destinationOffset: Long, offset: Long, min: Long, max: Long): Long {\n        prefetch(min + offset)\n\n        var current: ChunkBuffer = head\n        var copied = 0L\n        var skip = offset\n        var writePosition = destinationOffset\n        val maxCopySize = minOf(max, destination.size - destinationOffset)\n\n        while (copied < min && copied < maxCopySize) {\n            val chunkSize = current.readRemaining\n            if (chunkSize > skip) {\n                val size = minOf(chunkSize - skip, maxCopySize - copied)\n                current.memory.copyTo(\n                    destination,\n                    current.readPosition + skip,\n                    size,\n                    writePosition\n                )\n                skip = 0\n                copied += size\n                writePosition += size\n            } else {\n                skip -= chunkSize\n            }\n\n            current = current.next ?: break\n        }\n\n        return copied\n    }\n\n    /**\n     * @see doFill for similar logic\n     * @see appendView for similar logic\n     */\n    private fun doPrefetch(min: Long): Boolean {\n        var tail = _head.findTail()\n        var available = headRemaining + tailRemaining\n\n        do {\n            val next = fill()\n            if (next == null) {\n                noMoreChunksAvailable = true\n                return false\n            }\n\n            val chunkSize = next.readRemaining\n            if (tail === ChunkBuffer.Empty) {\n                _head = next\n                tail = next\n            } else {\n                tail.next = next\n                tailRemaining += chunkSize\n            }\n\n            available += chunkSize\n        } while (available < min)\n\n        return true\n    }\n\n    /**\n     * Number of bytes available for read\n     */\n    public final val remaining: Long get() = headRemaining.toLong() + tailRemaining\n\n    /**\n     * @return `true` if there is at least one byte to read\n     */\n    public final fun canRead(): Boolean = headPosition != headEndExclusive || tailRemaining != 0L\n\n    /**\n     * @return `true` if there are at least [n] bytes to read\n     */\n    public final fun hasBytes(n: Int): Boolean = headRemaining + tailRemaining >= n\n\n    /**\n     * `true` if no bytes available for read\n     */\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public final val isEmpty: Boolean\n        get() = endOfInput\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public final val isNotEmpty: Boolean\n        get() = isNotEmpty\n\n    private var noMoreChunksAvailable = false\n\n    final override val endOfInput: Boolean\n        get() = headRemaining == 0 && tailRemaining == 0L && (noMoreChunksAvailable || doFill() == null)\n\n    /**\n     * Release packet. After this function invocation the packet becomes empty.\n     * If it has been copied via [ByteReadPacket.copy]\n     * then the copy should be released as well.\n     */\n    public final fun release() {\n        val head = head\n        val empty = ChunkBuffer.Empty\n\n        if (head !== empty) {\n            this._head = empty\n            tailRemaining = 0\n            head.releaseAll(pool)\n        }\n    }\n\n    final override fun close() {\n        release()\n        if (!noMoreChunksAvailable) {\n            noMoreChunksAvailable = true\n        }\n        closeSource()\n    }\n\n    internal final fun stealAll(): ChunkBuffer? {\n        val head = head\n        val empty = ChunkBuffer.Empty\n\n        if (head === empty) return null\n        this._head = empty\n        tailRemaining = 0\n        return head\n    }\n\n    internal final fun steal(): ChunkBuffer? {\n        val head = head\n        val next = head.next\n        val empty = ChunkBuffer.Empty\n        if (head === empty) return null\n\n        if (next == null) {\n            this._head = empty\n            this.tailRemaining = 0\n        } else {\n            this._head = next\n            this.tailRemaining -= next.readRemaining\n        }\n\n        head.next = null\n        return head\n    }\n\n    internal final fun append(chain: ChunkBuffer) {\n        if (chain === ChunkBuffer.Empty) return\n\n        val size = chain.remainingAll()\n        if (_head === ChunkBuffer.Empty) {\n            _head = chain\n            tailRemaining = size - headRemaining\n        } else {\n            _head.findTail().next = chain\n            tailRemaining += size\n        }\n    }\n\n    internal final fun tryWriteAppend(chain: ChunkBuffer): Boolean {\n        val tail = head.findTail()\n        val size = chain.readRemaining\n\n        if (size == 0 || tail.writeRemaining < size) return false\n        tail.writeBufferAppend(chain, size)\n\n        if (head === tail) {\n            headEndExclusive = tail.writePosition\n        } else {\n            tailRemaining += size\n        }\n\n        return true\n    }\n\n    final override fun readByte(): Byte {\n        val index = headPosition\n        val nextIndex = index + 1\n        if (nextIndex < headEndExclusive) {\n            // fast-path when we are not reading the last byte\n            headPosition = nextIndex\n            return headMemory[index]\n        }\n\n        return readByteSlow()\n    }\n\n    private fun readByteSlow(): Byte {\n        val index = headPosition\n        if (index < headEndExclusive) {\n            val value = headMemory[index]\n            headPosition = index\n            val head = _head\n            head.discardUntilIndex(index)\n            ensureNext(head)\n            return value\n        }\n\n        val head = prepareRead(1) ?: prematureEndOfStream(1)\n        val byte = head.readByte()\n        completeReadHead(head)\n        return byte\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readShort(): Short = readShort()\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readFloat(): Float = readFloat()\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readDouble(): Double = readDouble()\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readInt(): Int {\n        return readInt()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readLong(): Long {\n        return readLong()\n    }\n\n    /**\n     * Read exactly [length] bytes to [dst] array at specified [offset]\n     */\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readFully(dst: ByteArray, offset: Int, length: Int) {\n        val rc = readAvailable(dst, offset, length)\n        if (rc != length) {\n            throw EOFException(\"Not enough data in packet to fill buffer: ${length - rc} more bytes required\")\n        }\n    }\n\n    /**\n     * Discards at most [n] bytes\n     * @return number of bytes has been discarded\n     */\n    public final fun discard(n: Int): Int {\n        require(n >= 0) { \"Negative discard is not allowed: $n\" }\n        return discardAsMuchAsPossible(n, 0)\n    }\n\n    /**\n     * Discards exactly [n] bytes or fails with [EOFException]\n     */\n    public final fun discardExact(n: Int) {\n        if (discard(n) != n) throw EOFException(\"Unable to discard $n bytes due to end of packet\")\n    }\n\n    @PublishedApi\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    internal inline fun read(block: (Buffer) -> Unit) {\n        read(block = block)\n    }\n\n    @PublishedApi\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    internal inline fun read(n: Int, block: (Buffer) -> Unit) {\n        read(n, block)\n    }\n\n    /**\n     * Returns next byte (unsigned) or `-1` if no more bytes available\n     */\n    final override fun tryPeek(): Int {\n        val head = head\n        if (headRemaining > 0) {\n            return head.tryPeekByte()\n        }\n\n        if (tailRemaining == 0L && noMoreChunksAvailable) return -1\n\n        return prepareReadLoop(1, head)?.tryPeekByte() ?: -1\n    }\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun peekTo(buffer: IoBuffer): Int {\n        val head = prepareReadHead(1) ?: return -1\n\n        val size = minOf(buffer.writeRemaining, head.readRemaining)\n        (buffer as Buffer).writeFully(head, size)\n\n        return size\n    }\n\n    final override fun discard(n: Long): Long {\n        if (n <= 0) return 0L\n        return discardAsMuchAsPossible(n, 0)\n    }\n\n    internal fun readAvailableCharacters(destination: CharArray, off: Int, len: Int): Int {\n        if (endOfInput) return -1\n\n        val out = object : Appendable {\n            private var idx = off\n\n            override fun append(c: Char): Appendable {\n                destination[idx++] = c\n                return this\n            }\n\n            override fun append(csq: CharSequence?): Appendable {\n                if (csq is String) {\n                    csq.getCharsInternal(destination, idx)\n                    idx += csq.length\n                } else if (csq != null) {\n                    for (i in 0 until csq.length) {\n                        destination[idx++] = csq[i]\n                    }\n                }\n\n                return this\n            }\n\n            override fun append(csq: CharSequence?, start: Int, end: Int): Appendable {\n                throw UnsupportedOperationException()\n            }\n        }\n\n        return readText(out, 0, len)\n    }\n\n    /**\n     * Read at least [min] and at most [max] characters and append them to [out]\n     * @return number of characters appended\n     */\n    public fun readText(out: Appendable, min: Int = 0, max: Int = Int.MAX_VALUE): Int {\n        if (max.toLong() >= remaining) {\n            val s = readTextExactBytes(bytesCount = remaining.toInt())\n            out.append(s)\n            return s.length\n        }\n        return readASCII(out, min, max)\n    }\n\n    /**\n     * Read exactly [exactCharacters] characters and append them to [out]\n     */\n    public fun readTextExact(out: Appendable, exactCharacters: Int) {\n        readText(out, exactCharacters, exactCharacters)\n    }\n\n    /**\n     * Read a string at last [min] and at most [max] characters length\n     */\n    public fun readText(min: Int = 0, max: Int = Int.MAX_VALUE): String {\n        if (min == 0 && (max == 0 || endOfInput)) return \"\"\n        val remaining = remaining\n        if (remaining > 0 && max.toLong() >= remaining) return readTextExactBytes(bytesCount = remaining.toInt())\n\n        return buildString(min.coerceAtLeast(16).coerceAtMost(max)) {\n            readASCII(this, min, max)\n        }\n    }\n\n    /**\n     * Read a string exactly [exactCharacters] length\n     */\n    public fun readTextExact(exactCharacters: Int): String {\n        return readText(exactCharacters, exactCharacters)\n    }\n\n    private fun readASCII(out: Appendable, min: Int, max: Int): Int {\n        when {\n            max == 0 && min == 0 -> return 0\n            endOfInput -> if (min == 0) return 0 else atLeastMinCharactersRequire(min)\n            max < min -> minShouldBeLess(min, max)\n        }\n\n        var copied = 0\n        var utf8 = false\n\n        takeWhile { buffer ->\n            val rc = buffer.decodeASCII {\n                if (copied == max) false\n                else {\n                    out.append(it)\n                    copied++\n                    true\n                }\n            }\n\n            when {\n                rc -> true\n                copied == max -> false\n                else -> {\n                    utf8 = true\n                    false\n                }\n            }\n        }\n\n        if (utf8) {\n            return copied + readUtf8(out, min - copied, max - copied)\n        }\n        if (copied < min) prematureEndOfStreamChars(min, copied)\n        return copied\n    }\n\n    private fun atLeastMinCharactersRequire(min: Int): Nothing =\n        throw EOFException(\"at least $min characters required but no bytes available\")\n\n    private fun minShouldBeLess(min: Int, max: Int): Nothing =\n        throw IllegalArgumentException(\"min should be less or equal to max but min = $min, max = $max\")\n\n    private fun prematureEndOfStreamChars(min: Int, copied: Int): Nothing = throw MalformedUTF8InputException(\n        \"Premature end of stream: expected at least $min chars but had only $copied\"\n    )\n\n    private fun readUtf8(out: Appendable, min: Int, max: Int): Int {\n        var copied = 0\n\n        takeWhileSize { buffer ->\n            val size = buffer.decodeUTF8 {\n                if (copied == max) false\n                else {\n                    out.append(it)\n                    copied++\n                    true\n                }\n            }\n\n            when {\n                size == 0 -> 1\n                size > 0 -> size\n                else -> 0\n            }\n        }\n\n        if (copied < min) prematureEndOfStreamChars(min, copied)\n\n        return copied\n    }\n\n    private tailrec fun discardAsMuchAsPossible(n: Long, skipped: Long): Long {\n        if (n == 0L) return skipped\n        val current = prepareRead(1) ?: return skipped\n        val size = minOf(current.readRemaining.toLong(), n).toInt()\n        current.discardExact(size)\n        headPosition += size\n        afterRead(current)\n\n        return discardAsMuchAsPossible(n - size, skipped + size)\n    }\n\n    private fun discardAsMuchAsPossible(n: Int, skipped: Int): Int {\n        var currentCount = n\n        var currentSkipped = skipped\n\n        while (true) {\n            if (currentCount == 0) {\n                return currentSkipped\n            }\n\n            val current = prepareRead(1) ?: return currentSkipped\n\n            val size = minOf(current.readRemaining, currentCount)\n            current.discardExact(size)\n            headPosition += size\n            afterRead(current)\n\n            currentCount -= size\n            currentSkipped += size\n        }\n    }\n\n    private tailrec fun readAsMuchAsPossible(array: ByteArray, offset: Int, length: Int, copied: Int): Int {\n        if (length == 0) return copied\n        val current = prepareRead(1) ?: return copied\n        val size = minOf(length, current.readRemaining)\n\n        current.readFully(array, offset, size)\n        headPosition = current.readPosition\n\n        return if (size != length || current.readRemaining == 0) {\n            afterRead(current)\n            readAsMuchAsPossible(array, offset + size, length - size, copied + size)\n        } else {\n            copied + size\n        }\n    }\n\n    private fun notEnoughBytesAvailable(n: Int): Nothing {\n        throw EOFException(\"Not enough data in packet ($remaining) to read $n byte(s)\")\n    }\n\n    @Deprecated(\"Not supported anymore.\", level = DeprecationLevel.ERROR)\n    public fun updateHeadRemaining(remaining: Int) {\n        // the only external usages are from readDirect\n        // so after using head chunk directly we should fix positions instead\n        val newPosition = headEndExclusive - remaining\n\n        if (newPosition < 0) {\n            throw IllegalArgumentException(\"Unable to update position to negative. newRemaining is too big.\")\n        }\n\n        headPosition = newPosition\n    }\n\n    @DangerousInternalIoApi\n    public fun prepareReadHead(minSize: Int): ChunkBuffer? = prepareReadLoop(minSize, head)\n\n    @DangerousInternalIoApi\n    public fun ensureNextHead(current: ChunkBuffer): ChunkBuffer? = ensureNext(current)\n\n    @PublishedApi\n    internal fun ensureNext(current: ChunkBuffer): ChunkBuffer? = ensureNext(\n        current,\n        ChunkBuffer.Empty\n    )\n\n    @DangerousInternalIoApi\n    public fun fixGapAfterRead(current: ChunkBuffer) {\n        val next = current.next ?: return fixGapAfterReadFallback(current)\n\n        val remaining = current.readRemaining\n        val overrunSize = minOf(remaining, Buffer.ReservedSize - current.endGap)\n        if (next.startGap < overrunSize) {\n            return fixGapAfterReadFallback(current)\n        }\n\n        next.restoreStartGap(overrunSize)\n\n        if (remaining > overrunSize) {\n            current.releaseEndGap()\n\n            this.headEndExclusive = current.writePosition\n            this.tailRemaining += overrunSize\n        } else {\n            this._head = next\n            this.tailRemaining -= next.readRemaining - overrunSize\n            current.cleanNext()\n            current.release(pool)\n        }\n    }\n\n    private fun fixGapAfterReadFallback(current: ChunkBuffer) {\n        if (noMoreChunksAvailable && current.next == null) {\n            this.headPosition = current.readPosition\n            this.headEndExclusive = current.writePosition\n            this.tailRemaining = 0\n            return\n        }\n\n        val size = current.readRemaining\n        val overrun = minOf(size, Buffer.ReservedSize - current.endGap)\n\n        if (size > overrun) {\n            fixGapAfterReadFallbackUnreserved(current, size, overrun)\n        } else {\n            val new = pool.borrow()\n            new.reserveEndGap(Buffer.ReservedSize)\n            new.next = current.cleanNext()\n\n            new.writeBufferAppend(current, size)\n            this._head = new\n        }\n\n        current.release(pool)\n    }\n\n    private fun fixGapAfterReadFallbackUnreserved(current: ChunkBuffer, size: Int, overrun: Int) {\n        // if we have a chunk with no end reservation\n        // we can split it into two to fix it\n\n        val chunk1 = pool.borrow()\n        val chunk2 = pool.borrow()\n\n        chunk1.reserveEndGap(Buffer.ReservedSize)\n        chunk2.reserveEndGap(Buffer.ReservedSize)\n        chunk1.next = chunk2\n        chunk2.next = current.cleanNext()\n\n        chunk1.writeBufferAppend(current, size - overrun)\n        chunk2.writeBufferAppend(current, overrun)\n\n        this._head = chunk1\n        this.tailRemaining = chunk2.remainingAll()\n    }\n\n    private tailrec fun ensureNext(current: ChunkBuffer, empty: ChunkBuffer): ChunkBuffer? {\n        if (current === empty) {\n            return doFill()\n        }\n\n        val next = current.cleanNext()\n        current.release(pool)\n\n        return when {\n            next == null -> {\n                this._head = empty\n                this.tailRemaining = 0L\n                ensureNext(empty, empty)\n            }\n            next.canRead() -> {\n                _head = next\n                tailRemaining -= next.readRemaining\n                next\n            }\n            else -> ensureNext(next, empty)\n        }\n    }\n\n    /**\n     * Reads the next chunk suitable for reading or `null` if no more chunks available. It is also allowed\n     * to return a chain of chunks linked through [ChunkBuffer.next]. The last chunk should have `null` next reference.\n     * Could rethrow exceptions from the underlying source.\n     */\n    protected open fun fill(): ChunkBuffer? {\n        val buffer = pool.borrow()\n        try {\n            buffer.reserveEndGap(Buffer.ReservedSize)\n            val copied = fill(buffer.memory, buffer.writePosition, buffer.writeRemaining)\n\n            if (copied == 0) {\n                noMoreChunksAvailable = true\n\n                if (!buffer.canRead()) {\n                    buffer.release(pool)\n                    return null\n                }\n            }\n\n            buffer.commitWritten(copied)\n\n            return buffer\n        } catch (t: Throwable) {\n            buffer.release(pool)\n            throw t\n        }\n    }\n\n    protected final fun markNoMoreChunksAvailable() {\n        if (!noMoreChunksAvailable) {\n            noMoreChunksAvailable = true\n        }\n    }\n\n    /**\n     * see [prefetch] for similar logic\n     */\n    private final fun doFill(): ChunkBuffer? {\n        if (noMoreChunksAvailable) return null\n        val chunk = fill()\n        if (chunk == null) {\n            noMoreChunksAvailable = true\n            return null\n        }\n        appendView(chunk)\n        return chunk\n    }\n\n    private final fun appendView(chunk: ChunkBuffer) {\n        val tail = _head.findTail()\n        if (tail === ChunkBuffer.Empty) {\n            _head = chunk\n            require(tailRemaining == 0L) {\n                throw IllegalStateException(\"It should be no tail remaining bytes if current tail is EmptyBuffer\")\n            }\n            tailRemaining = chunk.next?.remainingAll() ?: 0L\n        } else {\n            tail.next = chunk\n            tailRemaining += chunk.remainingAll()\n        }\n    }\n\n    @PublishedApi\n    internal fun prepareRead(minSize: Int): ChunkBuffer? {\n        val head = head\n        if (headEndExclusive - headPosition >= minSize) return head\n        return prepareReadLoop(minSize, head)\n    }\n\n    @PublishedApi\n    internal final fun prepareRead(minSize: Int, head: ChunkBuffer): ChunkBuffer? {\n        if (headEndExclusive - headPosition >= minSize) return head\n        return prepareReadLoop(minSize, head)\n    }\n\n    private tailrec fun prepareReadLoop(minSize: Int, head: ChunkBuffer): ChunkBuffer? {\n        val headSize = headRemaining\n        if (headSize >= minSize) return head\n\n        val next = head.next ?: doFill() ?: return null\n\n        if (headSize == 0) {\n            if (head !== ChunkBuffer.Empty) {\n                releaseHead(head)\n            }\n\n            return prepareReadLoop(minSize, next)\n        } else {\n            val desiredExtraBytes = minSize - headSize\n            val copied = head.writeBufferAppend(next, desiredExtraBytes)\n            headEndExclusive = head.writePosition\n            tailRemaining -= copied\n            if (!next.canRead()) {\n                head.next = null\n                head.next = next.cleanNext()\n                next.release(pool)\n            } else {\n                next.reserveStartGap(copied)\n            }\n        }\n\n        if (head.readRemaining >= minSize) return head\n        if (minSize > Buffer.ReservedSize) minSizeIsTooBig(minSize)\n\n        return prepareReadLoop(minSize, head)\n    }\n\n    private fun minSizeIsTooBig(minSize: Int): Nothing {\n        throw IllegalStateException(\"minSize of $minSize is too big (should be less than ${Buffer.ReservedSize})\")\n    }\n\n    private fun afterRead(head: ChunkBuffer) {\n        if (head.readRemaining == 0) {\n            releaseHead(head)\n        }\n    }\n\n    internal final fun releaseHead(head: ChunkBuffer): ChunkBuffer {\n        val next = head.cleanNext() ?: ChunkBuffer.Empty\n        this._head = next\n        this.tailRemaining -= next.readRemaining\n        head.release(pool)\n\n        return next\n    }\n\n    public companion object\n}\n","/*\n * Copyright 2016-2017 JetBrains s.r.o.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\npackage io.ktor.utils.io\n\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.*\nimport kotlinx.coroutines.*\n\n/**\n * Channel for asynchronous reading and writing of sequences of bytes.\n * This is a buffered **single-reader single-writer channel**.\n *\n * Read operations can be invoked concurrently with write operations, but multiple reads or multiple writes\n * cannot be invoked concurrently with themselves. Exceptions are [close] and [flush] which can be invoked\n * concurrently with any other operations and between themselves at any time.\n */\npublic interface ByteChannel : ByteReadChannel, ByteWriteChannel {\n    public fun attachJob(job: Job)\n}\n\n/**\n * Creates buffered channel for asynchronous reading and writing of sequences of bytes.\n */\npublic expect fun ByteChannel(autoFlush: Boolean = false): ByteChannel\n\n/**\n * Creates channel for reading from the specified byte array. Please note that it could use [content] directly\n * or copy its bytes depending on the platform.\n */\npublic fun ByteReadChannel(content: ByteArray): ByteReadChannel =\n    ByteReadChannel(content, 0, content.size)\n\n/**\n * Creates channel for reading from the specified byte array. Please note that it could use [content] directly\n * or copy its bytes depending on the platform.\n */\npublic fun ByteReadChannel(content: ByteArray, offset: Int): ByteReadChannel =\n    ByteReadChannel(content, offset, content.size)\n\n/**\n * Creates channel for reading from the specified byte array. Please note that it could use [content] directly\n * or copy its bytes depending on the platform\n */\npublic expect fun ByteReadChannel(content: ByteArray, offset: Int, length: Int): ByteReadChannel\n\npublic fun ByteReadChannel(text: String, charset: Charset = Charsets.UTF_8): ByteReadChannel =\n    ByteReadChannel(text.toByteArray(charset)) // TODO optimize to encode parts on demand\n\n/**\n * Byte channel that is always empty.\n */\n@Deprecated(\n    \"Use ByteReadChannel.Empty instead\",\n    ReplaceWith(\"ByteReadChannel.Empty\"),\n    level = DeprecationLevel.ERROR\n)\npublic val EmptyByteReadChannel: ByteReadChannel\n    get() = ByteReadChannel.Empty\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.pool.*\nimport kotlin.contracts.*\n\npublic expect val PACKET_MAX_COPY_SIZE: Int\n\n/**\n * Build a byte packet in [block] lambda. Creates a temporary builder and releases it in case of failure\n */\npublic inline fun buildPacket(headerSizeHint: Int = 0, block: BytePacketBuilder.() -> Unit): ByteReadPacket {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val builder = BytePacketBuilder(headerSizeHint)\n    try {\n        block(builder)\n        return builder.build()\n    } catch (t: Throwable) {\n        builder.release()\n        throw t\n    }\n}\n\npublic expect fun BytePacketBuilder(headerSizeHint: Int = 0): BytePacketBuilder\n\n/**\n * Discard all written bytes and prepare to build another packet.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun BytePacketBuilder.reset() {\n    release()\n}\n\n@DangerousInternalIoApi\n@Deprecated(\"Will be removed in future releases.\", level = DeprecationLevel.ERROR)\n@Suppress(\"DEPRECATION_ERROR\")\npublic abstract class BytePacketBuilderPlatformBase\ninternal constructor(pool: ObjectPool<ChunkBuffer>) : BytePacketBuilderBase(pool)\n\n@DangerousInternalIoApi\n@Deprecated(\"Will be removed in future releases\", level = DeprecationLevel.ERROR)\n@Suppress(\"DEPRECATION_ERROR\")\npublic abstract class BytePacketBuilderBase\ninternal constructor(pool: ObjectPool<ChunkBuffer>) : AbstractOutput(pool)\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.utils.io\n\n/**\n * Print exception stacktrace.\n */\npublic expect fun Throwable.printStack()\n\ninternal fun Throwable.unwrapCancellationException(): Throwable {\n    var exception: Throwable = this\n    while (exception is CancellationException) {\n        if (exception == exception.cause) {\n            return this\n        }\n\n        exception = exception.cause ?: return exception\n    }\n\n    return exception\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\n\n/**\n * This shouldn't be implemented directly. Inherit [AbstractOutput] instead.\n */\npublic expect interface Output : Appendable, Closeable {\n    @Deprecated(\n        \"This is no longer supported. All operations are big endian by default. Use writeXXXLittleEndian \" +\n            \"to write primitives in little endian order\" +\n            \" or do X.reverseByteOrder() and then writeXXX instead.\",\n        level = DeprecationLevel.ERROR\n    )\n    public var byteOrder: ByteOrder\n\n    public fun writeByte(v: Byte)\n\n    public fun flush()\n\n    override fun close()\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeShort(v: Short) {\n        writeShort(v)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeInt(v: Int) {\n        writeInt(v)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeLong(v: Long) {\n        writeLong(v)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeFloat(v: Float) {\n        writeFloat(v)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeDouble(v: Double) {\n        writeDouble(v)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeFully(src: ByteArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeFully(src: ShortArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeFully(src: IntArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeFully(src: LongArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeFully(src: FloatArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeFully(src: DoubleArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\", \"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun writeFully(src: IoBuffer, length: Int) {\n        writeFully(src, length)\n    }\n\n    public fun append(csq: CharArray, start: Int, end: Int): Appendable\n\n    @Suppress(\"EXPECTED_DECLARATION_WITH_BODY\", \"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun fill(n: Long, v: Byte) {\n        fill(n, v)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Output.append(csq: CharSequence, start: Int = 0, end: Int = csq.length): Appendable {\n    return append(csq, start, end)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Output.append(csq: CharArray, start: Int = 0, end: Int = csq.size): Appendable {\n    return append(csq, start, end)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Output.writeFully(src: ByteArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFullyBytesTemplate(offset, length) { buffer, currentOffset, count ->\n        buffer.writeFully(src, currentOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Output.writeFully(src: ShortArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFullyTemplate(2, offset, length) { buffer, currentOffset, count ->\n        buffer.writeFully(src, currentOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Output.writeFully(src: IntArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFullyTemplate(4, offset, length) { buffer, currentOffset, count ->\n        buffer.writeFully(src, currentOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Output.writeFully(src: LongArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFullyTemplate(8, offset, length) { buffer, currentOffset, count ->\n        buffer.writeFully(src, currentOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Output.writeFully(src: FloatArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFullyTemplate(4, offset, length) { buffer, currentOffset, count ->\n        buffer.writeFully(src, currentOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Output.writeFully(src: DoubleArray, offset: Int = 0, length: Int = src.size - offset) {\n    writeFullyTemplate(8, offset, length) { buffer, currentOffset, count ->\n        buffer.writeFully(src, currentOffset, count)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\npublic fun Output.writeFully(src: IoBuffer, length: Int = src.readRemaining) {\n    writeFully(src as Buffer, length)\n}\n\npublic fun Output.writeFully(src: Buffer, length: Int = src.readRemaining) {\n    writeFullyBytesTemplate(0, length) { buffer, _, count ->\n        buffer.writeFully(src, count)\n    }\n}\n\npublic fun Output.writeFully(src: Memory, offset: Int, length: Int) {\n    writeFully(src, offset.toLong(), length.toLong())\n}\n\npublic fun Output.writeFully(src: Memory, offset: Long, length: Long) {\n    writeFullyBytesTemplate(offset, length) { memory, destinationOffset, sourceOffset, count ->\n        src.copyTo(memory, sourceOffset, count, destinationOffset)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Output.fill(times: Long, value: Byte = 0) {\n    if (this is AbstractOutput) {\n        var written = 0L\n        writeWhile { buffer ->\n            val partTimes = minOf(buffer.writeRemaining.toLong(), times - written).toInt()\n            buffer.fill(partTimes, value)\n            written += partTimes\n            written < times\n        }\n    } else {\n        fillFallback(times, value)\n    }\n}\n\nprivate fun Output.fillFallback(times: Long, value: Byte) {\n    for (iterate in 0 until times) {\n        writeByte(value)\n    }\n}\n\n/**\n * Append number of chunks invoking [block] function while the returned value is true.\n * Depending on the output underlying implementation it could invoke [block] function with the same buffer several times\n * however it is guaranteed that it is always non-empty.\n */\n@DangerousInternalIoApi\npublic inline fun Output.writeWhile(block: (Buffer) -> Boolean) {\n    var tail: ChunkBuffer = prepareWriteHead(1, null)\n    try {\n        while (true) {\n            if (!block(tail)) break\n            tail = prepareWriteHead(1, tail)\n        }\n    } finally {\n        afterHeadWrite(tail)\n    }\n}\n\n/**\n * Append number of chunks invoking [block] function while the returned value is positive.\n * If returned value is positive then it will be invoked again with a buffer having at least requested number of\n * bytes space (could be the same buffer as before if it complies to the restriction).\n * @param initialSize for the first buffer passed to [block] function\n */\n@DangerousInternalIoApi\npublic inline fun Output.writeWhileSize(initialSize: Int = 1, block: (Buffer) -> Int) {\n    var tail = prepareWriteHead(initialSize, null)\n\n    try {\n        var size: Int\n        while (true) {\n            size = block(tail)\n            if (size <= 0) break\n            tail = prepareWriteHead(size, tail)\n        }\n    } finally {\n        afterHeadWrite(tail)\n    }\n}\n\npublic fun Output.writePacket(packet: ByteReadPacket) {\n    @Suppress(\"DEPRECATION_ERROR\")\n    if (this is BytePacketBuilderBase) {\n        writePacket(packet)\n        return\n    }\n\n    packet.takeWhile { from ->\n        writeFully(from)\n        true\n    }\n}\n\nprivate inline fun Output.writeFullyBytesTemplate(\n    offset: Int,\n    length: Int,\n    block: (Buffer, currentOffset: Int, count: Int) -> Unit\n) {\n    var currentOffset = offset\n    var remaining = length\n\n    writeWhile { buffer ->\n        val size = minOf(remaining, buffer.writeRemaining)\n        block(buffer, currentOffset, size)\n        currentOffset += size\n        remaining -= size\n        remaining > 0\n    }\n}\n\nprivate inline fun Output.writeFullyBytesTemplate(\n    initialOffset: Long,\n    length: Long,\n    block: (destination: Memory, destinationOffset: Long, currentOffset: Long, count: Long) -> Unit\n) {\n    var currentOffset = initialOffset\n    var remaining = length\n\n    writeWhile { buffer ->\n        val size = minOf(remaining, buffer.writeRemaining.toLong())\n        block(buffer.memory, buffer.writePosition.toLong(), currentOffset, size)\n        buffer.commitWritten(size.toInt())\n        currentOffset += size\n        remaining -= size\n        remaining > 0\n    }\n}\n\nprivate inline fun Output.writeFullyTemplate(\n    componentSize: Int,\n    offset: Int,\n    length: Int,\n    block: (Buffer, currentOffset: Int, count: Int) -> Unit\n) {\n    var currentOffset = offset\n    var remaining = length\n\n    writeWhileSize(componentSize) { buffer ->\n        val size = minOf(remaining, buffer.writeRemaining)\n        block(buffer, currentOffset, size)\n        currentOffset += size\n        remaining -= size\n        remaining * componentSize\n    }\n}\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.bits\n\nimport io.ktor.utils.io.core.internal.*\nimport org.khronos.webgl.*\nimport kotlin.require\n\n/**\n * Represents a linear range of bytes.\n */\npublic actual class Memory @DangerousInternalIoApi constructor(public val view: DataView) {\n    /**\n     * Size of memory range in bytes.\n     */\n    public actual inline val size: Long get() = view.byteLength.toLong()\n\n    /**\n     * Size of memory range in bytes represented as signed 32bit integer\n     * @throws IllegalStateException when size doesn't fit into a signed 32bit integer\n     */\n    public actual inline val size32: Int get() = view.byteLength\n\n    /**\n     * Returns byte at [index] position.\n     */\n    public actual inline fun loadAt(index: Int): Byte {\n        return view.getInt8(index)\n    }\n\n    /**\n     * Returns byte at [index] position.\n     */\n    public actual inline fun loadAt(index: Long): Byte {\n        return view.getInt8(index.toIntOrFail(\"index\"))\n    }\n\n    /**\n     * Write [value] at the specified [index].\n     */\n    public actual inline fun storeAt(index: Int, value: Byte) {\n        view.setInt8(index, value)\n    }\n\n    /**\n     * Write [value] at the specified [index]\n     */\n    public actual inline fun storeAt(index: Long, value: Byte) {\n        view.setInt8(index.toIntOrFail(\"index\"), value)\n    }\n\n    /**\n     * Returns memory's subrange. On some platforms it could do range checks but it is not guaranteed to be safe.\n     * It also could lead to memory allocations on some platforms.\n     */\n    public actual fun slice(offset: Int, length: Int): Memory {\n        require(offset >= 0) { \"offset shouldn't be negative: $offset\" }\n        require(length >= 0) { \"length shouldn't be negative: $length\" }\n        if (offset + length > size) {\n            throw IndexOutOfBoundsException(\"offset + length > size: $offset + $length > $size\")\n        }\n\n        return Memory(\n            DataView(\n                view.buffer,\n                view.byteOffset + offset,\n                length\n            )\n        )\n    }\n\n    /**\n     * Returns memory's subrange. On some platforms it could do range checks but it is not guaranteed to be safe.\n     * It also could lead to memory allocations on some platforms.\n     */\n    public actual fun slice(offset: Long, length: Long): Memory {\n        return slice(offset.toIntOrFail(\"offset\"), length.toIntOrFail(\"length\"))\n    }\n\n    /**\n     * Copies bytes from this memory range from the specified [offset] and [length]\n     * to the [destination] at [destinationOffset].\n     * Copying bytes from a memory to itself is allowed.\n     */\n    public actual fun copyTo(\n        destination: Memory,\n        offset: Int,\n        length: Int,\n        destinationOffset: Int\n    ) {\n        val src = Int8Array(view.buffer, view.byteOffset + offset, length)\n        val dst = Int8Array(destination.view.buffer, destination.view.byteOffset + destinationOffset, length)\n\n        dst.set(src)\n    }\n\n    /**\n     * Copies bytes from this memory range from the specified [offset] and [length]\n     * to the [destination] at [destinationOffset].\n     * Copying bytes from a memory to itself is allowed.\n     */\n    public actual fun copyTo(\n        destination: Memory,\n        offset: Long,\n        length: Long,\n        destinationOffset: Long\n    ) {\n        copyTo(\n            destination,\n            offset.toIntOrFail(\"offset\"),\n            length.toIntOrFail(\"length\"),\n            destinationOffset.toIntOrFail(\"destinationOffset\")\n        )\n    }\n\n    public actual companion object {\n        /**\n         * Represents an empty memory region\n         */\n        public actual val Empty: Memory = Memory(DataView(ArrayBuffer(0)))\n    }\n}\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [length]\n * to the [destination] at [destinationOffset].\n */\npublic actual fun Memory.copyTo(\n    destination: ByteArray,\n    offset: Int,\n    length: Int,\n    destinationOffset: Int\n) {\n    @Suppress(\"UnsafeCastFromDynamic\")\n    val to: Int8Array = destination.asDynamic()\n\n    val from = Int8Array(view.buffer, view.byteOffset + offset, length)\n\n    to.set(from, destinationOffset)\n}\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [length]\n * to the [destination] at [destinationOffset].\n */\npublic actual fun Memory.copyTo(\n    destination: ByteArray,\n    offset: Long,\n    length: Int,\n    destinationOffset: Int\n) {\n    copyTo(destination, offset.toIntOrFail(\"offset\"), length, destinationOffset)\n}\n\n/**\n * Fill memory range starting at the specified [offset] with [value] repeated [count] times.\n */\npublic actual fun Memory.fill(offset: Int, count: Int, value: Byte) {\n    for (index in offset until offset + count) {\n        this[index] = value\n    }\n}\n\n/**\n * Fill memory range starting at the specified [offset] with [value] repeated [count] times.\n */\npublic actual fun Memory.fill(offset: Long, count: Long, value: Byte) {\n    fill(offset.toIntOrFail(\"offset\"), count.toIntOrFail(\"count\"), value)\n}\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [length]\n * to the [destination] at [destinationOffset].\n */\npublic fun Memory.copyTo(destination: ArrayBuffer, offset: Int, length: Int, destinationOffset: Int) {\n    @Suppress(\"UnsafeCastFromDynamic\")\n    val to = Int8Array(destination, destinationOffset, length)\n    val from = Int8Array(view.buffer, view.byteOffset + offset, length)\n\n    to.set(from, 0)\n}\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [length]\n * to the [destination] at [destinationOffset].\n */\npublic fun Memory.copyTo(destination: ArrayBufferView, offset: Int, length: Int, destinationOffset: Int) {\n    @Suppress(\"UnsafeCastFromDynamic\")\n    val to = Int8Array(destination.buffer, destinationOffset + destination.byteOffset, length)\n    val from = Int8Array(view.buffer, view.byteOffset + offset, length)\n\n    to.set(from, 0)\n}\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [length]\n * to the [destination] at [destinationOffset].\n */\npublic fun ArrayBuffer.copyTo(destination: Memory, offset: Int, length: Int, destinationOffset: Int) {\n    val from = Int8Array(this, offset, length)\n    val to = Int8Array(destination.view.buffer, destination.view.byteOffset + destinationOffset, length)\n\n    to.set(from, 0)\n}\n\n/**\n * Copies bytes from this memory range from the specified [offset] and [length]\n * to the [destination] at [destinationOffset].\n */\npublic fun ArrayBufferView.copyTo(destination: Memory, offset: Int, length: Int, destinationOffset: Int) {\n    buffer.copyTo(destination, offset + byteOffset, length, destinationOffset)\n}\n\ninternal val Memory.Int8ArrayView: Int8Array get() = Int8Array(view.buffer, view.byteOffset, view.byteLength)\n","package io.ktor.utils.io.core\n\nimport kotlin.contracts.*\n\n@PublishedApi\ninternal inline fun AbstractInput.read(n: Int = 1, block: (Buffer) -> Unit) {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val buffer = prepareRead(n) ?: prematureEndOfStream(n)\n    val positionBefore = buffer.readPosition\n    try {\n        block(buffer)\n    } finally {\n        val positionAfter = buffer.readPosition\n        if (positionAfter < positionBefore) {\n            throw IllegalStateException(\"Buffer's position shouldn't be rewinded\")\n        }\n        if (positionAfter == buffer.writePosition) {\n            ensureNext(buffer)\n        } else {\n            headPosition = positionAfter\n        }\n    }\n}\n","package io.ktor.utils.io.core.internal\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.*\n\ninternal inline fun Buffer.decodeASCII(consumer: (Char) -> Boolean): Boolean {\n    read { memory, start, endExclusive ->\n        for (index in start until endExclusive) {\n            val codepoint = memory[index].toInt() and 0xff\n            if (codepoint and 0x80 == 0x80 || !consumer(codepoint.toChar())) {\n                discardExact(index - start)\n                return false\n            }\n        }\n\n        endExclusive - start\n    }\n\n    return true\n}\n\n@DangerousInternalIoApi\npublic suspend fun decodeUTF8LineLoopSuspend(\n    out: Appendable,\n    limit: Int,\n    nextChunk: suspend (Int) -> AbstractInput?\n): Boolean {\n    var decoded = 0\n    var size = 1\n    var cr = false\n    var end = false\n\n    while (!end && size != 0) {\n        val chunk = nextChunk(size) ?: break\n        chunk.takeWhileSize { buffer ->\n            var skip = 0\n            size = buffer.decodeUTF8 { ch ->\n                when (ch) {\n                    '\\r' -> {\n                        if (cr) {\n                            end = true\n                            return@decodeUTF8 false\n                        }\n                        cr = true\n                        true\n                    }\n                    '\\n' -> {\n                        end = true\n                        skip = 1\n                        false\n                    }\n                    else -> {\n                        if (cr) {\n                            end = true\n                            return@decodeUTF8 false\n                        }\n\n                        if (decoded == limit) {\n                            throw TooLongLineException(\"Too many characters in line: limit $limit exceeded\")\n                        }\n                        decoded++\n                        out.append(ch)\n                        true\n                    }\n                }\n            }\n\n            if (skip > 0) {\n                buffer.discardExact(skip)\n            }\n\n            size = if (end) 0 else size.coerceAtLeast(1)\n\n            size\n        }\n    }\n\n    if (size > 1) prematureEndOfStreamUtf(size)\n    if (cr) {\n        end = true\n    }\n\n    return decoded > 0 || end\n}\n\nprivate fun prematureEndOfStreamUtf(size: Int): Nothing =\n    throw EOFException(\"Premature end of stream: expected $size bytes to decode UTF-8 char\")\n\n@DangerousInternalIoApi\ninternal fun byteCountUtf8(firstByte: Int): Int {\n    var byteCount = 0\n    var mask = 0x80\n    var value = firstByte\n\n    for (i in 1..6) {\n        if (value and mask != 0) {\n            value = value and mask.inv()\n            mask = mask shr 1\n            byteCount++\n        } else {\n            break\n        }\n    }\n\n    return byteCount\n}\n\n@Suppress(\"DEPRECATION\")\n@Deprecated(\"Binary compatibility\", level = DeprecationLevel.HIDDEN)\npublic inline fun IoBuffer.decodeUTF8(consumer: (Char) -> Boolean): Int {\n    return (this as Buffer).decodeUTF8(consumer)\n}\n\n/**\n * Decodes all the bytes to utf8 applying every character on [consumer] until or consumer return `false`.\n * If a consumer returned false then a character will be pushed back (including all surrogates will be pushed back as well)\n * and [decodeUTF8] returns -1\n * @return number of bytes required to decode incomplete utf8 character or 0 if all bytes were processed\n * or -1 if consumer rejected loop\n */\n@DangerousInternalIoApi\npublic inline fun Buffer.decodeUTF8(consumer: (Char) -> Boolean): Int {\n    var byteCount = 0\n    var value = 0\n    var lastByteCount = 0\n\n    read { memory, start, endExclusive ->\n        for (index in start until endExclusive) {\n            val v = memory[index].toInt() and 0xff\n            when {\n                v and 0x80 == 0 -> {\n                    if (byteCount != 0) malformedByteCount(byteCount)\n                    if (!consumer(v.toChar())) {\n                        discardExact(index - start)\n                        return -1\n                    }\n                }\n                byteCount == 0 -> {\n                    // first unicode byte\n\n                    var mask = 0x80\n                    value = v\n\n                    for (i in 1..6) { // TODO do we support 6 bytes unicode?\n                        if (value and mask != 0) {\n                            value = value and mask.inv()\n                            mask = mask shr 1\n                            byteCount++\n                        } else {\n                            break\n                        }\n                    }\n\n                    lastByteCount = byteCount\n                    byteCount--\n\n                    if (lastByteCount > endExclusive - index) {\n                        discardExact(index - start)\n                        return lastByteCount\n                    }\n                }\n                else -> {\n                    // trailing unicode byte\n                    value = (value shl 6) or (v and 0x7f)\n                    byteCount--\n\n                    if (byteCount == 0) {\n                        if (isBmpCodePoint(value)) {\n                            if (!consumer(value.toChar())) {\n                                discardExact(index - start - lastByteCount + 1)\n                                return -1\n                            }\n                        } else if (!isValidCodePoint(value)) {\n                            malformedCodePoint(value)\n                        } else {\n                            if (!consumer(highSurrogate(value).toChar()) ||\n                                !consumer(lowSurrogate(value).toChar())\n                            ) {\n                                discardExact(index - start - lastByteCount + 1)\n                                return -1\n                            }\n                        }\n\n                        value = 0\n                    }\n                }\n            }\n        }\n\n        endExclusive - start\n    }\n\n    return 0\n}\n\n@Suppress(\"RedundantModalityModifier\")\ninternal class CharArraySequence(\n    private val array: CharArray,\n    private val offset: Int,\n    final override val length: Int\n) : CharSequence {\n    final override fun get(index: Int): Char {\n        if (index >= length) {\n            indexOutOfBounds(index)\n        }\n        return array[index + offset]\n    }\n\n    final override fun subSequence(startIndex: Int, endIndex: Int): CharSequence {\n        require(startIndex >= 0) { \"startIndex shouldn't be negative: $startIndex\" }\n        require(startIndex <= length) { \"startIndex is too large: $startIndex > $length\" }\n        require(startIndex + endIndex <= length) { \"endIndex is too large: $endIndex > $length\" }\n        require(endIndex >= startIndex) { \"endIndex should be greater or equal to startIndex: $startIndex > $endIndex\" }\n\n        return CharArraySequence(array, offset + startIndex, endIndex - startIndex)\n    }\n\n    private fun indexOutOfBounds(index: Int): Nothing {\n        throw IndexOutOfBoundsException(\"String index out of bounds: $index > $length\")\n    }\n}\n\n@Suppress(\"NOTHING_TO_INLINE\", \"EXPERIMENTAL_FEATURE_WARNING\")\ninternal inline class EncodeResult(val value: Int) {\n    constructor(characters: UShort, bytes: UShort) : this(characters.toInt() shl 16 or bytes.toInt())\n\n    inline val characters: UShort get() = value.highShort.toUShort()\n    inline val bytes: UShort get() = value.lowShort.toUShort()\n\n    inline operator fun component1(): UShort = characters\n    inline operator fun component2(): UShort = bytes\n}\n\ninternal fun Memory.encodeUTF8(text: CharSequence, from: Int, to: Int, dstOffset: Int, dstLimit: Int): EncodeResult {\n    // encode single-byte characters\n    val lastCharIndex = minOf(to, from + UShort.MAX_VALUE.toInt())\n    val resultLimit = dstLimit.coerceAtMost(UShort.MAX_VALUE.toInt())\n    var resultPosition = dstOffset\n    var index = from\n\n    do {\n        if (resultPosition >= resultLimit || index >= lastCharIndex) {\n            return EncodeResult((index - from).toUShort(), (resultPosition - dstOffset).toUShort())\n        }\n\n        val character = text[index++].toInt() and 0xffff\n        if (character and 0xff80 == 0) {\n            storeAt(resultPosition++, character.toByte())\n        } else {\n            break\n        }\n    } while (true)\n\n    index--\n    return encodeUTF8Stage1(text, index, lastCharIndex, from, resultPosition, resultLimit, dstOffset)\n}\n\n/**\n * Encode UTF-8 multibytes characters when we for sure have enough free space\n */\nprivate fun Memory.encodeUTF8Stage1(\n    text: CharSequence,\n    index1: Int,\n    lastCharIndex: Int,\n    from: Int,\n    resultPosition1: Int,\n    resultLimit: Int,\n    dstOffset: Int\n): EncodeResult {\n    var index = index1\n    var resultPosition: Int = resultPosition1\n    val stage1Limit = resultLimit - 3\n\n    do {\n        val freeSpace = stage1Limit - resultPosition\n        if (freeSpace <= 0 || index >= lastCharIndex) {\n            break\n        }\n\n        val character = text[index++]\n        val codepoint = when {\n            character.isHighSurrogate() -> {\n                if (index == lastCharIndex || !text[index].isLowSurrogate()) {\n                    63\n                } else {\n                    codePoint(character, text[index++])\n                }\n            }\n            else -> character.toInt()\n        }\n        val size = putUtf8Char(resultPosition, codepoint)\n\n        resultPosition += size\n    } while (true)\n\n    if (resultPosition == stage1Limit) {\n        return encodeUTF8Stage2(text, index, lastCharIndex, from, resultPosition, resultLimit, dstOffset)\n    }\n\n    return EncodeResult((index - from).toUShort(), (resultPosition - dstOffset).toUShort())\n}\n\nprivate fun Memory.encodeUTF8Stage2(\n    text: CharSequence,\n    index1: Int,\n    lastCharIndex: Int,\n    from: Int,\n    resultPosition1: Int,\n    resultLimit: Int,\n    dstOffset: Int\n): EncodeResult {\n    var index = index1\n    var resultPosition: Int = resultPosition1\n\n    do {\n        val freeSpace = resultLimit - resultPosition\n        if (freeSpace <= 0 || index >= lastCharIndex) {\n            break\n        }\n\n        val character = text[index++]\n        val codepoint = when {\n            !character.isHighSurrogate() -> character.toInt()\n            else -> {\n                if (index == lastCharIndex || !text[index].isLowSurrogate()) {\n                    63\n                } else {\n                    codePoint(character, text[index++])\n                }\n            }\n        }\n        if (charactersSize(codepoint) > freeSpace) {\n            index--\n            break\n        }\n        val size = putUtf8Char(resultPosition, codepoint)\n        resultPosition += size\n    } while (true)\n\n    return EncodeResult((index - from).toUShort(), (resultPosition - dstOffset).toUShort())\n}\n\n@Suppress(\"NOTHING_TO_INLINE\")\nprivate inline fun charactersSize(v: Int) = when {\n    v in 1..0x7f -> 1\n    v in 0x80..0x7ff -> 2\n    v in 0x800..0xffff -> 3\n    v in 0x10000..0x10ffff -> 4\n    else -> malformedCodePoint(v)\n}\n\n// TODO optimize it, now we are simply do naive encoding here\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal inline fun Memory.putUtf8Char(offset: Int, v: Int): Int = when {\n    v in 0..0x7f -> {\n        storeAt(offset, v.toByte())\n        1\n    }\n    v in 0x80..0x7ff -> {\n        this[offset] = (0xc0 or ((v shr 6) and 0x1f)).toByte()\n        this[offset + 1] = (0x80 or (v and 0x3f)).toByte()\n        2\n    }\n    v in 0x800..0xffff -> {\n        this[offset] = (0xe0 or ((v shr 12) and 0x0f)).toByte()\n        this[offset + 1] = (0x80 or ((v shr 6) and 0x3f)).toByte()\n        this[offset + 2] = (0x80 or (v and 0x3f)).toByte()\n        3\n    }\n    v in 0x10000..0x10ffff -> {\n        this[offset] = (0xf0 or ((v shr 18) and 0x07)).toByte() // 3 bits\n        this[offset + 1] = (0x80 or ((v shr 12) and 0x3f)).toByte() // 6 bits\n        this[offset + 2] = (0x80 or ((v shr 6) and 0x3f)).toByte() // 6 bits\n        this[offset + 3] = (0x80 or (v and 0x3f)).toByte() // 6 bits\n        4\n    }\n    else -> malformedCodePoint(v)\n}\n\n@PublishedApi\ninternal fun malformedByteCount(byteCount: Int): Nothing =\n    throw MalformedUTF8InputException(\"Expected $byteCount more character bytes\")\n\n@PublishedApi\ninternal fun malformedCodePoint(value: Int): Nothing =\n    throw IllegalArgumentException(\"Malformed code-point $value found\")\n\nprivate const val MaxCodePoint = 0x10ffff\nprivate const val MinLowSurrogate = 0xdc00\nprivate const val MinHighSurrogate = 0xd800\nprivate const val MinSupplementary = 0x10000\nprivate const val HighSurrogateMagic = MinHighSurrogate - (MinSupplementary ushr 10)\n\n@PublishedApi\ninternal fun isBmpCodePoint(cp: Int): Boolean = cp ushr 16 == 0\n\n@PublishedApi\ninternal fun isValidCodePoint(codePoint: Int): Boolean = codePoint <= MaxCodePoint\n\n@PublishedApi\ninternal fun lowSurrogate(cp: Int): Int = (cp and 0x3ff) + MinLowSurrogate\n\n@PublishedApi\ninternal fun highSurrogate(cp: Int): Int = (cp ushr 10) + HighSurrogateMagic\n\ninternal fun codePoint(high: Char, low: Char): Int {\n//    check(high.isHighSurrogate())\n//    check(low.isLowSurrogate())\n\n    val highValue = high.toInt() - HighSurrogateMagic\n    val lowValue = low.toInt() - MinLowSurrogate\n\n    return highValue shl 10 or lowValue\n}\n\npublic class MalformedUTF8InputException(message: String) : Exception(message)\n","@file:Suppress(\"LocalVariableName\", \"RedundantModalityModifier\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.pool.*\n\n/**\n * The default [Output] implementation.\n * @see flush\n * @see closeDestination\n */\n@ExperimentalIoApi\n@Deprecated(\n    \"AbstractOutput is deprecated and will be merged with Input in 2.0.0\",\n    ReplaceWith(\"Output\"),\n    DeprecationLevel.WARNING\n)\npublic abstract class AbstractOutput\ninternal constructor(\n    private val headerSizeHint: Int,\n    protected val pool: ObjectPool<ChunkBuffer>\n) : Appendable, Output {\n    public constructor(pool: ObjectPool<ChunkBuffer>) : this(0, pool)\n\n    public constructor() : this(ChunkBuffer.Pool)\n\n    /**\n     * An implementation should write [source] to the destination exactly [length] bytes.\n     * It should never capture the [source] instance\n     * longer than this method execution since it may be disposed after return.\n     */\n    protected abstract fun flush(source: Memory, offset: Int, length: Int)\n\n    /**\n     * An implementation should only close the destination.\n     */\n    protected abstract fun closeDestination()\n\n    private val state = AbstractOutputSharedState()\n\n    private var _head: ChunkBuffer?\n        get() = state.head\n        set(value) {\n            state.head = value\n        }\n\n    private var _tail: ChunkBuffer?\n        get() = state.tail\n        set(value) {\n            state.tail = value\n        }\n\n    internal val head: ChunkBuffer\n        get() = _head ?: ChunkBuffer.Empty\n\n    @PublishedApi\n    @Deprecated(\"Will be removed in future releases.\", level = DeprecationLevel.HIDDEN)\n    internal val tail: ChunkBuffer\n        get() {\n            return prepareWriteHead(1)\n        }\n\n    @Deprecated(\"Will be removed. Override flush(buffer) properly.\", level = DeprecationLevel.ERROR)\n    protected var currentTail: ChunkBuffer\n        get() = prepareWriteHead(1)\n        set(newValue) {\n            appendChain(newValue)\n        }\n\n    internal var tailMemory: Memory\n        get() = state.tailMemory\n        set(value) {\n            state.tailMemory = value\n        }\n\n    internal var tailPosition\n        get() = state.tailPosition\n        set(value) {\n            state.tailPosition = value\n        }\n\n    internal var tailEndExclusive\n        get() = state.tailEndExclusive\n        private set(value) {\n            state.tailEndExclusive = value\n        }\n\n    private var tailInitialPosition\n        get() = state.tailInitialPosition\n        set(value) {\n            state.tailInitialPosition = value\n        }\n\n    /**\n     * Number of bytes buffered in the chain except the tail chunk\n     */\n    private var chainedSize: Int\n        get() = state.chainedSize\n        set(value) {\n            state.chainedSize = value\n        }\n\n    internal inline val tailRemaining: Int get() = tailEndExclusive - tailPosition\n\n    /**\n     * Number of bytes currently buffered (pending).\n     */\n    protected final var _size: Int\n        get() = chainedSize + (tailPosition - tailInitialPosition)\n        @Deprecated(\"There is no need to update/reset this value anymore.\")\n        set(_) {\n        }\n\n    /**\n     * Byte order (Endianness) to be used by future write functions calls on this builder instance. Doesn't affect any\n     * previously written values.\n     * @default [ByteOrder.BIG_ENDIAN]\n     */\n    @Deprecated(\n        \"This is no longer supported. All operations are big endian by default. Use readXXXLittleEndian \" +\n            \"to read primitives in little endian\",\n        level = DeprecationLevel.ERROR\n    )\n    final override var byteOrder: ByteOrder = ByteOrder.BIG_ENDIAN\n        set(value) {\n            field = value\n            if (value != ByteOrder.BIG_ENDIAN) {\n                throw IllegalArgumentException(\n                    \"Only BIG_ENDIAN is supported. Use corresponding functions to read/write\" +\n                        \"in the little endian\"\n                )\n            }\n        }\n\n    final override fun flush() {\n        flushChain()\n    }\n\n    private fun flushChain() {\n        val oldTail = stealAll() ?: return\n\n        try {\n            oldTail.forEachChunk { chunk ->\n                flush(chunk.memory, chunk.readPosition, chunk.readRemaining)\n            }\n        } finally {\n            oldTail.releaseAll(pool)\n        }\n    }\n\n    /**\n     * Detach all chunks and cleanup all internal state so builder could be reusable again\n     * @return a chain of buffer views or `null` of it is empty\n     */\n    internal fun stealAll(): ChunkBuffer? {\n        val head = this._head ?: return null\n\n        _tail?.commitWrittenUntilIndex(tailPosition)\n\n        this._head = null\n        this._tail = null\n        tailPosition = 0\n        tailEndExclusive = 0\n        tailInitialPosition = 0\n        chainedSize = 0\n        tailMemory = Memory.Empty\n\n        return head\n    }\n\n    internal fun afterBytesStolen() {\n        val head = head\n        if (head !== ChunkBuffer.Empty) {\n            check(head.next == null)\n            head.resetForWrite()\n            head.reserveStartGap(headerSizeHint)\n            head.reserveEndGap(Buffer.ReservedSize)\n            tailPosition = head.writePosition\n            tailInitialPosition = tailPosition\n            tailEndExclusive = head.limit\n        }\n    }\n\n    internal final fun appendSingleChunk(buffer: ChunkBuffer) {\n        check(buffer.next == null) { \"It should be a single buffer chunk.\" }\n        appendChainImpl(buffer, buffer, 0)\n    }\n\n    internal final fun appendChain(head: ChunkBuffer) {\n        val tail = head.findTail()\n        val chainedSizeDelta = (head.remainingAll() - tail.readRemaining).toIntOrFail(\"total size increase\")\n        appendChainImpl(head, tail, chainedSizeDelta)\n    }\n\n    private fun appendNewChunk(): ChunkBuffer {\n        val new = pool.borrow()\n        new.reserveEndGap(Buffer.ReservedSize)\n\n        appendSingleChunk(new)\n\n        return new\n    }\n\n    private final fun appendChainImpl(head: ChunkBuffer, newTail: ChunkBuffer, chainedSizeDelta: Int) {\n        val _tail = _tail\n        if (_tail == null) {\n            _head = head\n            chainedSize = 0\n        } else {\n            _tail.next = head\n            val tailPosition = tailPosition\n            _tail.commitWrittenUntilIndex(tailPosition)\n            chainedSize += tailPosition - tailInitialPosition\n        }\n\n        this._tail = newTail\n        chainedSize += chainedSizeDelta\n        tailMemory = newTail.memory\n        tailPosition = newTail.writePosition\n        tailInitialPosition = newTail.readPosition\n        tailEndExclusive = newTail.limit\n    }\n\n    final override fun writeByte(v: Byte) {\n        val index = tailPosition\n        if (index < tailEndExclusive) {\n            tailPosition = index + 1\n            tailMemory[index] = v\n            return\n        }\n\n        return writeByteFallback(v)\n    }\n\n    private fun writeByteFallback(v: Byte) {\n        appendNewChunk().writeByte(v)\n        tailPosition++\n    }\n\n    /**\n     * Should flush and close the destination\n     */\n    final override fun close() {\n        try {\n            flush()\n        } finally {\n            closeDestination() // TODO check what should be done here\n        }\n    }\n\n    /**\n     * Append single UTF-8 character\n     */\n    override fun append(c: Char): AbstractOutput {\n        val tailPosition = tailPosition\n        if (tailEndExclusive - tailPosition >= 3) {\n            val size = tailMemory.putUtf8Char(tailPosition, c.toInt())\n            this.tailPosition = tailPosition + size\n            return this\n        }\n\n        appendCharFallback(c)\n        return this\n    }\n\n    private fun appendCharFallback(c: Char) {\n        write(3) { buffer ->\n            val size = buffer.memory.putUtf8Char(buffer.writePosition, c.toInt())\n            buffer.commitWritten(size)\n            size\n        }\n    }\n\n    override fun append(csq: CharSequence?): AbstractOutput {\n        if (csq == null) {\n            append(\"null\", 0, 4)\n        } else {\n            append(csq, 0, csq.length)\n        }\n        return this\n    }\n\n    override fun append(csq: CharSequence?, start: Int, end: Int): AbstractOutput {\n        if (csq == null) {\n            return append(\"null\", start, end)\n        }\n\n        writeText(csq, start, end, Charsets.UTF_8)\n\n        return this\n    }\n\n    /**\n     * Writes another packet to the end. Please note that the instance [p] gets consumed so you don't need to release it\n     */\n    public fun writePacket(p: ByteReadPacket) {\n        val foreignStolen = p.stealAll()\n        if (foreignStolen == null) {\n            p.release()\n            return\n        }\n\n        val _tail = _tail\n        if (_tail == null) {\n            appendChain(foreignStolen)\n            return\n        }\n\n        writePacketMerging(_tail, foreignStolen, p.pool)\n    }\n\n    /**\n     * Write chunk buffer to current [Output]. Assuming that chunk buffer is from current pool.\n     */\n    internal fun writeChunkBuffer(chunkBuffer: ChunkBuffer) {\n        val _tail = _tail\n        if (_tail == null) {\n            appendChain(chunkBuffer)\n            return\n        }\n\n        writePacketMerging(_tail, chunkBuffer, pool)\n    }\n\n    private fun writePacketMerging(tail: ChunkBuffer, foreignStolen: ChunkBuffer, pool: ObjectPool<ChunkBuffer>) {\n        tail.commitWrittenUntilIndex(tailPosition)\n\n        val lastSize = tail.readRemaining\n        val nextSize = foreignStolen.readRemaining\n\n        // at first we evaluate if it is reasonable to merge chunks\n        val maxCopySize = PACKET_MAX_COPY_SIZE\n        val appendSize = if (nextSize < maxCopySize && nextSize <= (tail.endGap + tail.writeRemaining)) {\n            nextSize\n        } else -1\n\n        val prependSize =\n            if (lastSize < maxCopySize && lastSize <= foreignStolen.startGap && foreignStolen.isExclusivelyOwned()) {\n                lastSize\n            } else -1\n\n        if (appendSize == -1 && prependSize == -1) {\n            // simply enqueue if there is no reason to merge\n            appendChain(foreignStolen)\n        } else if (prependSize == -1 || appendSize <= prependSize) {\n            // do append\n            tail.writeBufferAppend(foreignStolen, tail.writeRemaining + tail.endGap)\n            afterHeadWrite()\n            foreignStolen.cleanNext()?.let { next ->\n                appendChain(next)\n            }\n\n            foreignStolen.release(pool)\n        } else if (appendSize == -1 || prependSize < appendSize) {\n            writePacketSlowPrepend(foreignStolen, tail)\n        } else {\n            throw IllegalStateException(\"prep = $prependSize, app = $appendSize\")\n        }\n    }\n\n    /**\n     * Do prepend current [tail] to the beginning of [foreignStolen].\n     */\n    private fun writePacketSlowPrepend(foreignStolen: ChunkBuffer, tail: ChunkBuffer) {\n        foreignStolen.writeBufferPrepend(tail)\n\n        val _head = _head ?: error(\"head should't be null since it is already handled in the fast-path\")\n        if (_head === tail) {\n            this._head = foreignStolen\n        } else {\n            // we need to fix next reference of the previous chunk before the tail\n            // we have to traverse from the beginning to find it\n            var pre = _head\n            while (true) {\n                val next = pre.next!!\n                if (next === tail) break\n                pre = next\n            }\n\n            pre.next = foreignStolen\n        }\n\n        tail.release(pool)\n\n        this._tail = foreignStolen.findTail()\n    }\n\n    /**\n     * Write exact [n] bytes from packet to the builder\n     */\n    public fun writePacket(p: ByteReadPacket, n: Int) {\n        var remaining = n\n\n        while (remaining > 0) {\n            val headRemaining = p.headRemaining\n            if (headRemaining <= remaining) {\n                remaining -= headRemaining\n                appendSingleChunk(p.steal() ?: throw EOFException(\"Unexpected end of packet\"))\n            } else {\n                p.read { view ->\n                    writeFully(view, remaining)\n                }\n                break\n            }\n        }\n    }\n\n    /**\n     * Write exact [n] bytes from packet to the builder\n     */\n    public fun writePacket(p: ByteReadPacket, n: Long) {\n        var remaining = n\n\n        while (remaining > 0L) {\n            val headRemaining = p.headRemaining.toLong()\n            if (headRemaining <= remaining) {\n                remaining -= headRemaining\n                appendSingleChunk(p.steal() ?: throw EOFException(\"Unexpected end of packet\"))\n            } else {\n                p.read { view ->\n                    writeFully(view, remaining.toInt())\n                }\n                break\n            }\n        }\n    }\n\n    override fun append(csq: CharArray, start: Int, end: Int): Appendable {\n        writeText(csq, start, end, Charsets.UTF_8)\n        return this\n    }\n\n    private inline fun appendCharsTemplate(\n        start: Int,\n        end: Int,\n        block: Buffer.(index: Int) -> Int\n    ): Int {\n        var idx = start\n        if (idx >= end) return idx\n        idx = prepareWriteHead(1).block(idx)\n        afterHeadWrite()\n\n        while (idx < end) {\n            idx = appendNewChunk().block(idx)\n            afterHeadWrite()\n        }\n\n        return idx\n    }\n\n    @Deprecated(\"Use writeText instead\", ReplaceWith(\"writeText(s)\"))\n    public fun writeStringUtf8(s: String) {\n        writeText(s)\n    }\n\n    @Deprecated(\"Use writeText instead\", ReplaceWith(\"this.writeText(cs)\"))\n    public fun writeStringUtf8(cs: CharSequence) {\n        writeText(cs)\n    }\n\n    @Suppress(\"NOTHING_TO_INLINE\")\n    private inline fun Buffer.putUtf8Char(v: Int) = when {\n        v in 1..0x7f -> {\n            writeByte(v.toByte())\n            1\n        }\n        v > 0x7ff -> {\n            writeExact(3, \"3 bytes character\") { memory, offset ->\n                memory[offset] = (0xe0 or ((v shr 12) and 0x0f)).toByte()\n                memory[offset + 1] = (0x80 or ((v shr 6) and 0x3f)).toByte()\n                memory[offset + 2] = (0x80 or (v and 0x3f)).toByte()\n            }\n            3\n        }\n        else -> {\n            writeExact(2, \"2 bytes character\") { memory, offset ->\n                memory[offset] = (0xc0 or ((v shr 6) and 0x1f)).toByte()\n                memory[offset + 1] = (0x80 or (v and 0x3f)).toByte()\n            }\n            2\n        }\n    }\n\n    /**\n     * Release any resources that the builder holds. Builder shouldn't be used after release\n     */\n    public final fun release() {\n        close()\n    }\n\n    @DangerousInternalIoApi\n    public fun prepareWriteHead(n: Int): ChunkBuffer {\n        if (tailRemaining >= n) {\n            _tail?.let {\n                it.commitWrittenUntilIndex(tailPosition)\n                return it\n            }\n        }\n        return appendNewChunk()\n    }\n\n    @DangerousInternalIoApi\n    public fun afterHeadWrite() {\n        _tail?.let { tailPosition = it.writePosition }\n    }\n\n    @PublishedApi\n    internal inline fun write(size: Int, block: (Buffer) -> Int): Int {\n        val buffer = prepareWriteHead(size)\n        try {\n            val result = block(buffer)\n            check(result >= 0) { \"The returned value shouldn't be negative\" }\n\n            return result\n        } finally {\n            afterHeadWrite()\n        }\n    }\n\n    @PublishedApi\n    @Deprecated(\"There is no need to do that anymore.\", level = DeprecationLevel.HIDDEN)\n    internal fun addSize(n: Int) {\n        check(n >= 0) { \"It should be non-negative size increment: $n\" }\n        check(n <= tailRemaining) { \"Unable to mark more bytes than available: $n > $tailRemaining\" }\n\n        // For binary compatibility we need to update pointers\n        tailPosition += n\n    }\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    internal open fun last(buffer: IoBuffer) {\n        appendSingleChunk(buffer as ChunkBuffer)\n    }\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\n        \"Use appendNewChunk instead\",\n        replaceWith = ReplaceWith(\"appendNewChunk()\"),\n        level = DeprecationLevel.HIDDEN\n    )\n    public fun appendNewBuffer(): IoBuffer = appendNewChunk() as IoBuffer\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public open fun reset() {\n    }\n}\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\nimport kotlin.contracts.*\n\n/**\n * For every byte from this buffer invokes [block] function giving it as parameter.\n */\n@ExperimentalIoApi\npublic inline fun Buffer.forEach(block: (Byte) -> Unit) {\n    read { memory, start, endExclusive ->\n        for (index in start until endExclusive) {\n            block(memory[index])\n        }\n        endExclusive - start\n    }\n}\n\n/**\n * Read an unsigned byte or fail if no bytes available for reading.\n */\npublic fun Buffer.readUByte(): UByte = readByte().toUByte()\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\npublic inline fun IoBuffer.readUByte(): UByte = (this as Buffer).readUByte()\n\n/**\n * Write an unsigned byte or fail if not enough space available for writing.\n */\npublic fun Buffer.writeUByte(value: UByte) {\n    writeByte(value.toByte())\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\npublic fun IoBuffer.writeUByte(value: UByte) {\n    (this as Buffer).writeUByte(value)\n}\n\n/**\n * Read a short integer or fail if no bytes available for reading.\n * The numeric value is decoded in the network order (Big Endian).\n */\npublic fun Buffer.readShort(): Short = readExact(2, \"short integer\") { memory, offset ->\n    memory.loadShortAt(offset)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\npublic inline fun IoBuffer.readShort(): Short = (this as Buffer).readShort()\n\n/**\n * Read an unsigned short integer or fail if not enough bytes available for reading.\n * The numeric value is decoded in the network order (Big Endian).\n */\npublic fun Buffer.readUShort(): UShort = readExact(2, \"short unsigned integer\") { memory, offset ->\n    memory.loadUShortAt(offset)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\npublic inline fun IoBuffer.readUShort(): UShort = (this as Buffer).readUShort()\n\n/**\n * Read an integer or fail if not enough bytes available for reading.\n * The numeric value is decoded in the network order (Big Endian).\n */\npublic fun Buffer.readInt(): Int = readExact(4, \"regular integer\") { memory, offset ->\n    memory.loadIntAt(offset)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\npublic inline fun IoBuffer.readInt(): Int = (this as Buffer).readInt()\n\n/**\n * Read an unsigned integer or fail if not enough bytes available for reading.\n * The numeric value is decoded in the network order (Big Endian).\n */\npublic fun Buffer.readUInt(): UInt = readExact(4, \"regular unsigned integer\") { memory, offset ->\n    memory.loadUIntAt(offset)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\npublic inline fun IoBuffer.readUInt(): UInt = (this as Buffer).readUInt()\n\n/**\n * Read a long integer or fail if not enough bytes available for reading.\n * The numeric value is decoded in the network order (Big Endian).\n */\npublic fun Buffer.readLong(): Long = readExact(8, \"long integer\") { memory, offset ->\n    memory.loadLongAt(offset)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\npublic inline fun IoBuffer.readLong(): Long = (this as Buffer).readLong()\n\n/**\n * Read an unsigned long integer or fail if not enough bytes available for reading.\n * The numeric value is decoded in the network order (Big Endian).\n */\npublic fun Buffer.readULong(): ULong = readExact(8, \"long unsigned integer\") { memory, offset ->\n    memory.loadULongAt(offset)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\npublic inline fun IoBuffer.readULong(): ULong = (this as Buffer).readULong()\n\n/**\n * Read a floating point number or fail if not enough bytes available for reading.\n * The numeric value is decoded in the network order (Big Endian).\n */\npublic fun Buffer.readFloat(): Float = readExact(4, \"floating point number\") { memory, offset ->\n    memory.loadFloatAt(offset)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\npublic inline fun IoBuffer.readFloat(): Float = (this as Buffer).readFloat()\n\n/**\n * Read a floating point number or fail if not enough bytes available for reading.\n * The numeric value is decoded in the network order (Big Endian).\n */\npublic fun Buffer.readDouble(): Double = readExact(8, \"long floating point number\") { memory, offset ->\n    memory.loadDoubleAt(offset)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\npublic inline fun IoBuffer.readDouble(): Double = (this as Buffer).readDouble()\n\n/**\n * Write a short integer or fail if not enough space available for writing.\n * The numeric value is encoded in the network order (Big Endian).\n */\npublic fun Buffer.writeShort(value: Short): Unit = writeExact(2, \"short integer\") { memory, offset ->\n    memory.storeShortAt(offset, value)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\npublic inline fun IoBuffer.writeShort(value: Short): Unit = (this as Buffer).writeShort(value)\n\n/**\n * Write an unsigned short integer or fail if not enough space available for writing.\n * The numeric value is encoded in the network order (Big Endian).\n */\npublic fun Buffer.writeUShort(value: UShort): Unit =\n    writeExact(2, \"short unsigned integer\") { memory, offset ->\n        memory.storeUShortAt(offset, value)\n    }\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\npublic inline fun IoBuffer.writeUShort(value: UShort): Unit = (this as Buffer).writeUShort(value)\n\n/**\n * Write an integer or fail if not enough space available for writing.\n * The numeric value is encoded in the network order (Big Endian).\n */\npublic fun Buffer.writeInt(value: Int): Unit = writeExact(4, \"regular integer\") { memory, offset ->\n    memory.storeIntAt(offset, value)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\npublic inline fun IoBuffer.writeInt(value: Int): Unit = (this as Buffer).writeInt(value)\n\n/**\n * Write an unsigned integer or fail if not enough space available for writing.\n * The numeric value is encoded in the network order (Big Endian).\n */\npublic fun Buffer.writeUInt(value: UInt): Unit = writeExact(4, \"regular unsigned integer\") { memory, offset ->\n    memory.storeUIntAt(offset, value)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\npublic inline fun IoBuffer.writeUInt(value: UInt): Unit = (this as Buffer).writeUInt(value)\n\n/**\n * Write a long integer or fail if not enough space available for writing.\n * The numeric value is encoded in the network order (Big Endian).\n */\npublic fun Buffer.writeLong(value: Long): Unit = writeExact(8, \"long integer\") { memory, offset ->\n    memory.storeLongAt(offset, value)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\npublic inline fun IoBuffer.writeLong(value: Long): Unit = (this as Buffer).writeLong(value)\n\n/**\n * Write an unsigned long integer or fail if not enough space available for writing.\n * The numeric value is encoded in the network order (Big Endian).\n */\npublic fun Buffer.writeULong(value: ULong): Unit = writeExact(8, \"long unsigned integer\") { memory, offset ->\n    memory.storeULongAt(offset, value)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\npublic inline fun IoBuffer.writeULong(value: ULong): Unit = (this as Buffer).writeULong(value)\n\n/**\n * Write a floating point number or fail if not enough space available for writing.\n * The numeric value is encoded in the network order (Big Endian).\n */\npublic fun Buffer.writeFloat(value: Float): Unit = writeExact(4, \"floating point number\") { memory, offset ->\n    memory.storeFloatAt(offset, value)\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\npublic inline fun IoBuffer.writeFloat(value: Float): Unit = (this as Buffer).writeFloat(value)\n\n/**\n * Write a floating point number or fail if not enough space available for writing.\n * The numeric value is encoded in the network order (Big Endian).\n */\npublic fun Buffer.writeDouble(value: Double): Unit =\n    writeExact(8, \"long floating point number\") { memory, offset ->\n        memory.storeDoubleAt(offset, value)\n    }\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\npublic inline fun IoBuffer.writeDouble(value: Double): Unit = (this as Buffer).writeDouble(value)\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n */\npublic fun Buffer.readFully(destination: ByteArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readExact(length, \"byte array\") { memory, srcOffset ->\n        memory.loadByteArray(srcOffset, destination, offset, length)\n    }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\npublic inline fun IoBuffer.readFully(destination: ByteArray, offset: Int = 0, length: Int = destination.size - offset) {\n    (this as Buffer).readFully(destination, offset, length)\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n */\npublic fun Buffer.readFully(destination: UByteArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readFully(destination.asByteArray(), offset, length)\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] bytes.\n * If less than [length] bytes available then less bytes will be copied and the corresponding number\n * will be returned as result.\n * @return number of bytes copied to the [destination] or `-1` if the buffer is empty\n */\npublic fun Buffer.readAvailable(destination: ByteArray, offset: Int = 0, length: Int = destination.size - offset): Int {\n    require(offset >= 0) { \"offset shouldn't be negative: $offset\" }\n    require(length >= 0) { \"length shouldn't be negative: $length\" }\n    require(offset + length <= destination.size) {\n        \"offset + length should be less than the destination size: $offset\" +\n            \" + $length > ${destination.size}\"\n    }\n\n    if (!canRead()) return -1\n    val toBeRead = minOf(length, readRemaining)\n    readFully(destination, offset, toBeRead)\n    return toBeRead\n}\n\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Input instead.\")\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\npublic inline fun IoBuffer.readAvailable(\n    destination: ByteArray,\n    offset: Int = 0,\n    length: Int = destination.size - offset\n): Int {\n    return (this as Buffer).readAvailable(destination, offset, length)\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] bytes.\n * If less than [length] bytes available then less bytes will be copied and the corresponding number\n * will be returned as result.\n * @return number of bytes copied to the [destination] or `-1` if the buffer is empty\n */\npublic fun Buffer.readAvailable(\n    destination: UByteArray,\n    offset: Int = 0,\n    length: Int = destination.size - offset\n): Int {\n    return readAvailable(destination.asByteArray(), offset, length)\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified bytes [length].\n */\npublic fun Buffer.writeFully(source: ByteArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeExact(length, \"byte array\") { memory, dstOffset ->\n        memory.storeByteArray(dstOffset, source, offset, length)\n    }\n}\n\n@Deprecated(\"IoBuffer is deprecated. Use Memory or Output instead.\")\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\", \"DEPRECATION\")\npublic inline fun IoBuffer.writeFully(source: ByteArray, offset: Int = 0, length: Int = source.size - offset) {\n    (this as Buffer).writeFully(source, offset, length)\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified bytes [length].\n */\npublic fun Buffer.writeFully(source: UByteArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFully(source.asByteArray(), offset, length)\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.readFully(destination: ShortArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readExact(length * 2, \"short integers array\") { memory, srcOffset ->\n        memory.loadShortArray(srcOffset, destination, offset, length)\n    }\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.readFully(destination: UShortArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readFully(destination.asShortArray(), offset, length)\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] elements.\n * If less than [length] elements available then less elements will be copied and the corresponding number\n * will be returned as result (possibly zero).\n *\n * @return number of elements copied to the [destination] or `-1` if the buffer is empty,\n *  `0` - not enough bytes for at least an element\n */\npublic fun Buffer.readAvailable(\n    destination: ShortArray,\n    offset: Int = 0,\n    length: Int = destination.size - offset\n): Int {\n    require(offset >= 0) { \"offset shouldn't be negative: $offset\" }\n    require(length >= 0) { \"length shouldn't be negative: $length\" }\n    require(offset + length <= destination.size) {\n        \"offset + length should be less than the destination size: $offset\" +\n            \" + $length > ${destination.size}\"\n    }\n\n    if (!canRead()) return -1\n    val toBeRead = minOf(length / 2, readRemaining)\n    readFully(destination, offset, toBeRead)\n    return toBeRead\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] elements.\n * If less than [length] elements available then less elements will be copied and the corresponding number\n * will be returned as result (possibly zero).\n *\n * @return number of elements copied to the [destination] or `-1` if the buffer is empty,\n *  `0` - not enough bytes for at least an element\n */\npublic fun Buffer.readAvailable(\n    destination: UShortArray,\n    offset: Int = 0,\n    length: Int = destination.size - offset\n): Int {\n    return readAvailable(destination.asShortArray(), offset, length)\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified items [length].\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.writeFully(source: ShortArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeExact(length * 2, \"short integers array\") { memory, dstOffset ->\n        memory.storeShortArray(dstOffset, source, offset, length)\n    }\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified items [length].\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.writeFully(source: UShortArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFully(source.asShortArray(), offset, length)\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.readFully(destination: IntArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readExact(length * 4, \"integers array\") { memory, srcOffset ->\n        memory.loadIntArray(srcOffset, destination, offset, length)\n    }\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.readFully(destination: UIntArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readFully(destination.asIntArray(), offset, length)\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] elements.\n * If less than [length] elements available then less elements will be copied and the corresponding number\n * will be returned as result (possibly zero).\n *\n * @return number of elements copied to the [destination] or `-1` if the buffer is empty,\n *  `0` - not enough bytes for at least an element\n */\npublic fun Buffer.readAvailable(destination: IntArray, offset: Int = 0, length: Int = destination.size - offset): Int {\n    require(offset >= 0) { \"offset shouldn't be negative: $offset\" }\n    require(length >= 0) { \"length shouldn't be negative: $length\" }\n    require(offset + length <= destination.size) {\n        \"offset + length should be less than the destination size: $offset\" +\n            \" + $length > ${destination.size}\"\n    }\n\n    if (!canRead()) return -1\n    val toBeRead = minOf(length / 4, readRemaining)\n    readFully(destination, offset, toBeRead)\n    return toBeRead\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] elements.\n * If less than [length] elements available then less elements will be copied and the corresponding number\n * will be returned as result (possibly zero).\n *\n * @return number of elements copied to the [destination] or `-1` if the buffer is empty,\n *  `0` - not enough bytes for at least an element\n */\npublic fun Buffer.readAvailable(destination: UIntArray, offset: Int = 0, length: Int = destination.size - offset): Int {\n    return readAvailable(destination.asIntArray(), offset, length)\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified items [length].\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.writeFully(source: IntArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeExact(length * 4, \"integers array\") { memory, dstOffset ->\n        memory.storeIntArray(dstOffset, source, offset, length)\n    }\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified items [length].\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.writeFully(source: UIntArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFully(source.asIntArray(), offset, length)\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.readFully(destination: LongArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readExact(length * 8, \"long integers array\") { memory, srcOffset ->\n        memory.loadLongArray(srcOffset, destination, offset, length)\n    }\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.readFully(destination: ULongArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readFully(destination.asLongArray(), offset, length)\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] elements.\n * If less than [length] elements available then less elements will be copied and the corresponding number\n * will be returned as result (possibly zero).\n *\n * @return number of elements copied to the [destination] or `-1` if the buffer is empty,\n *  `0` - not enough bytes for at least an element\n */\npublic fun Buffer.readAvailable(destination: LongArray, offset: Int = 0, length: Int = destination.size - offset): Int {\n    require(offset >= 0) { \"offset shouldn't be negative: $offset\" }\n    require(length >= 0) { \"length shouldn't be negative: $length\" }\n    require(offset + length <= destination.size) {\n        \"offset + length should be less than the destination size: $offset\" +\n            \" + $length > ${destination.size}\"\n    }\n\n    if (!canRead()) return -1\n    val toBeRead = minOf(length / 8, readRemaining)\n    readFully(destination, offset, toBeRead)\n    return toBeRead\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] elements.\n * If less than [length] elements available then less elements will be copied and the corresponding number\n * will be returned as result (possibly zero).\n *\n * @return number of elements copied to the [destination] or `-1` if the buffer is empty,\n *  `0` - not enough bytes for at least an element\n */\npublic fun Buffer.readAvailable(\n    destination: ULongArray,\n    offset: Int = 0,\n    length: Int = destination.size - offset\n): Int {\n    return readAvailable(destination.asLongArray(), offset, length)\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified items [length].\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.writeFully(source: LongArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeExact(length * 8, \"long integers array\") { memory, dstOffset ->\n        memory.storeLongArray(dstOffset, source, offset, length)\n    }\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified items [length].\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.writeFully(source: ULongArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeFully(source.asLongArray(), offset, length)\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.readFully(destination: FloatArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readExact(length * 4, \"floating point numbers array\") { memory, srcOffset ->\n        memory.loadFloatArray(srcOffset, destination, offset, length)\n    }\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] elements.\n * If less than [length] elements available then less elements will be copied and the corresponding number\n * will be returned as result (possibly zero).\n *\n * @return number of elements copied to the [destination] or `-1` if the buffer is empty,\n *  `0` - not enough bytes for at least an element\n */\npublic fun Buffer.readAvailable(\n    destination: FloatArray,\n    offset: Int = 0,\n    length: Int = destination.size - offset\n): Int {\n    require(offset >= 0) { \"offset shouldn't be negative: $offset\" }\n    require(length >= 0) { \"length shouldn't be negative: $length\" }\n    require(offset + length <= destination.size) {\n        \"offset + length should be less than the destination size: $offset\" +\n            \" + $length > ${destination.size}\"\n    }\n\n    if (!canRead()) return -1\n    val toBeRead = minOf(length / 4, readRemaining)\n    readFully(destination, offset, toBeRead)\n    return toBeRead\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified items [length].\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.writeFully(source: FloatArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeExact(length * 4, \"floating point numbers array\") { memory, dstOffset ->\n        memory.storeFloatArray(dstOffset, source, offset, length)\n    }\n}\n\n/**\n * Read from this buffer to the [destination] array to [offset] and [length] bytes.\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.readFully(destination: DoubleArray, offset: Int = 0, length: Int = destination.size - offset) {\n    readExact(length * 8, \"floating point numbers array\") { memory, srcOffset ->\n        memory.loadDoubleArray(srcOffset, destination, offset, length)\n    }\n}\n\n/**\n * Read available for read bytes to the [destination] array range starting at array [offset] and [length] elements.\n * If less than [length] elements available then less elements will be copied and the corresponding number\n * will be returned as result (possibly zero).\n *\n * @return number of elements copied to the [destination] or `-1` if the buffer is empty,\n *  `0` - not enough bytes for at least an element\n */\npublic fun Buffer.readAvailable(\n    destination: DoubleArray,\n    offset: Int = 0,\n    length: Int = destination.size - offset\n): Int {\n    require(offset >= 0) { \"offset shouldn't be negative: $offset\" }\n    require(length >= 0) { \"length shouldn't be negative: $length\" }\n    require(offset + length <= destination.size) {\n        \"offset + length should be less than the destination size: $offset\" +\n            \" + $length > ${destination.size}\"\n    }\n\n    if (!canRead()) return -1\n    val toBeRead = minOf(length / 8, readRemaining)\n    readFully(destination, offset, toBeRead)\n    return toBeRead\n}\n\n/**\n * Write the whole [source] array range staring at [offset] and having the specified items [length].\n * Numeric values are interpreted in the network byte order (Big Endian).\n */\npublic fun Buffer.writeFully(source: DoubleArray, offset: Int = 0, length: Int = source.size - offset) {\n    writeExact(length * 8, \"floating point numbers array\") { memory, dstOffset ->\n        memory.storeDoubleArray(dstOffset, source, offset, length)\n    }\n}\n\n/**\n * Read at most [length] bytes from this buffer to the [dst] buffer.\n * @return number of bytes copied\n */\npublic fun Buffer.readFully(dst: Buffer, length: Int = dst.writeRemaining): Int {\n    require(length >= 0)\n    require(length <= dst.writeRemaining)\n\n    readExact(length, \"buffer content\") { memory, offset ->\n        memory.copyTo(dst.memory, offset, length, dst.writePosition)\n        dst.commitWritten(length)\n    }\n\n    return length\n}\n\n/**\n * Read at most [length] available bytes to the [dst] buffer or `-1` if no bytes available for read.\n * @return number of bytes copied or `-1` if empty\n */\npublic fun Buffer.readAvailable(dst: Buffer, length: Int = dst.writeRemaining): Int {\n    if (!canRead()) return -1\n\n    val readSize = minOf(dst.writeRemaining, readRemaining, length)\n\n    readExact(readSize, \"buffer content\") { memory, offset ->\n        memory.copyTo(dst.memory, offset, readSize, dst.writePosition)\n        dst.commitWritten(readSize)\n    }\n\n    return readSize\n}\n\n/**\n * Write all readable bytes from [src] to this buffer. Fails if not enough space available to write all bytes.\n */\npublic fun Buffer.writeFully(src: Buffer) {\n    val length = src.readRemaining\n\n    writeExact(length, \"buffer readable content\") { memory, offset ->\n        src.memory.copyTo(memory, src.readPosition, length, offset)\n        src.discardExact(length)\n    }\n}\n\n/**\n * Write at most [length] readable bytes from [src] to this buffer.\n * Fails if not enough space available to write all bytes.\n */\npublic fun Buffer.writeFully(src: Buffer, length: Int) {\n    require(length >= 0) { \"length shouldn't be negative: $length\" }\n    require(length <= src.readRemaining) {\n        \"length shouldn't be greater than the source read remaining: $length > ${src.readRemaining}\"\n    }\n    require(length <= writeRemaining) {\n        \"length shouldn't be greater than the destination write remaining space: $length > $writeRemaining\"\n    }\n\n    writeExact(length, \"buffer readable content\") { memory, offset ->\n        src.memory.copyTo(memory, src.readPosition, length, offset)\n        src.discardExact(length)\n    }\n}\n\n@PublishedApi\ninternal inline fun <R> Buffer.readExact(size: Int, name: String, block: (memory: Memory, offset: Int) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    var value: R\n\n    read { memory, start, endExclusive ->\n        require(endExclusive - start >= size) {\n            throw EOFException(\"Not enough bytes to read a $name of size $size.\")\n        }\n        value = block(memory, start)\n        size\n    }\n\n    return value\n}\n\n@PublishedApi\ninternal inline fun Buffer.writeExact(size: Int, name: String, block: (memory: Memory, offset: Int) -> Unit) {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    write { memory, start, endExclusive ->\n        val writeRemaining = endExclusive - start\n        if (writeRemaining < size) {\n            throw InsufficientSpaceException(name, size, writeRemaining)\n        }\n        block(memory, start)\n        size\n    }\n}\n","@file:Suppress(\"DeprecatedCallableAddReplaceWith\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.pool.*\n\n/**\n * Write byte [value] repeated the specified [times].\n */\npublic fun Buffer.fill(times: Int, value: Byte) {\n    require(times >= 0) { \"times shouldn't be negative: $times\" }\n    require(times <= writeRemaining) {\n        \"times shouldn't be greater than the write remaining space: $times > $writeRemaining\"\n    }\n\n    memory.fill(writePosition, times, value)\n    commitWritten(times)\n}\n\n/**\n * Write unsigned byte [value] repeated the specified [times].\n */\npublic fun Buffer.fill(times: Int, value: UByte) {\n    fill(times, value.toByte())\n}\n\n/**\n * Write byte [v] value repeated [n] times.\n */\n@Deprecated(\"Use fill with n with type Int\")\npublic fun Buffer.fill(n: Long, v: Byte) {\n    fill(n.toIntOrFail(\"n\"), v)\n}\n\n/**\n * Push back [n] bytes: only possible if there were at least [n] bytes read before this operation.\n */\n@Deprecated(\"Use rewind instead\", ReplaceWith(\"rewind(n)\"))\npublic fun Buffer.pushBack(n: Int): Unit = rewind(n)\n\n@Deprecated(\"Use duplicate instead\", ReplaceWith(\"duplicate()\"))\npublic fun Buffer.makeView(): Buffer = duplicate()\n\n@Deprecated(\"Use duplicate instead\", ReplaceWith(\"duplicate()\"))\npublic fun ChunkBuffer.makeView(): ChunkBuffer = duplicate()\n\n@Deprecated(\"Does nothing.\")\npublic fun Buffer.flush() {\n}\n\ninternal fun Buffer.appendChars(csq: CharArray, start: Int, end: Int): Int {\n    return appendChars(CharArraySequence(csq, 0, csq.size), start, end)\n}\n\ninternal fun Buffer.appendChars(csq: CharSequence, start: Int, end: Int): Int {\n    var charactersWritten: Int\n\n    write { dst, dstStart, dstEndExclusive ->\n        val result = dst.encodeUTF8(csq, start, end, dstStart, dstEndExclusive)\n        charactersWritten = result.characters.toInt()\n        result.bytes.toInt()\n    }\n\n    return start + charactersWritten\n}\n\n@Deprecated(\"This is no longer supported. Use a packet builder to append characters instead.\")\npublic fun Buffer.append(c: Char): Buffer {\n    write { memory, start, endExclusive ->\n        val size = memory.putUtf8Char(start, c.toInt())\n        when {\n            size > endExclusive - start -> appendFailed(1)\n            else -> size\n        }\n    }\n\n    return this\n}\n\n@Deprecated(\"This is no longer supported. Use a packet builder to append characters instead.\")\npublic fun Buffer.append(csq: CharSequence?): Buffer {\n    if (csq == null) {\n        return append(\"null\")\n    }\n\n    return append(csq, 0, csq.length)\n}\n\n@Deprecated(\"This is no longer supported. Use a packet builder to append characters instead.\")\npublic fun Buffer.append(csq: CharSequence?, start: Int, end: Int): Buffer = apply {\n    if (csq == null) {\n        return append(\"null\", start, end)\n    }\n\n    if (appendChars(csq, start, end) != end) {\n        appendFailed(end - start)\n    }\n}\n\nprivate fun appendFailed(length: Int): Nothing {\n    throw BufferLimitExceededException(\"Not enough free space available to write $length character(s).\")\n}\n\n@Deprecated(\"This is no longer supported. Use a packet builder to append characters instead.\")\npublic fun Buffer.append(csq: CharArray, start: Int, end: Int): Buffer {\n    return append(CharArraySequence(csq, 0, csq.size), start, end)\n}\n\n@Deprecated(\"This is no longer supported. Read from a packet instead.\")\npublic fun Buffer.readText(\n    decoder: CharsetDecoder,\n    out: Appendable,\n    lastBuffer: Boolean,\n    max: Int = Int.MAX_VALUE\n): Int {\n    return decoder.decodeBuffer(this, out, lastBuffer, max)\n}\n\n/**\n * releases buffer view and returns it to the [pool] if there are no more usages. Based on simple ref-counting so\n * it is very fragile.\n */\n@Suppress(\"DEPRECATION\")\npublic fun IoBuffer.release(pool: ObjectPool<IoBuffer>) {\n    // TODO ???\n    @Suppress(\"UNCHECKED_CAST\")\n    (this as ChunkBuffer).release(pool as ObjectPool<ChunkBuffer>)\n}\n\n/**\n * Peek the next unsigned byte or return `-1` if no more bytes available for reading. No bytes will be marked\n * as consumed in any case.\n * @see [Buffer.tryPeekByte]\n */\n@Deprecated(\"Use tryPeekByte instead\", replaceWith = ReplaceWith(\"tryPeekByte()\"))\npublic fun Buffer.tryPeek(): Int = tryPeekByte()\n\npublic fun Buffer.readFully(dst: Array<Byte>, offset: Int = 0, length: Int = dst.size - offset) {\n    read { memory, start, endExclusive ->\n        if (endExclusive - start < length) {\n            throw EOFException(\"Not enough bytes available to read $length bytes\")\n        }\n\n        for (index in 0 until length) {\n            dst[index + offset] = memory[index + start]\n        }\n\n        length\n    }\n}\n\n@Deprecated(\n    \"This is no longer supported. All operations are big endian by default. Use readXXXLittleEndian \" +\n        \"to read primitives in little endian\",\n    level = DeprecationLevel.ERROR\n)\npublic var Buffer.byteOrder: ByteOrder\n    get() = ByteOrder.BIG_ENDIAN\n    set(newOrder) {\n        if (newOrder != ByteOrder.BIG_ENDIAN) throw UnsupportedOperationException(\"Only BIG_ENDIAN is supported\")\n    }\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.ChunkBuffer\nimport io.ktor.utils.io.pool.DefaultPool\nimport io.ktor.utils.io.pool.ObjectPool\nimport kotlin.native.concurrent.ThreadLocal\n\ninternal const val DEFAULT_BUFFER_SIZE: Int = 4096\n\n/**\n * Invoke [block] function with a temporary [Buffer] instance of the specified [size] in bytes.\n * The provided instance shouldn't be captured and used outside of the [block] otherwise an undefined behaviour\n * may occur including crash and/or data corruption.\n */\n@ExperimentalIoApi\npublic inline fun <R> withBuffer(size: Int, block: Buffer.() -> R): R {\n    return with(Buffer(DefaultAllocator.alloc(size)), block)\n}\n\n/**\n * Invoke [block] function with a temporary [Buffer] instance taken from the specified [pool].\n * Depending on the pool it may be safe or unsafe to capture and use the provided buffer outside of the [block].\n * Usually it is always recommended to NOT capture an instance outside.\n */\n@ExperimentalIoApi\npublic inline fun <R> withBuffer(pool: ObjectPool<Buffer>, block: Buffer.() -> R): R {\n    val instance = pool.borrow()\n    return try {\n        block(instance)\n    } finally {\n        pool.recycle(instance)\n    }\n}\n\n/**\n * Invoke [block] function with a temporary [Buffer] instance taken from the specified [pool].\n * Depending on the pool it may be safe or unsafe to capture and use the provided buffer outside of the [block].\n * Usually it is always recommended to NOT capture an instance outside.\n * However since [ChunkBuffer] is reference counted, you can create a [Buffer.duplicate] (this is simply a view) and use\n * it outside of the [block] function but it is important to release the duplicate properly once not needed anymore\n * otherwise memory leak may occur on some platforms.\n */\ninternal inline fun <R> withChunkBuffer(pool: ObjectPool<ChunkBuffer>, block: ChunkBuffer.() -> R): R {\n    val instance = pool.borrow()\n    return try {\n        block(instance)\n    } finally {\n        instance.release(pool)\n    }\n}\n\n@ThreadLocal\n@Suppress(\"DEPRECATION\")\ninternal val DefaultChunkedBufferPool: ObjectPool<IoBuffer> = DefaultBufferPool()\n\n@Suppress(\"DEPRECATION\")\ninternal class DefaultBufferPool(\n    private val bufferSize: Int = DEFAULT_BUFFER_SIZE,\n    capacity: Int = 1000,\n    private val allocator: Allocator = DefaultAllocator\n) : DefaultPool<IoBuffer>(capacity) {\n\n    override fun produceInstance(): IoBuffer {\n        return IoBuffer(allocator.alloc(bufferSize), null, this)\n    }\n\n    override fun disposeInstance(instance: IoBuffer) {\n        allocator.free(instance.memory)\n        super.disposeInstance(instance)\n        instance.unlink()\n    }\n\n    override fun validateInstance(instance: IoBuffer) {\n        super.validateInstance(instance)\n\n        if (instance === IoBuffer.Empty) {\n            error(\"IoBuffer.Empty couldn't be recycled\")\n        }\n\n        check(instance !== IoBuffer.Empty) { \"Empty instance couldn't be recycled\" }\n        check(instance !== Buffer.Empty) { \"Empty instance couldn't be recycled\" }\n        check(instance !== ChunkBuffer.Empty) { \"Empty instance couldn't be recycled\" }\n\n        check(instance.referenceCount == 0) { \"Unable to clear buffer: it is still in use.\" }\n        check(instance.next == null) { \"Recycled instance shouldn't be a part of a chain.\" }\n        check(instance.origin == null) { \"Recycled instance shouldn't be a view or another buffer.\" }\n    }\n\n    override fun clearInstance(instance: IoBuffer): IoBuffer {\n        return super.clearInstance(instance).apply {\n            unpark()\n            reset()\n        }\n    }\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readShort(): Short {\n    return readPrimitive(2, { memory, index -> memory.loadShortAt(index) }, { readShortFallback() })\n}\n\nprivate fun Input.readShortFallback(): Short {\n    return readPrimitiveFallback(2) { it.readShort() }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readInt(): Int {\n    return readPrimitive(4, { memory, index -> memory.loadIntAt(index) }, { readIntFallback() })\n}\n\nprivate fun Input.readIntFallback(): Int {\n    return readPrimitiveFallback(4) { it.readInt() }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readLong(): Long {\n    return readPrimitive(8, { memory, index -> memory.loadLongAt(index) }, { readLongFallback() })\n}\n\nprivate fun Input.readLongFallback(): Long {\n    return readPrimitiveFallback(8) { it.readLong() }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readFloat(): Float {\n    return readPrimitive(4, { memory, index -> memory.loadFloatAt(index) }, { readFloatFallback() })\n}\n\npublic fun Input.readFloatFallback(): Float {\n    return readPrimitiveFallback(4) { it.readFloat() }\n}\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic fun Input.readDouble(): Double {\n    return readPrimitive(8, { memory, index -> memory.loadDoubleAt(index) }, { readDoubleFallback() })\n}\n\npublic fun Input.readDoubleFallback(): Double {\n    return readPrimitiveFallback(8) { it.readDouble() }\n}\n\nprivate inline fun <R> Input.readPrimitive(size: Int, main: (Memory, Int) -> R, fallback: () -> R): R {\n    if (this is AbstractInput && headRemaining > size) {\n        val index = headPosition\n        headPosition = index + size\n        return main(headMemory, index)\n    }\n\n    return fallback()\n}\n\nprivate inline fun <R> Input.readPrimitiveFallback(size: Int, read: (Buffer) -> R): R {\n    val head = prepareReadFirstHead(size) ?: prematureEndOfStream(size)\n    val value = read(head)\n    completeReadHead(head)\n    return value\n}\n","@file:Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\n\npublic fun Output.writeShort(value: Short) {\n    if (!writePrimitiveTemplate(2) { memory, index -> memory.storeShortAt(index, value) }) {\n        writeShortFallback(value)\n    }\n}\n\nprivate fun Output.writeShortFallback(value: Short) {\n    if (!writePrimitiveFallbackTemplate(2) { it.writeShort(value) }) {\n        writeByte(value.highByte)\n        writeByte(value.lowByte)\n    }\n}\n\npublic fun Output.writeInt(value: Int) {\n    if (!writePrimitiveTemplate(4) { memory, index -> memory.storeIntAt(index, value) }) {\n        writeIntFallback(value)\n    }\n}\n\nprivate fun Output.writeIntFallback(value: Int) {\n    if (!writePrimitiveFallbackTemplate(4) { it.writeInt(value) }) {\n        writeIntByteByByte(value)\n    }\n}\n\nprivate fun Output.writeIntByteByByte(value: Int) {\n    value.highShort.let {\n        writeByte(it.highByte)\n        writeByte(it.lowByte)\n    }\n    value.lowShort.let {\n        writeByte(it.highByte)\n        writeByte(it.lowByte)\n    }\n}\n\npublic fun Output.writeLong(value: Long) {\n    if (!writePrimitiveTemplate(8) { memory, index -> memory.storeLongAt(index, value) }) {\n        writeLongFallback(value)\n    }\n}\n\nprivate fun Output.writeLongFallback(value: Long) {\n    if (!writePrimitiveFallbackTemplate(8) { it.writeLong(value) }) {\n        writeIntByteByByte(value.highInt)\n        writeIntByteByByte(value.lowInt)\n    }\n}\n\npublic fun Output.writeFloat(value: Float) {\n    if (!writePrimitiveTemplate(4) { memory, index -> memory.storeFloatAt(index, value) }) {\n        writeIntFallback(value.toRawBits())\n    }\n}\n\npublic fun Output.writeDouble(value: Double) {\n    if (!writePrimitiveTemplate(8) { memory, index -> memory.storeDoubleAt(index, value) }) {\n        writeLongFallback(value.toRawBits())\n    }\n}\n\nprivate inline fun Output.writePrimitiveTemplate(\n    componentSize: Int,\n    block: (Memory, index: Int) -> Unit\n): Boolean {\n    if (this is AbstractOutput) {\n        val index = tailPosition\n        if (tailEndExclusive - index > componentSize) {\n            tailPosition = index + componentSize\n            block(tailMemory, index)\n            return true\n        }\n    }\n\n    return false\n}\n\nprivate inline fun Output.writePrimitiveFallbackTemplate(\n    componentSize: Int,\n    writeOperation: (Buffer) -> Unit\n): Boolean {\n    if (this is AbstractOutput) {\n        val tail = prepareWriteHead(componentSize)\n        writeOperation(tail)\n        afterHeadWrite()\n        return true\n    }\n\n    return false\n}\n","@file:Suppress(\"RedundantModalityModifier\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.errors.*\nimport io.ktor.utils.io.pool.*\n\n@DangerousInternalIoApi\n@Deprecated(\n    \"Will be removed in the future releases. Use Input or AbstractInput instead.\",\n    ReplaceWith(\"AbstractInput\", \"io.ktor.utils.io.core.AbstractInput\")\n)\npublic abstract class ByteReadPacketBase(\n    head: ChunkBuffer,\n    remaining: Long,\n    pool: ObjectPool<ChunkBuffer>\n) : AbstractInput(head, remaining, pool) {\n\n    @Suppress(\"DEPRECATION\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public constructor(\n        head: IoBuffer,\n        remaining: Long,\n        pool: ObjectPool<ChunkBuffer>\n    ) : this(head as ChunkBuffer, remaining, pool)\n\n    public companion object {\n        @Deprecated(\n            \"Use ByteReadPacket.Empty instead\",\n            ReplaceWith(\"ByteReadPacket.Empty\"),\n            level = DeprecationLevel.ERROR\n        )\n        public val Empty: ByteReadPacket\n            get() = ByteReadPacket.Empty\n    }\n}\n\npublic expect class EOFException(message: String) : IOException\n\n/**\n * For streaming input it should be [Input.endOfInput] instead.\n */\n@Deprecated(\"Use endOfInput property instead\", ReplaceWith(\"endOfInput\"))\npublic inline val Input.isEmpty: Boolean\n    get() = endOfInput\n\n/**\n * For streaming input there is no reliable way to detect it without triggering bytes population from the underlying\n * source. Consider using [Input.endOfInput] or use [ByteReadPacket] instead.\n */\n@Deprecated(\n    \"This makes no sense for streaming inputs. Some use-cases are covered by endOfInput property\",\n    ReplaceWith(\"!endOfInput\")\n)\npublic val Input.isNotEmpty: Boolean\n    get() {\n        if (endOfInput) return false\n        prepareReadFirstHead(1)?.let { found ->\n            completeReadHead(found)\n            return true\n        }\n        return false\n    }\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic inline val ByteReadPacket.isEmpty: Boolean\n    get() = endOfInput\n\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic inline val ByteReadPacket.isNotEmpty: Boolean\n    get() = !endOfInput\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.core.internal.*\nimport kotlin.contracts.*\n\n/**\n * Creates a temporary packet view of the packet being build without discarding any bytes from the builder.\n * This is similar to `build().copy()` except that the builder keeps already written bytes untouched.\n * A temporary view packet is passed as argument to [block] function and it shouldn't leak outside of this block\n * otherwise an unexpected behaviour may occur.\n */\n@Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\npublic inline fun <R> BytePacketBuilder.preview(block: (tmp: ByteReadPacket) -> R): R {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    val packet = preview()\n    return try {\n        block(packet)\n    } finally {\n        packet.release()\n    }\n}\n\n@PublishedApi\ninternal fun BytePacketBuilder.preview(): ByteReadPacket {\n    val head = head\n    return when {\n        head === ChunkBuffer.Empty -> ByteReadPacket.Empty\n        else -> ByteReadPacket(head.copyAll(), _pool)\n    }\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\n\n/**\n * Discards bytes until [delimiter] occurred\n * @return number of bytes discarded\n */\npublic fun Input.discardUntilDelimiter(delimiter: Byte): Long {\n    var discardedTotal = 0L\n\n    takeWhile { chunk ->\n        val discarded = chunk.discardUntilDelimiterImpl(delimiter)\n        discardedTotal += discarded\n        discarded > 0 && !chunk.canRead()\n    }\n\n    return discardedTotal\n}\n\n/**\n * Discards bytes until of of the specified delimiters [delimiter1] or [delimiter2] occurred\n * @return number of bytes discarded\n */\npublic fun Input.discardUntilDelimiters(delimiter1: Byte, delimiter2: Byte): Long {\n    var discardedTotal = 0L\n\n    takeWhile { chunk ->\n        val discarded = chunk.discardUntilDelimitersImpl(delimiter1, delimiter2)\n        discardedTotal += discarded\n        discarded > 0 && !chunk.canRead()\n    }\n\n    return discardedTotal\n}\n\n/**\n * Copies to [dst] array at [offset] at most [length] bytes or until the specified [delimiter] occurred.\n * @return number of bytes copied\n */\npublic fun Input.readUntilDelimiter(delimiter: Byte, dst: ByteArray, offset: Int = 0, length: Int = dst.size): Int {\n    var currentOffset = offset\n    var dstRemaining = length\n\n    takeWhile { chunk ->\n        val copied = chunk.readUntilDelimiterImpl(delimiter, dst, currentOffset, dstRemaining)\n        currentOffset += copied\n        dstRemaining -= copied\n        dstRemaining > 0 && !chunk.canRead()\n    }\n\n    return currentOffset - offset\n}\n\n/**\n * Copies to [dst] array at [offset] at most [length] bytes or until one of the specified delimiters\n * [delimiter1] or [delimiter2] occurred.\n * @return number of bytes copied\n */\npublic fun Input.readUntilDelimiters(\n    delimiter1: Byte,\n    delimiter2: Byte,\n    dst: ByteArray,\n    offset: Int = 0,\n    length: Int = dst.size\n): Int {\n    if (delimiter1 == delimiter2) return readUntilDelimiter(delimiter1, dst, offset, length)\n\n    var currentOffset = offset\n    var dstRemaining = length\n\n    takeWhile { chunk ->\n        val copied = chunk.readUntilDelimitersImpl(delimiter1, delimiter2, dst, currentOffset, dstRemaining)\n        currentOffset += copied\n        dstRemaining -= copied\n        !chunk.canRead() && dstRemaining > 0\n    }\n\n    return currentOffset - offset\n}\n\n/**\n * Copies to [dst] output until the specified [delimiter] occurred.\n * @return number of bytes copied\n */\npublic fun Input.readUntilDelimiter(delimiter: Byte, dst: Output): Long {\n    var copiedTotal = 0L\n    takeWhile { chunk ->\n        val copied = chunk.readUntilDelimiterImpl(delimiter, dst)\n        copiedTotal += copied\n        !chunk.canRead()\n    }\n\n    return copiedTotal\n}\n\n/**\n * Copies to [dst] output until one of the specified delimiters\n * [delimiter1] or [delimiter2] occurred.\n * @return number of bytes copied\n */\npublic fun Input.readUntilDelimiters(delimiter1: Byte, delimiter2: Byte, dst: Output): Long {\n    var copiedTotal = 0L\n\n    takeWhile { chunk ->\n        val copied = chunk.readUntilDelimitersImpl(delimiter1, delimiter2, dst)\n        copiedTotal += copied\n        !chunk.canRead()\n    }\n\n    return copiedTotal\n}\n\ninternal expect fun Buffer.discardUntilDelimiterImpl(delimiter: Byte): Int\n\ninternal fun discardUntilDelimiterImplMemory(buffer: Buffer, delimiter: Byte): Int {\n    val start = buffer.readPosition\n    var i = start\n    val limit = buffer.writePosition\n    val memory = buffer.memory\n\n    while (i < limit) {\n        if (memory[i] == delimiter) break\n        i++\n    }\n\n    buffer.discardUntilIndex(i)\n    return i - start\n}\n\ninternal expect fun Buffer.discardUntilDelimitersImpl(delimiter1: Byte, delimiter2: Byte): Int\n\ninternal fun discardUntilDelimitersImplMemory(buffer: Buffer, delimiter1: Byte, delimiter2: Byte): Int {\n    val start = buffer.readPosition\n    var i = start\n    val limit = buffer.writePosition\n    val memory = buffer.memory\n\n    while (i < limit) {\n        val v = memory[i]\n        if (v == delimiter1 || v == delimiter2) break\n        i++\n    }\n\n    buffer.discardUntilIndex(i)\n    return i - start\n}\n\ninternal expect fun Buffer.readUntilDelimiterImpl(\n    delimiter: Byte,\n    dst: ByteArray,\n    offset: Int,\n    length: Int\n): Int\n\ninternal expect fun Buffer.readUntilDelimitersImpl(\n    delimiter1: Byte,\n    delimiter2: Byte,\n    dst: ByteArray,\n    offset: Int,\n    length: Int\n): Int\n\ninternal expect fun Buffer.readUntilDelimiterImpl(\n    delimiter: Byte,\n    dst: Output\n): Int\n\ninternal expect fun Buffer.readUntilDelimitersImpl(\n    delimiter1: Byte,\n    delimiter2: Byte,\n    dst: Output\n): Int\n\ninternal inline fun Buffer.copyUntil(predicate: (Byte) -> Boolean, dst: ByteArray, offset: Int, length: Int): Int {\n    val readPosition = readPosition\n    var end = minOf(writePosition, readPosition + length)\n    val memory = memory\n    for (index in readPosition until end) {\n        if (predicate(memory.loadAt(index))) {\n            end = index\n            break\n        }\n    }\n\n    val copySize = end - readPosition\n    memory.loadByteArray(readPosition, dst, offset, copySize)\n    return copySize\n}\n\ninternal inline fun Buffer.copyUntil(predicate: (Byte) -> Boolean, dst: Output): Int {\n    var index = readPosition\n    val end = writePosition\n    val memory = memory\n    do {\n        if (index == end || predicate(memory.loadAt(index))) {\n            break\n        }\n        index++\n    } while (true)\n\n    val size = index - readPosition\n    dst.writeFully(this, size)\n    return size\n}\n","package io.ktor.utils.io.core.internal\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.bits.DefaultAllocator\nimport io.ktor.utils.io.concurrent.*\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.pool.*\nimport kotlinx.atomicfu.*\n\npublic open class ChunkBuffer(\n    memory: Memory,\n    origin: ChunkBuffer?,\n    internal val parentPool: ObjectPool<ChunkBuffer>?\n) : Buffer(memory) {\n    init {\n        require(origin !== this) { \"A chunk couldn't be a view of itself.\" }\n    }\n\n    private val nextRef: AtomicRef<ChunkBuffer?> = atomic(null)\n    private val refCount = atomic(1)\n\n    /**\n     * Reference to an origin buffer view this was copied from\n     */\n    public var origin: ChunkBuffer? by shared(origin)\n        private set\n\n    /**\n     * Reference to next buffer view. Useful to chain multiple views.\n     * @see appendNext\n     * @see cleanNext\n     */\n    public var next: ChunkBuffer? get() = nextRef.value\n        set(newValue) {\n            if (newValue == null) {\n                cleanNext()\n            } else {\n                appendNext(newValue)\n            }\n        }\n\n    public val referenceCount: Int get() = refCount.value\n\n    private fun appendNext(chunk: ChunkBuffer) {\n        if (!nextRef.compareAndSet(null, chunk)) {\n            throw IllegalStateException(\"This chunk has already a next chunk.\")\n        }\n    }\n\n    public fun cleanNext(): ChunkBuffer? {\n        return nextRef.getAndSet(null)\n    }\n\n    override fun duplicate(): ChunkBuffer = (origin ?: this).let { newOrigin ->\n        newOrigin.acquire()\n        ChunkBuffer(memory, newOrigin, parentPool).also { copy ->\n            duplicateTo(copy)\n        }\n    }\n\n    public open fun release(pool: ObjectPool<ChunkBuffer>) {\n        if (release()) {\n            val origin = origin\n            if (origin != null) {\n                unlink()\n                origin.release(pool)\n            } else {\n                val poolToUse = parentPool ?: pool\n                poolToUse.recycle(this)\n            }\n        }\n    }\n\n    internal fun unlink() {\n        if (!refCount.compareAndSet(0, -1)) {\n            throw IllegalStateException(\"Unable to unlink: buffer is in use.\")\n        }\n\n        cleanNext()\n        origin = null\n    }\n\n    /**\n     * Increase ref-count. May fail if already released.\n     */\n    internal fun acquire() {\n        refCount.update { old ->\n            if (old <= 0) throw IllegalStateException(\"Unable to acquire chunk: it is already released.\")\n            old + 1\n        }\n    }\n\n    /**\n     * Invoked by a pool before return the instance to a user.\n     */\n    internal fun unpark() {\n        refCount.update { old ->\n            if (old < 0) {\n                throw IllegalStateException(\"This instance is already disposed and couldn't be borrowed.\")\n            }\n            if (old > 0) {\n                throw IllegalStateException(\"This instance is already in use but somehow appeared in the pool.\")\n            }\n\n            1\n        }\n    }\n\n    /**\n     * Release ref-count.\n     * @return `true` if the last usage was released\n     */\n    internal fun release(): Boolean {\n        return refCount.updateAndGet { old ->\n            if (old <= 0) throw IllegalStateException(\"Unable to release: it is already released.\")\n            old - 1\n        } == 0\n    }\n\n    final override fun reset() {\n        require(origin == null) { \"Unable to reset buffer with origin\" }\n\n        super.reset()\n        @Suppress(\"DEPRECATION\")\n        attachment = null\n        nextRef.value = null\n    }\n\n    public companion object {\n        public val Pool: ObjectPool<ChunkBuffer> = object : ObjectPool<ChunkBuffer> {\n            override val capacity: Int\n                get() = DefaultChunkedBufferPool.capacity\n\n            override fun borrow(): ChunkBuffer {\n                return DefaultChunkedBufferPool.borrow()\n            }\n\n            @Suppress(\"DEPRECATION\")\n            override fun recycle(instance: ChunkBuffer) {\n                if (instance !is IoBuffer) {\n                    throw IllegalArgumentException(\"Only IoBuffer instances can be recycled.\")\n                }\n\n                DefaultChunkedBufferPool.recycle(instance)\n            }\n\n            override fun dispose() {\n                DefaultChunkedBufferPool.dispose()\n            }\n        }\n\n        @Suppress(\"DEPRECATION\")\n        public val Empty: ChunkBuffer get() = IoBuffer.Empty\n\n        /**\n         * A pool that always returns [ChunkBuffer.Empty]\n         */\n        public val EmptyPool: ObjectPool<ChunkBuffer> = object : ObjectPool<ChunkBuffer> {\n            override val capacity: Int get() = 1\n\n            override fun borrow() = Empty\n\n            override fun recycle(instance: ChunkBuffer) {\n                require(instance === ChunkBuffer.Empty) { \"Only ChunkBuffer.Empty instance could be recycled.\" }\n            }\n\n            override fun dispose() {\n            }\n        }\n\n        @Suppress(\"DEPRECATION\")\n        internal val NoPool: ObjectPool<ChunkBuffer> = object : NoPoolImpl<ChunkBuffer>() {\n            override fun borrow(): ChunkBuffer {\n                return IoBuffer(DefaultAllocator.alloc(DEFAULT_BUFFER_SIZE), null, this as ObjectPool<IoBuffer>)\n            }\n\n            override fun recycle(instance: ChunkBuffer) {\n                if (instance !is IoBuffer) {\n                    throw IllegalArgumentException(\"Only IoBuffer instances can be recycled.\")\n                }\n\n                DefaultAllocator.free(instance.memory)\n            }\n        }\n\n        internal val NoPoolManuallyManaged: ObjectPool<ChunkBuffer> = object : NoPoolImpl<ChunkBuffer>() {\n            override fun borrow(): ChunkBuffer {\n                throw UnsupportedOperationException(\"This pool doesn't support borrow\")\n            }\n\n            override fun recycle(instance: ChunkBuffer) {\n                // do nothing: manually managed objects should be disposed manually\n            }\n        }\n    }\n}\n\n/**\n * @return `true` if and only if there are no buffer views that share the same actual buffer. This actually does\n * refcount and only work guaranteed if other views created/not created via [Buffer.duplicate] function.\n * One can instantiate multiple buffers with the same buffer and this function will return `true` in spite of\n * the fact that the buffer is actually shared.\n */\ninternal fun ChunkBuffer.isExclusivelyOwned(): Boolean = referenceCount == 1\n","@file:Suppress(\"KDocMissingDocumentation\")\n\npackage io.ktor.utils.io.core.internal\n\nimport io.ktor.utils.io.core.*\nimport kotlin.jvm.*\nimport kotlin.native.concurrent.*\n\n/**\n * API marked with this annotation is internal and extremely fragile and not intended to be used by library users.\n * Such API could be changed without notice including rename, removal and behaviour change.\n * Also using API marked with this annotation could cause data loss or any other damage.\n */\n@Suppress(\"DEPRECATION\")\n@RequiresOptIn(level = RequiresOptIn.Level.ERROR)\n@Experimental(level = Experimental.Level.ERROR)\npublic annotation class DangerousInternalIoApi\n\ninternal fun ByteReadPacket.unsafeAppend(builder: BytePacketBuilder): Int {\n    val builderSize = builder.size\n    val builderHead = builder.stealAll() ?: return 0\n\n    if (builderSize <= PACKET_MAX_COPY_SIZE && builderHead.next == null && tryWriteAppend(builderHead)) {\n        builder.afterBytesStolen()\n        return builderSize\n    }\n\n    append(builderHead)\n    return builderSize\n}\n\n@Suppress(\"DEPRECATION\", \"UNUSED\")\n@JvmName(\"prepareReadFirstHead\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\npublic fun Input.prepareReadFirstHeadOld(minSize: Int): IoBuffer? {\n    return prepareReadFirstHead(minSize) as IoBuffer?\n}\n\n@DangerousInternalIoApi\npublic fun Input.prepareReadFirstHead(minSize: Int): ChunkBuffer? {\n    if (this is AbstractInput) {\n        return prepareReadHead(minSize)\n    }\n    if (this is ChunkBuffer) {\n        return if (canRead()) this else null\n    }\n\n    return prepareReadHeadFallback(minSize)\n}\n\nprivate fun Input.prepareReadHeadFallback(minSize: Int): ChunkBuffer? {\n    if (endOfInput) return null\n\n    val buffer = ChunkBuffer.Pool.borrow()\n    val copied = peekTo(\n        buffer.memory,\n        buffer.writePosition.toLong(),\n        0L,\n        minSize.toLong(),\n        buffer.writeRemaining.toLong()\n    ).toInt()\n    buffer.commitWritten(copied)\n\n    if (copied < minSize) {\n        prematureEndOfStream(minSize)\n    }\n\n    return buffer\n}\n\n@Suppress(\"UNUSED\", \"DEPRECATION\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\npublic fun Input.completeReadHead(current: IoBuffer) {\n    completeReadHead(current)\n}\n\n@DangerousInternalIoApi\npublic fun Input.completeReadHead(current: ChunkBuffer) {\n    if (current === this) {\n        return\n    }\n    if (this is AbstractInput) {\n        if (!current.canRead()) {\n            ensureNext(current)\n        } else if (current.endGap < Buffer.ReservedSize) {\n            fixGapAfterRead(current)\n        } else {\n            headPosition = current.readPosition\n        }\n        return\n    }\n\n    completeReadHeadFallback(current)\n}\n\nprivate fun Input.completeReadHeadFallback(current: ChunkBuffer) {\n    val discardAmount = current.capacity - current.writeRemaining - current.readRemaining\n    discardExact(discardAmount)\n    current.release(ChunkBuffer.Pool)\n}\n\n@Suppress(\"DEPRECATION\", \"UNUSED\")\n@JvmName(\"prepareReadNextHead\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\npublic fun Input.prepareReadNextHeadOld(current: IoBuffer): IoBuffer? {\n    return prepareReadNextHead(current) as IoBuffer?\n}\n\n@DangerousInternalIoApi\npublic fun Input.prepareReadNextHead(current: ChunkBuffer): ChunkBuffer? {\n    if (current === this) {\n        return if (canRead()) this else null\n    }\n    if (this is AbstractInput) {\n        return ensureNextHead(current)\n    }\n\n    return prepareNextReadHeadFallback(current)\n}\n\nprivate fun Input.prepareNextReadHeadFallback(current: ChunkBuffer): ChunkBuffer? {\n    val discardAmount = current.capacity - current.writeRemaining - current.readRemaining\n    discardExact(discardAmount)\n    current.resetForWrite()\n\n    if (endOfInput || peekTo(current) <= 0) {\n        current.release(ChunkBuffer.Pool)\n        return null\n    }\n\n    return current\n}\n\n@Suppress(\"DEPRECATION\", \"UNUSED\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\npublic fun Output.prepareWriteHead(capacity: Int, current: IoBuffer?): IoBuffer {\n    return prepareWriteHead(capacity, current) as IoBuffer\n}\n\n@DangerousInternalIoApi\npublic fun Output.prepareWriteHead(capacity: Int, current: ChunkBuffer?): ChunkBuffer {\n    if (this is AbstractOutput) {\n        if (current != null) {\n            afterHeadWrite()\n        }\n        return prepareWriteHead(capacity)\n    }\n\n    return prepareWriteHeadFallback(current)\n}\n\nprivate fun Output.prepareWriteHeadFallback(current: ChunkBuffer?): ChunkBuffer {\n    if (current != null) {\n        writeFully(current)\n        current.resetForWrite()\n        return current\n    }\n\n    return ChunkBuffer.Pool.borrow()\n}\n\n@Suppress(\"DEPRECATION\", \"UNUSED\")\n@Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\npublic fun Output.afterHeadWrite(current: IoBuffer) {\n    return afterHeadWrite(current)\n}\n\n@DangerousInternalIoApi\npublic fun Output.afterHeadWrite(current: ChunkBuffer) {\n    if (this is AbstractOutput) {\n        return afterHeadWrite()\n    }\n\n    afterWriteHeadFallback(current)\n}\n\n@JvmField\n@SharedImmutable\ninternal val EmptyByteArray = ByteArray(0)\n\nprivate fun Output.afterWriteHeadFallback(current: ChunkBuffer) {\n    writeFully(current)\n    current.release(ChunkBuffer.Pool)\n}\n","package io.ktor.utils.io.errors\n\nimport io.ktor.utils.io.core.*\n\npublic expect open class IOException(message: String, cause: Throwable?) : Exception {\n    public constructor(message: String)\n}\n\npublic expect open class EOFException(message: String) : IOException\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\")\n@Deprecated(\"Not implemented.\", level = DeprecationLevel.ERROR)\npublic fun <R> TODO_ERROR(value: R): Nothing = TODO(\"Not implemented. Value is $value\")\n\n@Suppress(\"DeprecatedCallableAddReplaceWith\")\n@Deprecated(\"Not implemented.\", level = DeprecationLevel.ERROR)\npublic fun TODO_ERROR(): Nothing = TODO(\"Not implemented.\")\n\ninternal fun checkPeekTo(destination: Buffer, offset: Int, min: Int, max: Int) {\n    require(offset >= 0) { \"offset shouldn't be negative: $offset.\" }\n    require(min >= 0) { \"min shouldn't be negative: $min.\" }\n    require(max >= min) { \"max should't be less than min: max = $max, min = $min.\" }\n    require(min <= destination.writeRemaining) {\n        \"Not enough free space in the destination buffer \" +\n            \"to write the specified minimum number of bytes: min = $min, free = ${destination.writeRemaining}.\"\n    }\n}\n\n@PublishedApi\ninternal fun incompatibleVersionError(): Nothing = throw Error(\n    \"This API is no longer supported. \" +\n        \"Please downgrade kotlinx-io or recompile your project/dependencies with new kotlinx-io.\"\n)\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.utils.io.internal\n\nimport io.ktor.utils.io.*\nimport kotlinx.atomicfu.*\nimport kotlinx.coroutines.*\n\n/**\n * Exclusive slot for waiting.\n * Only one waiter allowed.\n *\n * TODO: replace [Job] -> [Continuation] when all coroutines problems are fixed.\n */\ninternal class AwaitingSlot {\n    private val suspension: AtomicRef<CompletableJob?> = atomic(null)\n\n    init {\n        makeShared()\n    }\n\n    /**\n     * Wait for other [sleep] or resume.\n     */\n    public suspend fun sleep() {\n        if (trySuspend()) {\n            return\n        }\n\n        resume()\n    }\n\n    /**\n     * Resume waiter.\n     */\n    public fun resume() {\n        suspension.getAndSet(null)?.complete()\n    }\n\n    /**\n     * Cancel waiter.\n     */\n    public fun cancel(cause: Throwable?) {\n        val continuation = suspension.getAndSet(null) ?: return\n\n        if (cause != null) {\n            continuation.completeExceptionally(cause)\n        } else {\n            continuation.complete()\n        }\n    }\n\n    private suspend fun trySuspend(): Boolean {\n        var suspended = false\n\n        val job = Job()\n        if (suspension.compareAndSet(null, job)) {\n            suspended = true\n            job.join()\n        }\n\n        return suspended\n    }\n}\n","package io.ktor.utils.io.internal\n\nimport io.ktor.utils.io.ByteChannelSequentialBase\nimport io.ktor.utils.io.close\nimport io.ktor.utils.io.core.internal.ChunkBuffer\n\ninternal suspend fun ByteChannelSequentialBase.joinToImpl(dst: ByteChannelSequentialBase, closeOnEnd: Boolean) {\n    copyToSequentialImpl(dst, Long.MAX_VALUE)\n    if (closeOnEnd) dst.close()\n}\n\n/**\n * Reads up to [limit] bytes from receiver channel and writes them to [dst] channel.\n * Closes [dst] channel if fails to read or write with cause exception.\n * @return a number of copied bytes\n */\ninternal suspend fun ByteChannelSequentialBase.copyToSequentialImpl(dst: ByteChannelSequentialBase, limit: Long): Long {\n    require(this !== dst)\n    if (closedCause != null) {\n        dst.close(closedCause)\n        return 0L\n    }\n\n    var remainingLimit = limit\n\n    while (remainingLimit > 0) {\n        if (!awaitInternalAtLeast1()) {\n            break\n        }\n        val transferred = transferTo(dst, remainingLimit)\n\n        val copied = if (transferred == 0L) {\n            val tail = copyToTail(dst, remainingLimit)\n            if (tail == 0L) {\n                break\n            }\n\n            tail\n        } else {\n            if (dst.availableForWrite == 0) {\n                dst.awaitAtLeastNBytesAvailableForWrite(1)\n            }\n\n            transferred\n        }\n\n        remainingLimit -= copied\n    }\n\n    return limit - remainingLimit\n}\n\nprivate suspend fun ByteChannelSequentialBase.copyToTail(dst: ByteChannelSequentialBase, limit: Long): Long {\n    val lastPiece = ChunkBuffer.Pool.borrow()\n    try {\n        lastPiece.resetForWrite(limit.coerceAtMost(lastPiece.capacity.toLong()).toInt())\n        val rc = readAvailable(lastPiece)\n        if (rc == -1) {\n            lastPiece.release(ChunkBuffer.Pool)\n            return 0\n        }\n\n        dst.writeFully(lastPiece)\n        return rc.toLong()\n    } finally {\n        lastPiece.release(ChunkBuffer.Pool)\n    }\n}\n","package io.ktor.utils.io.pool\n\nimport io.ktor.utils.io.core.*\nimport kotlinx.atomicfu.*\n\npublic interface ObjectPool<T : Any> : Closeable {\n    /**\n     * Pool capacity\n     */\n    public val capacity: Int\n\n    /**\n     * borrow an instance. Pool can recycle an old instance or create a new one\n     */\n    public fun borrow(): T\n\n    /**\n     * Recycle an instance. Should be recycled what was borrowed before otherwise could fail\n     */\n    public fun recycle(instance: T)\n\n    /**\n     * Dispose the whole pool. None of borrowed objects could be used after the pool gets disposed\n     * otherwise it can result in undefined behaviour\n     */\n    public fun dispose()\n\n    /**\n     * Does pool dispose\n     */\n    override fun close() {\n        dispose()\n    }\n}\n\n/**\n * A pool implementation of zero capacity that always creates new instances\n */\npublic abstract class NoPoolImpl<T : Any> : ObjectPool<T> {\n    override val capacity: Int\n        get() = 0\n\n    override fun recycle(instance: T) {\n    }\n\n    override fun dispose() {\n    }\n}\n\n/**\n * A pool that produces at most one instance\n */\npublic abstract class SingleInstancePool<T : Any> : ObjectPool<T> {\n    private val borrowed = atomic(0)\n    private val disposed = atomic(false)\n\n    private val instance = atomic<T?>(null)\n\n    /**\n     * Creates a new instance of [T]\n     */\n    protected abstract fun produceInstance(): T\n\n    /**\n     * Dispose [instance] and release its resources\n     */\n    protected abstract fun disposeInstance(instance: T)\n\n    final override val capacity: Int get() = 1\n\n    final override fun borrow(): T {\n        borrowed.update {\n            if (it != 0) throw IllegalStateException(\"Instance is already consumed\")\n            1\n        }\n\n        val instance = produceInstance()\n        this.instance.value = instance\n\n        return instance\n    }\n\n    final override fun recycle(instance: T) {\n        if (this.instance.value !== instance) {\n            if (this.instance.value == null && borrowed.value != 0) {\n                throw IllegalStateException(\"Already recycled or an irrelevant instance tried to be recycled\")\n            }\n\n            throw IllegalStateException(\"Unable to recycle irrelevant instance\")\n        }\n\n        this.instance.value = null\n\n        if (!disposed.compareAndSet(false, true)) {\n            throw IllegalStateException(\"An instance is already disposed\")\n        }\n\n        disposeInstance(instance)\n    }\n\n    final override fun dispose() {\n        if (disposed.compareAndSet(false, true)) {\n            val value = instance.value ?: return\n            instance.value = null\n\n            disposeInstance(value)\n        }\n    }\n}\n\n/**\n * Default object pool implementation.\n */\npublic expect abstract class DefaultPool<T : Any>(capacity: Int) : ObjectPool<T> {\n    /**\n     * Pool capacity.\n     */\n    final override val capacity: Int\n\n    /**\n     * Creates a new instance of [T]\n     */\n    protected abstract fun produceInstance(): T\n\n    /**\n     * Dispose [instance] and release its resources\n     */\n    protected open fun disposeInstance(instance: T)\n\n    /**\n     * Clear [instance]'s state before reuse: reset pointers, counters and so on\n     */\n    protected open fun clearInstance(instance: T): T\n\n    /**\n     * Validate [instance] of [T]. Could verify that the object has been borrowed from this pool\n     */\n    protected open fun validateInstance(instance: T)\n\n    final override fun borrow(): T\n\n    final override fun recycle(instance: T)\n\n    final override fun dispose()\n}\n\n/**\n * Borrows and instance of [T] from the pool, invokes [block] with it and finally recycles it\n */\n@Deprecated(\"Use useInstance instead\", ReplaceWith(\"useInstance(block)\"))\npublic inline fun <T : Any, R> ObjectPool<T>.useBorrowed(block: (T) -> R): R {\n    return useInstance(block)\n}\n\n/**\n * Borrows and instance of [T] from the pool, invokes [block] with it and finally recycles it\n */\npublic inline fun <T : Any, R> ObjectPool<T>.useInstance(block: (T) -> R): R {\n    val instance = borrow()\n    try {\n        return block(instance)\n    } finally {\n        recycle(instance)\n    }\n}\n","package io.ktor.utils.io\n\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.internal.*\nimport kotlinx.coroutines.*\nimport org.khronos.webgl.*\n\n/**\n * Creates buffered channel for asynchronous reading and writing of sequences of bytes.\n */\npublic actual fun ByteChannel(autoFlush: Boolean): ByteChannel {\n    return ByteChannelJS(IoBuffer.Empty, autoFlush)\n}\n\n/**\n * Creates channel for reading from the specified byte array.\n */\npublic actual fun ByteReadChannel(content: ByteArray, offset: Int, length: Int): ByteReadChannel {\n    if (content.isEmpty()) return ByteReadChannel.Empty\n    val head = IoBuffer.Pool.borrow()\n    var tail = head\n\n    var start = offset\n    val end = start + length\n    while (true) {\n        tail.reserveEndGap(8)\n        val size = minOf(end - start, tail.writeRemaining)\n        (tail as Buffer).writeFully(content, start, size)\n        start += size\n\n        if (start == end) break\n        val current = tail\n        tail = IoBuffer.Pool.borrow()\n        current.next = tail\n    }\n\n    return ByteChannelJS(head, false).apply { close() }\n}\n\n/**\n * Creates channel for reading from the specified [ArrayBufferView]\n */\npublic fun ByteReadChannel(content: ArrayBufferView): ByteReadChannel {\n    if (content.byteLength == 0) return ByteReadChannel.Empty\n    val head = IoBuffer.Pool.borrow()\n    var tail = head\n\n    var start = 0\n    var remaining = content.byteLength - content.byteOffset\n    while (true) {\n        tail.reserveEndGap(8)\n        val size = minOf(remaining, tail.writeRemaining)\n        tail.writeFully(content, start, size)\n        start += size\n        remaining -= size\n\n        if (remaining == 0) break\n        tail = IoBuffer.Pool.borrow()\n    }\n\n    return ByteChannelJS(head, false).apply { close() }\n}\n\npublic actual suspend fun ByteReadChannel.joinTo(dst: ByteWriteChannel, closeOnEnd: Boolean) {\n    (this as ByteChannelSequentialBase).joinToImpl((dst as ByteChannelSequentialBase), closeOnEnd)\n}\n\n/**\n * Reads up to [limit] bytes from receiver channel and writes them to [dst] channel.\n * Closes [dst] channel if fails to read or write with cause exception.\n * @return a number of copied bytes\n */\npublic actual suspend fun ByteReadChannel.copyTo(dst: ByteWriteChannel, limit: Long): Long {\n    return (this as ByteChannelSequentialBase).copyToSequentialImpl((dst as ByteChannelSequentialBase), limit)\n}\n\ninternal class ByteChannelJS(initial: IoBuffer, autoFlush: Boolean) : ByteChannelSequentialBase(initial, autoFlush) {\n    private var attachedJob: Job? = null\n\n    @OptIn(InternalCoroutinesApi::class)\n    override fun attachJob(job: Job) {\n        attachedJob?.cancel()\n        attachedJob = job\n        job.invokeOnCompletion(onCancelling = true) { cause ->\n            attachedJob = null\n            if (cause != null) {\n                cancel(cause.unwrapCancellationException())\n            }\n        }\n    }\n\n    override suspend fun readAvailable(dst: ArrayBuffer, offset: Int, length: Int): Int {\n        return if (readable.isEmpty) {\n            readAvailableSuspend(dst, offset, length)\n        } else {\n            closedCause?.let { throw it }\n            readable.readAvailable(dst, offset, length)\n        }\n    }\n\n    private suspend fun readAvailableSuspend(dst: ArrayBuffer, offset: Int, length: Int): Int {\n        if (!await(1)) return -1\n        return readAvailable(dst, offset, length)\n    }\n\n    override suspend fun readFully(dst: ArrayBuffer, offset: Int, length: Int) {\n        if (availableForRead >= length) {\n            closedCause?.let { throw it }\n            readable.readFully(dst, offset, length)\n            return\n        }\n\n        return readFullySuspend(dst, offset, length)\n    }\n\n    private suspend fun readFullySuspend(dst: ArrayBuffer, offset: Int, length: Int) {\n        var start = offset\n        val end = offset + length\n        var remaining = length\n\n        while (start < end) {\n            val rc = readAvailable(dst, start, remaining)\n            if (rc == -1) throw EOFException(\"Premature end of stream: required $remaining more bytes\")\n            start += rc\n            remaining -= rc\n        }\n    }\n\n    override fun toString(): String = \"ByteChannel[$attachedJob, ${hashCode()}]\"\n}\n","// ktlint-disable filename\n/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.utils.io\n\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.core.internal.*\nimport kotlin.jvm.*\n\ninternal actual class ByteChannelSequentialBaseSharedState actual constructor() {\n    actual var closed: Boolean = false\n\n    actual var readByteOrder: ByteOrder = ByteOrder.BIG_ENDIAN\n\n    actual var writeByteOrder: ByteOrder = ByteOrder.BIG_ENDIAN\n\n    actual var totalBytesRead: Long = 0L\n\n    actual var totalBytesWritten: Long = 0L\n\n    actual var closedCause: Throwable? = null\n\n    actual var lastReadAvailable: Int = 0\n\n    actual var lastReadView: ChunkBuffer = ChunkBuffer.Empty\n}\n","// ktlint-disable filename\npackage io.ktor.utils.io\n\nimport kotlin.coroutines.*\n\ninternal actual class Condition actual constructor(val predicate: () -> Boolean) {\n    private var cont: Continuation<Unit>? = null\n\n    actual fun check(): Boolean {\n        return predicate()\n    }\n\n    actual fun signal() {\n        val cont = cont\n        if (cont != null && predicate()) {\n            this.cont = null\n            cont.resume(Unit)\n        }\n    }\n\n    actual suspend fun await(block: () -> Unit) {\n        if (predicate()) return\n\n        return suspendCoroutine { c ->\n            cont = c\n            block()\n        }\n    }\n    actual suspend fun await() {\n        if (predicate()) return\n\n        return suspendCoroutine { c ->\n            cont = c\n        }\n    }\n}\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.bits\n\n/**\n * Reverse number's byte order\n */\npublic actual fun Short.reverseByteOrder(): Short = swap(this)\n\n/**\n * Reverse number's byte order\n */\npublic actual fun Int.reverseByteOrder(): Int = swap(this)\n\n/**\n * Reverse number's byte order\n */\npublic actual fun Long.reverseByteOrder(): Long = swap(this)\n\n/**\n * Reverse number's byte order\n */\npublic actual fun Float.reverseByteOrder(): Float = swap(this)\n\n/**\n * Reverse number's byte order\n */\npublic actual fun Double.reverseByteOrder(): Double = swap(this)\n\nprivate inline fun swap(s: Short): Short = (((s.toInt() and 0xff) shl 8) or ((s.toInt() and 0xffff) ushr 8)).toShort()\n\nprivate inline fun swap(s: Int): Int =\n    (swap((s and 0xffff).toShort()).toInt() shl 16) or (swap((s ushr 16).toShort()).toInt() and 0xffff)\n\nprivate inline fun swap(s: Long): Long =\n    (swap((s and 0xffffffff).toInt()).toLong() shl 32) or (swap((s ushr 32).toInt()).toLong() and 0xffffffff)\n\nprivate inline fun swap(s: Float): Float = Float.fromBits(swap(s.toRawBits()))\n\nprivate inline fun swap(s: Double): Double = Double.fromBits(swap(s.toRawBits()))\n","package io.ktor.utils.io.bits\n\nimport io.ktor.utils.io.core.ExperimentalIoApi\n\n/**\n * Reverse number's byte order\n */\npublic expect fun Short.reverseByteOrder(): Short\n\n/**\n * Reverse number's byte order\n */\npublic expect fun Int.reverseByteOrder(): Int\n\n/**\n * Reverse number's byte order\n */\npublic expect fun Long.reverseByteOrder(): Long\n\n/**\n * Reverse number's byte order\n */\npublic expect fun Float.reverseByteOrder(): Float\n\n/**\n * Reverse number's byte order\n */\npublic expect fun Double.reverseByteOrder(): Double\n\n/**\n * Reverse number's byte order\n */\n@ExperimentalUnsignedTypes\npublic fun UShort.reverseByteOrder(): UShort = toShort().reverseByteOrder().toUShort()\n\n/**\n * Reverse number's byte order\n */\n@ExperimentalUnsignedTypes\npublic fun UInt.reverseByteOrder(): UInt = toInt().reverseByteOrder().toUInt()\n\n/**\n * Reverse number's byte order\n */\n@ExperimentalUnsignedTypes\npublic fun ULong.reverseByteOrder(): ULong = toLong().reverseByteOrder().toULong()\n\n@ExperimentalIoApi\npublic inline val Short.highByte: Byte get() = (toInt() ushr 8).toByte()\n\n@ExperimentalIoApi\npublic inline val Short.lowByte: Byte get() = (toInt() and 0xff).toByte()\n\n@ExperimentalIoApi\npublic inline val Int.highShort: Short get() = (this ushr 16).toShort()\n\n@ExperimentalIoApi\npublic inline val Int.lowShort: Short get() = (this and 0xffff).toShort()\n\n@ExperimentalIoApi\npublic inline val Long.highInt: Int get() = (this ushr 32).toInt()\n\n@ExperimentalIoApi\npublic inline val Long.lowInt: Int get() = (this and 0xffffffffL).toInt()\n","/*\n * Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.utils.io.pool\n\nimport kotlin.native.concurrent.*\n\n@ThreadLocal\npublic val ByteArrayPool: ObjectPool<ByteArray> = object : DefaultPool<ByteArray>(128) {\n    override fun produceInstance() = ByteArray(4096)\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.utils.io\n\n/**\n * Print exception stacktrace.\n */\npublic actual fun Throwable.printStack() {\n    @Suppress(\"UnsafeCastFromDynamic\")\n    println(asDynamic().stack)\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.utils.io\n\nimport io.ktor.utils.io.core.internal.*\n\n@DangerousInternalIoApi\npublic actual fun Any.preventFreeze() {\n}\n\n@DangerousInternalIoApi\npublic actual fun Any.makeShared() {\n}\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.bits\n\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.core.internal.*\nimport org.khronos.webgl.*\n\nprivate val isLittleEndianPlatform = ByteOrder.nativeOrder() === ByteOrder.LITTLE_ENDIAN\n\n/**\n * Copies short integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic actual fun Memory.loadShortArray(\n    offset: Int,\n    destination: ShortArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    val typed = Int16Array(view.buffer, view.byteOffset + offset, count)\n\n    if (isLittleEndianPlatform) {\n        // TODO investigate this implementation vs DataView.getInt16(...)\n        repeat(count) { index ->\n            destination[index + destinationOffset] = typed[index].reverseByteOrder()\n        }\n    } else {\n        repeat(count) { index ->\n            destination[index + destinationOffset] = typed[index]\n        }\n    }\n}\n\n/**\n * Copies short integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic actual fun Memory.loadShortArray(\n    offset: Long,\n    destination: ShortArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    loadShortArray(offset.toIntOrFail(\"offset\"), destination, destinationOffset, count)\n}\n\n/**\n * Copies regular integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic actual fun Memory.loadIntArray(\n    offset: Int,\n    destination: IntArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    val typed = Int32Array(view.buffer, view.byteOffset + offset, count)\n\n    if (isLittleEndianPlatform) {\n        repeat(count) { index ->\n            destination[index + destinationOffset] = typed[index].reverseByteOrder()\n        }\n    } else {\n        repeat(count) { index ->\n            destination[index + destinationOffset] = typed[index]\n        }\n    }\n}\n\n/**\n * Copies regular integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic actual fun Memory.loadIntArray(\n    offset: Long,\n    destination: IntArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    loadIntArray(offset.toIntOrFail(\"offset\"), destination, destinationOffset, count)\n}\n\n/**\n * Copies regular integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic actual fun Memory.loadLongArray(\n    offset: Int,\n    destination: LongArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    val typed = Int32Array(view.buffer, view.byteOffset + offset, count * 2)\n\n    if (isLittleEndianPlatform) {\n        for (index in 0 until count * 2 step 2) {\n            destination[index / 2 + destinationOffset] =\n                (typed[index + 1].reverseByteOrder().toLong() and 0xffffffffL) or\n                (typed[index].reverseByteOrder().toLong() shl 32)\n        }\n    } else {\n        for (index in 0 until count * 2 step 2) {\n            destination[index / 2 + destinationOffset] = (typed[index].toLong() and 0xffffffffL) or\n                (typed[index + 1].toLong() shl 32)\n        }\n    }\n}\n\n/**\n * Copies regular integers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic actual fun Memory.loadLongArray(\n    offset: Long,\n    destination: LongArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    loadLongArray(offset.toIntOrFail(\"offset\"), destination, destinationOffset, count)\n}\n\n/**\n * Copies floating point numbers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic actual fun Memory.loadFloatArray(\n    offset: Int,\n    destination: FloatArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    val typed = Float32Array(view.buffer, view.byteOffset + offset, count)\n\n    if (isLittleEndianPlatform) {\n        repeat(count) { index ->\n            destination[index + destinationOffset] = typed[index].reverseByteOrder()\n        }\n    } else {\n        repeat(count) { index ->\n            destination[index + destinationOffset] = typed[index]\n        }\n    }\n}\n\n/**\n * Copies floating point numbers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic actual fun Memory.loadFloatArray(\n    offset: Long,\n    destination: FloatArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    loadFloatArray(offset.toIntOrFail(\"offset\"), destination, destinationOffset, count)\n}\n\n/**\n * Copies floating point numbers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic actual fun Memory.loadDoubleArray(\n    offset: Int,\n    destination: DoubleArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    val typed = Float64Array(view.buffer, view.byteOffset + offset, count)\n\n    if (isLittleEndianPlatform) {\n        repeat(count) { index ->\n            destination[index + destinationOffset] = typed[index].reverseByteOrder()\n        }\n    } else {\n        repeat(count) { index ->\n            destination[index + destinationOffset] = typed[index]\n        }\n    }\n}\n\n/**\n * Copies floating point numbers from this memory range from the specified [offset] and [count]\n * to the [destination] at [destinationOffset] interpreting numbers in the network order (Big Endian).\n * @param destinationOffset items\n */\npublic actual fun Memory.loadDoubleArray(\n    offset: Long,\n    destination: DoubleArray,\n    destinationOffset: Int,\n    count: Int\n) {\n    loadDoubleArray(offset.toIntOrFail(\"offset\"), destination, destinationOffset, count)\n}\n\n/**\n * Copies short integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic actual fun Memory.storeShortArray(\n    offset: Int,\n    source: ShortArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    val typed = Int16Array(view.buffer, view.byteOffset + offset, count)\n\n    if (isLittleEndianPlatform) {\n        // TODO investigate this implementation vs DataView.getInt16(...)\n        repeat(count) { index ->\n            typed[index] = source[index + sourceOffset].reverseByteOrder()\n        }\n    } else {\n        repeat(count) { index ->\n            typed[index] = source[index + sourceOffset]\n        }\n    }\n}\n\n/**\n * Copies short integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic actual fun Memory.storeShortArray(\n    offset: Long,\n    source: ShortArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    storeShortArray(offset.toIntOrFail(\"offset\"), source, sourceOffset, count)\n}\n\n/**\n * Copies regular integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic actual fun Memory.storeIntArray(\n    offset: Int,\n    source: IntArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    val typed = Int32Array(view.buffer, view.byteOffset + offset, count)\n\n    if (isLittleEndianPlatform) {\n        repeat(count) { index ->\n            typed[index] = source[index + sourceOffset].reverseByteOrder()\n        }\n    } else {\n        repeat(count) { index ->\n            typed[index] = source[index + sourceOffset]\n        }\n    }\n}\n\n/**\n * Copies regular integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic actual fun Memory.storeIntArray(\n    offset: Long,\n    source: IntArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    storeIntArray(offset.toIntOrFail(\"offset\"), source, sourceOffset, count)\n}\n\n/**\n * Copies regular integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic actual fun Memory.storeLongArray(\n    offset: Int,\n    source: LongArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    val typed = Int32Array(view.buffer, view.byteOffset + offset, count * 2)\n\n    if (isLittleEndianPlatform) {\n        for (index in 0 until count * 2 step 2) {\n            val sourceIndex = index / 2 + sourceOffset\n            val sourceValue = source[sourceIndex]\n            typed[index] = (sourceValue ushr 32).toInt().reverseByteOrder()\n            typed[index + 1] = (sourceValue and 0xffffffffL).toInt().reverseByteOrder()\n        }\n    } else {\n        for (index in 0 until count * 2 step 2) {\n            val sourceIndex = index / 2 + sourceOffset\n            val sourceValue = source[sourceIndex]\n            typed[index] = (sourceValue ushr 32).toInt()\n            typed[index + 1] = (sourceValue and 0xffffffffL).toInt()\n        }\n    }\n}\n\n/**\n * Copies regular integers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic actual fun Memory.storeLongArray(\n    offset: Long,\n    source: LongArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    storeLongArray(offset.toIntOrFail(\"offset\"), source, sourceOffset, count)\n}\n\n/**\n * Copies floating point numbers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic actual fun Memory.storeFloatArray(\n    offset: Int,\n    source: FloatArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    val typed = Float32Array(view.buffer, view.byteOffset + offset, count)\n\n    if (isLittleEndianPlatform) {\n        repeat(count) { index ->\n            typed[index] = source[index + sourceOffset].reverseByteOrder()\n        }\n    } else {\n        repeat(count) { index ->\n            typed[index] = source[index + sourceOffset]\n        }\n    }\n}\n\n/**\n * Copies floating point numbers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic actual fun Memory.storeFloatArray(\n    offset: Long,\n    source: FloatArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    storeFloatArray(offset.toIntOrFail(\"offset\"), source, sourceOffset, count)\n}\n\n/**\n * Copies floating point numbers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic actual fun Memory.storeDoubleArray(\n    offset: Int,\n    source: DoubleArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    val typed = Float64Array(view.buffer, view.byteOffset + offset, count)\n\n    if (isLittleEndianPlatform) {\n        repeat(count) { index ->\n            typed[index] = source[index + sourceOffset].reverseByteOrder()\n        }\n    } else {\n        repeat(count) { index ->\n            typed[index] = source[index + sourceOffset]\n        }\n    }\n}\n\n/**\n * Copies floating point numbers from the [source] array at [sourceOffset] to this memory at the specified [offset]\n * interpreting numbers in the network order (Big Endian).\n * @param sourceOffset items\n */\npublic actual fun Memory.storeDoubleArray(\n    offset: Long,\n    source: DoubleArray,\n    sourceOffset: Int,\n    count: Int\n) {\n    storeDoubleArray(offset.toIntOrFail(\"offset\"), source, sourceOffset, count)\n}\n","/*\n * Copyright 2010-2021 JetBrains s.r.o. and Kotlin Programming Language contributors.\n * Use of this source code is governed by the Apache 2.0 license that can be found in the license/LICENSE.txt file.\n */\n\n// NOTE: THIS FILE IS AUTO-GENERATED, DO NOT EDIT!\n// See github.com/kotlin/dukat for details\n\npackage org.khronos.webgl\n\nimport kotlin.js.*\nimport org.w3c.dom.*\nimport org.w3c.dom.events.*\n\npublic external interface WebGLContextAttributes {\n    var alpha: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var depth: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var stencil: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var antialias: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var premultipliedAlpha: Boolean? /* = true */\n        get() = definedExternally\n        set(value) = definedExternally\n    var preserveDrawingBuffer: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var preferLowPowerToHighPerformance: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n    var failIfMajorPerformanceCaveat: Boolean? /* = false */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n@kotlin.internal.InlineOnly\npublic inline fun WebGLContextAttributes(alpha: Boolean? = true, depth: Boolean? = true, stencil: Boolean? = false, antialias: Boolean? = true, premultipliedAlpha: Boolean? = true, preserveDrawingBuffer: Boolean? = false, preferLowPowerToHighPerformance: Boolean? = false, failIfMajorPerformanceCaveat: Boolean? = false): WebGLContextAttributes {\n    val o = js(\"({})\")\n    o[\"alpha\"] = alpha\n    o[\"depth\"] = depth\n    o[\"stencil\"] = stencil\n    o[\"antialias\"] = antialias\n    o[\"premultipliedAlpha\"] = premultipliedAlpha\n    o[\"preserveDrawingBuffer\"] = preserveDrawingBuffer\n    o[\"preferLowPowerToHighPerformance\"] = preferLowPowerToHighPerformance\n    o[\"failIfMajorPerformanceCaveat\"] = failIfMajorPerformanceCaveat\n    return o\n}\n\npublic external abstract class WebGLObject\n\n/**\n * Exposes the JavaScript [WebGLBuffer](https://developer.mozilla.org/en/docs/Web/API/WebGLBuffer) to Kotlin\n */\npublic external abstract class WebGLBuffer : WebGLObject\n\n/**\n * Exposes the JavaScript [WebGLFramebuffer](https://developer.mozilla.org/en/docs/Web/API/WebGLFramebuffer) to Kotlin\n */\npublic external abstract class WebGLFramebuffer : WebGLObject\n\n/**\n * Exposes the JavaScript [WebGLProgram](https://developer.mozilla.org/en/docs/Web/API/WebGLProgram) to Kotlin\n */\npublic external abstract class WebGLProgram : WebGLObject\n\n/**\n * Exposes the JavaScript [WebGLRenderbuffer](https://developer.mozilla.org/en/docs/Web/API/WebGLRenderbuffer) to Kotlin\n */\npublic external abstract class WebGLRenderbuffer : WebGLObject\n\n/**\n * Exposes the JavaScript [WebGLShader](https://developer.mozilla.org/en/docs/Web/API/WebGLShader) to Kotlin\n */\npublic external abstract class WebGLShader : WebGLObject\n\n/**\n * Exposes the JavaScript [WebGLTexture](https://developer.mozilla.org/en/docs/Web/API/WebGLTexture) to Kotlin\n */\npublic external abstract class WebGLTexture : WebGLObject\n\n/**\n * Exposes the JavaScript [WebGLUniformLocation](https://developer.mozilla.org/en/docs/Web/API/WebGLUniformLocation) to Kotlin\n */\npublic external abstract class WebGLUniformLocation\n\n/**\n * Exposes the JavaScript [WebGLActiveInfo](https://developer.mozilla.org/en/docs/Web/API/WebGLActiveInfo) to Kotlin\n */\npublic external abstract class WebGLActiveInfo {\n    open val size: Int\n    open val type: Int\n    open val name: String\n}\n\n/**\n * Exposes the JavaScript [WebGLShaderPrecisionFormat](https://developer.mozilla.org/en/docs/Web/API/WebGLShaderPrecisionFormat) to Kotlin\n */\npublic external abstract class WebGLShaderPrecisionFormat {\n    open val rangeMin: Int\n    open val rangeMax: Int\n    open val precision: Int\n}\n\n@Suppress(\"NESTED_CLASS_IN_EXTERNAL_INTERFACE\")\npublic external interface WebGLRenderingContextBase {\n    val canvas: HTMLCanvasElement\n    val drawingBufferWidth: Int\n    val drawingBufferHeight: Int\n    fun getContextAttributes(): WebGLContextAttributes?\n    fun isContextLost(): Boolean\n    fun getSupportedExtensions(): Array<String>?\n    fun getExtension(name: String): dynamic\n    fun activeTexture(texture: Int)\n    fun attachShader(program: WebGLProgram?, shader: WebGLShader?)\n    fun bindAttribLocation(program: WebGLProgram?, index: Int, name: String)\n    fun bindBuffer(target: Int, buffer: WebGLBuffer?)\n    fun bindFramebuffer(target: Int, framebuffer: WebGLFramebuffer?)\n    fun bindRenderbuffer(target: Int, renderbuffer: WebGLRenderbuffer?)\n    fun bindTexture(target: Int, texture: WebGLTexture?)\n    fun blendColor(red: Float, green: Float, blue: Float, alpha: Float)\n    fun blendEquation(mode: Int)\n    fun blendEquationSeparate(modeRGB: Int, modeAlpha: Int)\n    fun blendFunc(sfactor: Int, dfactor: Int)\n    fun blendFuncSeparate(srcRGB: Int, dstRGB: Int, srcAlpha: Int, dstAlpha: Int)\n    fun bufferData(target: Int, size: Int, usage: Int)\n    fun bufferData(target: Int, data: BufferDataSource?, usage: Int)\n    fun bufferSubData(target: Int, offset: Int, data: BufferDataSource?)\n    fun checkFramebufferStatus(target: Int): Int\n    fun clear(mask: Int)\n    fun clearColor(red: Float, green: Float, blue: Float, alpha: Float)\n    fun clearDepth(depth: Float)\n    fun clearStencil(s: Int)\n    fun colorMask(red: Boolean, green: Boolean, blue: Boolean, alpha: Boolean)\n    fun compileShader(shader: WebGLShader?)\n    fun compressedTexImage2D(target: Int, level: Int, internalformat: Int, width: Int, height: Int, border: Int, data: ArrayBufferView)\n    fun compressedTexSubImage2D(target: Int, level: Int, xoffset: Int, yoffset: Int, width: Int, height: Int, format: Int, data: ArrayBufferView)\n    fun copyTexImage2D(target: Int, level: Int, internalformat: Int, x: Int, y: Int, width: Int, height: Int, border: Int)\n    fun copyTexSubImage2D(target: Int, level: Int, xoffset: Int, yoffset: Int, x: Int, y: Int, width: Int, height: Int)\n    fun createBuffer(): WebGLBuffer?\n    fun createFramebuffer(): WebGLFramebuffer?\n    fun createProgram(): WebGLProgram?\n    fun createRenderbuffer(): WebGLRenderbuffer?\n    fun createShader(type: Int): WebGLShader?\n    fun createTexture(): WebGLTexture?\n    fun cullFace(mode: Int)\n    fun deleteBuffer(buffer: WebGLBuffer?)\n    fun deleteFramebuffer(framebuffer: WebGLFramebuffer?)\n    fun deleteProgram(program: WebGLProgram?)\n    fun deleteRenderbuffer(renderbuffer: WebGLRenderbuffer?)\n    fun deleteShader(shader: WebGLShader?)\n    fun deleteTexture(texture: WebGLTexture?)\n    fun depthFunc(func: Int)\n    fun depthMask(flag: Boolean)\n    fun depthRange(zNear: Float, zFar: Float)\n    fun detachShader(program: WebGLProgram?, shader: WebGLShader?)\n    fun disable(cap: Int)\n    fun disableVertexAttribArray(index: Int)\n    fun drawArrays(mode: Int, first: Int, count: Int)\n    fun drawElements(mode: Int, count: Int, type: Int, offset: Int)\n    fun enable(cap: Int)\n    fun enableVertexAttribArray(index: Int)\n    fun finish()\n    fun flush()\n    fun framebufferRenderbuffer(target: Int, attachment: Int, renderbuffertarget: Int, renderbuffer: WebGLRenderbuffer?)\n    fun framebufferTexture2D(target: Int, attachment: Int, textarget: Int, texture: WebGLTexture?, level: Int)\n    fun frontFace(mode: Int)\n    fun generateMipmap(target: Int)\n    fun getActiveAttrib(program: WebGLProgram?, index: Int): WebGLActiveInfo?\n    fun getActiveUniform(program: WebGLProgram?, index: Int): WebGLActiveInfo?\n    fun getAttachedShaders(program: WebGLProgram?): Array<WebGLShader>?\n    fun getAttribLocation(program: WebGLProgram?, name: String): Int\n    fun getBufferParameter(target: Int, pname: Int): Any?\n    fun getParameter(pname: Int): Any?\n    fun getError(): Int\n    fun getFramebufferAttachmentParameter(target: Int, attachment: Int, pname: Int): Any?\n    fun getProgramParameter(program: WebGLProgram?, pname: Int): Any?\n    fun getProgramInfoLog(program: WebGLProgram?): String?\n    fun getRenderbufferParameter(target: Int, pname: Int): Any?\n    fun getShaderParameter(shader: WebGLShader?, pname: Int): Any?\n    fun getShaderPrecisionFormat(shadertype: Int, precisiontype: Int): WebGLShaderPrecisionFormat?\n    fun getShaderInfoLog(shader: WebGLShader?): String?\n    fun getShaderSource(shader: WebGLShader?): String?\n    fun getTexParameter(target: Int, pname: Int): Any?\n    fun getUniform(program: WebGLProgram?, location: WebGLUniformLocation?): Any?\n    fun getUniformLocation(program: WebGLProgram?, name: String): WebGLUniformLocation?\n    fun getVertexAttrib(index: Int, pname: Int): Any?\n    fun getVertexAttribOffset(index: Int, pname: Int): Int\n    fun hint(target: Int, mode: Int)\n    fun isBuffer(buffer: WebGLBuffer?): Boolean\n    fun isEnabled(cap: Int): Boolean\n    fun isFramebuffer(framebuffer: WebGLFramebuffer?): Boolean\n    fun isProgram(program: WebGLProgram?): Boolean\n    fun isRenderbuffer(renderbuffer: WebGLRenderbuffer?): Boolean\n    fun isShader(shader: WebGLShader?): Boolean\n    fun isTexture(texture: WebGLTexture?): Boolean\n    fun lineWidth(width: Float)\n    fun linkProgram(program: WebGLProgram?)\n    fun pixelStorei(pname: Int, param: Int)\n    fun polygonOffset(factor: Float, units: Float)\n    fun readPixels(x: Int, y: Int, width: Int, height: Int, format: Int, type: Int, pixels: ArrayBufferView?)\n    fun renderbufferStorage(target: Int, internalformat: Int, width: Int, height: Int)\n    fun sampleCoverage(value: Float, invert: Boolean)\n    fun scissor(x: Int, y: Int, width: Int, height: Int)\n    fun shaderSource(shader: WebGLShader?, source: String)\n    fun stencilFunc(func: Int, ref: Int, mask: Int)\n    fun stencilFuncSeparate(face: Int, func: Int, ref: Int, mask: Int)\n    fun stencilMask(mask: Int)\n    fun stencilMaskSeparate(face: Int, mask: Int)\n    fun stencilOp(fail: Int, zfail: Int, zpass: Int)\n    fun stencilOpSeparate(face: Int, fail: Int, zfail: Int, zpass: Int)\n    fun texImage2D(target: Int, level: Int, internalformat: Int, width: Int, height: Int, border: Int, format: Int, type: Int, pixels: ArrayBufferView?)\n    fun texImage2D(target: Int, level: Int, internalformat: Int, format: Int, type: Int, source: TexImageSource?)\n    fun texParameterf(target: Int, pname: Int, param: Float)\n    fun texParameteri(target: Int, pname: Int, param: Int)\n    fun texSubImage2D(target: Int, level: Int, xoffset: Int, yoffset: Int, width: Int, height: Int, format: Int, type: Int, pixels: ArrayBufferView?)\n    fun texSubImage2D(target: Int, level: Int, xoffset: Int, yoffset: Int, format: Int, type: Int, source: TexImageSource?)\n    fun uniform1f(location: WebGLUniformLocation?, x: Float)\n    fun uniform1fv(location: WebGLUniformLocation?, v: Float32Array)\n    fun uniform1fv(location: WebGLUniformLocation?, v: Array<Float>)\n    fun uniform1i(location: WebGLUniformLocation?, x: Int)\n    fun uniform1iv(location: WebGLUniformLocation?, v: Int32Array)\n    fun uniform1iv(location: WebGLUniformLocation?, v: Array<Int>)\n    fun uniform2f(location: WebGLUniformLocation?, x: Float, y: Float)\n    fun uniform2fv(location: WebGLUniformLocation?, v: Float32Array)\n    fun uniform2fv(location: WebGLUniformLocation?, v: Array<Float>)\n    fun uniform2i(location: WebGLUniformLocation?, x: Int, y: Int)\n    fun uniform2iv(location: WebGLUniformLocation?, v: Int32Array)\n    fun uniform2iv(location: WebGLUniformLocation?, v: Array<Int>)\n    fun uniform3f(location: WebGLUniformLocation?, x: Float, y: Float, z: Float)\n    fun uniform3fv(location: WebGLUniformLocation?, v: Float32Array)\n    fun uniform3fv(location: WebGLUniformLocation?, v: Array<Float>)\n    fun uniform3i(location: WebGLUniformLocation?, x: Int, y: Int, z: Int)\n    fun uniform3iv(location: WebGLUniformLocation?, v: Int32Array)\n    fun uniform3iv(location: WebGLUniformLocation?, v: Array<Int>)\n    fun uniform4f(location: WebGLUniformLocation?, x: Float, y: Float, z: Float, w: Float)\n    fun uniform4fv(location: WebGLUniformLocation?, v: Float32Array)\n    fun uniform4fv(location: WebGLUniformLocation?, v: Array<Float>)\n    fun uniform4i(location: WebGLUniformLocation?, x: Int, y: Int, z: Int, w: Int)\n    fun uniform4iv(location: WebGLUniformLocation?, v: Int32Array)\n    fun uniform4iv(location: WebGLUniformLocation?, v: Array<Int>)\n    fun uniformMatrix2fv(location: WebGLUniformLocation?, transpose: Boolean, value: Float32Array)\n    fun uniformMatrix2fv(location: WebGLUniformLocation?, transpose: Boolean, value: Array<Float>)\n    fun uniformMatrix3fv(location: WebGLUniformLocation?, transpose: Boolean, value: Float32Array)\n    fun uniformMatrix3fv(location: WebGLUniformLocation?, transpose: Boolean, value: Array<Float>)\n    fun uniformMatrix4fv(location: WebGLUniformLocation?, transpose: Boolean, value: Float32Array)\n    fun uniformMatrix4fv(location: WebGLUniformLocation?, transpose: Boolean, value: Array<Float>)\n    fun useProgram(program: WebGLProgram?)\n    fun validateProgram(program: WebGLProgram?)\n    fun vertexAttrib1f(index: Int, x: Float)\n    fun vertexAttrib1fv(index: Int, values: dynamic)\n    fun vertexAttrib2f(index: Int, x: Float, y: Float)\n    fun vertexAttrib2fv(index: Int, values: dynamic)\n    fun vertexAttrib3f(index: Int, x: Float, y: Float, z: Float)\n    fun vertexAttrib3fv(index: Int, values: dynamic)\n    fun vertexAttrib4f(index: Int, x: Float, y: Float, z: Float, w: Float)\n    fun vertexAttrib4fv(index: Int, values: dynamic)\n    fun vertexAttribPointer(index: Int, size: Int, type: Int, normalized: Boolean, stride: Int, offset: Int)\n    fun viewport(x: Int, y: Int, width: Int, height: Int)\n\n    companion object {\n        val DEPTH_BUFFER_BIT: Int\n        val STENCIL_BUFFER_BIT: Int\n        val COLOR_BUFFER_BIT: Int\n        val POINTS: Int\n        val LINES: Int\n        val LINE_LOOP: Int\n        val LINE_STRIP: Int\n        val TRIANGLES: Int\n        val TRIANGLE_STRIP: Int\n        val TRIANGLE_FAN: Int\n        val ZERO: Int\n        val ONE: Int\n        val SRC_COLOR: Int\n        val ONE_MINUS_SRC_COLOR: Int\n        val SRC_ALPHA: Int\n        val ONE_MINUS_SRC_ALPHA: Int\n        val DST_ALPHA: Int\n        val ONE_MINUS_DST_ALPHA: Int\n        val DST_COLOR: Int\n        val ONE_MINUS_DST_COLOR: Int\n        val SRC_ALPHA_SATURATE: Int\n        val FUNC_ADD: Int\n        val BLEND_EQUATION: Int\n        val BLEND_EQUATION_RGB: Int\n        val BLEND_EQUATION_ALPHA: Int\n        val FUNC_SUBTRACT: Int\n        val FUNC_REVERSE_SUBTRACT: Int\n        val BLEND_DST_RGB: Int\n        val BLEND_SRC_RGB: Int\n        val BLEND_DST_ALPHA: Int\n        val BLEND_SRC_ALPHA: Int\n        val CONSTANT_COLOR: Int\n        val ONE_MINUS_CONSTANT_COLOR: Int\n        val CONSTANT_ALPHA: Int\n        val ONE_MINUS_CONSTANT_ALPHA: Int\n        val BLEND_COLOR: Int\n        val ARRAY_BUFFER: Int\n        val ELEMENT_ARRAY_BUFFER: Int\n        val ARRAY_BUFFER_BINDING: Int\n        val ELEMENT_ARRAY_BUFFER_BINDING: Int\n        val STREAM_DRAW: Int\n        val STATIC_DRAW: Int\n        val DYNAMIC_DRAW: Int\n        val BUFFER_SIZE: Int\n        val BUFFER_USAGE: Int\n        val CURRENT_VERTEX_ATTRIB: Int\n        val FRONT: Int\n        val BACK: Int\n        val FRONT_AND_BACK: Int\n        val CULL_FACE: Int\n        val BLEND: Int\n        val DITHER: Int\n        val STENCIL_TEST: Int\n        val DEPTH_TEST: Int\n        val SCISSOR_TEST: Int\n        val POLYGON_OFFSET_FILL: Int\n        val SAMPLE_ALPHA_TO_COVERAGE: Int\n        val SAMPLE_COVERAGE: Int\n        val NO_ERROR: Int\n        val INVALID_ENUM: Int\n        val INVALID_VALUE: Int\n        val INVALID_OPERATION: Int\n        val OUT_OF_MEMORY: Int\n        val CW: Int\n        val CCW: Int\n        val LINE_WIDTH: Int\n        val ALIASED_POINT_SIZE_RANGE: Int\n        val ALIASED_LINE_WIDTH_RANGE: Int\n        val CULL_FACE_MODE: Int\n        val FRONT_FACE: Int\n        val DEPTH_RANGE: Int\n        val DEPTH_WRITEMASK: Int\n        val DEPTH_CLEAR_VALUE: Int\n        val DEPTH_FUNC: Int\n        val STENCIL_CLEAR_VALUE: Int\n        val STENCIL_FUNC: Int\n        val STENCIL_FAIL: Int\n        val STENCIL_PASS_DEPTH_FAIL: Int\n        val STENCIL_PASS_DEPTH_PASS: Int\n        val STENCIL_REF: Int\n        val STENCIL_VALUE_MASK: Int\n        val STENCIL_WRITEMASK: Int\n        val STENCIL_BACK_FUNC: Int\n        val STENCIL_BACK_FAIL: Int\n        val STENCIL_BACK_PASS_DEPTH_FAIL: Int\n        val STENCIL_BACK_PASS_DEPTH_PASS: Int\n        val STENCIL_BACK_REF: Int\n        val STENCIL_BACK_VALUE_MASK: Int\n        val STENCIL_BACK_WRITEMASK: Int\n        val VIEWPORT: Int\n        val SCISSOR_BOX: Int\n        val COLOR_CLEAR_VALUE: Int\n        val COLOR_WRITEMASK: Int\n        val UNPACK_ALIGNMENT: Int\n        val PACK_ALIGNMENT: Int\n        val MAX_TEXTURE_SIZE: Int\n        val MAX_VIEWPORT_DIMS: Int\n        val SUBPIXEL_BITS: Int\n        val RED_BITS: Int\n        val GREEN_BITS: Int\n        val BLUE_BITS: Int\n        val ALPHA_BITS: Int\n        val DEPTH_BITS: Int\n        val STENCIL_BITS: Int\n        val POLYGON_OFFSET_UNITS: Int\n        val POLYGON_OFFSET_FACTOR: Int\n        val TEXTURE_BINDING_2D: Int\n        val SAMPLE_BUFFERS: Int\n        val SAMPLES: Int\n        val SAMPLE_COVERAGE_VALUE: Int\n        val SAMPLE_COVERAGE_INVERT: Int\n        val COMPRESSED_TEXTURE_FORMATS: Int\n        val DONT_CARE: Int\n        val FASTEST: Int\n        val NICEST: Int\n        val GENERATE_MIPMAP_HINT: Int\n        val BYTE: Int\n        val UNSIGNED_BYTE: Int\n        val SHORT: Int\n        val UNSIGNED_SHORT: Int\n        val INT: Int\n        val UNSIGNED_INT: Int\n        val FLOAT: Int\n        val DEPTH_COMPONENT: Int\n        val ALPHA: Int\n        val RGB: Int\n        val RGBA: Int\n        val LUMINANCE: Int\n        val LUMINANCE_ALPHA: Int\n        val UNSIGNED_SHORT_4_4_4_4: Int\n        val UNSIGNED_SHORT_5_5_5_1: Int\n        val UNSIGNED_SHORT_5_6_5: Int\n        val FRAGMENT_SHADER: Int\n        val VERTEX_SHADER: Int\n        val MAX_VERTEX_ATTRIBS: Int\n        val MAX_VERTEX_UNIFORM_VECTORS: Int\n        val MAX_VARYING_VECTORS: Int\n        val MAX_COMBINED_TEXTURE_IMAGE_UNITS: Int\n        val MAX_VERTEX_TEXTURE_IMAGE_UNITS: Int\n        val MAX_TEXTURE_IMAGE_UNITS: Int\n        val MAX_FRAGMENT_UNIFORM_VECTORS: Int\n        val SHADER_TYPE: Int\n        val DELETE_STATUS: Int\n        val LINK_STATUS: Int\n        val VALIDATE_STATUS: Int\n        val ATTACHED_SHADERS: Int\n        val ACTIVE_UNIFORMS: Int\n        val ACTIVE_ATTRIBUTES: Int\n        val SHADING_LANGUAGE_VERSION: Int\n        val CURRENT_PROGRAM: Int\n        val NEVER: Int\n        val LESS: Int\n        val EQUAL: Int\n        val LEQUAL: Int\n        val GREATER: Int\n        val NOTEQUAL: Int\n        val GEQUAL: Int\n        val ALWAYS: Int\n        val KEEP: Int\n        val REPLACE: Int\n        val INCR: Int\n        val DECR: Int\n        val INVERT: Int\n        val INCR_WRAP: Int\n        val DECR_WRAP: Int\n        val VENDOR: Int\n        val RENDERER: Int\n        val VERSION: Int\n        val NEAREST: Int\n        val LINEAR: Int\n        val NEAREST_MIPMAP_NEAREST: Int\n        val LINEAR_MIPMAP_NEAREST: Int\n        val NEAREST_MIPMAP_LINEAR: Int\n        val LINEAR_MIPMAP_LINEAR: Int\n        val TEXTURE_MAG_FILTER: Int\n        val TEXTURE_MIN_FILTER: Int\n        val TEXTURE_WRAP_S: Int\n        val TEXTURE_WRAP_T: Int\n        val TEXTURE_2D: Int\n        val TEXTURE: Int\n        val TEXTURE_CUBE_MAP: Int\n        val TEXTURE_BINDING_CUBE_MAP: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_X: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_X: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_Y: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_Y: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_Z: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_Z: Int\n        val MAX_CUBE_MAP_TEXTURE_SIZE: Int\n        val TEXTURE0: Int\n        val TEXTURE1: Int\n        val TEXTURE2: Int\n        val TEXTURE3: Int\n        val TEXTURE4: Int\n        val TEXTURE5: Int\n        val TEXTURE6: Int\n        val TEXTURE7: Int\n        val TEXTURE8: Int\n        val TEXTURE9: Int\n        val TEXTURE10: Int\n        val TEXTURE11: Int\n        val TEXTURE12: Int\n        val TEXTURE13: Int\n        val TEXTURE14: Int\n        val TEXTURE15: Int\n        val TEXTURE16: Int\n        val TEXTURE17: Int\n        val TEXTURE18: Int\n        val TEXTURE19: Int\n        val TEXTURE20: Int\n        val TEXTURE21: Int\n        val TEXTURE22: Int\n        val TEXTURE23: Int\n        val TEXTURE24: Int\n        val TEXTURE25: Int\n        val TEXTURE26: Int\n        val TEXTURE27: Int\n        val TEXTURE28: Int\n        val TEXTURE29: Int\n        val TEXTURE30: Int\n        val TEXTURE31: Int\n        val ACTIVE_TEXTURE: Int\n        val REPEAT: Int\n        val CLAMP_TO_EDGE: Int\n        val MIRRORED_REPEAT: Int\n        val FLOAT_VEC2: Int\n        val FLOAT_VEC3: Int\n        val FLOAT_VEC4: Int\n        val INT_VEC2: Int\n        val INT_VEC3: Int\n        val INT_VEC4: Int\n        val BOOL: Int\n        val BOOL_VEC2: Int\n        val BOOL_VEC3: Int\n        val BOOL_VEC4: Int\n        val FLOAT_MAT2: Int\n        val FLOAT_MAT3: Int\n        val FLOAT_MAT4: Int\n        val SAMPLER_2D: Int\n        val SAMPLER_CUBE: Int\n        val VERTEX_ATTRIB_ARRAY_ENABLED: Int\n        val VERTEX_ATTRIB_ARRAY_SIZE: Int\n        val VERTEX_ATTRIB_ARRAY_STRIDE: Int\n        val VERTEX_ATTRIB_ARRAY_TYPE: Int\n        val VERTEX_ATTRIB_ARRAY_NORMALIZED: Int\n        val VERTEX_ATTRIB_ARRAY_POINTER: Int\n        val VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: Int\n        val IMPLEMENTATION_COLOR_READ_TYPE: Int\n        val IMPLEMENTATION_COLOR_READ_FORMAT: Int\n        val COMPILE_STATUS: Int\n        val LOW_FLOAT: Int\n        val MEDIUM_FLOAT: Int\n        val HIGH_FLOAT: Int\n        val LOW_INT: Int\n        val MEDIUM_INT: Int\n        val HIGH_INT: Int\n        val FRAMEBUFFER: Int\n        val RENDERBUFFER: Int\n        val RGBA4: Int\n        val RGB5_A1: Int\n        val RGB565: Int\n        val DEPTH_COMPONENT16: Int\n        val STENCIL_INDEX: Int\n        val STENCIL_INDEX8: Int\n        val DEPTH_STENCIL: Int\n        val RENDERBUFFER_WIDTH: Int\n        val RENDERBUFFER_HEIGHT: Int\n        val RENDERBUFFER_INTERNAL_FORMAT: Int\n        val RENDERBUFFER_RED_SIZE: Int\n        val RENDERBUFFER_GREEN_SIZE: Int\n        val RENDERBUFFER_BLUE_SIZE: Int\n        val RENDERBUFFER_ALPHA_SIZE: Int\n        val RENDERBUFFER_DEPTH_SIZE: Int\n        val RENDERBUFFER_STENCIL_SIZE: Int\n        val FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: Int\n        val FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: Int\n        val FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: Int\n        val FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: Int\n        val COLOR_ATTACHMENT0: Int\n        val DEPTH_ATTACHMENT: Int\n        val STENCIL_ATTACHMENT: Int\n        val DEPTH_STENCIL_ATTACHMENT: Int\n        val NONE: Int\n        val FRAMEBUFFER_COMPLETE: Int\n        val FRAMEBUFFER_INCOMPLETE_ATTACHMENT: Int\n        val FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: Int\n        val FRAMEBUFFER_INCOMPLETE_DIMENSIONS: Int\n        val FRAMEBUFFER_UNSUPPORTED: Int\n        val FRAMEBUFFER_BINDING: Int\n        val RENDERBUFFER_BINDING: Int\n        val MAX_RENDERBUFFER_SIZE: Int\n        val INVALID_FRAMEBUFFER_OPERATION: Int\n        val UNPACK_FLIP_Y_WEBGL: Int\n        val UNPACK_PREMULTIPLY_ALPHA_WEBGL: Int\n        val CONTEXT_LOST_WEBGL: Int\n        val UNPACK_COLORSPACE_CONVERSION_WEBGL: Int\n        val BROWSER_DEFAULT_WEBGL: Int\n    }\n}\n\n/**\n * Exposes the JavaScript [WebGLRenderingContext](https://developer.mozilla.org/en/docs/Web/API/WebGLRenderingContext) to Kotlin\n */\npublic external abstract class WebGLRenderingContext : WebGLRenderingContextBase, RenderingContext {\n    companion object {\n        val DEPTH_BUFFER_BIT: Int\n        val STENCIL_BUFFER_BIT: Int\n        val COLOR_BUFFER_BIT: Int\n        val POINTS: Int\n        val LINES: Int\n        val LINE_LOOP: Int\n        val LINE_STRIP: Int\n        val TRIANGLES: Int\n        val TRIANGLE_STRIP: Int\n        val TRIANGLE_FAN: Int\n        val ZERO: Int\n        val ONE: Int\n        val SRC_COLOR: Int\n        val ONE_MINUS_SRC_COLOR: Int\n        val SRC_ALPHA: Int\n        val ONE_MINUS_SRC_ALPHA: Int\n        val DST_ALPHA: Int\n        val ONE_MINUS_DST_ALPHA: Int\n        val DST_COLOR: Int\n        val ONE_MINUS_DST_COLOR: Int\n        val SRC_ALPHA_SATURATE: Int\n        val FUNC_ADD: Int\n        val BLEND_EQUATION: Int\n        val BLEND_EQUATION_RGB: Int\n        val BLEND_EQUATION_ALPHA: Int\n        val FUNC_SUBTRACT: Int\n        val FUNC_REVERSE_SUBTRACT: Int\n        val BLEND_DST_RGB: Int\n        val BLEND_SRC_RGB: Int\n        val BLEND_DST_ALPHA: Int\n        val BLEND_SRC_ALPHA: Int\n        val CONSTANT_COLOR: Int\n        val ONE_MINUS_CONSTANT_COLOR: Int\n        val CONSTANT_ALPHA: Int\n        val ONE_MINUS_CONSTANT_ALPHA: Int\n        val BLEND_COLOR: Int\n        val ARRAY_BUFFER: Int\n        val ELEMENT_ARRAY_BUFFER: Int\n        val ARRAY_BUFFER_BINDING: Int\n        val ELEMENT_ARRAY_BUFFER_BINDING: Int\n        val STREAM_DRAW: Int\n        val STATIC_DRAW: Int\n        val DYNAMIC_DRAW: Int\n        val BUFFER_SIZE: Int\n        val BUFFER_USAGE: Int\n        val CURRENT_VERTEX_ATTRIB: Int\n        val FRONT: Int\n        val BACK: Int\n        val FRONT_AND_BACK: Int\n        val CULL_FACE: Int\n        val BLEND: Int\n        val DITHER: Int\n        val STENCIL_TEST: Int\n        val DEPTH_TEST: Int\n        val SCISSOR_TEST: Int\n        val POLYGON_OFFSET_FILL: Int\n        val SAMPLE_ALPHA_TO_COVERAGE: Int\n        val SAMPLE_COVERAGE: Int\n        val NO_ERROR: Int\n        val INVALID_ENUM: Int\n        val INVALID_VALUE: Int\n        val INVALID_OPERATION: Int\n        val OUT_OF_MEMORY: Int\n        val CW: Int\n        val CCW: Int\n        val LINE_WIDTH: Int\n        val ALIASED_POINT_SIZE_RANGE: Int\n        val ALIASED_LINE_WIDTH_RANGE: Int\n        val CULL_FACE_MODE: Int\n        val FRONT_FACE: Int\n        val DEPTH_RANGE: Int\n        val DEPTH_WRITEMASK: Int\n        val DEPTH_CLEAR_VALUE: Int\n        val DEPTH_FUNC: Int\n        val STENCIL_CLEAR_VALUE: Int\n        val STENCIL_FUNC: Int\n        val STENCIL_FAIL: Int\n        val STENCIL_PASS_DEPTH_FAIL: Int\n        val STENCIL_PASS_DEPTH_PASS: Int\n        val STENCIL_REF: Int\n        val STENCIL_VALUE_MASK: Int\n        val STENCIL_WRITEMASK: Int\n        val STENCIL_BACK_FUNC: Int\n        val STENCIL_BACK_FAIL: Int\n        val STENCIL_BACK_PASS_DEPTH_FAIL: Int\n        val STENCIL_BACK_PASS_DEPTH_PASS: Int\n        val STENCIL_BACK_REF: Int\n        val STENCIL_BACK_VALUE_MASK: Int\n        val STENCIL_BACK_WRITEMASK: Int\n        val VIEWPORT: Int\n        val SCISSOR_BOX: Int\n        val COLOR_CLEAR_VALUE: Int\n        val COLOR_WRITEMASK: Int\n        val UNPACK_ALIGNMENT: Int\n        val PACK_ALIGNMENT: Int\n        val MAX_TEXTURE_SIZE: Int\n        val MAX_VIEWPORT_DIMS: Int\n        val SUBPIXEL_BITS: Int\n        val RED_BITS: Int\n        val GREEN_BITS: Int\n        val BLUE_BITS: Int\n        val ALPHA_BITS: Int\n        val DEPTH_BITS: Int\n        val STENCIL_BITS: Int\n        val POLYGON_OFFSET_UNITS: Int\n        val POLYGON_OFFSET_FACTOR: Int\n        val TEXTURE_BINDING_2D: Int\n        val SAMPLE_BUFFERS: Int\n        val SAMPLES: Int\n        val SAMPLE_COVERAGE_VALUE: Int\n        val SAMPLE_COVERAGE_INVERT: Int\n        val COMPRESSED_TEXTURE_FORMATS: Int\n        val DONT_CARE: Int\n        val FASTEST: Int\n        val NICEST: Int\n        val GENERATE_MIPMAP_HINT: Int\n        val BYTE: Int\n        val UNSIGNED_BYTE: Int\n        val SHORT: Int\n        val UNSIGNED_SHORT: Int\n        val INT: Int\n        val UNSIGNED_INT: Int\n        val FLOAT: Int\n        val DEPTH_COMPONENT: Int\n        val ALPHA: Int\n        val RGB: Int\n        val RGBA: Int\n        val LUMINANCE: Int\n        val LUMINANCE_ALPHA: Int\n        val UNSIGNED_SHORT_4_4_4_4: Int\n        val UNSIGNED_SHORT_5_5_5_1: Int\n        val UNSIGNED_SHORT_5_6_5: Int\n        val FRAGMENT_SHADER: Int\n        val VERTEX_SHADER: Int\n        val MAX_VERTEX_ATTRIBS: Int\n        val MAX_VERTEX_UNIFORM_VECTORS: Int\n        val MAX_VARYING_VECTORS: Int\n        val MAX_COMBINED_TEXTURE_IMAGE_UNITS: Int\n        val MAX_VERTEX_TEXTURE_IMAGE_UNITS: Int\n        val MAX_TEXTURE_IMAGE_UNITS: Int\n        val MAX_FRAGMENT_UNIFORM_VECTORS: Int\n        val SHADER_TYPE: Int\n        val DELETE_STATUS: Int\n        val LINK_STATUS: Int\n        val VALIDATE_STATUS: Int\n        val ATTACHED_SHADERS: Int\n        val ACTIVE_UNIFORMS: Int\n        val ACTIVE_ATTRIBUTES: Int\n        val SHADING_LANGUAGE_VERSION: Int\n        val CURRENT_PROGRAM: Int\n        val NEVER: Int\n        val LESS: Int\n        val EQUAL: Int\n        val LEQUAL: Int\n        val GREATER: Int\n        val NOTEQUAL: Int\n        val GEQUAL: Int\n        val ALWAYS: Int\n        val KEEP: Int\n        val REPLACE: Int\n        val INCR: Int\n        val DECR: Int\n        val INVERT: Int\n        val INCR_WRAP: Int\n        val DECR_WRAP: Int\n        val VENDOR: Int\n        val RENDERER: Int\n        val VERSION: Int\n        val NEAREST: Int\n        val LINEAR: Int\n        val NEAREST_MIPMAP_NEAREST: Int\n        val LINEAR_MIPMAP_NEAREST: Int\n        val NEAREST_MIPMAP_LINEAR: Int\n        val LINEAR_MIPMAP_LINEAR: Int\n        val TEXTURE_MAG_FILTER: Int\n        val TEXTURE_MIN_FILTER: Int\n        val TEXTURE_WRAP_S: Int\n        val TEXTURE_WRAP_T: Int\n        val TEXTURE_2D: Int\n        val TEXTURE: Int\n        val TEXTURE_CUBE_MAP: Int\n        val TEXTURE_BINDING_CUBE_MAP: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_X: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_X: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_Y: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_Y: Int\n        val TEXTURE_CUBE_MAP_POSITIVE_Z: Int\n        val TEXTURE_CUBE_MAP_NEGATIVE_Z: Int\n        val MAX_CUBE_MAP_TEXTURE_SIZE: Int\n        val TEXTURE0: Int\n        val TEXTURE1: Int\n        val TEXTURE2: Int\n        val TEXTURE3: Int\n        val TEXTURE4: Int\n        val TEXTURE5: Int\n        val TEXTURE6: Int\n        val TEXTURE7: Int\n        val TEXTURE8: Int\n        val TEXTURE9: Int\n        val TEXTURE10: Int\n        val TEXTURE11: Int\n        val TEXTURE12: Int\n        val TEXTURE13: Int\n        val TEXTURE14: Int\n        val TEXTURE15: Int\n        val TEXTURE16: Int\n        val TEXTURE17: Int\n        val TEXTURE18: Int\n        val TEXTURE19: Int\n        val TEXTURE20: Int\n        val TEXTURE21: Int\n        val TEXTURE22: Int\n        val TEXTURE23: Int\n        val TEXTURE24: Int\n        val TEXTURE25: Int\n        val TEXTURE26: Int\n        val TEXTURE27: Int\n        val TEXTURE28: Int\n        val TEXTURE29: Int\n        val TEXTURE30: Int\n        val TEXTURE31: Int\n        val ACTIVE_TEXTURE: Int\n        val REPEAT: Int\n        val CLAMP_TO_EDGE: Int\n        val MIRRORED_REPEAT: Int\n        val FLOAT_VEC2: Int\n        val FLOAT_VEC3: Int\n        val FLOAT_VEC4: Int\n        val INT_VEC2: Int\n        val INT_VEC3: Int\n        val INT_VEC4: Int\n        val BOOL: Int\n        val BOOL_VEC2: Int\n        val BOOL_VEC3: Int\n        val BOOL_VEC4: Int\n        val FLOAT_MAT2: Int\n        val FLOAT_MAT3: Int\n        val FLOAT_MAT4: Int\n        val SAMPLER_2D: Int\n        val SAMPLER_CUBE: Int\n        val VERTEX_ATTRIB_ARRAY_ENABLED: Int\n        val VERTEX_ATTRIB_ARRAY_SIZE: Int\n        val VERTEX_ATTRIB_ARRAY_STRIDE: Int\n        val VERTEX_ATTRIB_ARRAY_TYPE: Int\n        val VERTEX_ATTRIB_ARRAY_NORMALIZED: Int\n        val VERTEX_ATTRIB_ARRAY_POINTER: Int\n        val VERTEX_ATTRIB_ARRAY_BUFFER_BINDING: Int\n        val IMPLEMENTATION_COLOR_READ_TYPE: Int\n        val IMPLEMENTATION_COLOR_READ_FORMAT: Int\n        val COMPILE_STATUS: Int\n        val LOW_FLOAT: Int\n        val MEDIUM_FLOAT: Int\n        val HIGH_FLOAT: Int\n        val LOW_INT: Int\n        val MEDIUM_INT: Int\n        val HIGH_INT: Int\n        val FRAMEBUFFER: Int\n        val RENDERBUFFER: Int\n        val RGBA4: Int\n        val RGB5_A1: Int\n        val RGB565: Int\n        val DEPTH_COMPONENT16: Int\n        val STENCIL_INDEX: Int\n        val STENCIL_INDEX8: Int\n        val DEPTH_STENCIL: Int\n        val RENDERBUFFER_WIDTH: Int\n        val RENDERBUFFER_HEIGHT: Int\n        val RENDERBUFFER_INTERNAL_FORMAT: Int\n        val RENDERBUFFER_RED_SIZE: Int\n        val RENDERBUFFER_GREEN_SIZE: Int\n        val RENDERBUFFER_BLUE_SIZE: Int\n        val RENDERBUFFER_ALPHA_SIZE: Int\n        val RENDERBUFFER_DEPTH_SIZE: Int\n        val RENDERBUFFER_STENCIL_SIZE: Int\n        val FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE: Int\n        val FRAMEBUFFER_ATTACHMENT_OBJECT_NAME: Int\n        val FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL: Int\n        val FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE: Int\n        val COLOR_ATTACHMENT0: Int\n        val DEPTH_ATTACHMENT: Int\n        val STENCIL_ATTACHMENT: Int\n        val DEPTH_STENCIL_ATTACHMENT: Int\n        val NONE: Int\n        val FRAMEBUFFER_COMPLETE: Int\n        val FRAMEBUFFER_INCOMPLETE_ATTACHMENT: Int\n        val FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT: Int\n        val FRAMEBUFFER_INCOMPLETE_DIMENSIONS: Int\n        val FRAMEBUFFER_UNSUPPORTED: Int\n        val FRAMEBUFFER_BINDING: Int\n        val RENDERBUFFER_BINDING: Int\n        val MAX_RENDERBUFFER_SIZE: Int\n        val INVALID_FRAMEBUFFER_OPERATION: Int\n        val UNPACK_FLIP_Y_WEBGL: Int\n        val UNPACK_PREMULTIPLY_ALPHA_WEBGL: Int\n        val CONTEXT_LOST_WEBGL: Int\n        val UNPACK_COLORSPACE_CONVERSION_WEBGL: Int\n        val BROWSER_DEFAULT_WEBGL: Int\n    }\n}\n\n/**\n * Exposes the JavaScript [WebGLContextEvent](https://developer.mozilla.org/en/docs/Web/API/WebGLContextEvent) to Kotlin\n */\npublic external open class WebGLContextEvent(type: String, eventInit: WebGLContextEventInit = definedExternally) : Event {\n    open val statusMessage: String\n\n    companion object {\n        val NONE: Short\n        val CAPTURING_PHASE: Short\n        val AT_TARGET: Short\n        val BUBBLING_PHASE: Short\n    }\n}\n\npublic external interface WebGLContextEventInit : EventInit {\n    var statusMessage: String? /* = \"\" */\n        get() = definedExternally\n        set(value) = definedExternally\n}\n\n@Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n@kotlin.internal.InlineOnly\npublic inline fun WebGLContextEventInit(statusMessage: String? = \"\", bubbles: Boolean? = false, cancelable: Boolean? = false, composed: Boolean? = false): WebGLContextEventInit {\n    val o = js(\"({})\")\n    o[\"statusMessage\"] = statusMessage\n    o[\"bubbles\"] = bubbles\n    o[\"cancelable\"] = cancelable\n    o[\"composed\"] = composed\n    return o\n}\n\n/**\n * Exposes the JavaScript [ArrayBuffer](https://developer.mozilla.org/en/docs/Web/API/ArrayBuffer) to Kotlin\n */\npublic external open class ArrayBuffer(length: Int) : BufferDataSource {\n    open val byteLength: Int\n    fun slice(begin: Int, end: Int = definedExternally): ArrayBuffer\n\n    companion object {\n        fun isView(value: Any?): Boolean\n    }\n}\n\n/**\n * Exposes the JavaScript [ArrayBufferView](https://developer.mozilla.org/en/docs/Web/API/ArrayBufferView) to Kotlin\n */\npublic external interface ArrayBufferView : BufferDataSource {\n    val buffer: ArrayBuffer\n    val byteOffset: Int\n    val byteLength: Int\n}\n\n/**\n * Exposes the JavaScript [Int8Array](https://developer.mozilla.org/en/docs/Web/API/Int8Array) to Kotlin\n */\npublic external open class Int8Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Int8Array)\n    constructor(array: Array<Byte>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Int8Array, offset: Int = definedExternally)\n    fun set(array: Array<Byte>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Int8Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n@kotlin.internal.InlineOnly\npublic inline operator fun Int8Array.get(index: Int): Byte = asDynamic()[index]\n\n@Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n@kotlin.internal.InlineOnly\npublic inline operator fun Int8Array.set(index: Int, value: Byte) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [Uint8Array](https://developer.mozilla.org/en/docs/Web/API/Uint8Array) to Kotlin\n */\npublic external open class Uint8Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Uint8Array)\n    constructor(array: Array<Byte>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Uint8Array, offset: Int = definedExternally)\n    fun set(array: Array<Byte>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Uint8Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n@kotlin.internal.InlineOnly\npublic inline operator fun Uint8Array.get(index: Int): Byte = asDynamic()[index]\n\n@Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n@kotlin.internal.InlineOnly\npublic inline operator fun Uint8Array.set(index: Int, value: Byte) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [Uint8ClampedArray](https://developer.mozilla.org/en/docs/Web/API/Uint8ClampedArray) to Kotlin\n */\npublic external open class Uint8ClampedArray : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Uint8ClampedArray)\n    constructor(array: Array<Byte>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Uint8ClampedArray, offset: Int = definedExternally)\n    fun set(array: Array<Byte>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Uint8ClampedArray\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n@kotlin.internal.InlineOnly\npublic inline operator fun Uint8ClampedArray.get(index: Int): Byte = asDynamic()[index]\n\n@Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n@kotlin.internal.InlineOnly\npublic inline operator fun Uint8ClampedArray.set(index: Int, value: Byte) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [Int16Array](https://developer.mozilla.org/en/docs/Web/API/Int16Array) to Kotlin\n */\npublic external open class Int16Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Int16Array)\n    constructor(array: Array<Short>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Int16Array, offset: Int = definedExternally)\n    fun set(array: Array<Short>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Int16Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n@kotlin.internal.InlineOnly\npublic inline operator fun Int16Array.get(index: Int): Short = asDynamic()[index]\n\n@Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n@kotlin.internal.InlineOnly\npublic inline operator fun Int16Array.set(index: Int, value: Short) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [Uint16Array](https://developer.mozilla.org/en/docs/Web/API/Uint16Array) to Kotlin\n */\npublic external open class Uint16Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Uint16Array)\n    constructor(array: Array<Short>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Uint16Array, offset: Int = definedExternally)\n    fun set(array: Array<Short>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Uint16Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n@kotlin.internal.InlineOnly\npublic inline operator fun Uint16Array.get(index: Int): Short = asDynamic()[index]\n\n@Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n@kotlin.internal.InlineOnly\npublic inline operator fun Uint16Array.set(index: Int, value: Short) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [Int32Array](https://developer.mozilla.org/en/docs/Web/API/Int32Array) to Kotlin\n */\npublic external open class Int32Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Int32Array)\n    constructor(array: Array<Int>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Int32Array, offset: Int = definedExternally)\n    fun set(array: Array<Int>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Int32Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n@kotlin.internal.InlineOnly\npublic inline operator fun Int32Array.get(index: Int): Int = asDynamic()[index]\n\n@Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n@kotlin.internal.InlineOnly\npublic inline operator fun Int32Array.set(index: Int, value: Int) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [Uint32Array](https://developer.mozilla.org/en/docs/Web/API/Uint32Array) to Kotlin\n */\npublic external open class Uint32Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Uint32Array)\n    constructor(array: Array<Int>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Uint32Array, offset: Int = definedExternally)\n    fun set(array: Array<Int>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Uint32Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n@kotlin.internal.InlineOnly\npublic inline operator fun Uint32Array.get(index: Int): Int = asDynamic()[index]\n\n@Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n@kotlin.internal.InlineOnly\npublic inline operator fun Uint32Array.set(index: Int, value: Int) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [Float32Array](https://developer.mozilla.org/en/docs/Web/API/Float32Array) to Kotlin\n */\npublic external open class Float32Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Float32Array)\n    constructor(array: Array<Float>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Float32Array, offset: Int = definedExternally)\n    fun set(array: Array<Float>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Float32Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n@kotlin.internal.InlineOnly\npublic inline operator fun Float32Array.get(index: Int): Float = asDynamic()[index]\n\n@Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n@kotlin.internal.InlineOnly\npublic inline operator fun Float32Array.set(index: Int, value: Float) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [Float64Array](https://developer.mozilla.org/en/docs/Web/API/Float64Array) to Kotlin\n */\npublic external open class Float64Array : ArrayBufferView {\n    constructor(length: Int)\n    constructor(array: Float64Array)\n    constructor(array: Array<Double>)\n    constructor(buffer: ArrayBuffer, byteOffset: Int = definedExternally, length: Int = definedExternally)\n    open val length: Int\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun set(array: Float64Array, offset: Int = definedExternally)\n    fun set(array: Array<Double>, offset: Int = definedExternally)\n    fun subarray(start: Int, end: Int): Float64Array\n\n    companion object {\n        val BYTES_PER_ELEMENT: Int\n    }\n}\n\n@Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n@kotlin.internal.InlineOnly\npublic inline operator fun Float64Array.get(index: Int): Double = asDynamic()[index]\n\n@Suppress(\"INVISIBLE_REFERENCE\", \"INVISIBLE_MEMBER\")\n@kotlin.internal.InlineOnly\npublic inline operator fun Float64Array.set(index: Int, value: Double) { asDynamic()[index] = value }\n\n/**\n * Exposes the JavaScript [DataView](https://developer.mozilla.org/en/docs/Web/API/DataView) to Kotlin\n */\npublic external open class DataView(buffer: ArrayBuffer, byteOffset: Int = definedExternally, byteLength: Int = definedExternally) : ArrayBufferView {\n    override val buffer: ArrayBuffer\n    override val byteOffset: Int\n    override val byteLength: Int\n    fun getInt8(byteOffset: Int): Byte\n    fun getUint8(byteOffset: Int): Byte\n    fun getInt16(byteOffset: Int, littleEndian: Boolean = definedExternally): Short\n    fun getUint16(byteOffset: Int, littleEndian: Boolean = definedExternally): Short\n    fun getInt32(byteOffset: Int, littleEndian: Boolean = definedExternally): Int\n    fun getUint32(byteOffset: Int, littleEndian: Boolean = definedExternally): Int\n    fun getFloat32(byteOffset: Int, littleEndian: Boolean = definedExternally): Float\n    fun getFloat64(byteOffset: Int, littleEndian: Boolean = definedExternally): Double\n    fun setInt8(byteOffset: Int, value: Byte)\n    fun setUint8(byteOffset: Int, value: Byte)\n    fun setInt16(byteOffset: Int, value: Short, littleEndian: Boolean = definedExternally)\n    fun setUint16(byteOffset: Int, value: Short, littleEndian: Boolean = definedExternally)\n    fun setInt32(byteOffset: Int, value: Int, littleEndian: Boolean = definedExternally)\n    fun setUint32(byteOffset: Int, value: Int, littleEndian: Boolean = definedExternally)\n    fun setFloat32(byteOffset: Int, value: Float, littleEndian: Boolean = definedExternally)\n    fun setFloat64(byteOffset: Int, value: Double, littleEndian: Boolean = definedExternally)\n}\n\npublic external interface BufferDataSource\n\npublic external interface TexImageSource","package io.ktor.utils.io.charsets\n\nimport io.ktor.utils.io.core.*\nimport io.ktor.utils.io.js.*\nimport org.khronos.webgl.*\n\npublic actual abstract class Charset(internal val _name: String) {\n    public actual abstract fun newEncoder(): CharsetEncoder\n    public actual abstract fun newDecoder(): CharsetDecoder\n\n    public actual companion object {\n        public actual fun forName(name: String): Charset {\n            if (name == \"UTF-8\" || name == \"utf-8\" || name == \"UTF8\" || name == \"utf8\") return Charsets.UTF_8\n            if (name == \"ISO-8859-1\" || name == \"iso-8859-1\" || name.replace('_', '-').let {\n                it == \"iso-8859-1\" || it.toLowerCase() == \"iso-8859-1\"\n            } || name == \"latin1\" || name == \"Latin1\"\n            ) {\n                return Charsets.ISO_8859_1\n            }\n            throw IllegalArgumentException(\"Charset $name is not supported\")\n        }\n    }\n}\n\npublic actual val Charset.name: String get() = _name\n\n// -----------------------\n\npublic actual abstract class CharsetEncoder(internal val _charset: Charset)\nprivate data class CharsetEncoderImpl(private val charset: Charset) : CharsetEncoder(charset)\npublic actual val CharsetEncoder.charset: Charset get() = _charset\n\npublic actual fun CharsetEncoder.encodeToByteArray(input: CharSequence, fromIndex: Int, toIndex: Int): ByteArray =\n    encodeToByteArrayImpl1(input, fromIndex, toIndex)\n\ninternal actual fun CharsetEncoder.encodeImpl(input: CharSequence, fromIndex: Int, toIndex: Int, dst: Buffer): Int {\n    require(fromIndex <= toIndex)\n    if (charset == Charsets.ISO_8859_1) {\n        return encodeISO88591(input, fromIndex, toIndex, dst)\n    }\n\n    require(charset === Charsets.UTF_8) { \"Only UTF-8 encoding is supported in JS\" }\n\n    val encoder = TextEncoder() // Only UTF-8 is supported so we know that at most 6 bytes per character is used\n    var start = fromIndex\n    var dstRemaining = dst.writeRemaining\n\n    while (start < toIndex && dstRemaining > 0) {\n        val numChars = minOf(toIndex - start, dstRemaining / 6).coerceAtLeast(1)\n        val dropLastChar = input[start + numChars - 1].isHighSurrogate()\n        val endIndexExclusive = when {\n            dropLastChar && numChars == 1 -> start + 2\n            dropLastChar -> start + numChars - 1\n            else -> start + numChars\n        }\n\n        val array1 = encoder.encode(input.substring(start, endIndexExclusive))\n        if (array1.length > dstRemaining) break\n        dst.writeFully(array1)\n        start = endIndexExclusive\n        dstRemaining -= array1.length\n    }\n\n    return start - fromIndex\n}\n\npublic actual fun CharsetEncoder.encodeUTF8(input: ByteReadPacket, dst: Output) {\n    require(charset === Charsets.UTF_8)\n    // we only support UTF-8 so as far as input is UTF-8 encoded string then we simply copy bytes\n    dst.writePacket(input)\n}\n\ninternal actual fun CharsetEncoder.encodeComplete(dst: Buffer): Boolean = true\n\n// ----------------------------------------------------------------------\n\npublic actual abstract class CharsetDecoder(internal val _charset: Charset)\n\nprivate data class CharsetDecoderImpl(private val charset: Charset) : CharsetDecoder(charset)\n\npublic actual val CharsetDecoder.charset: Charset get() = _charset\n\ninternal actual fun CharsetDecoder.decodeBuffer(\n    input: Buffer,\n    out: Appendable,\n    lastBuffer: Boolean,\n    max: Int\n): Int {\n    if (max == 0) return 0\n\n    val decoder = Decoder(charset.name)\n    val copied: Int\n\n    input.readDirectInt8Array { view ->\n        val result = view.decodeBufferImpl(decoder, max)\n        out.append(result.charactersDecoded)\n        copied = result.bytesConsumed\n\n        result.bytesConsumed\n    }\n\n    return copied\n}\n\npublic actual fun CharsetDecoder.decode(input: Input, dst: Appendable, max: Int): Int {\n    val decoder = Decoder(charset.name, true)\n    var charactersCopied = 0\n\n    // use decode stream while we have remaining characters count > buffer size in bytes\n    // it is much faster than using decodeBufferImpl\n    input.takeWhileSize { buffer ->\n        val rem = max - charactersCopied\n        val bufferSize = buffer.readRemaining\n        if (rem < bufferSize) return@takeWhileSize 0\n\n        buffer.readDirectInt8Array { view ->\n            val decodedText = decodeWrap {\n                decoder.decodeStream(view, stream = true)\n            }\n            dst.append(decodedText)\n            charactersCopied += decodedText.length\n            view.byteLength\n        }\n\n        when {\n            charactersCopied == max -> {\n                val tail = try {\n                    decoder.decode()\n                } catch (_: dynamic) {\n                    \"\"\n                }\n\n                if (tail.isNotEmpty()) {\n                    // if we have a trailing byte then we can't handle this chunk via fast-path\n                    // because we don't know how many bytes in the end we need to preserve\n                    buffer.rewind(bufferSize)\n                }\n                0\n            }\n            charactersCopied < max -> MAX_CHARACTERS_SIZE_IN_BYTES\n            else -> 0\n        }\n    }\n\n    if (charactersCopied < max) {\n        var size = 1\n        input.takeWhileSize(1) { buffer ->\n            val rc = buffer.readDirectInt8Array { view ->\n                val result = view.decodeBufferImpl(decoder, max - charactersCopied)\n                dst.append(result.charactersDecoded)\n                charactersCopied += result.charactersDecoded.length\n                result.bytesConsumed\n            }\n            when {\n                rc > 0 -> size = 1\n                size == MAX_CHARACTERS_SIZE_IN_BYTES -> size = 0\n                else -> size++\n            }\n\n            size\n        }\n    }\n\n    return charactersCopied\n}\n\npublic actual fun CharsetDecoder.decodeExactBytes(input: Input, inputLength: Int): String {\n    if (inputLength == 0) return \"\"\n    if (input is AbstractInput && input.headRemaining >= inputLength) {\n        val decoder = Decoder(charset._name, true)\n\n        val head = input.head\n        val view = input.headMemory.view\n\n        val text = decodeWrap {\n            val subView: ArrayBufferView = when {\n                head.readPosition == 0 && inputLength == view.byteLength -> view\n                else -> DataView(view.buffer, view.byteOffset + head.readPosition, inputLength)\n            }\n\n            decoder.decode(subView)\n        }\n\n        input.discardExact(inputLength)\n        return text\n    }\n\n    return decodeExactBytesSlow(input, inputLength)\n}\n\n// -----------------------------------------------------------\n\npublic actual object Charsets {\n    public actual val UTF_8: Charset = CharsetImpl(\"UTF-8\")\n    public actual val ISO_8859_1: Charset = CharsetImpl(\"ISO-8859-1\")\n}\n\nprivate data class CharsetImpl(val name: String) : Charset(name) {\n    override fun newEncoder(): CharsetEncoder = CharsetEncoderImpl(this)\n    override fun newDecoder(): CharsetDecoder = CharsetDecoderImpl(this)\n}\n\npublic actual open class MalformedInputException actual constructor(message: String) : Throwable(message)\n\nprivate fun CharsetDecoder.decodeExactBytesSlow(input: Input, inputLength: Int): String {\n    val decoder = Decoder(charset.name, true)\n    var inputRemaining = inputLength\n    val sb = StringBuilder(inputLength)\n\n    decodeWrap {\n        input.takeWhileSize(6) { buffer ->\n            val chunkSize = buffer.readRemaining\n            val size = minOf(chunkSize, inputRemaining)\n            val text = when {\n                buffer.readPosition == 0 && buffer.memory.view.byteLength == size -> decoder.decodeStream(\n                    buffer.memory.view,\n                    true\n                )\n                else -> decoder.decodeStream(\n                    Int8Array(\n                        buffer.memory.view.buffer,\n                        buffer.memory.view.byteOffset + buffer.readPosition,\n                        size\n                    ),\n                    true\n                )\n            }\n            sb.append(text)\n\n            buffer.discardExact(size)\n            inputRemaining -= size\n\n            if (inputRemaining > 0) 6 else 0\n        }\n\n        if (inputRemaining > 0) {\n            input.takeWhile { buffer ->\n                val chunkSize = buffer.readRemaining\n                val size = minOf(chunkSize, inputRemaining)\n                val text = when {\n                    buffer.readPosition == 0 && buffer.memory.view.byteLength == size -> {\n                        decoder.decode(buffer.memory.view)\n                    }\n                    else -> decoder.decodeStream(\n                        Int8Array(\n                            buffer.memory.view.buffer,\n                            buffer.memory.view.byteOffset + buffer.readPosition,\n                            size\n                        ),\n                        true\n                    )\n                }\n                sb.append(text)\n                buffer.discardExact(size)\n                inputRemaining -= size\n                true\n            }\n        }\n\n        sb.append(decoder.decode())\n    }\n\n    if (inputRemaining > 0) {\n        throw EOFException(\n            \"Not enough bytes available: had only ${inputLength - inputRemaining} instead of $inputLength\"\n        )\n    }\n    return sb.toString()\n}\n","package io.ktor.utils.io.js\n\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.*\nimport org.khronos.webgl.*\n\n@Deprecated(\n    \"Use readText with charset instead\",\n    ReplaceWith(\n        \"readText(Charset.forName(encoding), max)\",\n        \"io.ktor.utils.io.core.readText\",\n        \"io.ktor.utils.io.charsets.Charset\"\n    )\n)\npublic fun ByteReadPacket.readText(encoding: String, max: Int = Int.MAX_VALUE): String =\n    readText(Charset.forName(encoding), max)\n\n@Deprecated(\n    \"Use readText with charset instead\",\n    ReplaceWith(\n        \"readText(out, Charset.forName(encoding), max)\",\n        \"io.ktor.utils.io.core.readText\",\n        \"io.ktor.utils.io.charsets.Charset\"\n    )\n)\npublic fun ByteReadPacket.readText(encoding: String = \"UTF-8\", out: Appendable, max: Int = Int.MAX_VALUE): Int {\n    return readText(out, Charset.forName(encoding), max)\n}\n\ninternal inline fun <R> decodeWrap(block: () -> R): R {\n    try {\n        return block()\n    } catch (t: Throwable) {\n        throw MalformedInputException(\"Failed to decode bytes: ${t.message ?: \"no cause provided\"}\")\n    }\n}\n","package io.ktor.utils.io.charsets\n\nimport io.ktor.utils.io.js.*\nimport org.khronos.webgl.*\n\n// I don't know any characters that have longer characters\ninternal const val MAX_CHARACTERS_SIZE_IN_BYTES: Int = 8\nprivate const val MAX_CHARACTERS_COUNT = Int.MAX_VALUE / MAX_CHARACTERS_SIZE_IN_BYTES\n\ninternal data class DecodeBufferResult(val charactersDecoded: String, val bytesConsumed: Int)\n\ninternal fun Int8Array.decodeBufferImpl(nativeDecoder: Decoder, maxCharacters: Int): DecodeBufferResult {\n    if (maxCharacters == 0) {\n        return DecodeBufferResult(\"\", 0)\n    }\n\n    // fast-path: try to assume that we have 1 byte per character content\n    try {\n        val sizeInBytes = maxCharacters.coerceAtMost(byteLength)\n        val text = nativeDecoder.decode(subarray(0, sizeInBytes))\n        if (text.length <= maxCharacters) {\n            return DecodeBufferResult(text, sizeInBytes)\n        }\n    } catch (_: dynamic) {\n    }\n\n    return decodeBufferImplSlow(nativeDecoder, maxCharacters)\n}\n\nprivate fun Int8Array.decodeBufferImplSlow(nativeDecoder: Decoder, maxCharacters: Int): DecodeBufferResult {\n    val maxBytes = when {\n        maxCharacters >= MAX_CHARACTERS_COUNT -> Int.MAX_VALUE\n        else -> maxCharacters * MAX_CHARACTERS_SIZE_IN_BYTES\n    }.coerceAtMost(byteLength)\n\n    var sizeInBytes = maxBytes\n    while (sizeInBytes > MAX_CHARACTERS_SIZE_IN_BYTES) {\n        try {\n            val text = nativeDecoder.decode(subarray(0, sizeInBytes))\n            if (text.length <= maxCharacters) {\n                return DecodeBufferResult(text, sizeInBytes)\n            }\n        } catch (_: dynamic) {\n        }\n\n        sizeInBytes /= 2\n    }\n\n    sizeInBytes = MAX_CHARACTERS_SIZE_IN_BYTES\n    while (sizeInBytes > 0) {\n        try {\n            val text = nativeDecoder.decode(subarray(0, sizeInBytes))\n            if (text.length <= maxCharacters) {\n                return DecodeBufferResult(text, sizeInBytes)\n            }\n        } catch (_: dynamic) {\n        }\n\n        sizeInBytes--\n    }\n\n    // all attempts were failed so most likely we have a broken character but we can't find it for some reason\n    // so the following decode most likely will fail\n    decodeWrap {\n        nativeDecoder.decode(this)\n    }\n\n    // if it didn't for some reason we have no idea what to do\n    throw MalformedInputException(\"Unable to decode buffer\")\n}\n","package io.ktor.utils.io.charsets\n\nimport io.ktor.utils.io.core.*\nimport org.khronos.webgl.*\n\ninternal fun encodeISO88591(input: CharSequence, fromIndex: Int, toIndex: Int, dst: Buffer): Int {\n    if (fromIndex >= toIndex) return 0\n\n    dst.writeDirect { view ->\n        val i8 = Int8Array(view.buffer, view.byteOffset, view.byteLength)\n        var writeIndex = 0\n        for (index in fromIndex until toIndex) {\n            val character = input[index].toInt()\n            if (character > 0xff) {\n                failedToMapError(character)\n            }\n            i8[writeIndex++] = character.toByte()\n        }\n        writeIndex\n    }\n    return toIndex - fromIndex\n}\n\nprivate fun failedToMapError(ch: Int): Nothing {\n    throw MalformedInputException(\"The character with unicode point $ch couldn't be mapped to ISO-8859-1 character\")\n}\n","@file:Suppress(\"ReplaceRangeToWithUntil\", \"RedundantModalityModifier\", \"DEPRECATION\", \"DEPRECATION_ERROR\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.pool.*\nimport org.khronos.webgl.*\nimport kotlin.contracts.*\n\n@Suppress(\"DIFFERENT_NAMES_FOR_THE_SAME_PARAMETER_IN_SUPERTYPES\")\n@Deprecated(\"Use Buffer instead.\", replaceWith = ReplaceWith(\"Buffer\", \"io.ktor.utils.io.core.Buffer\"))\npublic actual class IoBuffer internal actual constructor(\n    memory: Memory,\n    origin: ChunkBuffer?,\n    parentPool: ObjectPool<IoBuffer>?\n) : Input, Output, ChunkBuffer(memory, origin, parentPool as? ObjectPool<ChunkBuffer>) {\n    private val content: ArrayBuffer get() = memory.view.buffer\n\n    public actual constructor(\n        memory: Memory,\n        origin: ChunkBuffer?\n    ) : this(memory, origin, null)\n\n    override val endOfInput: Boolean get() = writePosition == readPosition\n\n    @Deprecated(\n        \"Not supported anymore. All operations are big endian by default. \" +\n            \"Read/write with readXXXLittleEndian/writeXXXLittleEndian or \" +\n            \"do readXXX/writeXXX with X.reverseByteOrder() instead.\",\n        level = DeprecationLevel.ERROR\n    )\n    actual final override var byteOrder: ByteOrder\n        get() = ByteOrder.BIG_ENDIAN\n        set(newOrder) {\n            if (newOrder != ByteOrder.BIG_ENDIAN) {\n                throw IllegalArgumentException(\"Only big endian is supported\")\n            }\n        }\n\n    final override fun peekTo(destination: Memory, destinationOffset: Long, offset: Long, min: Long, max: Long): Long {\n        return (this as Buffer).peekTo(destination, destinationOffset, offset, min, max)\n    }\n\n    final override fun tryPeek(): Int {\n        return tryPeekByte()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readFully(dst: ArrayBuffer, offset: Int, length: Int) {\n        (this as Buffer).readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: ArrayBuffer, offset: Int, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readAvailable(dst: IoBuffer, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFully(dst: ArrayBufferView, offset: Int, length: Int) {\n        if (readRemaining < length) {\n            throw IllegalStateException(\"Not enough bytes available ($readRemaining) to read $length bytes\")\n        }\n\n        if (length > dst.byteLength) {\n            throw IllegalArgumentException(\n                \"Destination buffer overflow: length = $length, buffer capacity ${dst.byteLength}\"\n            )\n        }\n        require(offset >= 0) { \"offset should be positive\" }\n        require(offset + length <= dst.byteLength) { throw IndexOutOfBoundsException(\"\") }\n\n        (this as Buffer).readFully(dst.buffer, dst.byteOffset + offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: ArrayBufferView, offset: Int, length: Int): Int {\n        val readRemaining = readRemaining\n        if (readRemaining == 0) return -1\n        val size = minOf(length, readRemaining)\n        (this as Buffer).readFully(dst, offset, size)\n        return size\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFully(dst: Int8Array, offset: Int, length: Int) {\n        (this as Buffer).readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: Int8Array, offset: Int, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readFully(dst: IoBuffer, length: Int) {\n        (this as Buffer).readFully(dst, length)\n    }\n\n    final override fun append(csq: CharSequence?, start: Int, end: Int): Appendable {\n        val idx = appendChars(csq ?: \"null\", start, end)\n        if (idx != end) throw IllegalStateException(\"Not enough free space to append char sequence\")\n        return this\n    }\n\n    final override fun append(csq: CharSequence?): Appendable {\n        return if (csq == null) append(\"null\") else append(csq, 0, csq.length)\n    }\n\n    final override fun append(csq: CharArray, start: Int, end: Int): Appendable {\n        val idx = appendChars(csq, start, end)\n\n        if (idx != end) throw IllegalStateException(\"Not enough free space to append char sequence\")\n        return this\n    }\n\n    override fun append(c: Char): Appendable {\n        (this as Buffer).append(c)\n        return this\n    }\n\n    @Deprecated(\n        \"Use writeFully instead\",\n        ReplaceWith(\"writeFully(array, offset, length)\"),\n        level = DeprecationLevel.ERROR\n    )\n    public fun write(array: ByteArray, offset: Int, length: Int) {\n        (this as Buffer).writeFully(array, offset, length)\n    }\n\n    @Deprecated(\n        \"Use writeFully instead\",\n        ReplaceWith(\"writeFully(array, offset, length)\"),\n        level = DeprecationLevel.ERROR\n    )\n    public fun write(src: Int8Array, offset: Int, length: Int) {\n        (this as Buffer).writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readShort(): Short {\n        return (this as Buffer).readShort()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readInt(): Int {\n        return (this as Buffer).readInt()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFloat(): Float {\n        return (this as Buffer).readFloat()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readDouble(): Double {\n        return (this as Buffer).readDouble()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFully(dst: ByteArray, offset: Int, length: Int) {\n        (this as Buffer).readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFully(dst: ShortArray, offset: Int, length: Int) {\n        (this as Buffer).readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFully(dst: IntArray, offset: Int, length: Int) {\n        (this as Buffer).readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFully(dst: LongArray, offset: Int, length: Int) {\n        (this as Buffer).readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFully(dst: FloatArray, offset: Int, length: Int) {\n        (this as Buffer).readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readFully(dst: DoubleArray, offset: Int, length: Int) {\n        (this as Buffer).readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: ByteArray, offset: Int, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: ShortArray, offset: Int, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: IntArray, offset: Int, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: LongArray, offset: Int, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: FloatArray, offset: Int, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun readAvailable(dst: DoubleArray, offset: Int, length: Int): Int {\n        return (this as Buffer).readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun peekTo(buffer: IoBuffer): Int {\n        return (this as Input).peekTo(buffer)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun readLong(): Long {\n        return (this as Buffer).readLong()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeShort(v: Short) {\n        (this as Buffer).writeShort(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeInt(v: Int) {\n        (this as Buffer).writeInt(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeFloat(v: Float) {\n        (this as Buffer).writeFloat(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeDouble(v: Double) {\n        (this as Buffer).writeDouble(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeFully(src: ByteArray, offset: Int, length: Int) {\n        (this as Buffer).writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeFully(src: ShortArray, offset: Int, length: Int) {\n        (this as Buffer).writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeFully(src: IntArray, offset: Int, length: Int) {\n        (this as Buffer).writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeFully(src: LongArray, offset: Int, length: Int) {\n        (this as Buffer).writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeFully(src: FloatArray, offset: Int, length: Int) {\n        (this as Buffer).writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeFully(src: DoubleArray, offset: Int, length: Int) {\n        (this as Buffer).writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun writeFully(src: IoBuffer, length: Int) {\n        (this as Buffer).writeFully(src, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    override fun fill(n: Long, v: Byte) {\n        (this as Buffer).fill(n, v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    final override fun writeLong(v: Long) {\n        (this as Buffer).writeLong(v)\n    }\n\n    @Deprecated(\"Use writeFully instead\", ReplaceWith(\"writeFully(src, length)\"), level = DeprecationLevel.ERROR)\n    public fun writeBuffer(src: IoBuffer, length: Int): Int {\n        (this as Buffer).writeFully(src, length)\n        return length\n    }\n\n    actual final override fun flush() {\n    }\n\n    @PublishedApi\n    internal fun readableView(): DataView {\n        val readPosition = readPosition\n        val writePosition = writePosition\n\n        return when {\n            readPosition == writePosition -> EmptyDataView\n            readPosition == 0 && writePosition == content.byteLength -> memory.view\n            else -> DataView(content, readPosition, writePosition - readPosition)\n        }\n    }\n\n    @PublishedApi\n    internal fun writableView(): DataView {\n        val writePosition = writePosition\n        val limit = limit\n\n        return when {\n            writePosition == limit -> EmptyDataView\n            writePosition == 0 && limit == content.byteLength -> memory.view\n            else -> DataView(content, writePosition, limit - writePosition)\n        }\n    }\n\n    /**\n     * Apply [block] function on a [DataView] of readable bytes.\n     * The [block] function should return number of consumed bytes.\n     * @return number of bytes consumed\n     */\n    @ExperimentalIoApi\n    public inline fun readDirect(block: (DataView) -> Int): Int {\n        val view = readableView()\n        val rc = block(view)\n        check(rc >= 0) { \"The returned value from block function shouldn't be negative: $rc\" }\n        discard(rc)\n        return rc\n    }\n\n    /**\n     * Apply [block] function on a [DataView] of the free space.\n     * The [block] function should return number of written bytes.\n     * @return number of bytes written\n     */\n    @ExperimentalIoApi\n    public inline fun writeDirect(block: (DataView) -> Int): Int {\n        val view = writableView()\n        val rc = block(view)\n        check(rc >= 0) { \"The returned value from block function shouldn't be negative: $rc\" }\n        check(rc <= writeRemaining) { \"The returned value from block function is too big: $rc > $writeRemaining\" }\n        commitWritten(rc)\n        return rc\n    }\n\n    public actual fun release(pool: ObjectPool<IoBuffer>) {\n        releaseImpl(pool)\n    }\n\n    actual override fun close() {\n        throw UnsupportedOperationException(\"close for buffer view is not supported\")\n    }\n\n    override fun toString(): String =\n        \"Buffer[readable = $readRemaining, writable = $writeRemaining, startGap = $startGap, endGap = $endGap]\"\n\n    public actual companion object {\n        /**\n         * Number of bytes usually reserved in the end of chunk\n         * when several instances of [IoBuffer] are connected into a chain (usually inside of [ByteReadPacket]\n         * or [BytePacketBuilder])\n         */\n        @DangerousInternalIoApi\n        public actual val ReservedSize: Int\n            get() = Buffer.ReservedSize\n\n        private val EmptyBuffer = ArrayBuffer(0)\n        private val EmptyDataView = DataView(EmptyBuffer)\n\n        public actual val Empty: IoBuffer = IoBuffer(Memory.Empty, null, EmptyBufferPoolImpl)\n\n        /**\n         * The default buffer pool\n         */\n        public actual val Pool: ObjectPool<IoBuffer> = object : DefaultPool<IoBuffer>(BUFFER_VIEW_POOL_SIZE) {\n            override fun produceInstance(): IoBuffer {\n                return IoBuffer(DefaultAllocator.alloc(DEFAULT_BUFFER_SIZE), null, this)\n            }\n\n            override fun clearInstance(instance: IoBuffer): IoBuffer {\n                return super.clearInstance(instance).apply {\n                    unpark()\n                    reset()\n                }\n            }\n\n            override fun validateInstance(instance: IoBuffer) {\n                super.validateInstance(instance)\n\n                require(instance.referenceCount == 0) {\n                    \"unable to recycle buffer: buffer view is in use (refCount = ${instance.referenceCount})\"\n                }\n                require(instance.origin == null) {\n                    \"Unable to recycle buffer view: view copy shouldn't be recycled\"\n                }\n            }\n\n            override fun disposeInstance(instance: IoBuffer) {\n                DefaultAllocator.free(instance.memory)\n                instance.unlink()\n            }\n        }\n\n        public actual val NoPool: ObjectPool<IoBuffer> = object : NoPoolImpl<IoBuffer>() {\n            override fun borrow(): IoBuffer {\n                return IoBuffer(DefaultAllocator.alloc(DEFAULT_BUFFER_SIZE), null, this)\n            }\n\n            override fun recycle(instance: IoBuffer) {\n                DefaultAllocator.free(instance.memory)\n            }\n        }\n\n        public actual val EmptyPool: ObjectPool<IoBuffer> = EmptyBufferPoolImpl\n    }\n}\n\npublic fun Buffer.readFully(dst: ArrayBuffer, offset: Int = 0, length: Int = dst.byteLength - offset) {\n    read { memory, start, endExclusive ->\n        if (endExclusive - start < length) {\n            throw EOFException(\"Not enough bytes available to read $length bytes\")\n        }\n\n        memory.copyTo(dst, start, length, offset)\n        length\n    }\n}\n\npublic fun Buffer.readFully(dst: ArrayBufferView, offset: Int = 0, length: Int = dst.byteLength - offset) {\n    read { memory, start, endExclusive ->\n        if (endExclusive - start < length) {\n            throw EOFException(\"Not enough bytes available to read $length bytes\")\n        }\n\n        memory.copyTo(dst, start, length, offset)\n        length\n    }\n}\n\npublic fun Buffer.readAvailable(dst: ArrayBuffer, offset: Int = 0, length: Int = dst.byteLength - offset): Int {\n    if (!canRead()) return -1\n    val readSize = minOf(length, readRemaining)\n    readFully(dst, offset, readSize)\n    return readSize\n}\n\npublic fun Buffer.readAvailable(dst: ArrayBufferView, offset: Int = 0, length: Int = dst.byteLength - offset): Int {\n    if (!canRead()) return -1\n    val readSize = minOf(length, readRemaining)\n    readFully(dst, offset, readSize)\n    return readSize\n}\n\npublic fun Buffer.writeFully(src: ArrayBuffer, offset: Int = 0, length: Int = src.byteLength) {\n    write { memory, start, endExclusive ->\n        if (endExclusive - start < length) {\n            throw InsufficientSpaceException(\"Not enough free space to write $length bytes\")\n        }\n\n        src.copyTo(memory, offset, length, start)\n        length\n    }\n}\n\npublic fun Buffer.writeFully(src: ArrayBufferView, offset: Int = 0, length: Int = src.byteLength - offset) {\n    write { memory, dstOffset, endExclusive ->\n        if (endExclusive - dstOffset < length) {\n            throw InsufficientSpaceException(\"Not enough free space to write $length bytes\")\n        }\n\n        src.copyTo(memory, offset, length, dstOffset)\n        length\n    }\n}\n\npublic inline fun Buffer.writeDirect(block: (DataView) -> Int): Int {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    return write { memory, start, endExclusive ->\n        block(memory.slice(start, endExclusive - start).view)\n    }\n}\n\npublic inline fun Buffer.readDirect(block: (DataView) -> Int): Int {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    return read { memory, start, endExclusive ->\n        block(memory.slice(start, endExclusive - start).view)\n    }\n}\n\npublic inline fun Buffer.writeDirectInt8Array(block: (Int8Array) -> Int): Int {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    return write { memory, start, endExclusive ->\n        block(Int8Array(memory.view.buffer, memory.view.byteOffset + start, endExclusive - start))\n    }\n}\n\npublic inline fun Buffer.readDirectInt8Array(block: (Int8Array) -> Int): Int {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    return read { memory, start, endExclusive ->\n        block(Int8Array(memory.view.buffer, memory.view.byteOffset + start, endExclusive - start))\n    }\n}\n","// ktlint-disable filename\npackage io.ktor.utils.io.core\n\nimport org.khronos.webgl.*\n\npublic actual enum class ByteOrder {\n    BIG_ENDIAN, LITTLE_ENDIAN;\n\n    public actual companion object {\n        private val native: ByteOrder\n\n        init {\n            val buffer = ArrayBuffer(4)\n            val arr = Int32Array(buffer)\n            val view = DataView(buffer)\n\n            arr[0] = 0x11223344\n\n            native = if (view.getInt32(0, true) == 0x11223344) LITTLE_ENDIAN else BIG_ENDIAN\n        }\n\n        public actual fun nativeOrder(): ByteOrder = native\n    }\n}\n","@file:Suppress(\"FunctionName\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\nimport io.ktor.utils.io.pool.*\nimport org.khronos.webgl.*\n\npublic actual fun ByteReadPacket(\n    array: ByteArray,\n    offset: Int,\n    length: Int,\n    block: (ByteArray) -> Unit\n): ByteReadPacket {\n    val content = array.asDynamic() as Int8Array\n    val sub = when {\n        offset == 0 && length == array.size -> content.buffer\n        else -> content.buffer.slice(offset, offset + length)\n    }\n\n    val pool = object : SingleInstancePool<ChunkBuffer>() {\n        override fun produceInstance(): ChunkBuffer {\n            @Suppress(\"DEPRECATION\")\n            return IoBuffer(Memory.of(sub), null, this as ObjectPool<IoBuffer>)\n        }\n\n        override fun disposeInstance(instance: ChunkBuffer) {\n            @Suppress(\"DEPRECATION\")\n            check(instance is IoBuffer) { \"Only IoBuffer could be recycled\" }\n            block(array)\n        }\n    }\n\n    return ByteReadPacket(pool.borrow().apply { resetForRead() }, pool)\n}\n","package io.ktor.utils.io.core\n\npublic actual interface Closeable {\n    public actual fun close()\n}\n\n@PublishedApi\ninternal actual fun Throwable.addSuppressedInternal(other: Throwable) {\n}\n","@file:Suppress(\"EXTENSION_SHADOWED_BY_MEMBER\")\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\nimport org.khronos.webgl.*\n\npublic fun Input.readFully(dst: Int8Array, offset: Int = 0, length: Int = dst.length - offset) {\n    if (this is AbstractInput) {\n        return readFully(dst, offset, length)\n    }\n\n    val rc = readAvailable(dst, offset, length)\n    if (rc != length) {\n        prematureEndOfStream(length)\n    }\n}\n\npublic fun Input.readFully(dst: ArrayBuffer, offset: Int = 0, length: Int = dst.byteLength - offset) {\n    if (this is AbstractInput) {\n        return readFully(dst, offset, length)\n    }\n\n    val rc = readAvailable(dst, offset, length)\n    if (rc != length) {\n        prematureEndOfStream(length)\n    }\n}\n\npublic fun Input.readFully(dst: ArrayBufferView, byteOffset: Int = 0, byteLength: Int = dst.byteLength - byteOffset) {\n    if (this is AbstractInput) {\n        return readFully(dst, byteOffset, byteLength)\n    }\n\n    val rc = readAvailable(dst, byteOffset, byteLength)\n    if (rc != byteLength) {\n        prematureEndOfStream(byteLength)\n    }\n}\n\npublic fun Input.readAvailable(dst: Int8Array, offset: Int = 0, length: Int = dst.length - offset): Int {\n    if (this is AbstractInput) {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Suppress(\"UNCHECKED_CAST_TO_EXTERNAL_INTERFACE\")\n    return readAvailable(dst as ArrayBufferView, offset, length)\n}\n\n@Suppress(\"Duplicates\")\npublic fun Input.readAvailable(dst: ArrayBuffer, offset: Int = 0, length: Int = dst.byteLength - offset): Int {\n    if (this is AbstractInput) {\n        return readAvailable(dst, offset, length)\n    }\n\n    var bytesCopied = 0\n    takeWhile { buffer ->\n        val partSize = minOf(buffer.readRemaining, length - bytesCopied)\n        buffer.memory.copyTo(dst, buffer.readPosition, partSize, bytesCopied)\n        bytesCopied += partSize\n        bytesCopied < length\n    }\n\n    return bytesCopied\n}\n\n@Suppress(\"Duplicates\")\npublic fun Input.readAvailable(\n    dst: ArrayBufferView,\n    byteOffset: Int = 0,\n    byteLength: Int = dst.byteLength - byteOffset\n): Int {\n    if (this is AbstractInput) {\n        return readAvailable(dst, byteOffset, byteLength)\n    }\n\n    var bytesCopied = 0\n    takeWhile { buffer ->\n        val partSize = minOf(buffer.readRemaining, byteLength - bytesCopied)\n        buffer.memory.copyTo(dst, buffer.readPosition, partSize, bytesCopied)\n        bytesCopied += partSize\n        bytesCopied < byteLength\n    }\n\n    return bytesCopied\n}\n\ninternal fun AbstractInput.readFully(dst: Int8Array, offset: Int, length: Int) {\n    @Suppress(\"UNCHECKED_CAST_TO_EXTERNAL_INTERFACE\")\n    return readFully(dst as ArrayBufferView, offset, length)\n}\n\ninternal fun AbstractInput.readFully(dst: ArrayBuffer, offset: Int, length: Int) {\n    if (remaining < length) {\n        throw IllegalArgumentException(\"Not enough bytes available ($remaining) to read $length bytes\")\n    }\n\n    var copied = 0\n    takeWhile { buffer: Buffer ->\n        val rc = buffer.readAvailable(dst, offset + copied, length - copied)\n        if (rc > 0) copied += rc\n        copied < length\n    }\n}\n\ninternal fun AbstractInput.readFully(dst: ArrayBufferView, offset: Int, length: Int) {\n    require(length <= dst.byteLength) {\n        throw IndexOutOfBoundsException(\"length $length is greater than view size ${dst.byteLength}\")\n    }\n\n    return readFully(dst.buffer, dst.byteOffset + offset, length)\n}\n\ninternal fun AbstractInput.readAvailable(dst: Int8Array, offset: Int, length: Int): Int {\n    val remaining = remaining\n    if (remaining == 0L) return -1\n    val size = minOf(remaining, length.toLong()).toInt()\n    readFully(dst, offset, size)\n    return size\n}\n\ninternal fun AbstractInput.readAvailable(dst: ArrayBuffer, offset: Int, length: Int): Int {\n    val remaining = remaining\n    if (remaining == 0L) return -1\n    val size = minOf(remaining, length.toLong()).toInt()\n    readFully(dst, offset, size)\n    return size\n}\n\ninternal fun AbstractInput.readAvailable(dst: ArrayBufferView, offset: Int, length: Int): Int {\n    val remaining = remaining\n    if (remaining == 0L) return -1\n    val size = minOf(remaining, length.toLong()).toInt()\n    readFully(dst, offset, size)\n    return size\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.utils.io.concurrent\n\nimport io.ktor.utils.io.core.internal.*\nimport kotlin.properties.*\nimport kotlin.reflect.*\n\n/**\n * Allows to create mutate property with frozen value.\n * Please note that any assigned value will be frozen.\n *\n * Usage:\n * ```kotlin\n * var myCounter by shared(0)\n * ```\n */\n@Suppress(\"NOTHING_TO_INLINE\")\n@DangerousInternalIoApi\npublic actual inline fun <T> shared(value: T): ReadWriteProperty<Any, T> = object : ReadWriteProperty<Any, T> {\n    private var value: T = value\n\n    override fun getValue(thisRef: Any, property: KProperty<*>): T {\n        return this.value\n    }\n\n    override fun setValue(thisRef: Any, property: KProperty<*>, value: T) {\n        this.value = value\n    }\n}\n\n/**\n * Allow to create thread local reference without freezing.\n * Please note that reference is thread-local only in kotlin-native. Otherwise it will be simple [value] reference.\n *\n * This reference is allowed to use only from creation thread. Otherwise it will return null.\n */\n@DangerousInternalIoApi\npublic actual fun <T : Any> threadLocal(value: T): ReadOnlyProperty<Any, T?> =\n    ReadOnlyProperty<Any, T?> { thisRef, property -> value }\n","// ktlint-disable filename\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.Memory\nimport org.khronos.webgl.*\n\n/**\n * Shouldn't be implemented directly. Inherit [AbstractInput] instead.\n */\n@Suppress(\"NO_ACTUAL_CLASS_MEMBER_FOR_EXPECTED_CLASS\")\npublic actual interface Input : Closeable {\n    @Deprecated(\n        \"Not supported anymore. All operations are big endian by default. \" +\n            \"Read and readXXXLittleEndian or readXXX then X.reverseByteOrder() instead.\",\n        level = DeprecationLevel.ERROR\n    )\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual var byteOrder: ByteOrder\n        get() = ByteOrder.BIG_ENDIAN\n        set(newValue) {\n            if (newValue != ByteOrder.BIG_ENDIAN) {\n                throw IllegalArgumentException(\"Only BIG_ENDIAN is supported\")\n            }\n        }\n\n    /**\n     * It is `true` when it is known that no more bytes will be available. When it is `false` then this means that\n     * it is not known yet or there are available bytes.\n     * Please note that `false` value doesn't guarantee that there are available bytes so `readByte()` may fail.\n     */\n    public actual val endOfInput: Boolean\n\n    /**\n     * Copy at least [min] but up to [max] bytes to the specified [destination] buffer from this input\n     * skipping [offset] bytes. If there are not enough bytes available to provide [min] bytes then\n     * it fails with an exception.\n     * It is safe to specify `max > destination.writeRemaining` but\n     * `min` shouldn't be bigger than the [destination] free space.\n     * This function could trigger the underlying source reading that may lead to blocking I/O.\n     * It is safe to specify too big [offset] but only if `min = 0`, fails otherwise.\n     * This function usually copy more bytes than [min] (unless `max = min`).\n     *\n     * @param destination to write bytes\n     * @param offset to skip input\n     * @param min bytes to be copied, shouldn't be greater than the buffer free space. Could be `0`.\n     * @param max bytes to be copied even if there are more bytes buffered, could be [Int.MAX_VALUE].\n     * @return number of bytes copied to the [destination] possibly `0`\n     * @throws Throwable when not enough bytes available to provide\n     */\n    public actual fun peekTo(\n        destination: Memory,\n        destinationOffset: Long,\n        offset: Long,\n        min: Long,\n        max: Long\n    ): Long\n\n    /**\n     * Read the next upcoming byte\n     * @throws EOFException if no more bytes available.\n     */\n    public actual fun readByte(): Byte\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readShort(): Short {\n        return readShort()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readInt(): Int {\n        return readInt()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readLong(): Long {\n        return readLong()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readFloat(): Float {\n        return readFloat()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readDouble(): Double {\n        return readDouble()\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readFully(dst: ByteArray, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readFully(dst: ShortArray, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readFully(dst: IntArray, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readFully(dst: LongArray, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readFully(dst: FloatArray, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readFully(dst: DoubleArray, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"DEPRECATION\")\n    public actual fun readFully(dst: IoBuffer, length: Int) {\n        return readFully(dst, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readAvailable(dst: ByteArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readAvailable(dst: ShortArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readAvailable(dst: IntArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readAvailable(dst: LongArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readAvailable(dst: FloatArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun readAvailable(dst: DoubleArray, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\", \"DEPRECATION\")\n    public actual fun readAvailable(dst: IoBuffer, length: Int): Int {\n        return readAvailable(dst, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFully(dst: Int8Array, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFully(dst: ArrayBuffer, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readFully(dst: ArrayBufferView, offset: Int, length: Int) {\n        return readFully(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readAvailable(dst: Int8Array, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readAvailable(dst: ArrayBuffer, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public fun readAvailable(dst: ArrayBufferView, offset: Int, length: Int): Int {\n        return readAvailable(dst, offset, length)\n    }\n\n    /*\n     * Returns next byte (unsigned) or `-1` if no more bytes available\n     */\n    public actual fun tryPeek(): Int\n\n    /**\n     * Copy available bytes to the specified [buffer] but keep them available.\n     * If the underlying implementation could trigger\n     * bytes population from the underlying source and block until any bytes available\n     *\n     * Very similar to [readAvailable] but don't discard copied bytes.\n     *\n     * @return number of bytes were copied\n     */\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"DEPRECATION\", \"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun peekTo(buffer: IoBuffer): Int {\n        return peekTo(buffer)\n    }\n\n    public actual fun discard(n: Long): Long\n\n    actual override fun close()\n}\n","// ktlint-disable filename\n/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\n\ninternal actual class AbstractOutputSharedState {\n    actual var head: ChunkBuffer? = null\n\n    actual var tail: ChunkBuffer? = null\n\n    actual var tailMemory: Memory = Memory.Empty\n\n    actual var tailPosition: Int = 0\n\n    actual var tailEndExclusive: Int = 0\n\n    actual var tailInitialPosition: Int = 0\n\n    actual var chainedSize: Int = 0\n}\n","// ktlint-disable filename\n/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.internal.*\n\ninternal actual class AbstractInputSharedState actual constructor(\n    actual var head: ChunkBuffer,\n    remaining: Long\n) {\n    actual var headMemory: Memory = head.memory\n\n    actual var headPosition: Int = head.readPosition\n\n    actual var headEndExclusive: Int = head.writePosition\n\n    actual var tailRemaining: Long = remaining - (headEndExclusive - headPosition)\n}\n","// ktlint-disable filename\n/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.utils.io.core\n\ninternal actual class BufferSharedState actual constructor(actual var limit: Int) {\n    actual var readPosition: Int = 0\n\n    actual var writePosition: Int = 0\n\n    actual var startGap: Int = 0\n\n    actual var attachment: Any? = null\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport org.khronos.webgl.*\n\nprivate fun Memory.asInt8Array(): Int8Array {\n    return Int8Array(view.buffer, view.byteOffset, view.byteLength)\n}\n\ninternal actual fun Buffer.discardUntilDelimiterImpl(delimiter: Byte): Int {\n    val content = memory.asInt8Array()\n    var idx = readPosition\n    val end = writePosition\n\n    while (idx < end) {\n        if (content[idx] == delimiter) break\n        idx++\n    }\n\n    val start = readPosition\n    discardUntilIndex(idx)\n    return idx - start\n}\n\ninternal actual fun Buffer.discardUntilDelimitersImpl(delimiter1: Byte, delimiter2: Byte): Int {\n    val content = memory.asInt8Array()\n    var idx = readPosition\n    val end = writePosition\n\n    while (idx < end) {\n        val v = content[idx]\n        if (v == delimiter1 || v == delimiter2) break\n        idx++\n    }\n\n    val start = readPosition\n    discardUntilIndex(idx)\n    return idx - start\n}\n\ninternal actual fun Buffer.readUntilDelimiterImpl(\n    delimiter: Byte,\n    dst: ByteArray,\n    offset: Int,\n    length: Int\n): Int {\n    check(offset >= 0)\n    check(length >= 0)\n    check(offset + length <= dst.size)\n\n    return readUntilImpl({ it == delimiter }, dst, offset, length)\n}\n\ninternal actual fun Buffer.readUntilDelimitersImpl(\n    delimiter1: Byte,\n    delimiter2: Byte,\n    dst: ByteArray,\n    offset: Int,\n    length: Int\n): Int {\n    check(offset >= 0)\n    check(length >= 0)\n    check(offset + length <= dst.size)\n    check(delimiter1 != delimiter2)\n\n    return readUntilImpl({ it == delimiter1 || it == delimiter2 }, dst, offset, length)\n}\n\ninternal actual fun Buffer.readUntilDelimiterImpl(delimiter: Byte, dst: Output): Int {\n    return readUntilImpl({ it == delimiter }, dst)\n}\n\ninternal actual fun Buffer.readUntilDelimitersImpl(delimiter1: Byte, delimiter2: Byte, dst: Output): Int {\n    check(delimiter1 != delimiter2)\n\n    return readUntilImpl({ it == delimiter1 || it == delimiter2 }, dst)\n}\n\nprivate inline fun Buffer.readUntilImpl(\n    predicate: (Byte) -> Boolean,\n    dst: ByteArray,\n    offset: Int,\n    length: Int\n): Int {\n    val array = memory.asInt8Array()\n    val start = readPosition\n    var i = start\n    val end = i + minOf(length, readRemaining)\n\n    while (i < end) {\n        if (predicate(array[i])) break\n        i++\n    }\n\n    val copied = i - start\n    val dstArray = dst.asDynamic() as Int8Array\n    dstArray.set(array.subarray(start, end), offset)\n    discardUntilIndex(i)\n\n    return copied\n}\n\nprivate inline fun Buffer.readUntilImpl(\n    predicate: (Byte) -> Boolean,\n    dst: Output\n): Int {\n    val array = memory.asInt8Array()\n    var i = readPosition\n    var copiedTotal = 0\n\n    dst.writeWhile { chunk ->\n        chunk.writeFully(chunk, 0)\n        val start = i\n        val end = minOf(i + chunk.writeRemaining, writePosition)\n\n        while (i < end) {\n            if (predicate(array[i])) break\n            i++\n        }\n\n        val size = i - start\n\n        chunk.memory.asInt8Array().set(array.subarray(start, i), chunk.writePosition)\n        chunk.commitWritten(size)\n        copiedTotal += size\n\n        chunk.writeRemaining == 0 && i < end\n    }\n\n    discardUntilIndex(i)\n    return copiedTotal\n}\n","// ktlint-disable filename\npackage io.ktor.utils.io.core\n\n/**\n * This shouldn't be implemented directly. Inherit [AbstractOutput] instead.\n */\n@Suppress(\"NO_ACTUAL_CLASS_MEMBER_FOR_EXPECTED_CLASS\")\npublic actual interface Output : Appendable, Closeable {\n    @Deprecated(\"Write with writeXXXLittleEndian or do X.reverseByteOrder() and then writeXXX instead.\")\n    public actual var byteOrder: ByteOrder\n\n    public actual fun writeByte(v: Byte)\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeShort(v: Short) {\n        writeShort(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeInt(v: Int) {\n        writeInt(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeLong(v: Long) {\n        writeLong(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeFloat(v: Float) {\n        writeFloat(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeDouble(v: Double) {\n        writeDouble(v)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeFully(src: ByteArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeFully(src: ShortArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeFully(src: IntArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeFully(src: LongArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeFully(src: FloatArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeFully(src: DoubleArray, offset: Int, length: Int) {\n        writeFully(src, offset, length)\n    }\n\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    public actual fun writeFully(src: IoBuffer, length: Int) {\n        writeFully(src, length)\n    }\n\n    public actual fun append(csq: CharArray, start: Int, end: Int): Appendable\n\n    @Suppress(\"ACTUAL_WITHOUT_EXPECT\")\n    @Deprecated(\"Binary compatibility.\", level = DeprecationLevel.HIDDEN)\n    public actual fun fill(n: Long, v: Byte) {\n        fill(n, v)\n    }\n\n    public actual fun flush()\n\n    actual override fun close()\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.core.internal.*\n\npublic actual val PACKET_MAX_COPY_SIZE: Int = 200\ninternal const val BUFFER_VIEW_POOL_SIZE = 100\ninternal const val BUFFER_VIEW_SIZE = 4096\n\npublic actual fun BytePacketBuilder(headerSizeHint: Int): BytePacketBuilder =\n    BytePacketBuilder(headerSizeHint, ChunkBuffer.Pool)\n\npublic actual typealias EOFException = io.ktor.utils.io.errors.EOFException\n","/*\n * Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.utils.io.js\n\nimport org.khronos.webgl.*\n\ninternal external class TextDecoder(encoding: String, options: dynamic = definedExternally) {\n    val encoding: String\n\n    fun decode(): String\n    fun decode(buffer: ArrayBuffer): String\n    fun decode(buffer: ArrayBuffer, options: dynamic): String\n    fun decode(buffer: ArrayBufferView): String\n    fun decode(buffer: ArrayBufferView, options: dynamic): String\n}\n\ninternal fun TextDecoder.toKtor(): Decoder = object : Decoder {\n    override fun decode(): String = this@toKtor.decode()\n    override fun decode(buffer: ArrayBufferView): String = this@toKtor.decode(buffer)\n    override fun decode(buffer: ArrayBufferView, options: dynamic): String = this@toKtor.decode(buffer, options)\n}\n\ninternal fun textDecoderOptions(fatal: Boolean = false): Any = Any().apply {\n    with(this.asDynamic()) {\n        this.fatal = fatal\n    }\n}\n","package io.ktor.utils.io.core\n\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.internal.*\nimport org.khronos.webgl.*\nimport kotlin.require\n\n/**\n * Create an instance of [String] from the specified [bytes] range starting at [offset] and bytes [length]\n * interpreting characters in the specified [charset].\n */\n@Suppress(\"FunctionName\")\npublic actual fun String(bytes: ByteArray, offset: Int, length: Int, charset: Charset): String {\n    if (offset < 0 || length < 0 || offset + length > bytes.size) {\n        checkIndices(offset, length, bytes)\n    }\n\n    @Suppress(\"UnsafeCastFromDynamic\")\n    val i8: Int8Array = bytes.asDynamic() // we know that K/JS generates Int8Array for ByteBuffer\n    val bufferOffset = i8.byteOffset + offset\n    val buffer = i8.buffer.slice(bufferOffset, bufferOffset + length)\n\n    @Suppress(\"DEPRECATION\")\n    val view = IoBuffer(Memory.of(buffer), null, IoBuffer.NoPool)\n    view.resetForRead()\n    val packet = ByteReadPacket(view, ChunkBuffer.NoPoolManuallyManaged)\n\n    return charset.newDecoder().decode(packet, Int.MAX_VALUE)\n}\n\npublic fun checkIndices(offset: Int, length: Int, bytes: ByteArray): Nothing {\n    require(offset >= 0) { throw IndexOutOfBoundsException(\"offset ($offset) shouldn't be negative\") }\n    require(length >= 0) { throw IndexOutOfBoundsException(\"length ($length) shouldn't be negative\") }\n    require(offset + length <= bytes.size) {\n        throw IndexOutOfBoundsException(\"offset ($offset) + length ($length) > bytes.size (${bytes.size})\")\n    }\n\n    throw IndexOutOfBoundsException()\n}\n\ninternal actual fun String.getCharsInternal(dst: CharArray, dstOffset: Int) {\n    val length = length\n    require(dstOffset + length <= dst.size)\n\n    var dstIndex = dstOffset\n    for (srcIndex in 0 until length) {\n        dst[dstIndex++] = this[srcIndex]\n    }\n}\n","package io.ktor.utils.io.errors\n\npublic actual open class IOException actual constructor(message: String, cause: Throwable?) :\n    Exception(message, cause) {\n    public actual constructor(message: String) : this(message, null)\n}\n\npublic actual open class EOFException actual constructor(message: String) : IOException(message)\n","/*\n * Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.utils.io.js\n\nimport io.ktor.utils.io.core.*\nimport org.khronos.webgl.*\n\nprivate val ENCODING_ALIASES = setOf(\n    \"ansi_x3.4-1968\",\n    \"ascii\",\n    \"cp1252\",\n    \"cp819\",\n    \"csisolatin1\",\n    \"ibm819\",\n    \"iso-8859-1\",\n    \"iso-ir-100\",\n    \"iso8859-1\",\n    \"iso88591\",\n    \"iso_8859-1\",\n    \"iso_8859-1:1987\",\n    \"l1\",\n    \"latin1\",\n    \"us-ascii\",\n    \"windows-1252\",\n    \"x-cp1252\"\n)\n\nprivate val REPLACEMENT = byteArrayOf(0xEF.toByte(), 0xBF.toByte(), 0xBD.toByte())\n\n/**\n * Windows-1252 decoder.\n *\n * According to https://encoding.spec.whatwg.org/, ISO-8859-1 should be treated as windows-1252 for http.\n */\ninternal class TextDecoderFallback(\n    encoding: String,\n    val fatal: Boolean\n) : Decoder {\n\n    init {\n        val requestedEncoding = encoding.trim().toLowerCase()\n        check(ENCODING_ALIASES.contains(requestedEncoding)) { \"$encoding is not supported.\" }\n    }\n\n    override fun decode(): String = \"\"\n\n    override fun decode(buffer: ArrayBufferView): String = buildPacket {\n        val bytes = buffer as Int8Array\n        for (index in 0 until bytes.length) {\n            val byte = bytes[index]\n            val point: Int = byte.toCodePoint()\n\n            if (point < 0) {\n                check(!fatal) { \"Invalid character: $point\" }\n                writeFully(REPLACEMENT)\n                continue\n            }\n\n            if (point > 0xFF) {\n                writeByte((point shr 8).toByte())\n            }\n\n            writeByte((point and 0xFF).toByte())\n        }\n    }.readBytes().decodeToString()\n\n    override fun decode(buffer: ArrayBufferView, options: dynamic): String {\n        return decode(buffer)\n    }\n}\n\nprivate fun Byte.toCodePoint(): Int {\n    val value = toInt() and 0xFF\n    if (value.isASCII()) {\n        return value\n    }\n\n    return WIN1252_TABLE[value - 0x80]\n}\n\nprivate fun Int.isASCII(): Boolean = this in 0..0x7F\n","/*\n * Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.utils.io.js\n\nimport org.khronos.webgl.*\n\ninternal fun Decoder(encoding: String, fatal: Boolean = true): Decoder = try {\n    TextDecoder(encoding, textDecoderOptions(fatal)).toKtor()\n} catch (cause: Throwable) {\n    TextDecoderFallback(encoding, fatal)\n}\n\ninternal interface Decoder {\n    fun decode(): String\n    fun decode(buffer: ArrayBufferView): String\n    fun decode(buffer: ArrayBufferView, options: dynamic): String\n}\n\ninternal inline fun Decoder.decodeStream(buffer: ArrayBufferView, stream: Boolean): String {\n    decodeWrap {\n        return decode(buffer, decodeOptions(stream))\n    }\n}\n\ninternal fun decodeOptions(stream: Boolean): dynamic = Any().apply {\n    with(this.asDynamic()) {\n        this.stream = stream\n    }\n}\n","@file:Suppress(\"NOTHING_TO_INLINE\")\n\npackage io.ktor.utils.io.bits\n\n/**\n * Read short signed 16bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.loadShortAt(offset: Int): Short\n\n/**\n * Read short signed 16bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.loadShortAt(offset: Long): Short\n\n/**\n * Write short signed 16bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.storeShortAt(offset: Int, value: Short)\n\n/**\n * Write short signed 16bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.storeShortAt(offset: Long, value: Short)\n\n/**\n * Read short unsigned 16bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.loadUShortAt(offset: Int): UShort = loadShortAt(offset).toUShort()\n\n/**\n * Read short unsigned 16bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.loadUShortAt(offset: Long): UShort = loadShortAt(offset).toUShort()\n\n/**\n * Write short unsigned 16bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.storeUShortAt(offset: Int, value: UShort): Unit = storeShortAt(offset, value.toShort())\n\n/**\n * Write short unsigned 16bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.storeUShortAt(offset: Long, value: UShort): Unit = storeShortAt(offset, value.toShort())\n\n/**\n * Read regular signed 32bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.loadIntAt(offset: Int): Int\n\n/**\n * Read regular signed 32bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.loadIntAt(offset: Long): Int\n\n/**\n * Write regular signed 32bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.storeIntAt(offset: Int, value: Int)\n\n/**\n * Write regular signed 32bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.storeIntAt(offset: Long, value: Int)\n\n/**\n * Read regular unsigned 32bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.loadUIntAt(offset: Int): UInt = loadIntAt(offset).toUInt()\n\n/**\n * Read regular unsigned 32bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.loadUIntAt(offset: Long): UInt = loadIntAt(offset).toUInt()\n\n/**\n * Write regular unsigned 32bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.storeUIntAt(offset: Int, value: UInt): Unit = storeIntAt(offset, value.toInt())\n\n/**\n * Write regular unsigned 32bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.storeUIntAt(offset: Long, value: UInt): Unit = storeIntAt(offset, value.toInt())\n\n/**\n * Read short signed 64bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.loadLongAt(offset: Int): Long\n\n/**\n * Read short signed 64bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.loadLongAt(offset: Long): Long\n\n/**\n * Write short signed 64bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.storeLongAt(offset: Int, value: Long)\n\n/**\n * write short signed 64bit integer in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.storeLongAt(offset: Long, value: Long)\n\n/**\n * Read short signed 64bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.loadULongAt(offset: Int): ULong = loadLongAt(offset).toULong()\n\n/**\n * Read short signed 64bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.loadULongAt(offset: Long): ULong = loadLongAt(offset).toULong()\n\n/**\n * Write short signed 64bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.storeULongAt(offset: Int, value: ULong): Unit = storeLongAt(offset, value.toLong())\n\n/**\n * Write short signed 64bit integer in the network byte order (Big Endian)\n */\npublic inline fun Memory.storeULongAt(offset: Long, value: ULong): Unit = storeLongAt(offset, value.toLong())\n\n/**\n * Read short signed 32bit floating point number in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.loadFloatAt(offset: Int): Float\n\n/**\n * Read short signed 32bit floating point number in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.loadFloatAt(offset: Long): Float\n\n/**\n * Write short signed 32bit floating point number in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.storeFloatAt(offset: Int, value: Float)\n\n/**\n * Write short signed 32bit floating point number in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.storeFloatAt(offset: Long, value: Float)\n\n/**\n * Read short signed 64bit floating point number in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.loadDoubleAt(offset: Int): Double\n\n/**\n * Read short signed 64bit floating point number in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.loadDoubleAt(offset: Long): Double\n\n/**\n * Write short signed 64bit floating point number in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.storeDoubleAt(offset: Int, value: Double)\n\n/**\n * Write short signed 64bit floating point number in the network byte order (Big Endian)\n */\npublic expect inline fun Memory.storeDoubleAt(offset: Long, value: Double)\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util\n\nimport io.ktor.utils.io.*\nimport io.ktor.utils.io.bits.*\nimport io.ktor.utils.io.core.*\nimport kotlinx.coroutines.*\n\nprivate const val CHUNK_BUFFER_SIZE = 4096L\n\n/**\n * Split source [ByteReadChannel] into 2 new one.\n * Cancel of one channel in split(input or both outputs) cancels other channels.\n */\npublic fun ByteReadChannel.split(coroutineScope: CoroutineScope): Pair<ByteReadChannel, ByteReadChannel> {\n    val first = ByteChannel(autoFlush = true)\n    val second = ByteChannel(autoFlush = true)\n\n    coroutineScope.launch {\n        try {\n            while (!isClosedForRead) {\n                this@split.readRemaining(CHUNK_BUFFER_SIZE).use { chunk ->\n                    listOf(\n                        async { first.writePacket(chunk.copy()) },\n                        async { second.writePacket(chunk.copy()) }\n                    ).awaitAll()\n                }\n            }\n\n            if (this is ByteChannel) {\n                closedCause?.let { throw it }\n            }\n        } catch (cause: Throwable) {\n            this@split.cancel(cause)\n            first.cancel(cause)\n            second.cancel(cause)\n        } finally {\n            first.close()\n            second.close()\n        }\n    }.invokeOnCompletion {\n        it ?: return@invokeOnCompletion\n        first.cancel(it)\n        second.cancel(it)\n    }\n\n    return first to second\n}\n\n/**\n * Copy source channel to both output channels chunk by chunk.\n */\n@InternalAPI\npublic fun ByteReadChannel.copyToBoth(first: ByteWriteChannel, second: ByteWriteChannel) {\n    GlobalScope.launch(Dispatchers.Unconfined) {\n        try {\n            while (!isClosedForRead && (!first.isClosedForWrite || !second.isClosedForWrite)) {\n                readRemaining(CHUNK_BUFFER_SIZE).use {\n                    try {\n                        first.writePacket(it.copy())\n                        second.writePacket(it.copy())\n                    } catch (cause: Throwable) {\n                        this@copyToBoth.cancel(cause)\n                        first.close(cause)\n                        second.close(cause)\n                    }\n                }\n            }\n\n            if (this is ByteChannel) {\n                closedCause?.let { throw it }\n            }\n        } catch (cause: Throwable) {\n            first.close(cause)\n            second.close(cause)\n        } finally {\n            first.close()\n            second.close()\n        }\n    }.invokeOnCompletion {\n        it ?: return@invokeOnCompletion\n        first.close(it)\n        second.close(it)\n    }\n}\n\n/**\n * Read channel to byte array.\n */\npublic suspend fun ByteReadChannel.toByteArray(): ByteArray = readRemaining().readBytes()\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util\n\n/**\n * Length of this [LongRange]\n */\n@Deprecated(\"Not supported anymore.\", level = DeprecationLevel.ERROR)\npublic val LongRange.length: Long\n    get() = (endInclusive - start + 1).coerceAtLeast(0L)\n\n/**\n * Returns `true` if [other] range is fully contained inside [this] range\n */\n@InternalAPI\npublic operator fun LongRange.contains(other: LongRange): Boolean =\n    other.start >= start && other.endInclusive <= endInclusive\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util\n\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\n\n/**\n * Print [Job] children tree.\n */\n@InternalAPI\npublic fun Job.printDebugTree(offset: Int = 0) {\n    println(\" \".repeat(offset) + this)\n\n    children.forEach {\n        it.printDebugTree(offset + 2)\n    }\n\n    if (offset == 0) println()\n}\n\n@InternalAPI\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal expect inline fun <R, A> (suspend R.(A) -> Unit).startCoroutineUninterceptedOrReturn3(\n    receiver: R,\n    arg: A,\n    continuation: Continuation<Unit>\n): Any?\n\n/**\n * Supervisor with empty coroutine exception handler ignoring all exceptions.\n */\n@InternalAPI\npublic fun SilentSupervisor(parent: Job? = null): CoroutineContext =\n    SupervisorJob(parent) + CoroutineExceptionHandler { _, _ -> }\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util\n\n/**\n * Specifies a key for an attribute in [Attributes]\n * @param T is type of the value stored in the attribute\n * @param name is a name of the attribute for diagnostic purposes\n */\npublic class AttributeKey<T>(public val name: String) {\n    override fun toString(): String = if (name.isEmpty()) super.toString() else \"AttributeKey: $name\"\n}\n\n/**\n * Create attributes instance suitable for the particular platform\n */\npublic expect fun Attributes(concurrent: Boolean = false): Attributes\n\n/**\n * Map of attributes accessible by [AttributeKey] in a typed manner\n */\npublic interface Attributes {\n    /**\n     * Gets a value of the attribute for the specified [key], or throws an exception if an attribute doesn't exist\n     */\n    public operator fun <T : Any> get(key: AttributeKey<T>): T =\n        getOrNull(key) ?: throw IllegalStateException(\"No instance for key $key\")\n\n    /**\n     * Gets a value of the attribute for the specified [key], or return `null` if an attribute doesn't exist\n     */\n    public fun <T : Any> getOrNull(key: AttributeKey<T>): T?\n\n    /**\n     * Checks if an attribute with the specified [key] exists\n     */\n    public operator fun contains(key: AttributeKey<*>): Boolean\n\n    /**\n     * Creates or changes an attribute with the specified [key] using [value]\n     */\n    public fun <T : Any> put(key: AttributeKey<T>, value: T)\n\n    /**\n     * Removes an attribute with the specified [key]\n     */\n    public fun <T : Any> remove(key: AttributeKey<T>)\n\n    /**\n     * Removes an attribute with the specified [key] and returns its current value, throws an exception if an attribute doesn't exist\n     */\n    public fun <T : Any> take(key: AttributeKey<T>): T = get(key).also { remove(key) }\n\n    /**\n     * Removes an attribute with the specified [key] and returns its current value, returns `null` if an attribute doesn't exist\n     */\n    public fun <T : Any> takeOrNull(key: AttributeKey<T>): T? = getOrNull(key).also { remove(key) }\n\n    /**\n     * Gets a value of the attribute for the specified [key], or calls supplied [block] to compute its value\n     */\n    public fun <T : Any> computeIfAbsent(key: AttributeKey<T>, block: () -> T): T\n\n    /**\n     * Returns [List] of all [AttributeKey] instances in this map\n     */\n    public val allKeys: List<AttributeKey<*>>\n}\n\n/**\n * Adds all attributes from another collection, replacing original values if any.\n */\npublic fun Attributes.putAll(other: Attributes) {\n    other.allKeys.forEach {\n        @Suppress(\"UNCHECKED_CAST\")\n        put(it as AttributeKey<Any>, other[it])\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util\n\n/**\n * A map with case insensitive [String] keys\n */\n@InternalAPI\npublic class CaseInsensitiveMap<Value> : MutableMap<String, Value> {\n    private val delegate = mutableMapOf<CaseInsensitiveString, Value>()\n\n    override val size: Int get() = delegate.size\n\n    override fun containsKey(key: String): Boolean = delegate.containsKey(CaseInsensitiveString(key))\n\n    override fun containsValue(value: Value): Boolean = delegate.containsValue(value)\n\n    override fun get(key: String): Value? = delegate[key.caseInsensitive()]\n\n    override fun isEmpty(): Boolean = delegate.isEmpty()\n\n    override fun clear() {\n        delegate.clear()\n    }\n\n    override fun put(key: String, value: Value): Value? = delegate.put(key.caseInsensitive(), value)\n\n    override fun putAll(from: Map<out String, Value>) {\n        from.forEach { (key, value) -> put(key, value) }\n    }\n\n    override fun remove(key: String): Value? = delegate.remove(key.caseInsensitive())\n\n    override val keys: MutableSet<String>\n        get() = DelegatingMutableSet(\n            delegate.keys,\n            { content },\n            { caseInsensitive() }\n        )\n\n    override val entries: MutableSet<MutableMap.MutableEntry<String, Value>>\n        get() = DelegatingMutableSet(\n            delegate.entries,\n            { Entry(key.content, value) },\n            { Entry(key.caseInsensitive(), value) }\n        )\n\n    override val values: MutableCollection<Value> get() = delegate.values\n\n    override fun equals(other: Any?): Boolean {\n        if (other == null || other !is CaseInsensitiveMap<*>) return false\n        return other.delegate == delegate\n    }\n\n    override fun hashCode(): Int = delegate.hashCode()\n}\n\nprivate class Entry<Key, Value>(\n    override val key: Key,\n    override var value: Value\n) : MutableMap.MutableEntry<Key, Value> {\n\n    override fun setValue(newValue: Value): Value {\n        value = newValue\n        return value\n    }\n\n    override fun hashCode(): Int = 17 * 31 + key!!.hashCode() + value!!.hashCode()\n\n    override fun equals(other: Any?): Boolean {\n        if (other == null || other !is Map.Entry<*, *>) return false\n        return other.key == key && other.value == value\n    }\n\n    override fun toString(): String = \"$key=$value\"\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\npackage io.ktor.util\n\n@InternalAPI\npublic class CaseInsensitiveSet() : MutableSet<String> {\n    private val backingMap = CaseInsensitiveMap<Boolean>()\n\n    public constructor(initial: Iterable<String>) : this() {\n        addAll(initial)\n    }\n\n    override fun add(element: String): Boolean {\n        if (element in backingMap) {\n            return false\n        }\n        backingMap[element] = true\n        return true\n    }\n\n    override val size: Int\n        get() = backingMap.size\n\n    override fun remove(element: String): Boolean {\n        return backingMap.remove(element) == true\n    }\n\n    override fun addAll(elements: Collection<String>): Boolean {\n        var added = false\n        for (element in elements) {\n            if (add(element)) {\n                added = true\n            }\n        }\n        return added\n    }\n\n    override fun clear() {\n        backingMap.clear()\n    }\n\n    override fun removeAll(elements: Collection<String>): Boolean {\n        return backingMap.keys.removeAll(elements)\n    }\n\n    override fun retainAll(elements: Collection<String>): Boolean {\n        return backingMap.keys.retainAll(elements)\n    }\n\n    override fun contains(element: String): Boolean {\n        return backingMap.contains(element)\n    }\n\n    override fun containsAll(elements: Collection<String>): Boolean {\n        return backingMap.keys.containsAll(elements)\n    }\n\n    override fun isEmpty(): Boolean {\n        return backingMap.isEmpty()\n    }\n\n    override fun iterator(): MutableIterator<String> = backingMap.keys.iterator()\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util\n\n/**\n * Check if [Char] is in lower case\n */\n@InternalAPI\npublic fun Char.isLowerCase(): Boolean = toLowerCase() == this\n\n/**\n * Convert [String] to [CharArray]\n */\n@InternalAPI\npublic fun String.toCharArray(): CharArray = CharArray(length) { get(it) }\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util\n\ninternal open class DelegatingMutableSet<From, To>(\n    private val delegate: MutableSet<From>,\n    private val convertTo: From.() -> To,\n    private val convert: To.() -> From\n) : MutableSet<To> {\n\n    public open fun Collection<To>.convert(): Collection<From> = map { it.convert() }\n    public open fun Collection<From>.convertTo(): Collection<To> = map { it.convertTo() }\n\n    override val size: Int = delegate.size\n\n    override fun add(element: To): Boolean = delegate.add(element.convert())\n\n    override fun addAll(elements: Collection<To>): Boolean = delegate.addAll(elements.convert())\n\n    override fun clear() {\n        delegate.clear()\n    }\n\n    override fun remove(element: To): Boolean = delegate.remove(element.convert())\n\n    override fun removeAll(elements: Collection<To>): Boolean = delegate.removeAll(elements.convert())\n\n    override fun retainAll(elements: Collection<To>): Boolean = delegate.retainAll(elements.convert())\n\n    override fun contains(element: To): Boolean = delegate.contains(element.convert())\n\n    override fun containsAll(elements: Collection<To>): Boolean = delegate.containsAll(elements.convert())\n\n    override fun isEmpty(): Boolean = delegate.isEmpty()\n\n    override fun iterator(): MutableIterator<To> = object : MutableIterator<To> {\n        val delegateIterator = delegate.iterator()\n\n        override fun hasNext(): Boolean = delegateIterator.hasNext()\n\n        override fun next(): To = delegateIterator.next().convertTo()\n\n        override fun remove() = delegateIterator.remove()\n    }\n\n    override fun hashCode(): Int = delegate.hashCode()\n\n    override fun equals(other: Any?): Boolean {\n        if (other == null || other !is Set<*>) return false\n\n        val elements = delegate.convertTo()\n        return other.containsAll(elements) && elements.containsAll(other)\n    }\n\n    override fun toString(): String = delegate.convertTo().toString()\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util\n\n/**\n * API marked with this annotation is internal, and it is not intended to be used outside Ktor.\n * It could be modified or removed without any notice. Using it outside Ktor could cause undefined behaviour and/or\n * any unexpected effects.\n */\n@Suppress(\"DEPRECATION\")\n@RequiresOptIn(\n    level = RequiresOptIn.Level.ERROR,\n    message = \"This API is internal in Ktor and should not be used. It could be removed or changed without notice.\"\n)\n@Experimental(level = Experimental.Level.ERROR)\n@Target(\n    AnnotationTarget.CLASS,\n    AnnotationTarget.TYPEALIAS,\n    AnnotationTarget.FUNCTION,\n    AnnotationTarget.PROPERTY,\n    AnnotationTarget.FIELD,\n    AnnotationTarget.CONSTRUCTOR,\n    AnnotationTarget.PROPERTY_SETTER\n)\npublic annotation class InternalAPI\n\n/**\n * API marked with this annotation is experimental and is not guaranteed to be stable.\n */\n@Suppress(\"DEPRECATION\")\n@RequiresOptIn(\n    level = RequiresOptIn.Level.WARNING,\n    message = \"This API is experimental. \" +\n        \"It could be removed or changed in future releases, or its behaviour may be different.\"\n)\n@Experimental(level = Experimental.Level.WARNING)\n@Target(\n    AnnotationTarget.CLASS,\n    AnnotationTarget.TYPEALIAS,\n    AnnotationTarget.FUNCTION,\n    AnnotationTarget.PROPERTY,\n    AnnotationTarget.FIELD,\n    AnnotationTarget.CONSTRUCTOR\n)\n@Deprecated(\n    \"This annotation is no longer used and there is no need to opt-in into it.\"\n)\npublic annotation class KtorExperimentalAPI\n\n/**\n * API marked with this annotation is intended to become public in the future [version].\n * Usually it means that the API can't be public at the moment of development due to\n * compatibility guarantees restrictions.\n *\n * Marking a public declaration with this annotation makes no sense\n * except for the case when it is also marked with [InternalAPI].\n *\n * Please note that the specified [version] and the fact of making something a candidate is not a guarantee,\n * so the target version could be changed without any notice or even the promotion could be cancelled at all.\n *\n * @property version in which the API is planned to be promoted\n */\n@InternalAPI\n@Retention(AnnotationRetention.SOURCE)\n@Target(\n    AnnotationTarget.CLASS,\n    AnnotationTarget.ANNOTATION_CLASS,\n    AnnotationTarget.CONSTRUCTOR,\n    AnnotationTarget.FUNCTION,\n    AnnotationTarget.PROPERTY,\n    AnnotationTarget.PROPERTY_SETTER,\n    AnnotationTarget.TYPEALIAS\n)\npublic annotation class PublicAPICandidate(val version: String)\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util\n\n/**\n * Read [Short] in network order(BE) with specified [offset] from [ByteArray].\n */\n@InternalAPI\npublic fun ByteArray.readShort(offset: Int): Short {\n    val result = ((this[offset].toInt() and 0xFF) shl 8) or (this[offset + 1].toInt() and 0xFF)\n    return result.toShort()\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\n@file:kotlin.jvm.JvmMultifileClass\n@file:kotlin.jvm.JvmName(\"CryptoKt\")\n\npackage io.ktor.util\n\nimport io.ktor.utils.io.charsets.*\nimport io.ktor.utils.io.core.*\nimport kotlin.native.concurrent.*\n\n@SharedImmutable\nprivate val digits = \"0123456789abcdef\".toCharArray()\n\n/**\n * Encode [bytes] as a HEX string with no spaces, newlines and `0x` prefixes.\n */\npublic fun hex(bytes: ByteArray): String {\n    val result = CharArray(bytes.size * 2)\n    var resultIndex = 0\n    val digits = digits\n\n    for (index in 0 until bytes.size) {\n        val b = bytes[index].toInt() and 0xff\n        result[resultIndex++] = digits[b shr 4]\n        result[resultIndex++] = digits[b and 0x0f]\n    }\n\n    return result.concatToString()\n}\n\n/**\n * Decode bytes from HEX string. It should be no spaces and `0x` prefixes.\n */\npublic fun hex(s: String): ByteArray {\n    val result = ByteArray(s.length / 2)\n    for (idx in 0 until result.size) {\n        val srcIdx = idx * 2\n        val high = s[srcIdx].toString().toInt(16) shl 4\n        val low = s[srcIdx + 1].toString().toInt(16)\n        result[idx] = (high or low).toByte()\n    }\n\n    return result\n}\n\n/**\n * Generates a nonce string. Could block if the system's entropy source is empty\n */\n@InternalAPI\npublic expect fun generateNonce(): String\n\n/**\n * Generates a nonce bytes of [size]. Could block if the system's entropy source is empty\n */\n@InternalAPI\npublic fun generateNonce(size: Int): ByteArray = buildPacket {\n    while (this.size < size) {\n        writeText(generateNonce())\n    }\n}.readBytes(size)\n\n/**\n * Compute SHA-1 hash for the specified [bytes]\n */\npublic expect fun sha1(bytes: ByteArray): ByteArray\n\n/**\n * Create [Digest] from specified hash [name].\n */\n@Suppress(\"FunctionName\")\n@InternalAPI\npublic expect fun Digest(name: String): Digest\n\n/**\n * Stateful digest class specified to calculate digest.\n */\n@InternalAPI\npublic interface Digest {\n    /**\n     * Add [bytes] to digest value.\n     */\n    public operator fun plusAssign(bytes: ByteArray)\n\n    /**\n     * Reset [Digest] state.\n     */\n    public fun reset()\n\n    /**\n     * Calculate digest bytes.\n     */\n    public suspend fun build(): ByteArray\n}\n\n/**\n * Calculate digest from current state and specified [bytes].\n */\n@InternalAPI\npublic suspend fun Digest.build(bytes: ByteArray): ByteArray {\n    this += bytes\n    return build()\n}\n\n/**\n * Calculate digest from current state and specified [string].\n */\n@InternalAPI\npublic suspend fun Digest.build(string: String, charset: Charset = Charsets.UTF_8): ByteArray {\n    this += string.toByteArray(charset)\n    return build()\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util\n\nimport io.ktor.utils.io.*\nimport kotlinx.coroutines.*\n\n/**\n * Empty [Encoder] that doesn't do any changes.\n */\npublic object Identity : Encoder {\n    override fun CoroutineScope.encode(source: ByteReadChannel): ByteReadChannel = source\n\n    override fun CoroutineScope.decode(source: ByteReadChannel): ByteReadChannel = source\n}\n\n/**\n * Content encoder.\n */\npublic interface Encoder {\n    /**\n     * Launch coroutine to encode [source] bytes.\n     */\n    public fun CoroutineScope.encode(source: ByteReadChannel): ByteReadChannel\n\n    /**\n     * Launch coroutine to decode [source] bytes.\n     */\n    public fun CoroutineScope.decode(source: ByteReadChannel): ByteReadChannel\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\n@file:Suppress(\"KDocMissingDocumentation\")\n\npackage io.ktor.util\n\n@InternalAPI\npublic expect class Lock() {\n    public fun lock()\n    public fun unlock()\n\n    public fun close()\n}\n\n@InternalAPI\npublic inline fun <R> Lock.withLock(crossinline block: () -> R): R {\n    try {\n        lock()\n        return block()\n    } finally {\n        unlock()\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util\n\n/**\n * Represents a nonce manager. Its responsibility is to produce nonce values\n * and verify nonce values from untrusted sources that they are provided by this manager.\n * This is usually required in web environment to mitigate CSRF attacks.\n * Depending on it's underlying implementation it could be stateful or stateless.\n * Note that there is usually some timeout for nonce values to reduce memory usage and to avoid replay attacks.\n * Nonce length is unspecified.\n */\npublic interface NonceManager {\n    /**\n     * Generate new nonce instance\n     */\n    public suspend fun newNonce(): String\n\n    /**\n     * Verify [nonce] value\n     * @return `true` if [nonce] is valid\n     */\n    public suspend fun verifyNonce(nonce: String): Boolean\n}\n\n/**\n * This implementation does only generate nonce values but doesn't validate them. This is recommended for testing only.\n */\npublic object GenerateOnlyNonceManager : NonceManager {\n    override suspend fun newNonce(): String {\n        return generateNonce()\n    }\n\n    override suspend fun verifyNonce(nonce: String): Boolean {\n        return true\n    }\n}\n\n/**\n * Stub implementation that always fails.\n * Will be removed so no public signatures should rely on it\n */\n@Deprecated(\"This should be removed with OAuth2StateProvider\", level = DeprecationLevel.ERROR)\n@InternalAPI\npublic object AlwaysFailNonceManager : NonceManager {\n    override suspend fun newNonce(): String {\n        throw UnsupportedOperationException(\"This manager should never be used\")\n    }\n\n    override suspend fun verifyNonce(nonce: String): Boolean {\n        throw UnsupportedOperationException(\"This manager should never be used\")\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util.collections\n\nimport io.ktor.util.*\n\n@InternalAPI\npublic open class ConcurrentCollection<E>(\n    private val delegate: MutableCollection<E>,\n    private val lock: Lock\n) : MutableCollection<E> {\n\n    override val size: Int get() = lock.withLock {\n        delegate.size\n    }\n\n    override fun contains(element: E): Boolean = lock.withLock {\n        delegate.contains(element)\n    }\n\n    override fun containsAll(elements: Collection<E>): Boolean = lock.withLock {\n        delegate.containsAll(elements)\n    }\n\n    override fun isEmpty(): Boolean = lock.withLock {\n        delegate.isEmpty()\n    }\n\n    override fun add(element: E): Boolean = lock.withLock {\n        delegate.add(element)\n    }\n\n    override fun addAll(elements: Collection<E>): Boolean = lock.withLock {\n        delegate.addAll(elements)\n    }\n\n    override fun clear(): Unit = lock.withLock {\n        delegate.clear()\n    }\n\n    override fun iterator(): MutableIterator<E> = delegate.iterator()\n\n    override fun remove(element: E): Boolean = lock.withLock {\n        delegate.remove(element)\n    }\n\n    override fun removeAll(elements: Collection<E>): Boolean = lock.withLock {\n        delegate.removeAll(elements)\n    }\n\n    override fun retainAll(elements: Collection<E>): Boolean = lock.withLock {\n        delegate.retainAll(elements)\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util\n\n/**\n * Provides data structure for associating a [String] with a [List] of Strings\n */\npublic interface StringValues {\n    public companion object {\n        /**\n         * Empty [StringValues] instance\n         */\n        public val Empty: StringValues = StringValuesImpl()\n\n        /**\n         * Builds a [StringValues] instance with the given [builder] function\n         * @param caseInsensitiveName specifies if map should have case-sensitive or case-insensitive names\n         * @param builder specifies a function to build a map\n         */\n        public inline fun build(\n            caseInsensitiveName: Boolean = false,\n            builder: StringValuesBuilder.() -> Unit\n        ): StringValues = StringValuesBuilder(caseInsensitiveName).apply(builder).build()\n    }\n\n    /**\n     * Specifies if map has case-sensitive or case-insensitive names\n     */\n    public val caseInsensitiveName: Boolean\n\n    /**\n     * Gets first value from the list of values associated with a [name], or null if the name is not present\n     */\n    public operator fun get(name: String): String? = getAll(name)?.firstOrNull()\n\n    /**\n     * Gets all values associated with the [name], or null if the name is not present\n     */\n    public fun getAll(name: String): List<String>?\n\n    /**\n     * Gets all names from the map\n     */\n    public fun names(): Set<String>\n\n    /**\n     * Gets all entries from the map\n     */\n    public fun entries(): Set<Map.Entry<String, List<String>>>\n\n    /**\n     * Checks if the given [name] exists in the map\n     */\n    public operator fun contains(name: String): Boolean = getAll(name) != null\n\n    /**\n     * Checks if the given [name] and [value] pair exists in the map\n     */\n    public fun contains(name: String, value: String): Boolean = getAll(name)?.contains(value) ?: false\n\n    /**\n     * Iterates over all entries in this map and calls [body] for each pair\n     *\n     * Can be optimized in implementations\n     */\n    public fun forEach(body: (String, List<String>) -> Unit): Unit = entries().forEach { (k, v) -> body(k, v) }\n\n    /**\n     * Checks if this map is empty\n     */\n    public fun isEmpty(): Boolean\n}\n\n@InternalAPI\n@Suppress(\"KDocMissingDocumentation\")\npublic open class StringValuesSingleImpl(\n    override val caseInsensitiveName: Boolean,\n    public val name: String,\n    public val values: List<String>\n) : StringValues {\n\n    override fun getAll(name: String): List<String>? = if (this.name.equals(name, caseInsensitiveName)) values else null\n\n    override fun entries(): Set<Map.Entry<String, List<String>>> = setOf(\n        object : Map.Entry<String, List<String>> {\n            override val key: String = name\n            override val value: List<String> = values\n            override fun toString() = \"$key=$value\"\n        }\n    )\n\n    override fun isEmpty(): Boolean = false\n\n    override fun names(): Set<String> = setOf(name)\n\n    override fun toString(): String = \"StringValues(case=${!caseInsensitiveName}) ${entries()}\"\n\n    override fun hashCode(): Int = entriesHashCode(entries(), 31 * caseInsensitiveName.hashCode())\n\n    override fun equals(other: Any?): Boolean {\n        if (this === other) return true\n        if (other !is StringValues) return false\n        if (caseInsensitiveName != other.caseInsensitiveName) return false\n        return entriesEquals(entries(), other.entries())\n    }\n\n    override fun forEach(body: (String, List<String>) -> Unit): Unit = body(name, values)\n\n    override fun get(name: String): String? =\n        if (name.equals(this.name, caseInsensitiveName)) values.firstOrNull() else null\n\n    override fun contains(name: String): Boolean = name.equals(this.name, caseInsensitiveName)\n\n    override fun contains(name: String, value: String): Boolean =\n        name.equals(this.name, caseInsensitiveName) && values.contains(value)\n}\n\n@InternalAPI\n@Suppress(\"KDocMissingDocumentation\")\npublic open class StringValuesImpl(\n    override val caseInsensitiveName: Boolean = false,\n    values: Map<String, List<String>> = emptyMap()\n) : StringValues {\n\n    protected val values: Map<String, List<String>> by lazy {\n        if (caseInsensitiveName) caseInsensitiveMap<List<String>>().apply { putAll(values) } else values.toMap()\n    }\n\n    override operator fun get(name: String): String? = listForKey(name)?.firstOrNull()\n\n    override fun getAll(name: String): List<String>? = listForKey(name)\n\n    override operator fun contains(name: String): Boolean = listForKey(name) != null\n\n    override fun contains(name: String, value: String): Boolean = listForKey(name)?.contains(value) ?: false\n\n    override fun names(): Set<String> = values.keys.unmodifiable()\n\n    override fun isEmpty(): Boolean = values.isEmpty()\n\n    override fun entries(): Set<Map.Entry<String, List<String>>> = values.entries.unmodifiable()\n\n    override fun forEach(body: (String, List<String>) -> Unit) {\n        for ((key, value) in values) body(key, value)\n    }\n\n    private fun listForKey(name: String): List<String>? = values[name]\n\n    override fun toString(): String = \"StringValues(case=${!caseInsensitiveName}) ${entries()}\"\n\n    override fun equals(other: Any?): Boolean {\n        if (this === other) return true\n        if (other !is StringValues) return false\n        if (caseInsensitiveName != other.caseInsensitiveName) return false\n        return entriesEquals(entries(), other.entries())\n    }\n\n    override fun hashCode(): Int = entriesHashCode(entries(), 31 * caseInsensitiveName.hashCode())\n}\n\n@InternalAPI\n@Suppress(\"KDocMissingDocumentation\")\npublic open class StringValuesBuilder(public val caseInsensitiveName: Boolean = false, size: Int = 8) {\n    protected val values: MutableMap<String, MutableList<String>> =\n        if (caseInsensitiveName) caseInsensitiveMap() else LinkedHashMap(size)\n\n    protected var built: Boolean = false\n\n    public fun getAll(name: String): List<String>? = values[name]\n\n    public operator fun contains(name: String): Boolean = name in values\n\n    public fun contains(name: String, value: String): Boolean = values[name]?.contains(value) ?: false\n\n    public fun names(): Set<String> = values.keys\n\n    public fun isEmpty(): Boolean = values.isEmpty()\n\n    public fun entries(): Set<Map.Entry<String, List<String>>> = values.entries.unmodifiable()\n\n    public operator fun set(name: String, value: String) {\n        validateValue(value)\n        val list = ensureListForKey(name, 1)\n        list.clear()\n        list.add(value)\n    }\n\n    public operator fun get(name: String): String? = getAll(name)?.firstOrNull()\n\n    public fun append(name: String, value: String) {\n        validateValue(value)\n        ensureListForKey(name, 1).add(value)\n    }\n\n    public fun appendAll(stringValues: StringValues) {\n        stringValues.forEach { name, values ->\n            appendAll(name, values)\n        }\n    }\n\n    public fun appendMissing(stringValues: StringValues) {\n        stringValues.forEach { name, values ->\n            appendMissing(name, values)\n        }\n    }\n\n    public fun appendAll(name: String, values: Iterable<String>) {\n        ensureListForKey(name, (values as? Collection)?.size ?: 2).let { list ->\n            values.forEach { value ->\n                validateValue(value)\n                list.add(value)\n            }\n        }\n    }\n\n    public fun appendMissing(name: String, values: Iterable<String>) {\n        val existing = this.values[name]?.toSet() ?: emptySet()\n\n        appendAll(name, values.filter { it !in existing })\n    }\n\n    public fun remove(name: String) {\n        values.remove(name)\n    }\n\n    public fun removeKeysWithNoEntries() {\n        for ((k, _) in values.filter { it.value.isEmpty() }) {\n            remove(k)\n        }\n    }\n\n    public fun remove(name: String, value: String): Boolean = values[name]?.remove(value) ?: false\n\n    public fun clear() {\n        values.clear()\n    }\n\n    public open fun build(): StringValues {\n        require(!built) { \"ValueMapBuilder can only build a single ValueMap\" }\n        built = true\n        return StringValuesImpl(caseInsensitiveName, values)\n    }\n\n    protected open fun validateName(name: String) {\n    }\n\n    protected open fun validateValue(value: String) {\n    }\n\n    private fun ensureListForKey(name: String, size: Int): MutableList<String> {\n        if (built) {\n            throw IllegalStateException(\n                \"Cannot modify a builder after build() function already invoked. \" +\n                    \"Make sure you call build() last.\"\n            )\n        }\n\n        return values[name] ?: ArrayList<String>(size).also { validateName(name); values[name] = it }\n    }\n}\n\n/**\n * Build an instance of [StringValues] from a vararg list of pairs\n */\npublic fun valuesOf(vararg pairs: Pair<String, List<String>>, caseInsensitiveKey: Boolean = false): StringValues {\n    return StringValuesImpl(caseInsensitiveKey, pairs.asList().toMap())\n}\n\n/**\n * Build an instance of [StringValues] from a single pair\n */\npublic fun valuesOf(name: String, value: String, caseInsensitiveKey: Boolean = false): StringValues {\n    return StringValuesSingleImpl(caseInsensitiveKey, name, listOf(value))\n}\n\n/**\n * Build an instance of [StringValues] with a single [name] and multiple [values]\n */\npublic fun valuesOf(name: String, values: List<String>, caseInsensitiveKey: Boolean = false): StringValues {\n    return StringValuesSingleImpl(caseInsensitiveKey, name, values)\n}\n\n/**\n * Build an empty [StringValues] instance.\n */\npublic fun valuesOf(): StringValues = StringValues.Empty\n\n/**\n * Build an instance of [StringValues] from the specified [map]\n */\npublic fun valuesOf(map: Map<String, Iterable<String>>, caseInsensitiveKey: Boolean = false): StringValues {\n    val size = map.size\n    if (size == 1) {\n        val entry = map.entries.single()\n        return StringValuesSingleImpl(caseInsensitiveKey, entry.key, entry.value.toList())\n    }\n    val values: MutableMap<String, List<String>> =\n        if (caseInsensitiveKey) caseInsensitiveMap() else LinkedHashMap(size)\n    map.entries.forEach { values.put(it.key, it.value.toList()) }\n    return StringValuesImpl(caseInsensitiveKey, values)\n}\n\n/**\n * Copy values to a new independent map\n */\npublic fun StringValues.toMap(): Map<String, List<String>> =\n    entries().associateByTo(LinkedHashMap(), { it.key }, { it.value.toList() })\n\n/**\n * Copy values to a list of pairs\n */\npublic fun StringValues.flattenEntries(): List<Pair<String, String>> = entries().flatMap { e ->\n    e.value.map { e.key to it }\n}\n\n/**\n * Invoke [block] function for every value pair\n */\npublic fun StringValues.flattenForEach(block: (String, String) -> Unit): Unit = forEach { name, items ->\n    items.forEach { block(name, it) }\n}\n\n/**\n * Create a new instance of [StringValues] filtered by the specified [predicate]\n * @param keepEmpty when `true` will keep empty lists otherwise keys with no values will be discarded\n */\npublic fun StringValues.filter(keepEmpty: Boolean = false, predicate: (String, String) -> Boolean): StringValues {\n    val entries = entries()\n    val values: MutableMap<String, MutableList<String>> =\n        if (caseInsensitiveName) caseInsensitiveMap() else LinkedHashMap(entries.size)\n\n    entries.forEach { entry ->\n        val list = entry.value.filterTo(ArrayList(entry.value.size)) { predicate(entry.key, it) }\n        if (keepEmpty || list.isNotEmpty()) {\n            values.put(entry.key, list)\n        }\n    }\n\n    return StringValuesImpl(caseInsensitiveName, values)\n}\n\n/**\n * Append values from [source] filtering values by the specified [predicate]\n * @param keepEmpty when `true` will keep empty lists otherwise keys with no values will be discarded\n */\npublic fun StringValuesBuilder.appendFiltered(\n    source: StringValues,\n    keepEmpty: Boolean = false,\n    predicate: (String, String) -> Boolean\n) {\n    source.forEach { name, value ->\n        val list = value.filterTo(ArrayList(value.size)) { predicate(name, it) }\n        if (keepEmpty || list.isNotEmpty()) {\n            appendAll(name, list)\n        }\n    }\n}\n\n/**\n * Append all values from the specified [builder]\n */\npublic fun StringValuesBuilder.appendAll(builder: StringValuesBuilder): StringValuesBuilder = apply {\n    builder.entries().forEach { (name, values) ->\n        appendAll(name, values)\n    }\n}\n\nprivate fun entriesEquals(a: Set<Map.Entry<String, List<String>>>, b: Set<Map.Entry<String, List<String>>>): Boolean {\n    return a == b\n}\n\nprivate fun entriesHashCode(entries: Set<Map.Entry<String, List<String>>>, seed: Int): Int {\n    return seed * 31 + entries.hashCode()\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util.cio\n\nimport io.ktor.utils.io.*\nimport io.ktor.utils.io.core.*\nimport kotlin.contracts.*\n\n/**\n * Convert [ByteReadChannel] to [ByteArray]\n */\npublic suspend fun ByteReadChannel.toByteArray(limit: Int = Int.MAX_VALUE): ByteArray =\n    readRemaining(limit.toLong()).readBytes()\n\n/**\n * Executes [block] on [ByteWriteChannel] and close it down correctly whether an exception\n */\npublic inline fun ByteWriteChannel.use(block: ByteWriteChannel.() -> Unit) {\n    contract {\n        callsInPlace(block, InvocationKind.EXACTLY_ONCE)\n    }\n\n    try {\n        block()\n    } catch (cause: Throwable) {\n        close(cause)\n        throw cause\n    } finally {\n        close()\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util.collections\n\nimport io.ktor.util.*\nimport io.ktor.util.collections.internal.*\nimport io.ktor.utils.io.*\nimport io.ktor.utils.io.concurrent.*\nimport kotlinx.atomicfu.locks.*\n\nprivate const val INITIAL_CAPACITY = 32\n\npublic class ConcurrentList<T> : MutableList<T> {\n    private var data by shared(SharedList<T>(INITIAL_CAPACITY))\n\n    override var size: Int by shared(0)\n        private set\n\n    private val lock = SynchronizedObject()\n\n    init {\n        makeShared()\n    }\n\n    override fun hashCode(): Int = synchronized(lock) {\n        return@synchronized fold(7) { state, current -> Hash.combine(state, current.hashCode()) }\n    }\n\n    override fun equals(other: Any?): Boolean = synchronized(lock) {\n        if (other == null || other !is List<*> || other.size != size) {\n            return@synchronized false\n        }\n\n        forEachIndexed { index, item ->\n            if (other[index] != item) return@synchronized false\n        }\n\n        return@synchronized true\n    }\n\n    override fun toString(): String = synchronized(lock) {\n        return@synchronized buildString {\n            append('[')\n            this@ConcurrentList.forEachIndexed { index, item ->\n                append(\"$item\")\n\n                if (index + 1 < size) {\n                    append(\", \")\n                }\n            }\n\n            append(']')\n        }\n    }\n\n    override fun contains(element: T): Boolean = indexOf(element) >= 0\n\n    override fun containsAll(elements: Collection<T>): Boolean = elements.all { contains(it) }\n\n    override fun get(index: Int): T = synchronized(lock) {\n        if (index >= size) {\n            throw NoSuchElementException()\n        }\n\n        return data[index]!!\n    }\n\n    override fun indexOf(element: T): Int = synchronized(lock) {\n        for (index in 0 until size) {\n            if (data[index] == element) {\n                return index\n            }\n        }\n\n        return -1\n    }\n\n    override fun isEmpty(): Boolean = size == 0\n\n    override fun lastIndexOf(element: T): Int = synchronized(lock) {\n        for (index in size - 1 downTo 0) {\n            if (data[index] == element) {\n                return index\n            }\n        }\n\n        return -1\n    }\n\n    override fun add(element: T): Boolean = synchronized(lock) {\n        if (size >= data.size) {\n            increaseCapacity()\n        }\n\n        data[size] = element\n        size += 1\n        return true\n    }\n\n    override fun add(index: Int, element: T) {\n        reserve(index, 1)\n        data[index] = element\n    }\n\n    override fun addAll(index: Int, elements: Collection<T>): Boolean {\n        reserve(index, elements.size)\n\n        var current = index\n        for (item in elements) {\n            data[current] = item\n            current += 1\n        }\n\n        return elements.isNotEmpty()\n    }\n\n    override fun addAll(elements: Collection<T>): Boolean {\n        elements.all { add(it) }\n        return elements.isNotEmpty()\n    }\n\n    override fun clear(): Unit = synchronized(lock) {\n        data = SharedList(INITIAL_CAPACITY)\n        size = 0\n    }\n\n    override fun iterator(): MutableIterator<T> = listIterator()\n\n    override fun listIterator(): MutableListIterator<T> = listIterator(0)\n\n    override fun listIterator(index: Int): MutableListIterator<T> = object : MutableListIterator<T> {\n        var current by shared(index)\n\n        override fun hasNext(): Boolean = current < this@ConcurrentList.size\n\n        override fun next(): T = this@ConcurrentList[current++]\n\n        override fun remove() {\n            removeAt(current - 1)\n            current--\n        }\n\n        override fun hasPrevious(): Boolean = current > 0\n\n        override fun nextIndex(): Int = current + 1\n\n        override fun previous(): T = this@ConcurrentList[current--]\n\n        override fun previousIndex(): Int = current - 1\n\n        override fun add(element: T) {\n            add(current, element)\n        }\n\n        override fun set(element: T) {\n            this@ConcurrentList[current - 1] = element\n        }\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): MutableList<T> =\n        ConcurrentListSlice(this, fromIndex, toIndex)\n\n    override fun remove(element: T): Boolean = synchronized(lock) {\n        val index = indexOf(element)\n        if (index < 0) {\n            return false\n        }\n\n        removeAt(index)\n        return true\n    }\n\n    override fun removeAll(elements: Collection<T>): Boolean {\n        var result = false\n        elements.forEach { result = remove(it) || result }\n        return result\n    }\n\n    override fun removeAt(index: Int): T = synchronized(lock) {\n        checkIndex(index)\n\n        val old = data[index]\n        data[index] = null\n\n        sweep(index)\n        return old!!\n    }\n\n    override fun retainAll(elements: Collection<T>): Boolean = synchronized(lock) {\n        var changed = false\n        var firstNull = -1\n        for (index in 0 until size) {\n            val item = data[index]!!\n\n            if (item !in elements) {\n                changed = true\n                data[index] = null\n\n                if (firstNull < 0) {\n                    firstNull = index\n                }\n            }\n        }\n\n        if (changed) {\n            sweep(firstNull)\n        }\n\n        return changed\n    }\n\n    override fun set(index: Int, element: T): T = synchronized(lock) {\n        checkIndex(index)\n        val old = data[index]\n        data[index] = element\n\n        return old ?: element\n    }\n\n    private fun checkIndex(index: Int) {\n        if (index >= size || index < 0) throw IndexOutOfBoundsException()\n    }\n\n    private fun increaseCapacity(targetCapacity: Int = data.size * 2) {\n        val newData = SharedList<T>(targetCapacity)\n        for (index in 0 until data.size) {\n            newData[index] = data[index]\n        }\n\n        data = newData\n    }\n\n    private fun sweep(firstNull: Int) {\n        var writePosition = firstNull\n\n        for (index in writePosition + 1 until size) {\n            if (data[index] == null) {\n                continue\n            }\n\n            data[writePosition] = data[index]\n            writePosition += 1\n        }\n\n        for (index in writePosition until size) {\n            data[index] = null\n        }\n\n        size = writePosition\n    }\n\n    private fun reserve(index: Int, gapSize: Int) {\n        val targetSize = gapSize + size\n        while (data.size < targetSize) {\n            increaseCapacity()\n        }\n\n        var readPosition = size - 1\n        while (readPosition >= index) {\n            data[readPosition + gapSize] = data[readPosition]\n            readPosition -= 1\n        }\n\n        for (current in index until index + gapSize) {\n            data[current] = null\n        }\n\n        size += gapSize\n    }\n}\n",null,"/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util.collections\n\nimport io.ktor.util.*\nimport io.ktor.util.collections.internal.*\nimport io.ktor.utils.io.*\nimport io.ktor.utils.io.concurrent.*\nimport kotlinx.atomicfu.*\n\nprivate const val INITIAL_CAPACITY = 32\nprivate const val MAX_LOAD_FACTOR = 0.5\nprivate const val UPSIZE_RATIO = 2\n\n/**\n * Ktor concurrent map implementation. Please do not use it.\n */\n@InternalAPI\npublic class ConcurrentMap<Key : Any, Value : Any>(\n    private val lock: Lock = Lock(),\n    initialCapacity: Int = INITIAL_CAPACITY\n) : MutableMap<Key, Value> {\n    private var table by shared(SharedList<SharedForwardList<MapNode<Key, Value>>>(initialCapacity))\n    private var insertionOrder by shared(SharedForwardList<MapNode<Key, Value>>())\n\n    private val _size = atomic(0)\n    private val loadFactor: Float get() = _size.value.toFloat() / table.size\n\n    public constructor(lock: Lock, map: Map<Key, Value>) : this(lock, map.size) {\n        putAll(map)\n    }\n\n    init {\n        makeShared()\n    }\n\n    override val size: Int\n        get() = _size.value\n\n    override fun containsKey(key: Key): Boolean = get(key) != null\n\n    override fun containsValue(value: Value): Boolean = locked {\n        for (bucket in table) {\n            bucket ?: continue\n\n            for (item in bucket) {\n                if (item.value == value) {\n                    return@locked true\n                }\n            }\n        }\n\n        return@locked false\n    }\n\n    override fun get(key: Key): Value? = locked {\n        val bucket = findBucket(key) ?: return@locked null\n        val item = bucket.find { it.key == key }\n\n        return@locked item?.value\n    }\n\n    override fun isEmpty(): Boolean = size == 0\n\n    override fun clear(): Unit = locked {\n        table = SharedList(INITIAL_CAPACITY)\n        insertionOrder = SharedForwardList()\n    }\n\n    override fun put(key: Key, value: Value): Value? = locked {\n        if (loadFactor > MAX_LOAD_FACTOR) {\n            upsize()\n        }\n\n        val bucket = findOrCreateBucket(key)\n        val item = bucket.find { it.key == key }\n\n        if (item != null) {\n            val oldValue = item.value\n            item.value = value\n            return@locked oldValue\n        }\n\n        val mapNode = MapNode(key, value)\n        val node = insertionOrder.appendLast(mapNode)\n\n        mapNode.backReference = node\n        bucket.appendFirst(mapNode)\n\n        _size.incrementAndGet()\n        return@locked null\n    }\n\n    override fun putAll(from: Map<out Key, Value>) {\n        for ((key, value) in from) {\n            put(key, value)\n        }\n    }\n\n    override fun remove(key: Key): Value? = locked {\n        val bucket = findBucket(key) ?: return@locked null\n\n        with(bucket.iterator()) {\n            while (hasNext()) {\n                val item = next()\n\n                if (item.key == key) {\n                    val result = item.value\n                    _size.decrementAndGet()\n\n                    item.remove()\n                    remove()\n\n                    return@locked result\n                }\n            }\n        }\n\n        return@locked null\n    }\n\n    override val entries: MutableSet<MutableMap.MutableEntry<Key, Value>>\n        get() = MutableMapEntries(this)\n\n    override val keys: MutableSet<Key>\n        get() = ConcurrentMapKeys(this)\n\n    override val values: MutableCollection<Value>\n        get() = ConcurrentMapValues(this)\n\n    override fun equals(other: Any?): Boolean = locked {\n        if (other == null || other !is Map<*, *> || other.size != size) {\n            return@locked false\n        }\n\n        for ((key, value) in other.entries) {\n            if (get(key) != value) {\n                return@locked false\n            }\n        }\n\n        return@locked true\n    }\n\n    override fun hashCode(): Int = locked {\n        var current = 7\n        for ((key, value) in entries) {\n            current = Hash.combine(key.hashCode(), value.hashCode(), current)\n        }\n\n        return@locked current\n    }\n\n    override fun toString(): String = locked {\n        return@locked buildString {\n            append(\"{\")\n            this@ConcurrentMap.entries.forEachIndexed { index, (key, value) ->\n                append(\"$key=$value\")\n\n                if (index != size - 1) {\n                    append(\", \")\n                }\n            }\n\n            append(\"}\")\n        }\n    }\n\n    internal fun iterator(): MutableIterator<MutableMap.MutableEntry<Key, Value>> =\n        object : MutableIterator<MutableMap.MutableEntry<Key, Value>> {\n            private var current: ForwardListNode<MapNode<Key, Value>>? by shared(insertionOrder.first())\n            private val previous: ForwardListNode<MapNode<Key, Value>>? get() = current?.previous\n\n            init {\n                makeShared()\n            }\n\n            override fun hasNext(): Boolean = current != null\n\n            override fun next(): MutableMap.MutableEntry<Key, Value> {\n                val result = current!!.item!!\n                current = current?.next\n                return result\n            }\n\n            override fun remove() {\n                val item = previous!!.item!!\n                remove(item.key)\n            }\n        }\n\n    /**\n     * Perform concurrent insert.\n     */\n    @Deprecated(\n        \"This is accidentally does insert instead of get. Use computeIfAbsent or getOrElse instead.\",\n        level = DeprecationLevel.ERROR\n    )\n    public fun getOrDefault(key: Key, block: () -> Value): Value = locked {\n        return@locked computeIfAbsent(key, block)\n    }\n\n    /**\n     * Computes [block] and inserts result in map. The [block] will be evaluated at most once.\n     */\n    public fun computeIfAbsent(key: Key, block: () -> Value): Value = locked {\n        val value = get(key)\n        if (value != null) {\n            return@locked value\n        }\n        val newValue = block()\n        put(key, newValue)\n\n        return@locked newValue\n    }\n\n    private fun findBucket(key: Key): SharedForwardList<MapNode<Key, Value>>? {\n        val bucketId = key.hashCode() and (table.size - 1)\n        return table[bucketId]\n    }\n\n    private fun findOrCreateBucket(key: Key): SharedForwardList<MapNode<Key, Value>> {\n        val bucketId = key.hashCode() and (table.size - 1)\n        val result = table[bucketId]\n\n        if (result == null) {\n            val bucket = SharedForwardList<MapNode<Key, Value>>()\n            table[bucketId] = bucket\n            return bucket\n        }\n\n        return result\n    }\n\n    private fun upsize() {\n        val newTable = ConcurrentMap<Key, Value>(initialCapacity = table.size * UPSIZE_RATIO)\n        newTable.putAll(this)\n\n        table = newTable.table\n    }\n\n    private fun <T> locked(block: () -> T): T = lock.withLock { block() }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util.collections.internal\n\nimport kotlin.math.*\n\ninternal class ConcurrentListSlice<T>(\n    private val origin: MutableList<T>,\n    private val fromIndex: Int,\n    private val toIndex: Int\n) : AbstractMutableList<T>() {\n    override val size: Int\n        get() = min(origin.size, toIndex - fromIndex)\n\n    override fun get(index: Int): T {\n        return origin[fromIndex + index]\n    }\n\n    override fun add(index: Int, element: T) {\n        error(\"Unsupported append in ConcurrentList slice\")\n    }\n\n    override fun removeAt(index: Int): T {\n        error(\"Unsupported remove in ConcurrentList slice\")\n    }\n\n    override fun set(index: Int, element: T): T = origin.set(fromIndex + index, element)\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util.collections.internal\n\nimport io.ktor.util.collections.*\nimport io.ktor.utils.io.*\n\ninternal class ConcurrentMapKeys<Key : Any, Value : Any>(\n    private val delegate: ConcurrentMap<Key, Value>\n) : MutableSet<Key> {\n\n    init {\n        makeShared()\n    }\n\n    override fun add(element: Key): Boolean = throw UnsupportedOperationException()\n\n    override fun addAll(elements: Collection<Key>): Boolean {\n        throw UnsupportedOperationException()\n    }\n\n    override fun clear() {\n        delegate.clear()\n    }\n\n    override fun iterator(): MutableIterator<Key> = object : MutableIterator<Key> {\n        private val delegateIterator: MutableIterator<MutableMap.MutableEntry<Key, Value>> = delegate.iterator()\n\n        init {\n            makeShared()\n        }\n\n        override fun hasNext(): Boolean = delegateIterator.hasNext()\n\n        override fun next(): Key = delegateIterator.next().key\n\n        override fun remove() {\n            delegateIterator.remove()\n        }\n    }\n\n    override fun remove(element: Key): Boolean = delegate.remove(element) != null\n\n    override fun removeAll(elements: Collection<Key>): Boolean {\n        var modified = false\n        elements.forEach {\n            modified = remove(it) || modified\n        }\n\n        return modified\n    }\n\n    override fun retainAll(elements: Collection<Key>): Boolean {\n        var modified = false\n\n        with(iterator()) {\n            while (hasNext()) {\n                if (next() in elements) {\n                    continue\n                }\n\n                modified = true\n                remove()\n            }\n        }\n\n        return modified\n    }\n\n    override val size: Int\n        get() = delegate.size\n\n    override fun contains(element: Key): Boolean = delegate.contains(element)\n\n    override fun containsAll(elements: Collection<Key>): Boolean = elements.all { contains(it) }\n\n    override fun isEmpty(): Boolean = size == 0\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util.collections.internal\n\nimport io.ktor.util.collections.*\nimport io.ktor.utils.io.*\n\ninternal class ConcurrentMapValues<Key : Any, Value : Any>(\n    private val delegate: ConcurrentMap<Key, Value>\n) : MutableCollection<Value> {\n\n    init {\n        makeShared()\n    }\n\n    override val size: Int\n        get() = delegate.size\n\n    override fun contains(element: Value): Boolean = delegate.containsValue(element)\n\n    override fun containsAll(elements: Collection<Value>): Boolean = elements.all { contains(it) }\n\n    override fun isEmpty(): Boolean = delegate.size == 0\n\n    override fun add(element: Value): Boolean {\n        throw UnsupportedOperationException()\n    }\n\n    override fun addAll(elements: Collection<Value>): Boolean {\n        throw UnsupportedOperationException()\n    }\n\n    override fun clear() {\n        delegate.clear()\n    }\n\n    override fun iterator(): MutableIterator<Value> = object : MutableIterator<Value> {\n        val delegateIterator = delegate.iterator()\n\n        init {\n            makeShared()\n        }\n\n        override fun hasNext(): Boolean = delegateIterator.hasNext()\n\n        override fun next(): Value = delegateIterator.next().value\n\n        override fun remove() {\n            delegateIterator.remove()\n        }\n    }\n\n    override fun remove(element: Value): Boolean {\n        var modified = false\n\n        with(iterator()) {\n            while (hasNext()) {\n                if (next() == element) {\n                    continue\n                }\n\n                modified = true\n                remove()\n            }\n        }\n\n        return modified\n    }\n\n    override fun removeAll(elements: Collection<Value>): Boolean {\n        var modified = false\n\n        with(iterator()) {\n            while (hasNext()) {\n                if (next() !in elements) {\n                    continue\n                }\n\n                modified = true\n                remove()\n            }\n        }\n\n        return modified\n    }\n\n    override fun retainAll(elements: Collection<Value>): Boolean {\n        error(\"Common concurrent map doesn't support this operation yet.\")\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util.collections.internal\n\nimport io.ktor.utils.io.concurrent.*\n\ninternal class ForwardListIterator<T : Any>(head: ForwardListNode<T>) : MutableIterator<T> {\n    var previous by shared<ForwardListNode<T>?>(head)\n    val current: ForwardListNode<T>? get() = previous?.next\n\n    override fun hasNext(): Boolean = current?.item != null\n\n    override fun next(): T {\n        previous = current\n        return previous?.item ?: throw NoSuchElementException()\n    }\n\n    override fun remove() {\n        previous?.remove() ?: error(\"Fail to remove element before iteration\")\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util.collections.internal\n\nimport io.ktor.utils.io.*\nimport io.ktor.utils.io.concurrent.*\n\ninternal class ForwardListNode<T : Any>(\n    private val list: SharedForwardList<T>,\n    next: ForwardListNode<T>?,\n    val item: T?,\n    previous: ForwardListNode<T>?\n) {\n    var next by shared(next)\n    var previous: ForwardListNode<T>? by shared(previous)\n\n    init {\n        makeShared()\n    }\n\n    fun insertAfter(value: T): ForwardListNode<T> {\n        val result = ForwardListNode(list, next, value, this)\n        next?.previous = result\n        next = result\n        return result\n    }\n\n    fun removeNext() {\n        if (next == list.tail) {\n            list.tail = this\n        }\n\n        next = next?.next\n        next?.previous = this\n    }\n\n    fun remove() {\n        previous!!.removeNext()\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util.collections.internal\n\nimport io.ktor.utils.io.*\nimport io.ktor.utils.io.concurrent.*\n\ninternal class MapNode<Key, Value>(override val key: Key, value: Value) : MutableMap.MutableEntry<Key, Value> {\n    internal var backReference: ForwardListNode<MapNode<Key, Value>>? by shared(null)\n    override var value: Value by shared(value)\n\n    val hash: Int = key.hashCode()\n\n    init {\n        makeShared()\n    }\n\n    override fun setValue(newValue: Value): Value {\n        val result = value\n        value = newValue\n        return result\n    }\n\n    internal fun remove() {\n        backReference!!.remove()\n        backReference = null\n    }\n\n    override fun toString(): String = \"MapItem[$key, $value]\"\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util.collections.internal\n\nimport io.ktor.util.collections.*\nimport io.ktor.utils.io.*\n\ninternal class MutableMapEntries<Key : Any, Value : Any>(\n    private val delegate: ConcurrentMap<Key, Value>\n) : MutableSet<MutableMap.MutableEntry<Key, Value>> {\n\n    init {\n        makeShared()\n    }\n\n    override fun add(element: MutableMap.MutableEntry<Key, Value>): Boolean =\n        delegate.put(element.key, element.value) != element.value\n\n    override fun addAll(elements: Collection<MutableMap.MutableEntry<Key, Value>>): Boolean {\n        var result = false\n\n        elements.forEach {\n            result = add(it) || result\n        }\n\n        return result\n    }\n\n    override fun clear() {\n        delegate.clear()\n    }\n\n    override fun iterator(): MutableIterator<MutableMap.MutableEntry<Key, Value>> =\n        object : MutableIterator<MutableMap.MutableEntry<Key, Value>> {\n            private val origin = delegate.iterator()\n            override fun hasNext(): Boolean = origin.hasNext()\n\n            override fun next(): MutableMap.MutableEntry<Key, Value> = origin.next()\n\n            override fun remove(): Unit = origin.remove()\n        }\n\n    override fun remove(element: MutableMap.MutableEntry<Key, Value>): Boolean =\n        delegate.remove(element.key) != null\n\n    override fun removeAll(elements: Collection<MutableMap.MutableEntry<Key, Value>>): Boolean {\n        var modified = false\n        elements.forEach {\n            modified = remove(it) || modified\n        }\n\n        return modified\n    }\n\n    override fun retainAll(elements: Collection<MutableMap.MutableEntry<Key, Value>>): Boolean {\n        var modified = false\n        with(iterator()) {\n            while (hasNext()) {\n                if (next() in elements) {\n                    continue\n                }\n\n                modified = true\n                remove()\n            }\n        }\n\n        return modified\n    }\n\n    override val size: Int\n        get() = delegate.size\n\n    override fun contains(element: MutableMap.MutableEntry<Key, Value>): Boolean =\n        delegate[element.key] == element.value\n\n    override fun containsAll(elements: Collection<MutableMap.MutableEntry<Key, Value>>): Boolean =\n        elements.all { contains(it) }\n\n    override fun isEmpty(): Boolean = delegate.isEmpty()\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util.collections.internal\n\nimport io.ktor.utils.io.*\nimport io.ktor.utils.io.concurrent.*\n\ninternal class SharedForwardList<T : Any> : MutableIterable<T> {\n    internal var head: ForwardListNode<T>? by shared(null)\n    internal var tail by shared(head)\n\n    init {\n        makeShared()\n\n        head = ForwardListNode(this, null, null, null)\n        tail = head\n    }\n\n    fun first(): ForwardListNode<T>? {\n        return head!!.next\n    }\n\n    fun last(): ForwardListNode<T>? {\n        if (head == tail) {\n            return null\n        }\n\n        return tail\n    }\n\n    fun appendFirst(value: T): ForwardListNode<T> {\n        val newValue = head!!.insertAfter(value)\n        if (head == tail) {\n            tail = newValue\n        }\n\n        return newValue\n    }\n\n    fun appendLast(value: T): ForwardListNode<T> {\n        tail = tail!!.insertAfter(value)\n        return tail!!\n    }\n\n    override fun iterator(): MutableIterator<T> =\n        ForwardListIterator(head!!)\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util.collections.internal\n\nimport io.ktor.util.*\nimport io.ktor.utils.io.*\nimport kotlinx.atomicfu.*\n\n@InternalAPI\ninternal class SharedList<T>(override val size: Int) : List<T?> {\n    private val data: AtomicArray<T?> = atomicArrayOfNulls<T>(size)\n\n    init {\n        makeShared()\n    }\n\n    operator fun set(index: Int, value: T?) {\n        data[index].value = value\n    }\n\n    override fun contains(element: T?): Boolean {\n        for (index in 0 until size) {\n            if (data[index].value == element) {\n                return true\n            }\n        }\n\n        return false\n    }\n\n    override fun containsAll(elements: Collection<T?>): Boolean = elements.all { contains(it) }\n\n    override fun get(index: Int): T? = data[index].value\n\n    override fun indexOf(element: T?): Int {\n        for (index in 0 until size) {\n            if (data[index].value == element) {\n                return index\n            }\n        }\n\n        return -1\n    }\n\n    override fun isEmpty(): Boolean = size == 0\n\n    override fun iterator(): Iterator<T?> = listIterator(0)\n\n    override fun lastIndexOf(element: T?): Int = asReversed().indexOf(element)\n\n    override fun listIterator(): ListIterator<T?> = listIterator(0)\n\n    override fun listIterator(index: Int): ListIterator<T?> = object : ListIterator<T?> {\n        private val currentIndex = atomic(index)\n\n        init {\n            makeShared()\n        }\n\n        override fun hasNext(): Boolean = currentIndex.value < size\n\n        override fun hasPrevious(): Boolean = currentIndex.value > 0\n\n        override fun next(): T? {\n            check(hasNext())\n            val current = currentIndex.getAndIncrement()\n            return data[current].value\n        }\n\n        override fun nextIndex(): Int {\n            check(hasNext())\n            return currentIndex.value + 1\n        }\n\n        override fun previous(): T? {\n            check(hasPrevious())\n            val current = currentIndex.getAndDecrement()\n            return data[current].value\n        }\n\n        override fun previousIndex(): Int {\n            check(hasPrevious())\n            return currentIndex.value - 1\n        }\n    }\n\n    override fun subList(fromIndex: Int, toIndex: Int): List<T?> {\n        val result = SharedList<T>(toIndex - fromIndex)\n\n        for (index in fromIndex until toIndex) {\n            result[index - fromIndex] = data[index].value\n        }\n\n        return result\n    }\n}\n","/*\n * Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.util.converters\n\nimport io.ktor.util.reflect.*\nimport kotlin.reflect.*\n\n/**\n * Data conversion service that does serialization and deserialization to/from list of strings\n */\npublic interface ConversionService {\n    /**\n     * Deserialize [values] to an instance of [type]\n     */\n    public fun fromValues(values: List<String>, type: TypeInfo): Any?\n\n    /**\n     * Serialize a [value] to values list\n     */\n    public fun toValues(value: Any?): List<String>\n}\n\n/**\n * The default conversion service that supports only basic types and enums\n */\npublic object DefaultConversionService : ConversionService {\n    override fun toValues(value: Any?): List<String> {\n        if (value == null) {\n            return emptyList()\n        }\n        val converted = platformDefaultToValues(value)\n        if (converted != null) {\n            return converted\n        }\n        return when (value) {\n            is Iterable<*> -> value.flatMap { toValues(it) }\n            else -> {\n                when (val klass = value::class) {\n                    Int::class,\n                    Float::class,\n                    Double::class,\n                    Long::class,\n                    Short::class,\n                    Char::class,\n                    Boolean::class,\n                    String::class -> listOf(value.toString())\n                    else -> throw DataConversionException(\n                        \"Class $klass is not supported in default data conversion service\"\n                    )\n                }\n            }\n        }\n    }\n\n    override fun fromValues(values: List<String>, type: TypeInfo): Any? {\n        if (values.isEmpty()) {\n            return null\n        }\n\n        if (type.type == List::class) {\n            val argumentType = type.kotlinType?.arguments?.single()?.type?.classifier as? KClass<*>\n            if (argumentType != null) {\n                return values.map { fromValue(it, argumentType) }\n            }\n        }\n\n        when {\n            values.isEmpty() ->\n                throw DataConversionException(\"There are no values when trying to construct single value $type\")\n            values.size > 1 ->\n                throw DataConversionException(\"There are multiple values when trying to construct single value $type\")\n            else -> return fromValue(values.single(), type.type)\n        }\n    }\n\n    public fun fromValue(value: String, klass: KClass<*>): Any {\n        val converted = convertPrimitives(klass, value)\n        if (converted != null) {\n            return converted\n        }\n\n        val platformConverted = platformDefaultFromValues(value, klass)\n        if (platformConverted != null) {\n            return platformConverted\n        }\n\n        throwConversionException(klass.toString())\n    }\n\n    private fun convertPrimitives(klass: KClass<*>, value: String) = when (klass) {\n        Int::class -> value.toInt()\n        Float::class -> value.toFloat()\n        Double::class -> value.toDouble()\n        Long::class -> value.toLong()\n        Short::class -> value.toShort()\n        Char::class -> value.single()\n        Boolean::class -> value.toBoolean()\n        String::class -> value\n        else -> null\n    }\n\n    private fun throwConversionException(typeName: String): Nothing {\n        throw DataConversionException(\"Type $typeName is not supported in default data conversion service\")\n    }\n}\n\ninternal expect fun platformDefaultFromValues(value: String, klass: KClass<*>): Any?\n\ninternal expect fun platformDefaultToValues(value: Any): List<String>?\n\n/**\n * Thrown when failed to convert value\n */\npublic open class DataConversionException(message: String = \"Invalid data format\") : Exception(message)\n","/*\n * Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.util.converters\n\nimport io.ktor.util.*\nimport io.ktor.util.reflect.*\nimport kotlin.reflect.*\n\n/**\n * Data conversion feature to serialize and deserialize types using [converters] registry\n */\npublic class DataConversion(configuration: Configuration) : ConversionService {\n    private val converters: Map<KClass<*>, ConversionService> = configuration.converters.toMap()\n\n    override fun fromValues(values: List<String>, type: TypeInfo): Any? {\n        if (values.isEmpty()) {\n            return null\n        }\n        val converter = converters[type.type] ?: DefaultConversionService\n        return converter.fromValues(values, type)\n    }\n\n    override fun toValues(value: Any?): List<String> {\n        val type: KClass<*> = value?.let { it::class } ?: return listOf()\n        val converter = converters[type] ?: DefaultConversionService\n        return converter.toValues(value)\n    }\n\n    /**\n     * Data conversion service configuration\n     */\n    public class Configuration {\n        internal val converters = mutableMapOf<KClass<*>, ConversionService>()\n\n        /**\n         * Register a [convertor] for [type] type\n         */\n        public fun convert(type: KClass<*>, convertor: ConversionService) {\n            converters[type] = convertor\n        }\n\n        /**\n         * Register and [configure] convertor for type [klass]\n         */\n        @Suppress(\"UNCHECKED_CAST\")\n        public fun <T : Any> convert(type: KType, configure: DelegatingConversionService.Configuration<T>.() -> Unit) {\n            val klass = type.classifier as KClass<T>\n            val configuration = DelegatingConversionService.Configuration(klass).apply(configure)\n\n            val service = DelegatingConversionService(\n                klass,\n                configuration.decoder,\n                configuration.encoder as ((Any?) -> List<String>)?\n            )\n            convert(klass, service)\n        }\n\n        /**\n         * Register and [configure] convertor for reified type [T]\n         */\n        @OptIn(ExperimentalStdlibApi::class)\n        public inline fun <reified T : Any> convert(\n            noinline configure: DelegatingConversionService.Configuration<T>.() -> Unit\n        ): Unit = convert(typeOf<T>(), configure)\n    }\n}\n\n/**\n * Implementation of [ConversionService] that delegates [fromValues] and [toValues] to [decoder] and [encoder]\n */\npublic class DelegatingConversionService(\n    private val klass: KClass<*>,\n    private val decoder: ((values: List<String>) -> Any?)?,\n    private val encoder: ((value: Any?) -> List<String>)?,\n) : ConversionService {\n\n    override fun fromValues(values: List<String>, type: TypeInfo): Any? {\n        if (decoder == null) throw IllegalStateException(\"Decoder was not specified for type '$klass'\")\n        return decoder!!(values)\n    }\n\n    override fun toValues(value: Any?): List<String> {\n        if (encoder == null) throw IllegalStateException(\"Encoder was not specified for type '$klass'\")\n        return encoder!!(value)\n    }\n\n    /**\n     * Custom convertor builder to be used in [DataConversion.Configuration]\n     */\n    public class Configuration<T : Any> @PublishedApi internal constructor(internal val klass: KClass<T>) {\n\n        internal var decoder: ((values: List<String>) -> T)? = null\n        internal var encoder: ((value: T) -> List<String>)? = null\n\n        /**\n         * Configure decoder function. Only one decoder could be supplied\n         * @throws IllegalStateException\n         */\n        public fun decode(converter: (values: List<String>) -> T) {\n            if (decoder != null) throw IllegalStateException(\"Decoder has already been set for type '$klass'\")\n            decoder = converter\n        }\n\n        /**\n         * Configure encoder function. Only one encoder could be supplied\n         * @throws IllegalStateException\n         */\n        public fun encode(converter: (value: T) -> List<String>) {\n            if (encoder != null) throw IllegalStateException(\"Encoder has already been set for type '$klass'\")\n            encoder = converter\n        }\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util.date\n\nimport kotlin.time.*\n\n/**\n * According to:\n * http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/time.h.html\n */\n\n/**\n * Day of week\n * [value] is 3 letter shortcut\n */\n@Suppress(\"KDocMissingDocumentation\")\npublic enum class WeekDay(public val value: String) {\n    MONDAY(\"Mon\"),\n    TUESDAY(\"Tue\"),\n    WEDNESDAY(\"Wed\"),\n    THURSDAY(\"Thu\"),\n    FRIDAY(\"Fri\"),\n    SATURDAY(\"Sat\"),\n    SUNDAY(\"Sun\");\n\n    public companion object {\n        /**\n         * Lookup an instance by [ordinal]\n         */\n        public fun from(ordinal: Int): WeekDay = values()[ordinal]\n\n        /**\n         * Lookup an instance by short week day name [WeekDay.value]\n         */\n        public fun from(value: String): WeekDay = values().find { it.value == value }\n            ?: error(\"Invalid day of week: $value\")\n    }\n}\n\n/**\n * Month\n * [value] is 3 letter shortcut\n */\n@Suppress(\"KDocMissingDocumentation\")\npublic enum class Month(public val value: String) {\n    JANUARY(\"Jan\"),\n    FEBRUARY(\"Feb\"),\n    MARCH(\"Mar\"),\n    APRIL(\"Apr\"),\n    MAY(\"May\"),\n    JUNE(\"Jun\"),\n    JULY(\"Jul\"),\n    AUGUST(\"Aug\"),\n    SEPTEMBER(\"Sep\"),\n    OCTOBER(\"Oct\"),\n    NOVEMBER(\"Nov\"),\n    DECEMBER(\"Dec\");\n\n    public companion object {\n        /**\n         * Lookup an instance by [ordinal]\n         */\n        public fun from(ordinal: Int): Month = values()[ordinal]\n\n        /**\n         * Lookup an instance by short month name [Month.value]\n         */\n        public fun from(value: String): Month = values().find { it.value == value }\n            ?: error(\"Invalid month: $value\")\n    }\n}\n\n/**\n * Date in GMT timezone\n *\n * @property seconds: seconds from 0 to 60(last is for leap second)\n * @property minutes: minutes from 0 to 59\n * @property hours: hours from 0 to 23\n * @property dayOfWeek an instance of the corresponding day of week\n * @property dayOfMonth: day of month from 1 to 31\n * @property dayOfYear: day of year from 1 to 366\n * @property month an instance of the corresponding month\n * @property year: year in common era(CE: https://en.wikipedia.org/wiki/Common_Era)\n *\n * @property timestamp is a number of epoch milliseconds\n */\npublic data class GMTDate internal constructor(\n    val seconds: Int,\n    val minutes: Int,\n    val hours: Int,\n\n    val dayOfWeek: WeekDay,\n    val dayOfMonth: Int,\n    val dayOfYear: Int,\n\n    val month: Month,\n    val year: Int,\n\n    val timestamp: Long\n) : Comparable<GMTDate> {\n\n    override fun compareTo(other: GMTDate): Int = timestamp.compareTo(other.timestamp)\n\n    public companion object {\n        /**\n         * An instance of [GMTDate] corresponding to the epoch beginning\n         */\n        public val START: GMTDate = GMTDate(0)\n    }\n}\n\n/**\n * Create new gmt date from the [timestamp].\n * @param timestamp is a number of epoch milliseconds (it is `now` by default).\n */\n@Suppress(\"FunctionName\")\npublic expect fun GMTDate(timestamp: Long? = null): GMTDate\n\n/**\n * Create an instance of [GMTDate] from the specified date/time components\n */\n@Suppress(\"FunctionName\")\npublic expect fun GMTDate(seconds: Int, minutes: Int, hours: Int, dayOfMonth: Int, month: Month, year: Int): GMTDate\n\n/**\n * Adds the specified number of [milliseconds]\n */\npublic operator fun GMTDate.plus(milliseconds: Long): GMTDate = GMTDate(timestamp + milliseconds)\n\n/**\n * Subtracts the specified number of [milliseconds]\n */\npublic operator fun GMTDate.minus(milliseconds: Long): GMTDate = GMTDate(timestamp - milliseconds)\n\n/**\n * Adds the specified [duration]\n */\n@ExperimentalTime\npublic operator fun GMTDate.plus(duration: Duration): GMTDate = GMTDate(timestamp + duration.toLongMilliseconds())\n\n/**\n * Subtracts the specified [duration]\n */\n@ExperimentalTime\npublic operator fun GMTDate.minus(duration: Duration): GMTDate = GMTDate(timestamp - duration.toLongMilliseconds())\n\n/**\n * Truncate to seconds by discarding sub-second part\n */\npublic fun GMTDate.truncateToSeconds(): GMTDate = GMTDate(seconds, minutes, hours, dayOfMonth, month, year)\n\n/**\n * Gets current system time in milliseconds since certain moment in the past, only delta between two subsequent calls makes sense.\n */\npublic expect fun getTimeMillis(): Long\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util.date\n\nimport io.ktor.util.*\n\n/**\n * Build [GMTDate] parser using [pattern] string.\n *\n * Pattern string format:\n * | Unit     | pattern char | Description                                          |\n * | -------- | ------------ | ---------------------------------------------------- |\n * | Seconds  | s            | parse seconds 0 to 60                                |\n * | Minutes  | m            | parse minutes 0 to 60                                |\n * | Hours    | h            | parse hours 0 to 23                                  |\n * | Month    | M            | parse month from Jan to Dec(see [Month] for details) |\n * | Year     | Y            | parse year                                           |\n * | Any char | *            | Match any character                                  |\n */\n@InternalAPI\npublic class GMTDateParser(private val pattern: String) {\n    init {\n        check(pattern.isNotEmpty()) { \"Date parser pattern shouldn't be empty.\" }\n    }\n\n    /**\n     * Parse [GMTDate] from [dateString] using [pattern].\n     */\n    public fun parse(dateString: String): GMTDate {\n        val builder = GMTDateBuilder()\n\n        var start = 0\n        var current = pattern[start]\n        var chunkStart = 0\n        var index = 1\n\n        try {\n            while (index < pattern.length) {\n                if (pattern[index] == current) {\n                    index++\n                    continue\n                }\n\n                val chunkEnd = chunkStart + index - start\n                builder.handleToken(current, dateString.substring(chunkStart, chunkEnd))\n\n                chunkStart = chunkEnd\n                start = index\n                current = pattern[index]\n\n                index++\n            }\n\n            if (chunkStart < dateString.length) {\n                builder.handleToken(current, dateString.substring(chunkStart))\n            }\n        } catch (_: Throwable) {\n            throw InvalidDateStringException(dateString, chunkStart, pattern)\n        }\n\n        return builder.build()\n    }\n\n    private fun GMTDateBuilder.handleToken(\n        type: Char,\n        chunk: String\n    ): Unit = when (type) {\n        SECONDS -> {\n            seconds = chunk.toInt()\n        }\n        MINUTES -> {\n            minutes = chunk.toInt()\n        }\n        HOURS -> {\n            hours = chunk.toInt()\n        }\n        DAY_OF_MONTH -> {\n            dayOfMonth = chunk.toInt()\n        }\n        MONTH -> {\n            month = Month.from(chunk)\n        }\n        YEAR -> {\n            year = chunk.toInt()\n        }\n        ZONE ->\n            check(chunk == \"GMT\")\n        ANY -> Unit\n        else -> {\n            check(chunk.all { it == type })\n        }\n    }\n\n    public companion object {\n        public const val SECONDS: Char = 's'\n        public const val MINUTES: Char = 'm'\n        public const val HOURS: Char = 'h'\n\n        public const val DAY_OF_MONTH: Char = 'd'\n        public const val MONTH: Char = 'M'\n        public const val YEAR: Char = 'Y'\n\n        public const val ZONE: Char = 'z'\n\n        public const val ANY: Char = '*'\n    }\n}\n\ninternal class GMTDateBuilder {\n    var seconds: Int? = null\n    var minutes: Int? = null\n    var hours: Int? = null\n\n    var dayOfMonth: Int? = null\n    lateinit var month: Month\n    var year: Int? = null\n\n    public fun build(): GMTDate = GMTDate(seconds!!, minutes!!, hours!!, dayOfMonth!!, month, year!!)\n}\n\n/**\n * Thrown when the date string doesn't the string pattern.\n */\npublic class InvalidDateStringException(\n    data: String,\n    at: Int,\n    pattern: String\n) : IllegalStateException(\"Failed to parse date string: \\\"${data}\\\" at index $at. Pattern: \\\"$pattern\\\"\")\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util.pipeline\n\nimport kotlin.coroutines.*\n\n/**\n * Represents running execution of a pipeline\n * @param context object representing context in which pipeline executes\n * @param interceptors list of interceptors to execute\n * @param subject object representing subject that goes along the pipeline\n */\n@ContextDsl\ninternal class DebugPipelineContext<TSubject : Any, TContext : Any> constructor(\n    override val context: TContext,\n    private val interceptors: List<PipelineInterceptor<TSubject, TContext>>,\n    subject: TSubject,\n    override val coroutineContext: CoroutineContext\n) : PipelineContext<TSubject, TContext>,\n    @Suppress(\"DEPRECATION\")\n    PipelineExecutor<TSubject> {\n\n    /**\n     * Subject of this pipeline execution\n     */\n    override var subject: TSubject = subject\n        private set\n\n    private var index = 0\n\n    /**\n     * Finishes current pipeline execution\n     */\n    override fun finish() {\n        index = -1\n    }\n\n    /**\n     * Continues execution of the pipeline with the given subject\n     */\n    override suspend fun proceedWith(subject: TSubject): TSubject {\n        this.subject = subject\n        return proceed()\n    }\n\n    /**\n     * Continues execution of the pipeline with the same subject\n     */\n    override suspend fun proceed(): TSubject {\n        val index = index\n        if (index < 0) return subject\n\n        if (index >= interceptors.size) {\n            finish()\n            return subject\n        }\n\n        return proceedLoop()\n    }\n\n    override suspend fun execute(initial: TSubject): TSubject {\n        index = 0\n        subject = initial\n        return proceed()\n    }\n\n    private suspend fun proceedLoop(): TSubject {\n        do {\n            val index = index\n            if (index == -1) {\n                break\n            }\n            val interceptors = interceptors\n            if (index >= interceptors.size) {\n                finish()\n                break\n            }\n            val executeInterceptor = interceptors[index]\n            this.index = index + 1\n            executeInterceptor.invoke(this, subject)\n        } while (true)\n\n        return subject\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util.pipeline\n\nimport io.ktor.util.collections.*\nimport io.ktor.utils.io.concurrent.*\n\ninternal class PhaseContent<TSubject : Any, Call : Any>(\n    val phase: PipelinePhase,\n    val relation: PipelinePhaseRelation,\n    interceptors: MutableList<PipelineInterceptor<TSubject, Call>>\n) {\n    private var interceptors: MutableList<PipelineInterceptor<TSubject, Call>> by shared(interceptors)\n\n    @Suppress(\"UNCHECKED_CAST\")\n    constructor(\n        phase: PipelinePhase,\n        relation: PipelinePhaseRelation\n    ) : this(phase, relation, SharedArrayList as MutableList<PipelineInterceptor<TSubject, Call>>) {\n        check(SharedArrayList.isEmpty()) { \"The shared empty array list has been modified\" }\n    }\n\n    var shared: Boolean by shared(true)\n\n    val isEmpty: Boolean get() = interceptors.isEmpty()\n    val size: Int get() = interceptors.size\n\n    fun addInterceptor(interceptor: PipelineInterceptor<TSubject, Call>) {\n        if (shared) {\n            copyInterceptors()\n        }\n\n        interceptors.add(interceptor)\n    }\n\n    fun addTo(destination: MutableList<PipelineInterceptor<TSubject, Call>>) {\n        val interceptors = interceptors\n\n        if (destination is ArrayList) {\n            destination.ensureCapacity(destination.size + interceptors.size)\n        }\n\n        for (index in 0 until interceptors.size) {\n            destination.add(interceptors[index])\n        }\n    }\n\n    fun addTo(destination: PhaseContent<TSubject, Call>) {\n        if (isEmpty) return\n\n        if (destination.isEmpty) {\n            destination.interceptors = sharedInterceptors()\n            destination.shared = true\n            return\n        }\n\n        if (destination.shared) {\n            destination.copyInterceptors()\n        }\n\n        addTo(destination.interceptors)\n    }\n\n    fun sharedInterceptors(): MutableList<PipelineInterceptor<TSubject, Call>> {\n        shared = true\n        return interceptors\n    }\n\n    fun copiedInterceptors(): MutableList<PipelineInterceptor<TSubject, Call>> =\n        sharedListOf<PipelineInterceptor<TSubject, Call>>().apply {\n            addAll(interceptors)\n        }\n\n    override fun toString(): String = \"Phase `${phase.name}`, $size handlers\"\n\n    private fun copyInterceptors() {\n        interceptors = copiedInterceptors()\n        shared = false\n    }\n\n    companion object {\n        val SharedArrayList: MutableList<Any?> = sharedListOf()\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util.pipeline\n\nimport io.ktor.util.*\nimport io.ktor.util.collections.*\nimport io.ktor.utils.io.concurrent.*\nimport kotlinx.atomicfu.*\nimport kotlin.coroutines.*\n\n/**\n * Represents an execution pipeline for asynchronous extensible computations\n */\npublic open class Pipeline<TSubject : Any, TContext : Any>(\n    vararg phases: PipelinePhase\n) {\n    /**\n     * Provides common place to store pipeline attributes\n     */\n    public val attributes: Attributes = Attributes(concurrent = true)\n\n    /**\n     * Indicated if debug mode is enabled. In debug mode users will get more details in the stacktrace.\n     */\n    public open val developmentMode: Boolean = false\n\n    private val phasesRaw: MutableList<Any> = sharedListOf(*phases)\n\n    private var interceptorsQuantity by shared(0)\n\n    /**\n     * Phases of this pipeline\n     */\n    public val items: List<PipelinePhase>\n        get() = phasesRaw.map {\n            it as? PipelinePhase ?: (it as? PhaseContent<*, *>)?.phase!!\n        }\n\n    /**\n     * @return `true` if there are no interceptors installed regardless number of phases\n     */\n    @InternalAPI\n    public val isEmpty: Boolean\n        get() = interceptorsQuantity == 0\n\n    private val _interceptors: AtomicRef<List<suspend PipelineContext<TSubject, TContext>.(TSubject) -> Unit>?> =\n        atomic(null)\n\n    private var interceptors: List<PipelineInterceptor<TSubject, TContext>>?\n        get() = _interceptors.value\n        set(value) {\n            _interceptors.value = value\n        }\n\n    /**\n     * share between pipelines/contexts\n     */\n    private var interceptorsListShared: Boolean by shared(false)\n\n    /**\n     * interceptors list is shared with pipeline phase content\n     */\n    private var interceptorsListSharedPhase: PipelinePhase? by shared(null)\n\n    public constructor(\n        phase: PipelinePhase,\n        interceptors: List<PipelineInterceptor<TSubject, TContext>>\n    ) : this(phase) {\n        interceptors.forEach { intercept(phase, it) }\n    }\n\n    /**\n     * Executes this pipeline in the given [context] and with the given [subject]\n     */\n    public suspend fun execute(context: TContext, subject: TSubject): TSubject =\n        createContext(context, subject, coroutineContext).execute(subject)\n\n    /**\n     * Adds [phase] to the end of this pipeline\n     */\n    public fun addPhase(phase: PipelinePhase) {\n        if (hasPhase(phase)) {\n            return\n        }\n\n        phasesRaw.add(phase)\n    }\n\n    /**\n     * Inserts [phase] after the [reference] phase. If there are other phases inserted after [reference], then [phase]\n     * will be inserted after them.\n     * Example:\n     * ```\n     * val pipeline = Pipeline<String, String>(a)\n     * pipeline.insertPhaseAfter(a, b)\n     * pipeline.insertPhaseAfter(a, c)\n     * assertEquals(listOf(a, b, c), pipeline.items)\n     * ```\n     */\n    public fun insertPhaseAfter(reference: PipelinePhase, phase: PipelinePhase) {\n        if (hasPhase(phase)) return\n\n        val index = findPhaseIndex(reference)\n        if (index == -1) {\n            throw InvalidPhaseException(\"Phase $reference was not registered for this pipeline\")\n        }\n        // insert after the last phase that has Relation.After on [reference]\n        var lastRelatedPhaseIndex = index\n        for (i in index + 1..phasesRaw.lastIndex) {\n            val relation = (phasesRaw[i] as? PhaseContent<*, *>)?.relation ?: break\n            val relatedTo = (relation as? PipelinePhaseRelation.After)?.relativeTo ?: continue\n            lastRelatedPhaseIndex = if (relatedTo == reference) i else lastRelatedPhaseIndex\n        }\n\n        phasesRaw.add(\n            lastRelatedPhaseIndex + 1,\n            PhaseContent<TSubject, TContext>(phase, PipelinePhaseRelation.After(reference))\n        )\n    }\n\n    /**\n     * Inserts [phase] before the [reference] phase.\n     * Example:\n     * ```\n     * val pipeline = Pipeline<String, String>(c)\n     * pipeline.insertPhaseBefore(c, a)\n     * pipeline.insertPhaseBefore(c, b)\n     * assertEquals(listOf(a, b, c), pipeline.items)\n     * ```\n     */\n    public fun insertPhaseBefore(reference: PipelinePhase, phase: PipelinePhase) {\n        if (hasPhase(phase)) return\n\n        val index = findPhaseIndex(reference)\n        if (index == -1) {\n            throw InvalidPhaseException(\"Phase $reference was not registered for this pipeline\")\n        }\n\n        phasesRaw.add(index, PhaseContent<TSubject, TContext>(phase, PipelinePhaseRelation.Before(reference)))\n    }\n\n    /**\n     * Adds [block] to the [phase] of this pipeline\n     */\n    public fun intercept(phase: PipelinePhase, block: PipelineInterceptor<TSubject, TContext>) {\n        val phaseContent = findPhase(phase)\n            ?: throw InvalidPhaseException(\"Phase $phase was not registered for this pipeline\")\n\n        if (tryAddToPhaseFastPath(phase, block)) {\n            interceptorsQuantity++\n            return\n        }\n\n        phaseContent.addInterceptor(block)\n        interceptorsQuantity++\n        resetInterceptorsList()\n\n        afterIntercepted()\n    }\n\n    /**\n     * Invoked after an interceptor has been installed\n     */\n    public open fun afterIntercepted() {\n    }\n\n    /**\n     * Merges another pipeline into this pipeline, maintaining relative phases order\n     */\n    public fun merge(from: Pipeline<TSubject, TContext>) {\n        if (fastPathMerge(from)) {\n            return\n        }\n\n        if (interceptorsQuantity == 0) {\n            setInterceptorsListFromAnotherPipeline(from)\n        } else {\n            resetInterceptorsList()\n        }\n\n        val fromPhases = from.phasesRaw\n        val toInsert = fromPhases.toMutableList()\n        // the worst case is O(n^2), but it will happen only\n        // when all phases were inserted before each other into the second pipeline\n        // (see test testDependantPhasesLastCommon).\n        // in practice, it will be linear time for most cases\n        while (toInsert.isNotEmpty()) {\n            val iterator = toInsert.iterator()\n            while (iterator.hasNext()) {\n                val fromPhaseOrContent = iterator.next()\n\n                val fromPhase = (fromPhaseOrContent as? PipelinePhase)\n                    ?: (fromPhaseOrContent as PhaseContent<*, *>).phase\n\n                if (hasPhase(fromPhase)) {\n                    iterator.remove()\n                } else {\n                    val inserted = insertRelativePhase(fromPhaseOrContent, fromPhase)\n                    if (!inserted) continue\n                    iterator.remove()\n                }\n\n                if (fromPhaseOrContent is PhaseContent<*, *> && !fromPhaseOrContent.isEmpty) {\n                    @Suppress(\"UNCHECKED_CAST\")\n                    fromPhaseOrContent as PhaseContent<TSubject, TContext>\n\n                    fromPhaseOrContent.addTo(findPhase(fromPhase)!!)\n                    interceptorsQuantity += fromPhaseOrContent.size\n                }\n            }\n        }\n    }\n\n    internal fun phaseInterceptors(phase: PipelinePhase): List<PipelineInterceptor<TSubject, TContext>> =\n        findPhase(phase)?.sharedInterceptors() ?: emptyList()\n\n    /**\n     * For tests only\n     */\n    internal fun interceptorsForTests(): List<PipelineInterceptor<TSubject, TContext>> {\n        return interceptors ?: cacheInterceptors()\n    }\n\n    @Suppress(\"DEPRECATION\")\n    private fun createContext(\n        context: TContext,\n        subject: TSubject,\n        coroutineContext: CoroutineContext\n    ): PipelineExecutor<TSubject> =\n        pipelineExecutorFor(context, sharedInterceptorsList(), subject, coroutineContext, developmentMode)\n\n    private fun findPhase(phase: PipelinePhase): PhaseContent<TSubject, TContext>? {\n        val phasesList = phasesRaw\n\n        for (index in 0 until phasesList.size) {\n            val current = phasesList[index]\n            if (current === phase) {\n                val content = PhaseContent<TSubject, TContext>(phase, PipelinePhaseRelation.Last)\n                phasesList[index] = content\n                return content\n            }\n\n            if (current is PhaseContent<*, *> && current.phase === phase) {\n                @Suppress(\"UNCHECKED_CAST\")\n                return current as PhaseContent<TSubject, TContext>\n            }\n        }\n\n        return null\n    }\n\n    private fun findPhaseIndex(phase: PipelinePhase): Int {\n        val phasesList = phasesRaw\n        for (index in 0 until phasesList.size) {\n            val current = phasesList[index]\n            if (current === phase || (current is PhaseContent<*, *> && current.phase === phase)) {\n                return index\n            }\n        }\n\n        return -1\n    }\n\n    private fun hasPhase(phase: PipelinePhase): Boolean {\n        val phasesList = phasesRaw\n        for (index in 0 until phasesList.size) {\n            val current = phasesList[index]\n            if (current === phase || (current is PhaseContent<*, *> && current.phase === phase)) {\n                return true\n            }\n        }\n\n        return false\n    }\n\n    private fun cacheInterceptors(): List<PipelineInterceptor<TSubject, TContext>> {\n        val interceptorsQuantity = interceptorsQuantity\n        if (interceptorsQuantity == 0) {\n            notSharedInterceptorsList(emptyList())\n            return emptyList()\n        }\n\n        val phases = phasesRaw\n        if (interceptorsQuantity == 1) {\n            for (phaseIndex in 0..phases.lastIndex) {\n                @Suppress(\"UNCHECKED_CAST\")\n                val phaseContent =\n                    phases[phaseIndex] as? PhaseContent<TSubject, TContext> ?: continue\n\n                if (!phaseContent.isEmpty) {\n                    val interceptors = phaseContent.sharedInterceptors()\n                    setInterceptorsListFromPhase(phaseContent)\n                    return interceptors\n                }\n            }\n        }\n\n        val destination: MutableList<suspend PipelineContext<TSubject, TContext>.(TSubject) -> Unit> = sharedListOf()\n        for (phaseIndex in 0..phases.lastIndex) {\n            @Suppress(\"UNCHECKED_CAST\")\n            val phase = phases[phaseIndex] as? PhaseContent<TSubject, TContext>\n                ?: continue\n\n            phase.addTo(destination)\n        }\n\n        notSharedInterceptorsList(destination)\n        return destination\n    }\n\n    private fun fastPathMerge(from: Pipeline<TSubject, TContext>): Boolean {\n        if (from.phasesRaw.isEmpty()) {\n            return true\n        }\n\n        if (phasesRaw.isNotEmpty()) {\n            return false\n        }\n\n        val fromPhases = from.phasesRaw\n\n        for (index in 0..fromPhases.lastIndex) {\n            val fromPhaseOrContent = fromPhases[index]\n            if (fromPhaseOrContent is PipelinePhase) {\n                phasesRaw.add(fromPhaseOrContent)\n                continue\n            }\n\n            if (fromPhaseOrContent is PhaseContent<*, *>) {\n                @Suppress(\"UNCHECKED_CAST\")\n                fromPhaseOrContent as PhaseContent<TSubject, TContext>\n\n                phasesRaw.add(\n                    PhaseContent(\n                        fromPhaseOrContent.phase,\n                        fromPhaseOrContent.relation,\n                        fromPhaseOrContent.sharedInterceptors()\n                    )\n                )\n                continue\n            }\n        }\n\n        interceptorsQuantity += from.interceptorsQuantity\n        setInterceptorsListFromAnotherPipeline(from)\n        return true\n    }\n\n    private fun sharedInterceptorsList(): List<PipelineInterceptor<TSubject, TContext>> {\n        if (interceptors == null) {\n            cacheInterceptors()\n        }\n\n        interceptorsListShared = true\n        return interceptors!!\n    }\n\n    private fun resetInterceptorsList() {\n        interceptors = null\n        interceptorsListShared = false\n        interceptorsListSharedPhase = null\n    }\n\n    private fun notSharedInterceptorsList(list: List<PipelineInterceptor<TSubject, TContext>>) {\n        interceptors = list\n        interceptorsListShared = false\n        interceptorsListSharedPhase = null\n    }\n\n    private fun setInterceptorsListFromPhase(phaseContent: PhaseContent<TSubject, TContext>) {\n        interceptors = phaseContent.sharedInterceptors()\n        interceptorsListShared = false\n        interceptorsListSharedPhase = phaseContent.phase\n    }\n\n    private fun setInterceptorsListFromAnotherPipeline(pipeline: Pipeline<TSubject, TContext>) {\n        interceptors = pipeline.sharedInterceptorsList()\n        interceptorsListShared = true\n        interceptorsListSharedPhase = null\n    }\n\n    private fun tryAddToPhaseFastPath(phase: PipelinePhase, block: PipelineInterceptor<TSubject, TContext>): Boolean {\n        val currentInterceptors = interceptors\n        if (phasesRaw.isEmpty() || currentInterceptors == null) {\n            return false\n        }\n\n        if (interceptorsListShared || currentInterceptors !is MutableList) {\n            return false\n        }\n\n        if (interceptorsListSharedPhase == phase) {\n            currentInterceptors.add(block)\n            return true\n        }\n\n        if (phase == phasesRaw.last() || findPhaseIndex(phase) == phasesRaw.lastIndex) {\n            findPhase(phase)!!.addInterceptor(block)\n            currentInterceptors.add(block)\n            return true\n        }\n\n        return false\n    }\n\n    private fun insertRelativePhase(fromPhaseOrContent: Any, fromPhase: PipelinePhase): Boolean {\n        val fromPhaseRelation = when {\n            fromPhaseOrContent === fromPhase -> PipelinePhaseRelation.Last\n            else -> (fromPhaseOrContent as PhaseContent<*, *>).relation\n        }\n\n        when {\n            fromPhaseRelation is PipelinePhaseRelation.Last ->\n                addPhase(fromPhase)\n            fromPhaseRelation is PipelinePhaseRelation.Before && hasPhase(fromPhaseRelation.relativeTo) ->\n                insertPhaseBefore(fromPhaseRelation.relativeTo, fromPhase)\n            fromPhaseRelation is PipelinePhaseRelation.After ->\n                insertPhaseAfter(fromPhaseRelation.relativeTo, fromPhase)\n            else -> return false\n        }\n        return true\n    }\n}\n\n/**\n * Executes this pipeline\n */\n@Suppress(\"NOTHING_TO_INLINE\")\npublic suspend inline fun <TContext : Any> Pipeline<Unit, TContext>.execute(\n    context: TContext\n): Unit = execute(context, Unit)\n\n/**\n * Intercepts an untyped pipeline when the subject is of the given type\n */\npublic inline fun <reified TSubject : Any, TContext : Any> Pipeline<*, TContext>.intercept(\n    phase: PipelinePhase,\n    noinline block: suspend PipelineContext<TSubject, TContext>.(TSubject) -> Unit\n) {\n    intercept(phase) interceptor@{ subject ->\n        if (subject !is TSubject) return@interceptor\n\n        @Suppress(\"UNCHECKED_CAST\")\n        val reinterpret = this as? PipelineContext<TSubject, TContext>\n        reinterpret?.block(subject)\n    }\n}\n\n/**\n * Represents an interceptor type which is a suspend extension function for context\n */\npublic typealias PipelineInterceptor<TSubject, TContext> =\n    suspend PipelineContext<TSubject, TContext>.(TSubject) -> Unit\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util.pipeline\n\n/**\n * Represents relations between pipeline phases\n */\ninternal sealed class PipelinePhaseRelation {\n    /**\n     * Given phase should be executed after [relativeTo] phase\n     * @property relativeTo represents phases for relative positioning\n     */\n    class After(val relativeTo: PipelinePhase) : PipelinePhaseRelation()\n\n    /**\n     * Given phase should be executed before [relativeTo] phase\n     * @property relativeTo represents phases for relative positioning\n     */\n    class Before(val relativeTo: PipelinePhase) : PipelinePhaseRelation()\n\n    /**\n     * Given phase should be executed last\n     */\n    object Last : PipelinePhaseRelation()\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util.pipeline\n\nimport kotlinx.coroutines.internal.*\nimport kotlin.coroutines.*\n\n/**\n * Recreates the exception with the original cause to keep exception structure.\n *\n * Notice: This method breaks the [exception] identity.\n */\ninternal fun recoverStackTraceBridge(exception: Throwable, continuation: Continuation<*>): Throwable = try {\n    @Suppress(\"INVISIBLE_MEMBER\")\n    recoverStackTrace(exception, continuation).withCause(exception.cause)\n} catch (_: Throwable) {\n    exception\n}\n\ninternal expect fun Throwable.withCause(cause: Throwable?): Throwable\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util.pipeline\n\n/**\n * Represents a phase in a pipeline\n *\n * @param name a name for this phase\n */\npublic class PipelinePhase(public val name: String) {\n    override fun toString(): String = \"Phase('$name')\"\n}\n\n/**\n * An exception about misconfigured phases in a pipeline\n */\npublic class InvalidPhaseException(message: String) : Throwable(message)\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util.pipeline\n\ninternal object StackWalkingFailed {\n    public fun failedToCaptureStackFrame() {\n        error(\n            \"Failed to capture stack frame. This is usually happens when a coroutine is running so\" +\n                \" the frame stack is changing quickly \" +\n                \"and the coroutine debug agent is unable to capture it concurrently.\" +\n                \" You may retry running your test to see this particular trace.\"\n        )\n    }\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util.pipeline\n\nimport io.ktor.util.*\nimport kotlin.coroutines.*\n\n/**\n * This is a fake coroutine stack frame. It is reported by [SuspendFunctionGun] when the debug agent\n * is trying to probe jobs state by peeking frames when the coroutine is running at the same time\n * and the frames sequence is concurrently changed.\n */\ninternal object StackWalkingFailedFrame : CoroutineStackFrame, Continuation<Nothing> {\n    override val callerFrame: CoroutineStackFrame? get() = null\n\n    override fun getStackTraceElement(): StackTraceElement? {\n        return createStackTraceElement(\n            StackWalkingFailed::class,\n            StackWalkingFailed::failedToCaptureStackFrame.name,\n            \"StackWalkingFailed.kt\",\n            8\n        )\n    }\n\n    override val context: CoroutineContext\n        get() = EmptyCoroutineContext\n\n    override fun resumeWith(result: Result<Nothing>) {\n        StackWalkingFailed.failedToCaptureStackFrame()\n    }\n}\n","/*\n * Copyright 2014-2019 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.util\n\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\n\n@InternalAPI\n@Suppress(\"NOTHING_TO_INLINE\")\ninternal actual inline fun <R, A> (suspend R.(A) -> Unit).startCoroutineUninterceptedOrReturn3(\n    receiver: R,\n    arg: A,\n    continuation: Continuation<Unit>\n): Any? {\n    val block: suspend () -> Unit = { this(receiver, arg) }\n    return block.startCoroutineUninterceptedOrReturn(continuation)\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util\n\nimport kotlinx.coroutines.*\nimport org.khronos.webgl.*\nimport kotlin.js.*\n\nprivate const val NONCE_SIZE_IN_BYTES = 8\n\n/**\n * Generates a nonce string.\n */\n@InternalAPI\npublic actual fun generateNonce(): String {\n    val buffer = ByteArray(NONCE_SIZE_IN_BYTES)\n    if (PlatformUtils.IS_NODE) {\n        _crypto.randomFillSync(buffer)\n    } else {\n        _crypto.getRandomValues(buffer)\n    }\n    return hex(buffer)\n}\n\n/**\n * Create [Digest] from specified hash [name].\n */\n@InternalAPI\npublic actual fun Digest(name: String): Digest = object : Digest {\n    private val state = mutableListOf<ByteArray>()\n    override fun plusAssign(bytes: ByteArray) {\n        state += bytes\n    }\n\n    override fun reset() {\n        state.clear()\n    }\n\n    override suspend fun build(): ByteArray {\n        val snapshot = state.reduce { a, b -> a + b }\n        val digestBuffer = _crypto.subtle.digest(name, snapshot).asDeferred().await()\n        val digestView = DataView(digestBuffer)\n        return ByteArray(digestView.byteLength) { digestView.getUint8(it) }\n    }\n}\n\n// Variable is renamed to `_crypto` so it wouldn't clash with existing `crypto` variable.\n// JS IR backend doesn't reserve names accessed inside js(\"\") calls\nprivate val _crypto: Crypto by lazy { // lazy because otherwise it's untestable due to evaluation order\n    if (PlatformUtils.IS_NODE) {\n        js(\"eval('require')('crypto')\")\n    } else {\n        js(\"(window.crypto ? window.crypto : window.msCrypto)\")\n    }\n}\n\nprivate external class Crypto {\n    val subtle: SubtleCrypto\n\n    public fun getRandomValues(array: ByteArray)\n\n    public fun randomFillSync(array: ByteArray)\n}\n\nprivate external class SubtleCrypto {\n    public fun digest(algoName: String, buffer: ByteArray): Promise<ArrayBuffer>\n}\n\n/**\n * Compute SHA-1 hash for the specified [bytes]\n */\npublic actual fun sha1(bytes: ByteArray): ByteArray = error(\"sha1 currently is not supported in ktor-js\")\n","// ktlint-disable filename\n/*\n * Copyright 2014-2019 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.util\n\n@InternalAPI\npublic actual class Lock {\n    public actual fun lock() {}\n    public actual fun unlock() {}\n    public actual fun close() {}\n}\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util.pipeline\n\nimport io.ktor.util.*\nimport io.ktor.util.CoroutineStackFrame\nimport io.ktor.util.StackTraceElement\nimport io.ktor.utils.io.*\nimport kotlinx.coroutines.*\nimport kotlin.coroutines.*\nimport kotlin.coroutines.intrinsics.*\n\ninternal class SuspendFunctionGun<TSubject : Any, TContext : Any>(\n    initial: TSubject,\n    override val context: TContext,\n    private val blocks: List<PipelineInterceptor<TSubject, TContext>>\n) : PipelineContext<TSubject, TContext>,\n    @Suppress(\"DEPRECATION\")\n    PipelineExecutor<TSubject>,\n    CoroutineScope {\n\n    override val coroutineContext: CoroutineContext get() = continuation.context\n\n    // Stack-walking state\n    private var lastPeekedIndex: Int = -1\n\n    // this is impossible to inline because of property name clash\n    // between PipelineContext.context and Continuation.context\n    private val continuation: Continuation<Unit> = object : Continuation<Unit>, CoroutineStackFrame {\n        override val callerFrame: CoroutineStackFrame? get() = peekContinuation() as? CoroutineStackFrame\n\n        override fun getStackTraceElement(): StackTraceElement? = null\n\n        private fun peekContinuation(): Continuation<*>? {\n            if (lastPeekedIndex < 0) return null\n\n            when (val rootContinuation = rootContinuation) {\n                null -> return null\n                is Continuation<*> -> {\n                    --lastPeekedIndex\n                    return rootContinuation\n                }\n                is ArrayList<*> -> {\n                    if (rootContinuation.isEmpty()) {\n                        // If the list is empty, then lastPeekedIndex should be -1\n                        // and null should be already returned at the beginning of the function.\n                        // So if we are here and see that the list is empty but lastPeekedIndex wasn't -1,\n                        // then it means that element(s) has disappeared concurrently.\n                        return StackWalkingFailedFrame\n                    }\n                    @Suppress(\"UNCHECKED_CAST\")\n                    return peekContinuationFromList(rootContinuation as List<Continuation<*>>)\n                }\n                else -> return null\n            }\n        }\n\n        private fun peekContinuationFromList(list: List<Continuation<*>>): Continuation<*>? {\n            // this is only invoked by debug agent during job state probes\n            // lastPeekedIndex is non-volatile intentionally\n            // and the list of continuations is not synchronized too\n            // so this is not guaranteed to work properly (may produce incorrect trace),\n            // but the only we care is to not crash here\n            // and simply return StackWalkingFailedFrame on any unfortunate accident\n\n            try {\n                val index = lastPeekedIndex\n                val result = list.getOrNull(index) ?: return StackWalkingFailedFrame\n                lastPeekedIndex = index - 1\n                return result\n            } catch (_: Throwable) {\n                return StackWalkingFailedFrame\n            }\n        }\n\n        @Suppress(\"UNCHECKED_CAST\")\n        override val context: CoroutineContext\n            get() = when (val cont = rootContinuation) {\n                null -> throw IllegalStateException(\"Not started\")\n                is Continuation<*> -> cont.context\n                is List<*> -> (cont as List<Continuation<*>>).last().context\n                else -> throw IllegalStateException(\"Unexpected rootContinuation value\")\n            }\n\n        override fun resumeWith(result: Result<Unit>) {\n            if (result.isFailure) {\n                resumeRootWith(Result.failure(result.exceptionOrNull()!!))\n                return\n            }\n\n            loop(false)\n        }\n    }\n\n    override var subject: TSubject = initial\n        private set\n\n    private var rootContinuation: Any? = null\n    private var index = 0\n\n    init {\n        preventFreeze()\n    }\n\n    override fun finish() {\n        index = blocks.size\n    }\n\n    override suspend fun proceed(): TSubject = suspendCoroutineUninterceptedOrReturn { continuation ->\n        if (index == blocks.size) return@suspendCoroutineUninterceptedOrReturn subject\n\n        addContinuation(continuation)\n\n        if (loop(true)) {\n            discardLastRootContinuation()\n            return@suspendCoroutineUninterceptedOrReturn subject\n        }\n\n        COROUTINE_SUSPENDED\n    }\n\n    override suspend fun proceedWith(subject: TSubject): TSubject {\n        this.subject = subject\n        return proceed()\n    }\n\n    override suspend fun execute(initial: TSubject): TSubject {\n        index = 0\n        if (index == blocks.size) return initial\n        subject = initial\n\n        if (rootContinuation != null) throw IllegalStateException(\"Already started\")\n\n        return proceed()\n    }\n\n    /**\n     * @return `true` if it is possible to return result immediately\n     */\n    private fun loop(direct: Boolean): Boolean {\n        do {\n            val index = index // it is important to read index every time\n            if (index == blocks.size) {\n                if (!direct) {\n                    resumeRootWith(Result.success(subject))\n                    return false\n                }\n\n                return true\n            }\n\n            this@SuspendFunctionGun.index = index + 1 // it is important to increase it before function invocation\n            val next = blocks[index]\n\n            try {\n                val me = this@SuspendFunctionGun\n\n                val rc = next.startCoroutineUninterceptedOrReturn3(me, me.subject, me.continuation)\n                if (rc === COROUTINE_SUSPENDED) {\n                    return false\n                }\n            } catch (cause: Throwable) {\n                resumeRootWith(Result.failure(cause))\n                return false\n            }\n        } while (true)\n    }\n\n    private fun resumeRootWith(result: Result<TSubject>) {\n        val rootContinuation = rootContinuation\n\n        @Suppress(\"UNCHECKED_CAST\")\n        val next = when (rootContinuation) {\n            null -> throw IllegalStateException(\"No more continuations to resume\")\n            is Continuation<*> -> {\n                this.rootContinuation = null\n                lastPeekedIndex = -1\n                rootContinuation\n            }\n            is ArrayList<*> -> {\n                if (rootContinuation.isEmpty()) throw IllegalStateException(\"No more continuations to resume\")\n                lastPeekedIndex = rootContinuation.lastIndex - 1\n                rootContinuation.removeAt(rootContinuation.lastIndex)\n            }\n            else -> unexpectedRootContinuationValue(rootContinuation)\n        } as Continuation<TSubject>\n\n        if (!result.isFailure) {\n            next.resumeWith(result)\n        } else {\n            val exception = recoverStackTraceBridge(result.exceptionOrNull()!!, next)\n            next.resumeWithException(exception)\n        }\n    }\n\n    private fun discardLastRootContinuation() {\n        val rootContinuation = rootContinuation\n\n        @Suppress(\"UNCHECKED_CAST\")\n        when (rootContinuation) {\n            null -> throw IllegalStateException(\"No more continuations to resume\")\n            is Continuation<*> -> {\n                lastPeekedIndex = -1\n                this.rootContinuation = null\n            }\n            is ArrayList<*> -> {\n                if (rootContinuation.isEmpty()) throw IllegalStateException(\"No more continuations to resume\")\n                rootContinuation.removeAt(rootContinuation.lastIndex)\n                lastPeekedIndex = rootContinuation.lastIndex\n            }\n            else -> unexpectedRootContinuationValue(rootContinuation)\n        }\n    }\n\n    private fun addContinuation(continuation: Continuation<TSubject>) {\n        when (val rootContinuation = rootContinuation) {\n            null -> {\n                lastPeekedIndex = 0\n                this.rootContinuation = continuation\n            }\n            is Continuation<*> -> {\n                this.rootContinuation = ArrayList<Continuation<*>>(blocks.size).apply {\n                    add(rootContinuation)\n                    add(continuation)\n                    lastPeekedIndex = 1\n                }\n            }\n            is ArrayList<*> -> {\n                @Suppress(\"UNCHECKED_CAST\")\n                rootContinuation as ArrayList<Continuation<TSubject>>\n                rootContinuation.add(continuation)\n                lastPeekedIndex = rootContinuation.lastIndex\n            }\n            else -> unexpectedRootContinuationValue(rootContinuation)\n        }\n    }\n\n    private fun unexpectedRootContinuationValue(rootContinuation: Any?): Nothing {\n        throw IllegalStateException(\"Unexpected rootContinuation content: $rootContinuation\")\n    }\n}\n","/*\n * Copyright 2014-2019 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.util\n\n/**\n * Create ES specific [Attributes] instance.\n */\n@JsName(\"AttributesJsFn\")\npublic actual fun Attributes(concurrent: Boolean): Attributes = AttributesJs()\n\n@Suppress(\"KDocMissingDocumentation\")\npublic class AttributesJs : Attributes {\n    private val map = mutableMapOf<AttributeKey<*>, Any?>()\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun <T : Any> getOrNull(key: AttributeKey<T>): T? = map[key] as T?\n\n    override operator fun contains(key: AttributeKey<*>): Boolean = map.containsKey(key)\n\n    override fun <T : Any> put(key: AttributeKey<T>, value: T) {\n        map[key] = value\n    }\n\n    override fun <T : Any> remove(key: AttributeKey<T>) {\n        map.remove(key)\n    }\n\n    @Suppress(\"UNCHECKED_CAST\")\n    override fun <T : Any> computeIfAbsent(key: AttributeKey<T>, block: () -> T): T {\n        map[key]?.let { return it as T }\n        return block().also { result ->\n            map[key] = result\n        }\n    }\n\n    override val allKeys: List<AttributeKey<*>>\n        get() = map.keys.toList()\n}\n","// ktlint-disable filename\n/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util\n\npublic actual object PlatformUtils {\n    public actual val IS_BROWSER: Boolean = js(\n        \"typeof window !== 'undefined' && typeof window.document !== 'undefined'\"\n    ) as Boolean\n\n    public actual val IS_NODE: Boolean = js(\n        \"typeof process !== 'undefined' && process.versions != null && process.versions.node != null\"\n    ) as Boolean\n\n    public actual val IS_JVM: Boolean = false\n    public actual val IS_NATIVE: Boolean = false\n    public actual val IS_DEVELOPMENT_MODE: Boolean = false\n}\n","/*\n * Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.util.reflect\n\nimport kotlin.reflect.*\n\n/**\n * Information about type.\n */\npublic expect interface Type\n\ninternal expect val KType.platformType: Type\n\n/**\n * Ktor type information.\n * @property type: source KClass<*>\n * @property reifiedType: type with substituted generics\n * @property kotlinType: kotlin reified type with all generic type parameters.\n */\npublic interface TypeInfo {\n    public val type: KClass<*>\n    public val reifiedType: Type\n    public val kotlinType: KType?\n}\n\ninternal data class TypeInfoImpl(\n    override val type: KClass<*>,\n    override val reifiedType: Type,\n    override val kotlinType: KType? = null\n) : TypeInfo\n\n/**\n * Returns [TypeInfo] for the specified type [T]\n */\npublic expect inline fun <reified T> typeInfo(): TypeInfo\n\n/**\n * Check [this] is instance of [type].\n */\npublic expect fun Any.instanceOf(type: KClass<*>): Boolean\n","/*\n * Copyright 2014-2019 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.util\n\npublic actual fun <T> Set<T>.unmodifiable(): Set<T> = this\n","/*\n * Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.util.converters\n\nimport kotlin.reflect.*\n\ninternal actual fun platformDefaultFromValues(value: String, klass: KClass<*>): Any? = null\ninternal actual fun platformDefaultToValues(value: Any): List<String>? = null\n","/*\n * Copyright 2014-2019 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n */\n\npackage io.ktor.util.date\n\nimport kotlin.js.*\n\npublic actual fun GMTDate(timestamp: Long?): GMTDate {\n    val date = timestamp?.toDouble()?.let { Date(it) } ?: Date()\n\n    if (date.getTime().isNaN()) throw InvalidTimestampException(timestamp!!)\n\n    with(date) {\n        /* from SUNDAY 0 -> MONDAY 0 */\n        val dayOfWeek = WeekDay.from((getUTCDay() + 6) % 7)\n\n        val month = Month.from(getUTCMonth())\n\n        return GMTDate(\n            getUTCSeconds(),\n            getUTCMinutes(),\n            getUTCHours(),\n\n            dayOfWeek,\n            getUTCDate(),\n            getUTCFullYear(),\n\n            month,\n            getUTCFullYear(),\n\n            getTime().toLong()\n        )\n    }\n}\n\npublic actual fun GMTDate(seconds: Int, minutes: Int, hours: Int, dayOfMonth: Int, month: Month, year: Int): GMTDate {\n    val timestamp = Date.UTC(year, month.ordinal, dayOfMonth, hours, minutes, seconds).toLong()\n    return GMTDate(timestamp)\n}\n\n/**\n * Invalid exception: possible overflow or underflow\n */\npublic class InvalidTimestampException(timestamp: Long) : IllegalStateException(\n    \"Invalid date timestamp exception: $timestamp\"\n)\n\n/**\n * Gets current system time in milliseconds since certain moment in the past, only delta between two subsequent calls makes sense.\n */\npublic actual fun getTimeMillis(): Long = Date().getTime().toLong()\n","/*\n* Copyright 2014-2021 JetBrains s.r.o and contributors. Use of this source code is governed by the Apache 2.0 license.\n*/\n\npackage io.ktor.util.network\n\n/**\n * Represents remote endpoint with [hostname] and [port].\n *\n * The address will be resolved after construction.\n *\n * @throws UnresolvedAddressException if the [hostname] cannot be resolved.\n */\npublic actual class NetworkAddress internal constructor(\n    internal val hostname: String,\n    internal val port: Int,\n    internal val address: String\n)\n\n/**\n * Network address hostname.\n */\npublic actual val NetworkAddress.hostname: String\n    get() = hostname\n\n/**\n * Network address port.\n */\npublic actual val NetworkAddress.port: Int\n    get() = port\n\n/**\n * Represents remote endpoint with [hostname] and [port].\n *\n * The address will be resolved after construction.\n *\n * @throws UnresolvedAddressException if the [hostname] cannot be resolved.\n */\npublic actual fun NetworkAddress(hostname: String, port: Int): NetworkAddress =\n    NetworkAddress(hostname, port, hostname)\n\npublic actual class UnresolvedAddressException : IllegalArgumentException()\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(681);\n"],"names":["root","factory","exports","module","define","amd","this","window","alert","HttpClient","cryptJs","client","r","Kotlin","_","isBooleanArray","a","Array","isArray","Int8Array","$type$","isByteArray","isShortArray","Int16Array","isCharArray","Uint16Array","isIntArray","Int32Array","isFloatArray","Float32Array","isDoubleArray","Float64Array","isLongArray","isArrayish","ArrayBuffer","isView","arrayToString","toString","String","fromCharCode","prototype","map","call","e","join","getCallableRef","f","callableName","name","toShort","toByte","toChar","numberToInt","Long","toInt","doubleToInt","toBoxedChar","BoxedChar","unboxChar","equals","obj1","obj2","hashCode","obj","objType","getObjectHashCode","numberHashCode","Number","str","hash","i","length","charCodeAt","getStringHashCode","o","buf","bufFloat64","bufFloat32","bufInt32","lowIndex","highIndex","OBJECT_HASH_CODE_PROPERTY_NAME","Math","random","Object","defineProperty","throwMarkerError","Error","imul","b","isInheritanceFromInterface","ctor","iface","metadata","$metadata$","interfaces","superPrototype","getPrototypeOf","superConstructor","constructor","identityHashCode","low_","low","high_","high","IntCache_","fromInt","value","cachedObj","fromNumber","isNaN","ZERO","TWO_PWR_63_DBL_","MIN_VALUE","MAX_VALUE","negate","TWO_PWR_32_DBL_","fromBits","lowBits","highBits","fromString","radix","opt_radix","charAt","substring","indexOf","radixToPower","pow","result","size","min","parseInt","power","multiply","add","TWO_PWR_16_DBL_","TWO_PWR_24_DBL_","TWO_PWR_31_DBL_","TWO_PWR_48_DBL_","TWO_PWR_64_DBL_","ONE","NEG_ONE","TWO_PWR_24_","toNumber","getLowBitsUnsigned","isZero","isNegative","equalsLong","radixLong","div","rem","subtract","remDiv","digits","getHighBits","getLowBits","getNumBitsAbs","val","bit","isOdd","other","notEqualsLong","lessThan","compare","lessThanOrEqual","greaterThan","greaterThanOrEqual","thisNeg","otherNeg","not","a48","a32","a16","a00","b48","b32","b16","c48","c32","c16","c00","b00","approx","shiftRight","shiftLeft","res","max","floor","log2","ceil","log","LN2","delta","approxRes","approxRem","modulo","and","or","xor","numBits","shiftRightUnsigned","compareTo_11rb$","inc","dec","valueOf","unaryPlus","unaryMinus","inv","rangeTo","kotlin","ranges","LongRange","defineInlineFunction","fun","wrapFunction","apply","arguments","suspendCall","coroutineResult","coroutineReceiver","setCoroutineResult","getReifiedTypeParameterKType","compareTo","typeA","doubleCompareTo","primitiveCompareTo","ia","imulEmulated","doubleToRawBits","doubleFromBits","floatToRawBits","floatFromBits","ensureNotNull","x","throwNPE","startsWith","searchString","position","lastIndexOf","endsWith","subjectString","undefined","lastIndex","sign","trunc","NaN","taylor_2_bound","sqrt","taylor_n_bound","upper_taylor_2_bound","upper_taylor_n_bound","sinh","abs","y","exp","y1","isFinite","cosh","tanh","Infinity","asinh","acosh","atanh","log1p","x2","x3","expm1","hypot","log10","LOG10E","LOG2E","clz32","asUint","__proto__","fill","TypeError","O","len","relativeStart","k","end","relativeEnd","finalValue","normalizeOffset","offset","typedArraySlice","begin","subarray","arrays","TypedArray","slice","Function","self","array","callback","totalOrderComparator","sort","compareFunction","Kind","callGetter","thisObject","klass","propertyName","propertyDescriptor","getOwnPropertyDescriptor","get","isType","object","proto","kind","OBJECT","klassMetadata","INTERFACE","isNumber","isChar","isComparable","type","Comparable","isCharSequence","CharSequence","ordinal","initValue","MIN_HIGH_SURROGATE","MAX_LOW_SURROGATE","fillArrayVal","init","element","index","NoSuchElementException","IntRange","destination","item","asCollection","emptySet","setOf","toCollection","checkIndexOverflow","iterator","hasNext","next","single","j","emptyList","listOf","optimizeReadOnlyList","optimizeReadOnlySet","elements","addAll","separator","prefix","postfix","limit","truncated","transform","buffer","count","to","last","first","step","EMPTY","minimumValue","maximumValue","FilteringSequence","predicate","it","n","emptySequence","TakeSequence","TransformingSequence","CharIterator","IntIterator","LongIterator","start","getProgressionLastElement","endInclusive","NotImplementedError","nextByte","nextChar","nextShort","nextInt","nextLong","nextFloat","nextDouble","nextBoolean","CharProgressionIterator","isEmpty","CharProgression","rangeStart","rangeEnd","IntProgressionIterator","IntProgression","LongProgressionIterator","LongProgression","CharRange","mod","c","differenceModulo","BooleanIterator","ByteIterator","ShortIterator","FloatIterator","DoubleIterator","context","current","v","currentResult","isFailure","currentException","exceptionOrNull","doResume","outcome","exception","completion","Result","createFailure","intercepted","CoroutineImpl","receiver","cause","message","Exception","RuntimeException","checkRadix","ArrayList","fromIndex","toIndex","comparator","midPoint","reverseIndex","tmp","bottom","top","middle","needle","binarySearchRange","ch","diff","toArray","copyToArrayImpl","collection","push","list","copyToArray","collectionsSort","startIndex","endIndex","source","destinationOffset","rangeSize","set","subrange","throwIndexOverflow","expectedSize","AbstractCollection","AbstractMutableCollection","AbstractMutableList","AbstractMap","AbstractMutableSet","_stableSortingIsSupported","comparison","getStableSortingIsSupported","mergeSort","median","left","leftIndex","rightIndex","right","leftValue","rightValue","target","checkIsMutable","remove","modified","_index","changed","times","hasPrevious","newValue","oldValue","entries","clear","key","from","iter","entry","modCount","splice","concat","pop","arrayCopy","value1","value2","internalMap","equality","InternalHashCodeMap","initialCapacity","loadFactor","createJsMap","keys","original","BaseOutput","BufferedOutput","initialResult","ClassCastException","NEGATIVE_INFINITY","toRawBits","bits","POSITIVE_INFINITY","isInfinite","hi26","INV_2_26","low27","INV_2_53","KClassImpl","jClass","createEntrySet","chainOrEntry","chain","isChain","chainSize","keyIndex","itemIndex","state","lastEntry","_head","_tail","node","old","newEntry","build","println","outputStream","write","messageString","s","flush","console","cur","simpleName","jsClass","PrimitiveKClassImpl","classifier","isMarkedNullable","kClass","variance","prefixString","functionClasses","arity","getKClassM","getKClass1","jClasses","ErrorKClass","stringClass","SimpleKClassImpl","content","toUpperCase","uppercase","MAX_HIGH_SURROGATE","MIN_LOW_SURROGATE","isWhitespaceImpl","toIntOrNull","numberFormatError","char","digitToIntImpl","prepend","pattern","options","RegExp","toFlags","match","IndexOutOfBoundsException","reversed","isLowSurrogate","isHighSurrogate","concatToString","string","toInsert","newLength","dstIndex","stringCsq","reset","exec","input","test","findNext","replacement","substituteGroupRefs","replace","lastStart","sb","foundMatch","range","nonGlobalOptions","subSequence","requireNonNegativeLimit","matches","sequence","literal","AbstractList","readGroupIndex","groupValues","groupIndex","newGroupIndex","groupCount","ignoreCase","JsMath","n1","n2","thisChar","otherChar","uppercaseChar","toLowerCase","regionMatches","isWhitespace","regionMatchesImpl","thisOffset","otherOffset","throwOnMalformed","CharacterCodingException","byte1","malformed","bytes","byte2","byte3","byte4","byteIndex","byte","stringBuilder","codePointFrom2","code","REPLACEMENT_CHAR","codePointFrom3","codePointFrom4","MatchGroup","previous","nextIndex","otherIterator","elem","elemOther","AbstractSet","ourValue","ArrayAsCollection","ArithmeticException","values","contains","isVarargs","filterInPlace","predicateResultToRemove","writeIndex","readIndex","removeIndex","SequenceBuilderIterator","nextStep","block","SequenceScope","reverseElementIndex","throwOnFailure","GeneratorSequence","seedFunction","nextFunction","nextItem","nextState","FlatteningSequence","itemIterator","nextItemIterator","SubSequence","safe","getOrThrow","acc","removed","interceptor","CombinedContext","baseKey","operation","initial","newLeft","Random","defaultPlatformRandom","accumulator","until","checkRangeBounds","fastLog2","bitCount","nLow","nHigh","rnd","doubleFromParts","r1","nextDown","steps","remainder","vr","seed","boundsErrorMessage","t","v0","takeUpperBits","seed1","seed2","thisUpper","otherUpper","newIndent","marginPrefix","isBlank","lines","line","firstNonWhitespaceIndex","firstChar","limitBeforeMul","limitForMaxRadix","digitOf","digit","NumberFormatException","chars","indices","indexOfAny","charArrayOf","currentStartIndex","strings","findAnyOf","currentIndex","second","DelimitedRangesSequence","asList","delimiters","splitToSequence","lineSequence","nextSearchIndex","initializer","isInitialized","InitializedLazyImpl","Pair","that","UByte","UInt","uintCompare","data","ulongCompare","uintDivide","ulongDivide","uintRemainder","ulongRemainder","UIntProgression","UIntRange","uintToDouble","UIntProgressionIterator","UIntIterator","ULong","nextUInt","nextULong","ULongProgression","ulongToDouble","ulongToString","ULongProgressionIterator","ULongIterator","ac","bc","UShort","v1","v2","divisor","dividend","quotient","base","toMutableList","sortWith","collectionSizeOrNull","booleanArrayIterator","byteArrayIterator","shortArrayIterator","charArrayIterator","intArrayIterator","longArrayIterator","floatArrayIterator","doubleArrayIterator","captureStackTrace","instance","stack","UnsafeLazyImpl","delegate","NullPointerException","round","KTypeImpl","intClass","doubleClass","booleanClass","functionClass","booleanArrayClass","charArrayClass","byteArrayClass","shortArrayClass","intArrayClass","longArrayClass","floatArrayClass","doubleArrayClass","arrayClass","anyClass","throwableClass","toLongOrNull","decodeUtf8","oldChar","newChar","_suppressed","suppressed","emptyMap","toMutableMap","ReversedListReadOnly","toSet","createCoroutineUnintercepted","ClosedDoubleRange","MIN_SURROGATE","MAX_SURROGATE","replaceIndentByMargin","startFound","lastIndexOfAny","delimiter","currentOffset","isLimited","collectionSizeOrDefault","NodeJsOutput","BufferedOutputToConsoleLog","Comparator","HttpClientConfig","sendPipeline","config","feature","info","response","HttpRequest","execute","builder","executeUnsafe","HttpResponse","port","host","HttpStatement","EmptyContent","takeFrom","complete","url","maxElem","found","Frame","encode","ContentDisposition","parameters","headers","HttpStatusCode","urlString","Grammar","LETTERS_AND_NUMBERS","lazy","buildRegexParser","atLeastOne","AttributeKey","pool","closed","readByteOrder","readable","reverseByteOrder","head","tail","p","startGap","writePosition","writeRemaining","memory","prepareReadNextHead","readPosition","after","remaining","release","dstOffset","prepareReadFirstHead","failLongToIntConversion","dst","allKeys","makeShared","delegateIterator","interceptors","phase","StackWalkingFailed","rootContinuation","__webpack_module_cache__","__webpack_require__","moduleId","cachedModule","__webpack_modules__","__webpack_exports__"],"sourceRoot":""}