# ソフトウェア設計

# 5.1. データベース設計 (Firestore)
- **コレクション**: `addressbook`
- **ドキュメント構造**:
    ```json
    {
      "name": "String (Document IDとしても使用)",
      "email": "String",
      "timestamp": "ServerTimestamp"
    }
    ```
  
# モジュール設計
- アドレス帳リスト取得関数(
  startPosition, beforeOrAfter, limit, sortKey, sortOrder,
)
  - beforeOrAfter: AFTERならstartPositionから昇順に、BEFOREなら逆順に列挙
  - sortKeyは TIMESTAMP, NAME, EMAIL
  - 応答: 取得できた時点でスナップショットを返す。非同期(コールバック)
 
- アドレス情報追加更新関数(
  name, email,
)
- アドレス情報削除関数(name)

# 5.2. データ転送
- **アドレス取得データ単位**
  - Firestoreからのアドレス情報取得は最大10件を上限とする。例えば画面のサイズが25行の場合、3回に分けて取得し、そのうち25件を一画面に表示する。
- **ページング制御 (無限スクロール)**
  -以下のような表示範囲が変化した場合、次のアドレスをクエリ取得する。
    - ユーザーがスクロール
    - ターミナルサイズ変更
  - ページングには Firestore のカーソル機能 (`startAfter`) を使用し、直前のページの最後のデータ以降を取得する。

# 5.3. マルチプラットフォーム対応
- **抽象化レイヤー**:
    - OS固有の処理（PID取得、スタックトレース、標準関数）は `utils.hpp/cpp` でラップし、条件付きコンパイル (`#ifdef _WIN32`) で吸収する。
- **Windows (MSVC) 対応**:
    - **マクロ衝突回避**: Windows API (`windows.h`) の `RGB` マクロが FTXUI の `Color::RGB` と衝突するため、インクルード後に `#undef RGB` を行う。
    - **ランタイムライブラリ**: Firebase C++ SDK との整合性を保つため、動的リンクライブラリ (`MD`) を優先的に使用する。
    - **システムリンクター**: Windows では `bcrypt`, `ws2_32`, `rpcrt4`, `ole32` などのシステム .lib を明示的にリンクする。

# 5.4. 安全性と堅牢性
- **メモリ管理 (Lambda Capture)**:
    - FTXUIのコンポーネントツリーは非同期にレンダリングされるため、コールバック内でのローカル変数への参照キャプチャ (`[&]`) は避け、常に値キャプチャ (`[=]`) または `shared_ptr` による寿命管理を行う。これにより、関数スコープ終了後のアクセス違反 (Access Violation) を防止する。
- **スレッド安全性**:
    - **時刻処理**: 標準の `std::localtime` は内部バッファを共有するため、バックグラウンドスレッド（Firebaseコールバック）での使用は危険である。Windows では `localtime_s`、POSIX では `localtime_r` を使用して再入可能性を確保する。
    - **UI更新ガード**: UIループ (`screen.Loop`) が開始される前に別スレッドから `screen.Post` が呼ばれるのを防ぐため、`std::atomic<bool>` フラグによる実行制御を行う。

# ログ・デバッグ
- **ファイル出力**: `app.log` 形式のファイルに記録。
- **例外処理**: Windows では `SetUnhandledExceptionFilter` を使用し、クラッシュ時にコンソールの状態（代替バッファ、カーソル）を強制復帰させるハンドラを登録している。

# テスト項目

## 1. 起動と終了
- **1.1. 正常起動と終了 (`q`キー)**
  1. `API_KEY` 環境変数を設定して `target` を実行する。
  2. 'q' キーを押して終了する。
  - **確認**: エラーなく起動し、ヘッダーに "Connected" と表示されること。正常に終了すること。

- **1.2. APIキー未設定での起動**
  1. `API_KEY` 環境変数を設定せずに `target` を実行する。
  - **確認**: ヘッダーに "Disconnected" と表示されること。

- **1.3. 正常終了 (`[Close]` ボタン)**
  1. `target` を実行する。
  2. フッターの `[Close]` ボタンを押す。
  - **確認**: 正常に終了すること。

## 2. 接続設定 (Activation)
- **2.1. ダイアログ表示**
  1. APIキー未設定の状態でフッターの `[Activate]` ボタンを押す。
  - **確認**: APIキー設定ダイアログが表示されること。

- **2.2. 接続キャンセル**
  1. APIキー設定ダイアログで 値を変更し、`[Cancel]` ボタンを押す。
  - **確認**: ダイアログが閉じること。再度ダイアログを開き変更前の値に戻っていること。

- **2.3. 接続試行と成功**
  1. APIキー設定ダイアログで有効なAPIキーを入力し `[Connect]` ボタンを押す。
  - **確認**: ダイアログが閉じ、ヘッダーのステータスが "Connected" に変わること。

- **2.4. 接続試行と失敗 (無効なキー)**
  1. APIキー設定ダイアログで無効なAPIキーを入力し `[Connect]` ボタンを押す。
  - **確認**: ダイアログ内にエラーメッセージが表示されること。

- **2.5. 接続試行 (空のキー)**
  1. APIキー設定ダイアログでAPIキーを空にして `[Connect]` ボタンを押す。
  - **確認**: ダイアログが閉じ、ヘッダーのステータスが "Disconnected" のままであること。ダイアログ内にエラーは表示されないこと。

## 3. データ表示
- **3.1. リスト表示とデフォルトソート**
  1. 接続成功後、データがリストに表示される。
  - **確認**: `Name`, `Mail Address`, `Created At`, `Operation` のカラムが表示されていること。`Created At` カラムのヘッダーに `▼` が表示され、データが作成日時の降順でソートされていること。

- **3.2. ソート機能**
  1. `Name` カラムのヘッダーをクリックする。
  - **確認**: `Name` で昇順ソートされ、カラム名に `▲` が表示されること。
  2. もう一度 `Name` カラムのヘッダーをクリックする。
  - **確認**: `Name` で降順ソートされ、カラム名に `▼` が表示されること。

- **3.3. 無限スクロール**
  1. リストを一番下までスクロールする。
  - **確認**: `Loading...` と表示された後、次のデータが読み込まれること。全件読み込み後は `last of data` が表示されること。

## 4. データ操作
- **4.1. データ選択**
  1. リストのいずれかの行をクリックする。
  - **確認**: フッターの `Name`, `Email` 入力欄に、選択した行のデータがコピーされること。

- **4.2. データ追加**
  1. フッターの `Name`, `Email` を編集し `[Add]` ボタンを押す。
  - **確認**: リストに新しいデータが追加されること。追加後、入力欄に新しいランダムな値がセットされること。

- **4.3. データ削除**
  1. リストのいずれかの行の `[Remove]` ボタンを押す。
  - **確認**: 該当する行がリストから削除されること。
  2. リストのいずれかの行を選択し、`Delete` キーを押す。
  - **確認**: 該当する行がリストから削除されること。

## 5. UI/キーボード操作
- **5.1. フォーカス移動**
  1. `Tab` キーと `Shift+Tab` キーを押す。
  - **確認**: フッターの入力欄やボタン間でフォーカスが移動すること。

- **5.2. ボタン実行**
  1. ボタンにフォーカスを合わせて `Enter` キーを押す。
  - **確認**: ボタンが実行されること。